diff -urNad openttd-1.3.2/docs/tile_index_transformations.svg openttd-1.3.2-DC3.0RC3/docs/tile_index_transformations.svg
--- openttd-1.3.2/docs/tile_index_transformations.svg	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/docs/tile_index_transformations.svg	2013-11-22 05:49:06.000000000 +0100
@@ -0,0 +1,1849 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="752.40002"
+   height="359.76001"
+   id="svg2"
+   version="1.1"
+   inkscape:version="0.48.3.1 r9886"
+   sodipodi:docname="tile_index_transformations.svg"
+   style="enable-background:new">
+  <defs
+     id="defs4">
+    <marker
+       inkscape:stockid="Arrow2Sstart"
+       orient="auto"
+       refY="0"
+       refX="0"
+       id="Arrow2Sstart"
+       style="overflow:visible">
+      <path
+         id="path4778"
+         style="font-size:12px;fill-rule:evenodd;stroke-width:0.625;stroke-linejoin:round"
+         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
+         transform="matrix(0.3,0,0,0.3,-0.69,0)"
+         inkscape:connector-curvature="0" />
+    </marker>
+    <marker
+       inkscape:stockid="Arrow1Mstart"
+       orient="auto"
+       refY="0"
+       refX="0"
+       id="Arrow1Mstart"
+       style="overflow:visible">
+      <path
+         id="path4754"
+         d="M 0,0 5,-5 -12.5,0 5,5 0,0 z"
+         style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt;marker-start:none"
+         transform="matrix(0.4,0,0,0.4,4,0)"
+         inkscape:connector-curvature="0" />
+    </marker>
+    <marker
+       inkscape:stockid="Arrow2Mstart"
+       orient="auto"
+       refY="0"
+       refX="0"
+       id="Arrow2Mstart"
+       style="overflow:visible">
+      <path
+         id="path4772"
+         style="font-size:12px;fill-rule:evenodd;stroke-width:0.625;stroke-linejoin:round"
+         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
+         transform="scale(0.6,0.6)"
+         inkscape:connector-curvature="0" />
+    </marker>
+    <marker
+       inkscape:stockid="Arrow2Mend"
+       orient="auto"
+       refY="0"
+       refX="0"
+       id="Arrow2Mend"
+       style="overflow:visible">
+      <path
+         id="path4247"
+         style="font-size:12px;fill-rule:evenodd;stroke-width:0.625;stroke-linejoin:round"
+         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
+         transform="scale(-0.6,-0.6)"
+         inkscape:connector-curvature="0" />
+    </marker>
+    <marker
+       inkscape:stockid="Arrow2Send"
+       orient="auto"
+       refY="0"
+       refX="0"
+       id="Arrow2Send"
+       style="overflow:visible">
+      <path
+         id="path4253"
+         style="font-size:12px;fill-rule:evenodd;stroke-width:0.625;stroke-linejoin:round"
+         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
+         transform="matrix(-0.3,0,0,-0.3,0.69,0)"
+         inkscape:connector-curvature="0" />
+    </marker>
+    <marker
+       inkscape:stockid="Arrow2Lend"
+       orient="auto"
+       refY="0"
+       refX="0"
+       id="Arrow2Lend"
+       style="overflow:visible">
+      <path
+         id="path4241"
+         style="font-size:12px;fill-rule:evenodd;stroke-width:0.625;stroke-linejoin:round"
+         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
+         transform="matrix(-1.1,0,0,-1.1,-1.1,0)"
+         inkscape:connector-curvature="0" />
+    </marker>
+    <marker
+       inkscape:stockid="Arrow1Send"
+       orient="auto"
+       refY="0"
+       refX="0"
+       id="Arrow1Send"
+       style="overflow:visible">
+      <path
+         id="path4235"
+         d="M 0,0 5,-5 -12.5,0 5,5 0,0 z"
+         style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt;marker-start:none"
+         transform="matrix(-0.2,0,0,-0.2,-1.2,0)"
+         inkscape:connector-curvature="0" />
+    </marker>
+    <marker
+       inkscape:stockid="Arrow1Lend"
+       orient="auto"
+       refY="0"
+       refX="0"
+       id="Arrow1Lend"
+       style="overflow:visible">
+      <path
+         id="path4223"
+         d="M 0,0 5,-5 -12.5,0 5,5 0,0 z"
+         style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt;marker-start:none"
+         transform="matrix(-0.8,0,0,-0.8,-10,0)"
+         inkscape:connector-curvature="0" />
+    </marker>
+    <marker
+       inkscape:stockid="Arrow1Lend"
+       orient="auto"
+       refY="0"
+       refX="0"
+       id="Arrow1Lend-0"
+       style="overflow:visible">
+      <path
+         inkscape:connector-curvature="0"
+         id="path4223-2"
+         d="M 0,0 5,-5 -12.5,0 5,5 0,0 z"
+         style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt;marker-start:none"
+         transform="matrix(-0.8,0,0,-0.8,-10,0)" />
+    </marker>
+    <marker
+       inkscape:stockid="Arrow2Mend"
+       orient="auto"
+       refY="0"
+       refX="0"
+       id="Arrow2Mend-2"
+       style="overflow:visible">
+      <path
+         inkscape:connector-curvature="0"
+         id="path4247-6"
+         style="font-size:12px;fill-rule:evenodd;stroke-width:0.625;stroke-linejoin:round"
+         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
+         transform="scale(-0.6,-0.6)" />
+    </marker>
+    <marker
+       inkscape:stockid="Arrow2Sstart"
+       orient="auto"
+       refY="0"
+       refX="0"
+       id="Arrow2Sstart-8"
+       style="overflow:visible">
+      <path
+         inkscape:connector-curvature="0"
+         id="path4778-8"
+         style="font-size:12px;fill-rule:evenodd;stroke-width:0.625;stroke-linejoin:round"
+         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
+         transform="matrix(0.3,0,0,0.3,-0.69,0)" />
+    </marker>
+    <marker
+       inkscape:stockid="Arrow2Sstart"
+       orient="auto"
+       refY="0"
+       refX="0"
+       id="marker6497"
+       style="overflow:visible">
+      <path
+         inkscape:connector-curvature="0"
+         id="path6499"
+         style="font-size:12px;fill-rule:evenodd;stroke-width:0.625;stroke-linejoin:round"
+         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
+         transform="matrix(0.3,0,0,0.3,-0.69,0)" />
+    </marker>
+  </defs>
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#ffffff"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0.0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="0.99999999"
+     inkscape:cx="301.96543"
+     inkscape:cy="13.791855"
+     inkscape:document-units="px"
+     inkscape:current-layer="layer5"
+     showgrid="false"
+     inkscape:object-paths="false"
+     inkscape:snap-intersection-paths="false"
+     inkscape:object-nodes="false"
+     inkscape:snap-smooth-nodes="false"
+     inkscape:snap-midpoints="false"
+     inkscape:window-width="1280"
+     inkscape:window-height="775"
+     inkscape:window-x="0"
+     inkscape:window-y="24"
+     inkscape:window-maximized="1"
+     inkscape:snap-nodes="false"
+     inkscape:snap-center="false"
+     inkscape:snap-object-midpoints="false"
+     inkscape:snap-global="true"
+     inkscape:snap-grids="true"
+     inkscape:snap-to-guides="false"
+     inkscape:snap-bbox="true"
+     inkscape:bbox-paths="false"
+     inkscape:bbox-nodes="false"
+     inkscape:snap-bbox-edge-midpoints="false"
+     inkscape:snap-bbox-midpoints="false"
+     inkscape:snap-page="true">
+    <inkscape:grid
+       type="xygrid"
+       id="grid3198" />
+  </sodipodi:namedview>
+  <metadata
+     id="metadata7">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title />
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:groupmode="layer"
+     id="layer7"
+     inkscape:label="background"
+     style="display:inline"
+     transform="translate(0,-692.60215)"
+     sodipodi:insensitive="true">
+    <path
+       style="fill:#ffffff;stroke:none"
+       d="m 0,692.60215 0,359.76005 752.40002,0 0,-359.76005 z"
+       id="rect3861-5"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="ccccc" />
+  </g>
+  <g
+     inkscape:groupmode="layer"
+     id="layer4"
+     inkscape:label="tile markers"
+     style="display:inline"
+     transform="translate(0,-692.60215)"
+     sodipodi:insensitive="true">
+    <rect
+       style="fill:#ececec;stroke:none"
+       id="rect6565"
+       width="151.78932"
+       height="94.868332"
+       x="618.09161"
+       y="1213.2018"
+       transform="matrix(-0.89442719,0.4472136,0.89442719,0.4472136,0,0)" />
+    <rect
+       transform="matrix(0.89442719,0.4472136,-0.89442719,0.4472136,0,0)"
+       y="788.85455"
+       x="1023.465"
+       height="94.868332"
+       width="151.78932"
+       id="rect6563"
+       style="fill:#ececec;stroke:none" />
+    <rect
+       style="fill:#ff2a2a;stroke:none"
+       id="rect3939"
+       width="18.973665"
+       height="18.973665"
+       x="1023.465"
+       y="788.85455"
+       transform="matrix(0.89442719,0.4472136,-0.89442719,0.4472136,0,0)" />
+    <rect
+       style="fill:#7fff2a;stroke:none"
+       id="rect3941"
+       width="18.973665"
+       height="18.973665"
+       x="1099.3596"
+       y="807.82825"
+       transform="matrix(0.89442719,0.4472136,-0.89442719,0.4472136,0,0)" />
+    <rect
+       y="-1308.0702"
+       x="618.09149"
+       height="18.973665"
+       width="18.973665"
+       id="rect4184"
+       style="fill:#ff2a2a;stroke:none"
+       transform="matrix(-0.89442719,0.4472136,-0.89442719,-0.4472136,0,0)" />
+    <rect
+       y="-1289.0963"
+       x="693.98615"
+       height="18.973665"
+       width="18.973665"
+       id="rect4186"
+       style="fill:#7fff2a;stroke:none"
+       transform="matrix(-0.89442719,0.4472136,-0.89442719,-0.4472136,0,0)" />
+    <rect
+       style="fill:#5599ff;fill-opacity:1;stroke:none"
+       id="rect4209"
+       width="18.973665"
+       height="18.973665"
+       x="1213.2018"
+       y="618.09155"
+       transform="matrix(0.89442719,0.4472136,-0.89442719,0.4472136,0,0)" />
+  </g>
+  <g
+     inkscape:groupmode="layer"
+     id="layer2"
+     inkscape:label="grid"
+     style="display:inline"
+     transform="translate(0,-692.60215)"
+     sodipodi:insensitive="true">
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="m 21.478511,717.99944 30.4056,-15.2028"
+       id="path6826"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 21.498719,734.95989 85.804991,702.80675"
+       id="path6824"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="m 21.473939,751.94285 98.252001,-49.126"
+       id="path6822"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 21.476615,768.91207 153.66589,702.81744"
+       id="path6820"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 21.484403,785.87875 187.64275,702.79958"
+       id="path6818"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 21.479351,802.85183 221.57491,702.80406"
+       id="path6816"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 21.479831,819.82215 255.48455,702.8198"
+       id="path6814"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 21.486815,836.78922 289.42022,702.82253"
+       id="path6812"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 21.490283,853.75806 323.40134,702.80253"
+       id="path6810"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 21.488111,870.72971 357.33068,702.80843"
+       id="path6808"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 21.485735,887.70146 391.24315,702.82275"
+       id="path6806"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 21.475955,904.6769 425.23908,702.79536"
+       id="path6804"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 21.496175,921.63735 459.15995,702.80547"
+       id="path6802"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 23.871443,937.42028 493.08089,702.81558"
+       id="path6800"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 57.860395,937.39638 527.00902,702.82206"
+       id="path6796"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 91.75825,937.418 560.9977,702.79829"
+       id="path6792"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 125.73238,937.4015 594.92198,702.8067"
+       id="path6788"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 159.70164,937.38744 628.83947,702.81853"
+       id="path6784"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 193.61767,937.39998 662.76335,702.82716"
+       id="path6780"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 227.58728,937.38572 696.7563,702.80123"
+       id="path6776"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 261.45812,937.42087 730.67773,702.81108"
+       id="path6772"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 295.46368,937.38867 730.9224,719.65931"
+       id="path6768"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 329.36915,937.40652 730.89763,736.64226"
+       id="path6764"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 363.30457,937.40933 730.89054,753.61638"
+       id="path6760"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 397.26559,937.39938 730.90807,770.57816"
+       id="path6756"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 431.21478,937.39542 730.88947,787.55803"
+       id="path6752"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 465.14321,937.40171 730.90356,804.52155"
+       id="path6748"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 499.04942,937.41919 730.8993,821.49425"
+       id="path6744"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 533.0223,937.40331 730.91399,838.45746"
+       id="path6740"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 566.95674,937.40664 730.89965,855.43518"
+       id="path6736"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="m 600.93184,937.38968 129.9776,-64.98881"
+       id="path6732"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="m 634.83216,937.41006 96.0675,-48.03375"
+       id="path6728"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="m 668.81856,937.3874 62.10125,-31.05061"
+       id="path6724"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 702.69631,937.41911 730.8951,923.31972"
+       id="path6720"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 56.355552,937.39751 21.479855,919.95966"
+       id="path6696"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 90.335997,937.41719 21.491231,902.99479"
+       id="path6692"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 124.23228,937.39475 21.475271,886.01624"
+       id="path6688"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 158.21008,937.41307 21.488099,869.05209"
+       id="path6684"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 192.11394,937.39447 21.482375,852.07867"
+       id="path6680"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 226.05024,937.39205 21.460943,835.09739"
+       id="path6676"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 260.02396,937.40835 21.481163,818.13693"
+       id="path6672"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 293.95187,937.40171 21.471383,801.16148"
+       id="path6668"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 327.88655,937.39854 21.485903,784.19819"
+       id="path6664"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 361.80511,937.3872 21.466823,767.21808"
+       id="path6660"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 395.80138,937.41476 21.484655,750.25644"
+       id="path6656"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 429.7105,937.3988 21.477287,733.28219"
+       id="path6652"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 463.64177,937.39382 21.496559,716.32125"
+       id="path6648"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 497.62729,937.41608 28.417835,702.81134"
+       id="path6644"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 531.55715,937.41039 62.337528,702.80061"
+       id="path6640"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 565.46932,937.39597 96.333707,702.82814"
+       id="path6636"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="m 599.44158,937.41151 -469.186,-234.593"
+       id="path6632"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 633.38754,937.41392 164.17308,702.80671"
+       id="path6628"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 667.30681,937.403 198.09737,702.79829"
+       id="path6624"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 701.26308,937.41057 232.08605,702.82206"
+       id="path6620"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 730.91854,935.26775 266.01419,702.81558"
+       id="path6616"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 730.8993,918.28755 299.92884,702.80234"
+       id="path6614"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 730.91399,901.32434 333.85601,702.79537"
+       id="path6612"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 730.91114,884.35237 367.8442,702.8189"
+       id="path6610"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 730.92445,867.38844 401.77282,702.81264"
+       id="path6608"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 730.89965,850.40549 435.6937,702.80251"
+       id="path6606"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 730.92439,833.44731 469.65468,702.81246"
+       id="path6604"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 730.91011,816.46958 503.61054,702.8198"
+       id="path6602"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 730.89586,799.49191 537.52014,702.80406"
+       id="path6600"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 730.90549,782.52618 571.45229,702.79957"
+       id="path6598"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 730.89911,765.55221 605.42957,702.81744"
+       id="path6596"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 730.91633,748.59027 639.36948,702.81685"
+       id="path6594"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 730.90495,731.61404 673.27622,702.79967"
+       id="path6592"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.36840001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;display:inline"
+       d="M 730.91178,714.64687 707.21132,702.79664"
+       id="path6590"
+       inkscape:connector-curvature="0" />
+  </g>
+  <g
+     inkscape:groupmode="layer"
+     id="layer3"
+     inkscape:label="tile areas"
+     style="display:inline"
+     transform="translate(0,-692.60215)">
+    <rect
+       style="fill:none;stroke:#000000;stroke-width:3.79473329;stroke-miterlimit:4;stroke-dasharray:none"
+       id="rect3169"
+       width="151.78932"
+       height="94.868355"
+       x="1023.465"
+       y="788.85455"
+       transform="matrix(0.89442719,0.4472136,-0.89442719,0.4472136,0,0)" />
+    <rect
+       y="-1308.0699"
+       x="618.09161"
+       height="94.868355"
+       width="151.78932"
+       id="rect4188"
+       style="fill:none;stroke:#000000;stroke-width:3.79473329;stroke-miterlimit:4;stroke-dasharray:none"
+       transform="matrix(-0.89442719,0.4472136,-0.89442719,-0.4472136,0,0)" />
+    <rect
+       transform="matrix(0.89717184,0.44168167,-0.89717184,0.44168167,0,0)"
+       y="1248.6029"
+       x="1282.3198"
+       height="7.8371782"
+       width="12.53948"
+       id="rect3247"
+       style="fill:none;stroke:#000000;stroke-width:1.12329161;stroke-miterlimit:4;stroke-dasharray:none" />
+    <rect
+       style="fill:none;stroke:#000000;stroke-width:1.12329161;stroke-miterlimit:4;stroke-dasharray:none"
+       id="rect4093"
+       width="12.53948"
+       height="7.8371782"
+       x="1045.6216"
+       y="1485.3011"
+       transform="matrix(-0.89717184,0.44168167,0.89717184,0.44168167,0,0)" />
+    <rect
+       style="fill:none;stroke:#000000;stroke-width:1.12329161;stroke-miterlimit:4;stroke-dasharray:none"
+       id="rect4145"
+       width="12.53948"
+       height="7.8371782"
+       x="1353.5859"
+       y="1313.1813"
+       transform="matrix(0.89717184,0.44168167,-0.89717184,0.44168167,0,0)" />
+    <rect
+       transform="matrix(0.89717184,0.44168167,-0.89717184,0.44168167,0,0)"
+       y="1313.1813"
+       x="1353.5859"
+       height="7.8371782"
+       width="12.53948"
+       id="rect3270"
+       style="fill:none;stroke:#000000;stroke-width:1.12329161;stroke-miterlimit:4;stroke-dasharray:none" />
+  </g>
+  <g
+     inkscape:groupmode="layer"
+     id="layer5"
+     inkscape:label="labels"
+     style="display:inline"
+     transform="translate(0,-692.60215)">
+    <text
+       xml:space="preserve"
+       style="font-size:34.48934937px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       x="123.57652"
+       y="797.86407"
+       id="text5637"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan5639"
+         x="123.57652"
+         y="797.86407"
+         style="font-weight:bold">ROTATE 90° CW (example)</tspan></text>
+    <path
+       style="fill:none;stroke:#000000;stroke-width:5.27452183;stroke-miterlimit:4;marker-end:url(#Arrow2Send)"
+       d="m 329.37463,828.07604 c 20.84196,-12.56761 54.63347,-12.56761 75.47543,0"
+       id="path5717"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+    <rect
+       transform="matrix(0.89442719,0.4472136,-0.89442719,0.4472136,0,0)"
+       y="1042.3517"
+       x="1075.5519"
+       height="15.939886"
+       width="15.939886"
+       id="rect3131"
+       style="fill:#ff2a2a;stroke:none;display:inline" />
+    <rect
+       transform="matrix(0.89442719,0.4472136,-0.89442719,0.4472136,0,0)"
+       y="1085.2841"
+       x="1118.4843"
+       height="15.939886"
+       width="15.939886"
+       id="rect3133"
+       style="fill:#7fff2a;stroke:none;display:inline" />
+    <rect
+       transform="matrix(-0.89442719,0.4472136,-0.89442719,-0.4472136,0,0)"
+       style="fill:#7fff2a;stroke:none;display:inline"
+       id="rect3135"
+       width="15.939886"
+       height="15.939886"
+       x="1106.7502"
+       y="-1155.8905" />
+    <rect
+       transform="matrix(0.8944272,0.44721358,-0.8944272,0.44721358,0,0)"
+       y="1128.2166"
+       x="1161.4166"
+       height="15.939887"
+       width="15.939887"
+       id="rect3137"
+       style="fill:#5599ff;fill-opacity:1;stroke:none;display:inline" />
+    <text
+       sodipodi:linespacing="125%"
+       id="text3139"
+       y="958.45111"
+       x="25.466764"
+       style="font-size:11.43270588px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       xml:space="preserve"><tspan
+         style="font-weight:bold"
+         y="958.45111"
+         x="25.466764"
+         id="tspan3141"
+         sodipodi:role="line">1</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:11.43270588px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       x="25.466791"
+       y="996.85114"
+       id="text3143"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3145"
+         x="25.466791"
+         y="996.85114"
+         style="font-weight:bold">1</tspan></text>
+    <text
+       sodipodi:linespacing="125%"
+       id="text3147"
+       y="1016.1264"
+       x="25.762766"
+       style="font-size:11.43270588px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       xml:space="preserve"><tspan
+         style="font-weight:bold"
+         y="1016.1264"
+         x="25.762766"
+         id="tspan3149"
+         sodipodi:role="line">2</tspan></text>
+    <rect
+       transform="matrix(-0.89442719,0.4472136,-0.89442719,-0.4472136,0,0)"
+       style="fill:#ff2a2a;stroke:none;display:inline"
+       id="rect3231"
+       width="15.939886"
+       height="15.939886"
+       x="1063.8177"
+       y="-1112.9579" />
+    <text
+       xml:space="preserve"
+       style="font-size:11.43270588px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       x="25.763147"
+       y="977.72668"
+       id="text3233"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3235"
+         x="25.763147"
+         y="977.72668"
+         style="font-weight:bold">2</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:10.08127022px;font-style:normal;font-weight:normal;line-height:171.00000381%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="48.410496"
+       y="958.31488"
+       id="text3261"
+       sodipodi:linespacing="171%"><tspan
+         sodipodi:role="line"
+         id="tspan3263"
+         x="48.410496"
+         y="958.31488"
+         style="font-size:11px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;line-height:171.00000381%;font-family:Sans;-inkscape-font-specification:Sans">northern tile of the area (TileAreaT::tile)</tspan><tspan
+         sodipodi:role="line"
+         x="48.410496"
+         y="977.12488"
+         id="tspan3267"
+         style="font-size:11px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;line-height:171.00000381%;font-family:Sans;-inkscape-font-specification:Sans">transformed northern tile of the area (transformed_north)</tspan><tspan
+         sodipodi:role="line"
+         x="48.410496"
+         y="995.93488"
+         style="font-size:11px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;line-height:171.00000381%;font-family:Sans;-inkscape-font-specification:Sans"
+         id="tspan5100">tile of the area (tile)</tspan><tspan
+         sodipodi:role="line"
+         x="48.410496"
+         y="1014.7449"
+         id="tspan3271"
+         style="font-size:11px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;line-height:171.00000381%;font-family:Sans;-inkscape-font-specification:Sans">transformed tile of the area (transformed_tile)</tspan><tspan
+         sodipodi:role="line"
+         x="48.410496"
+         y="1033.5549"
+         style="font-size:11px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;line-height:171.00000381%;font-family:Sans;-inkscape-font-specification:Sans"
+         id="tspan5104">northern tile of the transformed area (dst_area_north)</tspan></text>
+    <rect
+       style="fill:#ff2a2a;stroke:none;display:inline"
+       id="rect3273"
+       width="15.939886"
+       height="15.939886"
+       x="-795.13434"
+       y="-1519.1414"
+       transform="matrix(0.89442719,-0.4472136,-0.89442719,-0.4472136,0,0)" />
+    <text
+       sodipodi:linespacing="227%"
+       id="text3299"
+       y="958.31488"
+       x="406.78116"
+       style="font-size:10.08127022px;font-style:normal;font-weight:normal;line-height:226.99999809%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       xml:space="preserve"><tspan
+         style="font-size:11px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;line-height:226.99999809%;font-family:Sans;-inkscape-font-specification:Sans"
+         y="958.31488"
+         x="406.78116"
+         sodipodi:role="line"
+         id="tspan6555">TileAreaT::TransformTile:</tspan><tspan
+         style="font-size:11px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;line-height:226.99999809%;font-family:Sans;-inkscape-font-specification:Sans"
+         y="983.28485"
+         x="406.78116"
+         sodipodi:role="line"
+         id="tspan6557">TileAreaT::ReverseTransformTile:</tspan><tspan
+         style="font-size:11px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;line-height:226.99999809%;font-family:Sans;-inkscape-font-specification:Sans"
+         y="1008.2549"
+         x="406.78116"
+         sodipodi:role="line"
+         id="tspan6559">TileAreaT::TransformedNorth:</tspan><tspan
+         style="font-size:11px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;line-height:226.99999809%;font-family:Sans;-inkscape-font-specification:Sans"
+         id="tspan3309"
+         y="1033.2249"
+         x="406.78116"
+         sodipodi:role="line">TileAreaT::ReverseTransformedNorth:</tspan></text>
+    <rect
+       transform="matrix(0.89442719,-0.44721359,-0.89442719,-0.44721359,0,0)"
+       y="-1548.417"
+       x="-765.8595"
+       height="15.939887"
+       width="15.939887"
+       id="rect3313"
+       style="fill:#5599ff;fill-opacity:1;stroke:none;display:inline" />
+    <text
+       sodipodi:linespacing="125%"
+       id="text3315"
+       y="-1023.6799"
+       x="668.86713"
+       style="font-size:11.43270588px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       xml:space="preserve"
+       transform="scale(1,-1)"><tspan
+         style="font-weight:bold"
+         y="-1023.6799"
+         x="668.86713"
+         id="tspan3317"
+         sodipodi:role="line">→</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:11.43270588px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       x="643.63861"
+       y="1032.0898"
+       id="text3327"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3329"
+         x="643.63861"
+         y="1032.0898"
+         style="font-weight:bold">2</tspan></text>
+    <rect
+       transform="matrix(-0.89442719,-0.4472136,0.89442719,-0.4472136,0,0)"
+       y="-740.44305"
+       x="-1522.8073"
+       height="15.939886"
+       width="15.939886"
+       id="rect3331"
+       style="fill:#ff2a2a;stroke:none;display:inline" />
+    <rect
+       style="fill:#5599ff;fill-opacity:1;stroke:none;display:inline"
+       id="rect3333"
+       width="15.939887"
+       height="15.939887"
+       x="-1493.599"
+       y="-769.65118"
+       transform="matrix(-0.89442719,-0.44721359,0.89442719,-0.44721359,0,0)" />
+    <text
+       xml:space="preserve"
+       style="font-size:11.43270588px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       x="668.79767"
+       y="-1000.8605"
+       id="text3335"
+       sodipodi:linespacing="125%"
+       transform="scale(1,-1)"><tspan
+         sodipodi:role="line"
+         id="tspan3337"
+         x="668.79767"
+         y="-1000.8605"
+         style="font-weight:bold">→</tspan></text>
+    <text
+       sodipodi:linespacing="125%"
+       id="text3339"
+       y="1009.2702"
+       x="695.83484"
+       style="font-size:11.43270588px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       xml:space="preserve"><tspan
+         style="font-weight:bold"
+         y="1009.2702"
+         x="695.83484"
+         id="tspan3341"
+         sodipodi:role="line">2</tspan></text>
+    <rect
+       transform="matrix(0.89442719,0.4472136,-0.89442719,0.4472136,0,0)"
+       y="710.38507"
+       x="1408.5416"
+       height="15.939886"
+       width="15.939886"
+       id="rect3343"
+       style="fill:#7fff2a;fill-opacity:1;stroke:none;display:inline" />
+    <rect
+       style="fill:#7fff2a;fill-opacity:1;stroke:none;display:inline"
+       id="rect3345"
+       width="15.939887"
+       height="15.939887"
+       x="1464.4972"
+       y="654.42877"
+       transform="matrix(0.89442719,0.44721359,-0.89442719,0.44721359,0,0)" />
+    <text
+       xml:space="preserve"
+       style="font-size:11.43270588px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       x="694.79431"
+       y="958.90826"
+       id="text3347"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3349"
+         x="694.79431"
+         y="958.90826"
+         style="font-weight:bold">→</tspan></text>
+    <text
+       sodipodi:linespacing="125%"
+       id="text3351"
+       y="958.98401"
+       x="620.51727"
+       style="font-size:11.43270588px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       xml:space="preserve"><tspan
+         style="font-weight:bold"
+         y="958.98401"
+         x="620.51727"
+         id="tspan3353"
+         sodipodi:role="line">1</tspan></text>
+    <rect
+       style="fill:#ff2a2a;stroke:none;display:inline"
+       id="rect3355"
+       width="15.939886"
+       height="15.939886"
+       x="1432.6057"
+       y="686.32031"
+       transform="matrix(0.89442719,0.4472136,-0.89442719,0.4472136,0,0)" />
+    <text
+       xml:space="preserve"
+       style="font-size:11.43270588px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       x="663.5658"
+       y="958.98401"
+       id="text3357"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3359"
+         x="663.5658"
+         y="958.98401"
+         style="font-weight:bold">2</tspan></text>
+    <text
+       sodipodi:linespacing="125%"
+       id="text3361"
+       y="958.90826"
+       x="643.74567"
+       style="font-size:11.43270588px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       xml:space="preserve"><tspan
+         style="font-weight:bold"
+         y="958.90826"
+         x="643.74567"
+         id="tspan3363"
+         sodipodi:role="line">,</tspan></text>
+    <text
+       sodipodi:linespacing="125%"
+       id="text4175"
+       y="958.98364"
+       x="720.61444"
+       style="font-size:11.43270588px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       xml:space="preserve"><tspan
+         style="font-weight:bold"
+         y="958.98364"
+         x="720.61444"
+         id="tspan4177"
+         sodipodi:role="line">2</tspan></text>
+    <rect
+       style="fill:#7fff2a;fill-opacity:1;stroke:none;display:inline"
+       id="rect4179"
+       width="15.939886"
+       height="15.939886"
+       x="1435.2516"
+       y="737.54517"
+       transform="matrix(0.89442719,0.4472136,-0.89442719,0.4472136,0,0)" />
+    <rect
+       transform="matrix(-0.89442719,0.44721359,0.89442719,0.44721359,0,0)"
+       y="1459.3159"
+       x="713.48022"
+       height="15.939887"
+       width="15.939887"
+       id="rect4181"
+       style="fill:#7fff2a;fill-opacity:1;stroke:none;display:inline" />
+    <text
+       sodipodi:linespacing="125%"
+       id="text4183"
+       y="982.99976"
+       x="694.39142"
+       style="font-size:11.43270588px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       xml:space="preserve"><tspan
+         style="font-weight:bold"
+         y="982.99976"
+         x="694.39142"
+         id="tspan4185"
+         sodipodi:role="line">→</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:11.43270588px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       x="662.77679"
+       y="983.07538"
+       id="text4187"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan4189"
+         x="662.77679"
+         y="983.07538"
+         style="font-weight:bold">2</tspan></text>
+    <rect
+       transform="matrix(-0.89442719,0.4472136,0.89442719,0.4472136,0,0)"
+       y="1491.2074"
+       x="681.58911"
+       height="15.939886"
+       width="15.939886"
+       id="rect4191"
+       style="fill:#ff2a2a;stroke:none;display:inline" />
+    <text
+       sodipodi:linespacing="125%"
+       id="text4193"
+       y="983.07538"
+       x="720.21057"
+       style="font-size:11.43270588px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       xml:space="preserve"><tspan
+         style="font-weight:bold"
+         y="983.07538"
+         x="720.21057"
+         id="tspan4195"
+         sodipodi:role="line">2</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:11.43270588px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       x="643.34283"
+       y="982.99976"
+       id="text4197"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan4199"
+         x="643.34283"
+         y="982.99976"
+         style="font-weight:bold">,</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:11.43270588px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       x="619.72919"
+       y="983.07507"
+       id="text4201"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan4203"
+         x="619.72919"
+         y="983.07507"
+         style="font-weight:bold">1</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:26.54228592px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="95.972397"
+       y="746.4621"
+       id="text5106"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan5108"
+         x="95.972397"
+         y="746.4621">Explanation on TileAreaT transformations</tspan></text>
+    <g
+       id="g6532"
+       transform="matrix(1.2,0,0,1.2,25.4513,-206.20779)">
+      <path
+         inkscape:connector-curvature="0"
+         id="path4743"
+         d="m 38.351894,925.43359 33.224791,0"
+         style="fill:none;stroke:#000000;stroke-width:1.28295767;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;marker-start:url(#Arrow2Sstart);marker-end:url(#Arrow2Send)" />
+      <path
+         style="fill:none;stroke:#000000;stroke-width:2.00492573;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;marker-start:url(#Arrow2Sstart);marker-end:url(#Arrow2Send)"
+         d="m 54.96429,918.13257 0,14.60204"
+         id="path5805"
+         inkscape:connector-curvature="0" />
+      <text
+         sodipodi:linespacing="125%"
+         id="text5824"
+         y="915.06653"
+         x="50.374447"
+         style="font-size:10px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+         xml:space="preserve"><tspan
+           style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-family:Serif;-inkscape-font-specification:Serif Bold"
+           y="915.06653"
+           x="50.374447"
+           id="tspan5826"
+           sodipodi:role="line">N</tspan></text>
+      <text
+         xml:space="preserve"
+         style="font-size:10px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+         x="51.324154"
+         y="943.08575"
+         id="text5828"
+         sodipodi:linespacing="125%"><tspan
+           sodipodi:role="line"
+           id="tspan5830"
+           x="51.324154"
+           y="943.08575"
+           style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-family:Serif;-inkscape-font-specification:Serif Bold">S</tspan></text>
+      <text
+         sodipodi:linespacing="125%"
+         id="text5832"
+         y="929.07861"
+         x="78.171951"
+         style="font-size:10px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+         xml:space="preserve"><tspan
+           style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-family:Serif;-inkscape-font-specification:Serif Bold"
+           y="929.07861"
+           x="78.171951"
+           id="tspan5834"
+           sodipodi:role="line">E</tspan></text>
+      <text
+         xml:space="preserve"
+         style="font-size:10px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+         x="22.337685"
+         y="929.07861"
+         id="text5836"
+         sodipodi:linespacing="125%"><tspan
+           sodipodi:role="line"
+           id="tspan5838"
+           x="22.337685"
+           y="929.07861"
+           style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-family:Serif;-inkscape-font-specification:Serif Bold">W</tspan></text>
+      <path
+         inkscape:connector-curvature="0"
+         id="path6075"
+         d="M 90.015437,942.72921 19.30476,907.37387"
+         style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;marker-start:url(#Arrow2Sstart);marker-end:none;display:inline;enable-background:new" />
+      <path
+         inkscape:connector-curvature="0"
+         id="path5870"
+         d="M 19.30476,942.72921 90.015437,907.37387"
+         style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;marker-start:url(#Arrow2Sstart);marker-end:none;display:inline;enable-background:new" />
+      <text
+         sodipodi:linespacing="125%"
+         id="text6477"
+         y="948.11798"
+         x="11.056497"
+         style="font-size:10px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;enable-background:new;font-family:Sans"
+         xml:space="preserve"><tspan
+           y="948.11798"
+           x="11.056497"
+           id="tspan6479"
+           sodipodi:role="line">x</tspan></text>
+      <text
+         sodipodi:linespacing="125%"
+         id="text6481"
+         y="946.11218"
+         x="91.75"
+         style="font-size:10px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;enable-background:new;font-family:Sans"
+         xml:space="preserve"><tspan
+           y="946.11218"
+           x="91.75"
+           id="tspan6483"
+           sodipodi:role="line">y</tspan></text>
+    </g>
+    <text
+       xml:space="preserve"
+       style="font-size:11.43270588px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       x="604.51727"
+       y="958.98401"
+       id="text3188"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3190"
+         x="604.51727"
+         y="958.98401"
+         style="font-weight:bold">(</tspan></text>
+    <text
+       sodipodi:linespacing="125%"
+       id="text3192"
+       y="958.98401"
+       x="682.51727"
+       style="font-size:11.43270588px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       xml:space="preserve"><tspan
+         style="font-weight:bold"
+         y="958.98401"
+         x="682.51727"
+         id="tspan3194"
+         sodipodi:role="line">)</tspan></text>
+    <text
+       sodipodi:linespacing="125%"
+       id="text3196"
+       y="982.98401"
+       x="604.51727"
+       style="font-size:11.43270588px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       xml:space="preserve"><tspan
+         style="font-weight:bold"
+         y="982.98401"
+         x="604.51727"
+         id="tspan3198"
+         sodipodi:role="line">(</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:11.43270588px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       x="682.51727"
+       y="982.98401"
+       id="text3200"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3202"
+         x="682.51727"
+         y="982.98401"
+         style="font-weight:bold">)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:13.60865021px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;enable-background:new;font-family:Sans"
+       x="204.80836"
+       y="823.93964"
+       id="text5672"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan5674"
+         x="204.80836"
+         y="823.93964"
+         style="font-weight:bold">1</tspan></text>
+    <text
+       sodipodi:linespacing="125%"
+       id="text5676"
+       y="866.36603"
+       x="255.71988"
+       style="font-size:13.60865021px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;enable-background:new;font-family:Sans"
+       xml:space="preserve"><tspan
+         style="font-weight:bold"
+         y="866.36603"
+         x="255.71988"
+         id="tspan5678"
+         sodipodi:role="line">1</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:13.60865021px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;enable-background:new;font-family:Sans"
+       x="510.63068"
+       y="891.9115"
+       id="text5680"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan5682"
+         x="510.63068"
+         y="891.9115"
+         style="font-weight:bold">2</tspan></text>
+    <text
+       sodipodi:linespacing="125%"
+       id="text5684"
+       y="866.45581"
+       x="595.48383"
+       style="font-size:13.60865021px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;enable-background:new;font-family:Sans"
+       xml:space="preserve"><tspan
+         style="font-weight:bold"
+         y="866.45581"
+         x="595.48383"
+         id="tspan5686"
+         sodipodi:role="line">2</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:10px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="49.000977"
+       y="1067.2064"
+       id="text3205"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3207"
+         x="49.000977"
+         y="1067.2064"
+         style="font-size:11px">northern tile of the source area</tspan></text>
+    <text
+       sodipodi:linespacing="125%"
+       id="text3213"
+       y="1087.2064"
+       x="49.000977"
+       style="font-size:10px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       xml:space="preserve"><tspan
+         style="font-size:11px"
+         y="1087.2064"
+         x="49.000977"
+         id="tspan3215"
+         sodipodi:role="line">tile of the source area</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:10px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="49.000977"
+       y="1107.2064"
+       id="text3217"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3219"
+         x="49.000977"
+         y="1107.2064"
+         style="font-size:11px">source tile of the northern tile of the transformed area </tspan></text>
+    <text
+       sodipodi:linespacing="125%"
+       id="text3221"
+       y="1127.2064"
+       x="49.000977"
+       style="font-size:10px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       xml:space="preserve"><tspan
+         style="font-size:11px"
+         y="1127.2064"
+         x="49.000977"
+         id="tspan3223"
+         sodipodi:role="line">source area</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:10px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="49.000977"
+       y="1147.2064"
+       id="text3225"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3227"
+         x="49.000977"
+         y="1147.2064"
+         style="font-size:11px">transformation</tspan></text>
+    <rect
+       style="fill:#ff2a2a;stroke:none;display:inline"
+       id="rect3229"
+       width="15.939886"
+       height="15.939886"
+       x="1198.6404"
+       y="1162.7954"
+       transform="matrix(0.89442719,0.4472136,-0.89442719,0.4472136,0,0)" />
+    <text
+       xml:space="preserve"
+       style="font-size:11.43270588px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       x="27.83223"
+       y="1067.3622"
+       id="text3231"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3233"
+         x="27.83223"
+         y="1067.3622"
+         style="font-weight:bold">1</tspan></text>
+    <rect
+       transform="matrix(0.89442719,0.4472136,-0.89442719,0.4472136,0,0)"
+       y="1185.1561"
+       x="1221.0011"
+       height="15.939886"
+       width="15.939886"
+       id="rect3235"
+       style="fill:#7fff2a;stroke:none;display:inline" />
+    <text
+       sodipodi:linespacing="125%"
+       id="text3237"
+       y="1087.3622"
+       x="27.83223"
+       style="font-size:11.43270588px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       xml:space="preserve"><tspan
+         style="font-weight:bold"
+         y="1087.3622"
+         x="27.83223"
+         id="tspan3239"
+         sodipodi:role="line">1</tspan></text>
+    <rect
+       style="fill:#5599ff;stroke:none;display:inline"
+       id="rect3241"
+       width="15.939886"
+       height="15.939886"
+       x="1243.3618"
+       y="1207.5168"
+       transform="matrix(0.89442719,0.4472136,-0.89442719,0.4472136,0,0)" />
+    <text
+       xml:space="preserve"
+       style="font-size:11.43270588px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       x="27.83223"
+       y="1107.3622"
+       id="text3243"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3245"
+         x="27.83223"
+         y="1107.3622"
+         style="font-weight:bold">1</tspan></text>
+    <text
+       sodipodi:linespacing="125%"
+       id="text4089"
+       y="1147.3622"
+       x="27.83223"
+       style="font-size:11.43270588px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       xml:space="preserve"><tspan
+         style="font-weight:bold"
+         y="1147.3622"
+         x="27.83223"
+         id="tspan4091"
+         sodipodi:role="line">↷</tspan></text>
+    <text
+       sodipodi:linespacing="125%"
+       id="text4095"
+       y="1067.2064"
+       x="409.00098"
+       style="font-size:10px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       xml:space="preserve"><tspan
+         style="font-size:11px"
+         y="1067.2064"
+         x="409.00098"
+         id="tspan4097"
+         sodipodi:role="line">transformed northern tile of the source area</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:10px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="409.00098"
+       y="1087.2064"
+       id="text4099"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan4101"
+         x="409.00098"
+         y="1087.2064"
+         style="font-size:11px">transformed tile of the source area</tspan></text>
+    <text
+       sodipodi:linespacing="125%"
+       id="text4103"
+       y="1107.2064"
+       x="409.00098"
+       style="font-size:10px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       xml:space="preserve"><tspan
+         style="font-size:11px"
+         y="1107.2064"
+         x="409.00098"
+         id="tspan4105"
+         sodipodi:role="line">northern tile of the transformed area</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:10px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="409.00098"
+       y="1127.2064"
+       id="text4107"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan4109"
+         x="409.00098"
+         y="1127.2064"
+         style="font-size:11px">transformed area</tspan></text>
+    <text
+       sodipodi:linespacing="125%"
+       id="text4111"
+       y="1147.2064"
+       x="409.00098"
+       style="font-size:10px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       xml:space="preserve"><tspan
+         style="font-size:11px"
+         y="1147.2064"
+         x="409.00098"
+         id="tspan4113"
+         sodipodi:role="line">inverted transformation</tspan></text>
+    <rect
+       transform="matrix(0.89442719,0.4472136,-0.89442719,0.4472136,0,0)"
+       y="961.54974"
+       x="1399.8859"
+       height="15.939886"
+       width="15.939886"
+       id="rect4115"
+       style="fill:#ff2a2a;stroke:none;display:inline" />
+    <text
+       sodipodi:linespacing="125%"
+       id="text4117"
+       y="1067.3622"
+       x="387.83221"
+       style="font-size:11.43270588px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       xml:space="preserve"><tspan
+         style="font-weight:bold"
+         y="1067.3622"
+         x="387.83221"
+         id="tspan4119"
+         sodipodi:role="line">2</tspan></text>
+    <rect
+       style="fill:#7fff2a;stroke:none;display:inline"
+       id="rect4121"
+       width="15.939886"
+       height="15.939886"
+       x="1422.2466"
+       y="983.91058"
+       transform="matrix(0.89442719,0.4472136,-0.89442719,0.4472136,0,0)" />
+    <text
+       xml:space="preserve"
+       style="font-size:11.43270588px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       x="387.83221"
+       y="1087.3622"
+       id="text4123"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan4125"
+         x="387.83221"
+         y="1087.3622"
+         style="font-weight:bold">2</tspan></text>
+    <rect
+       transform="matrix(0.89442719,0.4472136,-0.89442719,0.4472136,0,0)"
+       y="1006.2711"
+       x="1444.6073"
+       height="15.939886"
+       width="15.939886"
+       id="rect4127"
+       style="fill:#5599ff;stroke:none;display:inline" />
+    <text
+       sodipodi:linespacing="125%"
+       id="text4129"
+       y="1107.3622"
+       x="387.83221"
+       style="font-size:11.43270588px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       xml:space="preserve"><tspan
+         style="font-weight:bold"
+         y="1107.3622"
+         x="387.83221"
+         id="tspan4131"
+         sodipodi:role="line">2</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:11.43270588px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       x="387.83221"
+       y="1147.3622"
+       id="text4133"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan4135"
+         x="387.83221"
+         y="1147.3622"
+         style="font-weight:bold">↶</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:10px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="49.000977"
+       y="1187.2064"
+       id="text4147"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan4149"
+         x="49.000977"
+         y="1187.2064"
+         style="font-size:11px">.TransformTile(</tspan></text>
+    <text
+       sodipodi:linespacing="125%"
+       id="text4151"
+       y="1187.2064"
+       x="163.00098"
+       style="font-size:10px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       xml:space="preserve"><tspan
+         style="font-size:11px"
+         y="1187.2064"
+         x="163.00098"
+         id="tspan4153"
+         sodipodi:role="line">,</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:10px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="199.00098"
+       y="1187.2064"
+       id="text4155"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan4157"
+         x="199.00098"
+         y="1187.2064"
+         style="font-size:11px">,</tspan></text>
+    <text
+       sodipodi:linespacing="125%"
+       id="text4159"
+       y="1187.2064"
+       x="217.00098"
+       style="font-size:10px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       xml:space="preserve"><tspan
+         style="font-size:11px"
+         y="1187.2064"
+         x="217.00098"
+         id="tspan4161"
+         sodipodi:role="line">) →</tspan></text>
+    <rect
+       style="fill:#7fff2a;stroke:none;display:inline"
+       id="rect4169"
+       width="15.939886"
+       height="15.939886"
+       x="1396.5323"
+       y="1233.2321"
+       transform="matrix(0.89442719,0.4472136,-0.89442719,0.4472136,0,0)" />
+    <text
+       xml:space="preserve"
+       style="font-size:11.43270588px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       x="141.83223"
+       y="1187.3622"
+       id="text4171"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan4173"
+         x="141.83223"
+         y="1187.3622"
+         style="font-weight:bold">1</tspan></text>
+    <rect
+       style="fill:#ff2a2a;stroke:none;display:inline"
+       id="rect3253"
+       width="15.939886"
+       height="15.939886"
+       x="1417.7751"
+       y="1211.989"
+       transform="matrix(0.89442719,0.4472136,-0.89442719,0.4472136,0,0)" />
+    <text
+       xml:space="preserve"
+       style="font-size:11.43270588px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       x="179.83221"
+       y="1187.3622"
+       id="text3255"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3257"
+         x="179.83221"
+         y="1187.3622"
+         style="font-weight:bold">2</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:11.43270588px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       x="205.83223"
+       y="1187.3622"
+       id="text3259"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3261"
+         x="205.83223"
+         y="1187.3622"
+         style="font-weight:bold">↷</tspan></text>
+    <rect
+       transform="matrix(0.89442719,0.4472136,-0.89442719,0.4472136,0,0)"
+       y="1173.9766"
+       x="1455.7881"
+       height="15.939886"
+       width="15.939886"
+       id="rect3263"
+       style="fill:#7fff2a;stroke:none;display:inline" />
+    <text
+       sodipodi:linespacing="125%"
+       id="text3265"
+       y="1187.3622"
+       x="247.83221"
+       style="font-size:11.43270588px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       xml:space="preserve"><tspan
+         style="font-weight:bold"
+         y="1187.3622"
+         x="247.83221"
+         id="tspan3268"
+         sodipodi:role="line">2</tspan></text>
+    <text
+       sodipodi:linespacing="125%"
+       id="text3272"
+       y="1187.2064"
+       x="49.000977"
+       style="font-size:10px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       xml:space="preserve"><tspan
+         style="font-size:11px"
+         y="1187.2064"
+         x="49.000977"
+         id="tspan3274"
+         sodipodi:role="line">.TransformTile(</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:10px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="163.00098"
+       y="1187.2064"
+       id="text3276"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3278"
+         x="163.00098"
+         y="1187.2064"
+         style="font-size:11px">,</tspan></text>
+    <text
+       sodipodi:linespacing="125%"
+       id="text3280"
+       y="1187.2064"
+       x="199.00098"
+       style="font-size:10px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       xml:space="preserve"><tspan
+         style="font-size:11px"
+         y="1187.2064"
+         x="199.00098"
+         id="tspan3282"
+         sodipodi:role="line">,</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:10px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="217.00098"
+       y="1187.2064"
+       id="text3284"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3286"
+         x="217.00098"
+         y="1187.2064"
+         style="font-size:11px">) →</tspan></text>
+    <rect
+       transform="matrix(0.89442719,0.4472136,-0.89442719,0.4472136,0,0)"
+       y="1233.2321"
+       x="1396.5323"
+       height="15.939886"
+       width="15.939886"
+       id="rect3288"
+       style="fill:#7fff2a;stroke:none;display:inline" />
+    <text
+       sodipodi:linespacing="125%"
+       id="text3290"
+       y="1187.3622"
+       x="141.83223"
+       style="font-size:11.43270588px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       xml:space="preserve"><tspan
+         style="font-weight:bold"
+         y="1187.3622"
+         x="141.83223"
+         id="tspan3292"
+         sodipodi:role="line">1</tspan></text>
+    <rect
+       transform="matrix(0.89442719,0.4472136,-0.89442719,0.4472136,0,0)"
+       y="1211.989"
+       x="1417.7751"
+       height="15.939886"
+       width="15.939886"
+       id="rect3294"
+       style="fill:#ff2a2a;stroke:none;display:inline" />
+    <text
+       sodipodi:linespacing="125%"
+       id="text3296"
+       y="1187.3622"
+       x="179.83221"
+       style="font-size:11.43270588px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       xml:space="preserve"><tspan
+         style="font-weight:bold"
+         y="1187.3622"
+         x="179.83221"
+         id="tspan3298"
+         sodipodi:role="line">2</tspan></text>
+    <text
+       sodipodi:linespacing="125%"
+       id="text3300"
+       y="1187.3622"
+       x="205.83223"
+       style="font-size:11.43270588px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       xml:space="preserve"><tspan
+         style="font-weight:bold"
+         y="1187.3622"
+         x="205.83223"
+         id="tspan3302"
+         sodipodi:role="line">↷</tspan></text>
+    <rect
+       style="fill:#7fff2a;stroke:none;display:inline"
+       id="rect3304"
+       width="15.939886"
+       height="15.939886"
+       x="1455.7881"
+       y="1173.9766"
+       transform="matrix(0.89442719,0.4472136,-0.89442719,0.4472136,0,0)" />
+    <text
+       xml:space="preserve"
+       style="font-size:11.43270588px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;display:inline;font-family:Sans"
+       x="247.83221"
+       y="1187.3622"
+       id="text3306"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3308"
+         x="247.83221"
+         y="1187.3622"
+         style="font-weight:bold">2</tspan></text>
+  </g>
+</svg>
diff -urNad openttd-1.3.2/media/extra_grf/flat_blacktiles.nfo openttd-1.3.2-DC3.0RC3/media/extra_grf/flat_blacktiles.nfo
--- openttd-1.3.2/media/extra_grf/flat_blacktiles.nfo	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/media/extra_grf/flat_blacktiles.nfo	2013-11-22 05:49:06.000000000 +0100
@@ -0,0 +1,25 @@
+// Automatically generated by GRFCODEC. Do not modify!
+// (Info version 7)
+// Escapes: 2+ 2- 2< 2> 2u< 2u> 2/ 2% 2u/ 2u% 2* 2& 2| 2^ 2sto = 2s 2rst = 2r 2psto 2ror = 2rot 2cmp 2ucmp 2<< 2u>> 2>>
+// Escapes: 71 70 7= 7! 7< 7> 7G 7g 7gG 7GG 7gg 7c 7C
+// Escapes: D= = DR D+ = DF D- = DC Du* = DM D* = DnF Du<< = DnC D<< = DO D& D| Du/ D/ Du% D%
+// Format: spritenum pcxfile xpos ypos compression ysize xsize xrel yrel
+    0 sprites/flat_blacktiles.png 18 8 09 31 64 -31 0
+    1 sprites/flat_blacktiles.png 98 8 09 31 64 -31 0
+    2 sprites/flat_blacktiles.png 178 8 09 23 64 -31 0
+    3 sprites/flat_blacktiles.png 258 8 09 23 64 -31 0
+    4 sprites/flat_blacktiles.png 338 8 09 31 64 -31 0
+    5 sprites/flat_blacktiles.png 418 8 09 31 64 -31 0
+    6 sprites/flat_blacktiles.png 498 8 09 23 64 -31 0
+    7 sprites/flat_blacktiles.png 578 8 09 23 64 -31 0
+    8 sprites/flat_blacktiles.png 658 8 09 39 64 -31 -8
+    9 sprites/flat_blacktiles.png 2 72 09 39 64 -31 -8
+   10 sprites/flat_blacktiles.png 82 72 09 31 64 -31 -8
+   11 sprites/flat_blacktiles.png 162 72 09 31 64 -31 -8
+   12 sprites/flat_blacktiles.png 242 72 09 39 64 -31 -8
+   13 sprites/flat_blacktiles.png 322 72 09 39 64 -31 -8
+   14 sprites/flat_blacktiles.png 402 72 09 31 64 -31 -8
+   15 sprites/flat_blacktiles.png 482 72 09 47 64 -31 -16
+   16 sprites/flat_blacktiles.png 562 72 09 15 64 -31 0
+   17 sprites/flat_blacktiles.png 642 72 09 31 64 -31 -8
+   18 sprites/flat_blacktiles.png 722 72 09 31 64 -31 -8
diff -urNad openttd-1.3.2/media/extra_grf/flat_blacktiles.png openttd-1.3.2-DC3.0RC3/media/extra_grf/flat_blacktiles.png
--- openttd-1.3.2/media/extra_grf/flat_blacktiles.png	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/media/extra_grf/flat_blacktiles.png	2013-11-22 05:49:06.000000000 +0100
@@ -0,0 +1,7 @@
+PNG
+
+   IHDR         Z)   sRGB    PLTE     000@@@PPPdddttt4<HDL\X`plt0,@<PL`\xx@d̨H,X<hP,|hH\xԼܰ@ Xp  48LTlh|܄윤 <L( `<tXt8PlĴD `,D`xԜ    @Tl,8(H8\LlXĀlԔ4 @  P0`@pTh,4,D <X0Ph<h|L\l|4 H,8`HLtX`lx  8 H(X4h@|T,l@XL(`4tD(T8`@pP̀`Ԕp਀켔Pd(x8(L@d`$(D04T@@dPPtdd(p@,X@hLxXh l $ 4 H `x8X@`Pl(`x4pPt444444dX|Hp\,pDdĨȰи<  \            P l      ̈ 0dؘX$h4|D(\8xHd\4l@|L\센X            Ll,H4lTҒ~< T h |    @    00 @@ PP   Dp$Ht(Lx,P|0THdd`D`WK   bKGD H   	pHYs        tIME :Z  bIDATx]r*s۞ lD`>CS؛?YoD،/hGn5CSZDf> = BI衩=lA {u7c wgpVǸ|_*+J>_}dS>^hzuem2#[nx|]}3|[
+=_:_}![A +o<o kMz-5^c[$:tv,ec~"oM߅H7#n}7C߈;N5hHŤp]CO75`*p"v }e߈ϿXfoyw-RU|5L2G eX.Hw$㓎WC		*\5٦o``|쫊Xe^`@R82!Ta( bxuoR7suYumw;U&a`<HQw=`{>iIw_Zb3Nx"b-[.g=I.;	v7*~ sܽ55Z#su8Q`5V%'*+0H' +gk$}k5}.,-Uw,UWtv$w1d{&i0yBv_u6gy\v&A[$A8Ap2 .d!!yMXR7AADdAAADdAAAADdAAADdAA!_NIj`'/_^})ɇTF.KDtŉÄC_̇-A\py_cm	sB.>`>U,AA!4ޭ{ɶdAe}>p<RCߊ>SolV#kx|;a^x"n"OoVExw}Cp/!slEOp/"L$_B|g'GЇ"D 8ˈX-*+7*U|}xnDR;gKcJ@ _>:D/%^vQkD:Z$/H!(+ׇd@ABA'q(ƷEmPZ:!_SxVw7ˇWX8U_'+m8os|yX oOKߐ^$
+1~}2#]/"`6?y&B(a񀟸 :qᚏB:Bh^PXa*1g# 'ݼlf#W;IG/ U'C_'ZL>>Ta/ V]A{Tw'WŌJd# VcrF9zYtNvYUE@VBxĪz&=/IW}oTjkAenӆXA*cf7$T7O O(Z$ؽpolގNE`{cx'+wzB~+t	w`u5fFyQ!7
+N%]3{1	EЙݲ]2WyBPg}/yeMg8'A&E_LvӔe\}Wu> >ςof$[24.~ẋ༅ & L'7AN*sWdn1B9-昕qh ,/j7AT oHLa
+ /i0kQ.0p71yF4yD_*"`\$yD`] A(42@k<" O#"2     "2  @_( /    IENDB`
\ No newline at end of file
diff -urNad openttd-1.3.2/patches-1.3.2-DC3.0-RC2.txt openttd-1.3.2-DC3.0RC3/patches-1.3.2-DC3.0-RC2.txt
--- openttd-1.3.2/patches-1.3.2-DC3.0-RC2.txt	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/patches-1.3.2-DC3.0-RC2.txt	2013-11-22 05:49:06.000000000 +0100
@@ -0,0 +1,79 @@
+YAPP 3.0-RC2  - Yet Another Patch Pack v3.0-RC2 for openttd-1.3.2
+
+Changes since 2.99: 
+  + show cargo destinations for all vehicles (thx to BoyC)
+  + template based train replacement
+  + large maps
+  + up to 256 newgrfs in single player
+  + industry filter
+  + wider rivers
+  - vehicle leasing (to avoid multiplayer desyncs)
+  - VTCPM - Vehicle Type Cargo Payment Modifiers (to avoid multiplayer desyncs, use a newgrf instead)
+
+Major patches:
+ YACD - Yet Another CargoDestinations ( http://www.tt-forums.net/viewtopic.php?f=33&t=54253 )
+ Large maps - Up to size 1048576 x 1048576 ( http://www.tt-forums.net/viewtopic.php?f=33&t=33137 )
+ Lost Cargo Costs - Lost cargo generates lost money on underrated stations ( http://www.tt-forums.net/viewtopic.php?f=33&t=68754 )
+ Daylength - Change the length of a day ( http://www.tt-forums.net/viewtopic.php?f=33&t=42432 )
+ STS - Slim Timetable Separation ( http://www.tt-forums.net/viewtopic.php?t=54332 )
+ IS2 - Infrastucture Sharing ( http://www.tt-forums.net/viewtopic.php?f=33&t=42254 )
+ Clipboard - Copy & paste infrastucture with templates ( http://www.tt-forums.net/viewtopic.php?f=33&t=45488 )
+ Speed limits for Road vehicles - Set a maximum km/h in a town ( http://www.tt-forums.net/viewtopic.php?f=33&t=35402 )
+ Trafficlights+randomroad - Towns build traffic lights for road vehicles ( http://www.tt-forums.net/viewtopic.php?f=33&t=36261 )
+ Conditional loading - Let the vehicle wait for percent of cargo at station ( http://www.tt-forums.net/viewtopic.php?p=936600 )
+ More conditonal orders - Adding waiting/accepted cargo + free platforms conditionals for playing ECS ( http://www.tt-forums.net/viewtopic.php?f=33&t=38317 )
+
+Minor patches:
+ TBTR - Template based train replacement ( http://www.tt-forums.net/viewtopic.php?f=33&t=58904 )
+ Town Cargo - Adjust town cargo generation factor ( http://www.tt-forums.net/viewtopic.php?f=33&t=46399 )
+ Cargo Production - Adjust industry cargo generation factor
+ Polyline - Construct railways a bit more easy ( http://www.tt-forums.net/viewtopic.php?f=33&t=57080 )
+ Build and refit - Instantly buy the refitted vehicle ( http://www.tt-forums.net/viewtopic.php?f=33&t=35805 )
+ Advanced Station Control - Remove cargo from station via ctrl-click ( http://www.tt-forums.net/viewtopic.php?f=33&t=59590 )
+ Change timetable for all station via ctrl-click ( http://www.tt-forums.net/viewtopic.php?f=32&t=50274 )
+ Trees growth reduced - ( http://www.tt-forums.net/viewtopic.php?f=33&t=45502 )
+ Huge airports - 2 larger airports; use hugeairports newgrf for preview ( http://www.tt-forums.net/viewtopic.php?f=33&t=56933 )
+ Airport upgrade - Upgrade airports without demolish them ( http://www.tt-forums.net/viewtopic.php?f=33&t=35867 )
+ Town Construction Cost - Raise construction cost near towns ( http://www.tt-forums.net/viewtopic.php?t=32942 )
+ Taxes - Adds tax base on company value ( http://www.tt-forums.net/viewtopic.php?f=33&t=45642 )
+ Repair cost - Cost of repair for each breakdown is 1/1024 vehicle value ( http://www.tt-forums.net/viewtopic.php?f=33&t=45642 )
+ Donate money - Give money to other companies ( https://www.tt-forums.net/viewtopic.php?f=33&t=63899 )
+ Ship movement - Ships can't cross each other except at docks ( http://www.tt-forums.net/viewtopic.php?f=33&t=42758 )
+ Snow in temperate Climate ( http://www.tt-forums.net/viewtopic.php?t=24574 )
+ Import towns - Generating scenarios with cities from real world coordinates ( http://www.tt-forums.net/viewtopic.php?f=29&t=68926 )
+ ATC Speed Control - Slow down faster trains behind a slow one ( http://www.tt-forums.net/viewtopic.php?f=33&t=52085 )
+ Wider rivers - Terragenesis map generator build a bit wider more realistic rivers ( http://www.icosahedron.de/openttd/patches/wide_rivers.diff )
+ More newgrf - up to 256 newgrfs in single player ( http://www.tt-forums.net/viewtopic.php?f=31&t=37435 )
+ Toggle curve speed penalty for road vehicles
+
+Fancy patches:
+ Departure board - Show departure board of any station ( http://www.tt-forums.net/viewtopic.php?f=33&t=49956 )
+ Tooltip & stopover - Show production rate on mouseover & show stopovers of a vehicle ( https://www.tt-forums.net/viewtopic.php?f=33&t=53394 )
+ Transparent tunnels - Show vehicles in tunnels ( http://www.tt-forums.net/viewtopic.php?f=33&t=66960 )
+ Trip history - History of income of a vehicle ( http://www.tt-forums.net/viewtopic.php?f=33&t=33411 )
+ Specific group name - Automatically name the group from the first and last station or town while dragging to new group button. ( http://www.tt-forums.net/viewtopic.php?f=33&t=64762 )
+ Industry Station Names - Name stations based on production of industry ( http://www.tt-forums.net/viewtopic.php?f=33&t=35613 )
+ Station coverage areas - Show coverage of any complex station via ctrl-click ( http://www.tt-forums.net/viewtopic.php?f=33&t=44835 )
+ Station forecast - Supply and demand display on station building ( http://www.tt-forums.net/viewtopic.php?f=33&t=59297 )
+ Town rating colours - Indicate the local authority via color ( http://www.tt-forums.net/viewtopic.php?f=33&t=42598 )
+ Group profit - Summarize the income of vehicle in one group ( http://www.tt-forums.net/viewtopic.php?f=33&t=33148 )
+ Watch GUI - Show other companies building ( http://www.tt-forums.net/viewtopic.php?f=33&t=45221 )
+ Filter industry - Filter by cargo in industry list window ( http://bugs.openttd.org/task/5455 )
+ Toggle cashtill sound when income
+
+Some little changes:
+ Faster road reconstruction
+ Statusbar height was increased by 2px to display big letters correctly with hungarian (or other) accents.
+
+
+Small bugs:
+ Trip history can't handle minutes and it always calculates in days.
+ Town rating colours shows red labels incorrectly for the first month of the game.
+ Industry station names can generate 2 nearby stations with the same name.
+ There is no preview of huge airports in building menu when you don't use the hugeairports grf. Apart from this you can still build a fully working huge airport.
+ Cargo related conditional orders is available for trains & road vehicles only.
+ Town window shows wrong summary of passengers and mails.
+ Patches Refit & TBTR are disabled in multiplayer to avoid desync.
+
+
+I recommend to play YACD with Neighbours are important or Real growth gamescript to avoid a lot of PAX too quickly.
diff -urNad openttd-1.3.2/projects/openttd_vs100.vcxproj openttd-1.3.2-DC3.0RC3/projects/openttd_vs100.vcxproj
--- openttd-1.3.2/projects/openttd_vs100.vcxproj	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/projects/openttd_vs100.vcxproj	2013-11-22 05:49:06.000000000 +0100
@@ -291,15 +291,29 @@
     </Link>
   </ItemDefinitionGroup>
   <ItemGroup>
+    <ClCompile Include="..\src\aaa_template_gui_main.cpp" />
+    <ClCompile Include="..\src\aaa_template_gui_create.cpp" />
+    <ClCompile Include="..\src\aaa_template_gui_create_virtualtrain.cpp" />
+    <ClCompile Include="..\src\aaa_template_gui_replaceall.cpp" />
+    <ClCompile Include="..\src\aaa_template_vehicle.cpp" />
+    <ClCompile Include="..\src\aaa_template_vehicle_func.cpp" />
+    <ClInclude Include="..\src\aaa_template_gui_main.h" />
+    <ClInclude Include="..\src\aaa_template_gui_create.h" />
+    <ClInclude Include="..\src\aaa_template_gui_create_virtualtrain.h" />
+    <ClInclude Include="..\src\aaa_template_gui_replaceall.h" />
+    <ClInclude Include="..\src\aaa_template_vehicle.h" />
+    <ClInclude Include="..\src\aaa_template_vehicle_func.h" />
     <ClCompile Include="..\src\airport.cpp" />
     <ClCompile Include="..\src\animated_tile.cpp" />
     <ClCompile Include="..\src\articulated_vehicles.cpp" />
     <ClCompile Include="..\src\autoreplace.cpp" />
     <ClCompile Include="..\src\bmp.cpp" />
+    <ClCompile Include="..\src\cargodest.cpp" />
     <ClCompile Include="..\src\cargomonitor.cpp" />
     <ClCompile Include="..\src\cargopacket.cpp" />
     <ClCompile Include="..\src\cargotype.cpp" />
     <ClCompile Include="..\src\cheat.cpp" />
+    <ClCompile Include="..\src\clipboard.cpp" />
     <ClCompile Include="..\src\command.cpp" />
     <ClCompile Include="..\src\console.cpp" />
     <ClCompile Include="..\src\console_cmds.cpp" />
@@ -328,6 +342,7 @@
     <ClCompile Include="..\src\ground_vehicle.cpp" />
     <ClCompile Include="..\src\heightmap.cpp" />
     <ClCompile Include="..\src\highscore.cpp" />
+    <ClCompile Include="..\src\infrastructure.cpp" />
     <ClCompile Include="..\src\hotkeys.cpp" />
     <ClCompile Include="..\src\ini.cpp" />
     <ClCompile Include="..\src\ini_load.cpp" />
@@ -373,6 +388,8 @@
     <ClCompile Include="..\src\tile_map.cpp" />
     <ClCompile Include="..\src\tilearea.cpp" />
     <ClCompile Include="..\src\townname.cpp" />
+    <ClCompile Include="..\src\triphistory_cmd.cpp" />
+    <ClCompile Include="..\src\trafficlight.cpp" />
     <ClCompile Include="..\src\vehicle.cpp" />
     <ClCompile Include="..\src\vehiclelist.cpp" />
     <ClCompile Include="..\src\viewport.cpp" />
@@ -394,12 +411,19 @@
     <ClInclude Include="..\src\bmp.h" />
     <ClInclude Include="..\src\bridge.h" />
     <ClInclude Include="..\src\cargo_type.h" />
+    <ClInclude Include="..\src\cargodest_base.h" />
+    <ClInclude Include="..\src\cargodest_func.h" />
+    <ClInclude Include="..\src\cargodest_gui.h" />
+    <ClInclude Include="..\src\cargodest_type.h" />
     <ClInclude Include="..\src\cargomonitor.h" />
     <ClInclude Include="..\src\cargopacket.h" />
     <ClInclude Include="..\src\cargotype.h" />
     <ClInclude Include="..\src\cheat_func.h" />
     <ClInclude Include="..\src\cheat_type.h" />
     <ClInclude Include="..\src\clear_func.h" />
+    <ClInclude Include="..\src\clipboard_func.h" />
+    <ClInclude Include="..\src\clipboard_gui.h" />
+    <ClInclude Include="..\src\clipboard_type.h" />
     <ClInclude Include="..\src\cmd_helper.h" />
     <ClInclude Include="..\src\command_func.h" />
     <ClInclude Include="..\src\command_type.h" />
@@ -412,6 +436,7 @@
     <ClInclude Include="..\src\console_gui.h" />
     <ClInclude Include="..\src\console_internal.h" />
     <ClInclude Include="..\src\console_type.h" />
+    <ClInclude Include="..\src\copypaste_cmd.h" />
     <ClInclude Include="..\src\crashlog.h" />
     <ClInclude Include="..\src\currency.h" />
     <ClInclude Include="..\src\date_func.h" />
@@ -467,6 +492,7 @@
     <ClInclude Include="..\src\industry.h" />
     <ClInclude Include="..\src\industry_type.h" />
     <ClInclude Include="..\src\industrytype.h" />
+    <ClInclude Include="..\src\infrastructure_func.h" />
     <ClInclude Include="..\src\ini_type.h" />
     <ClInclude Include="..\src\landscape.h" />
     <ClInclude Include="..\src\landscape_type.h" />
@@ -475,6 +501,7 @@
     <ClInclude Include="..\src\map_func.h" />
     <ClInclude Include="..\src\map_type.h" />
     <ClInclude Include="..\src\mixer.h" />
+    <ClInclude Include="..\src\triphistory.h" />
     <ClInclude Include="..\src\network\network.h" />
     <ClInclude Include="..\src\network\network_admin.h" />
     <ClInclude Include="..\src\network\network_base.h" />
@@ -523,6 +550,7 @@
     <ClInclude Include="..\src\sound\null_s.h" />
     <ClInclude Include="..\src\video\null_v.h" />
     <ClInclude Include="..\src\object.h" />
+    <ClCompile Include="..\src\triphistory_gui.cpp" />
     <ClInclude Include="..\src\object_base.h" />
     <ClInclude Include="..\src\object_type.h" />
     <ClInclude Include="..\src\openttd.h" />
@@ -591,6 +619,7 @@
     <ClInclude Include="..\src\tgp.h" />
     <ClInclude Include="..\src\tile_cmd.h" />
     <ClInclude Include="..\src\tile_type.h" />
+    <ClInclude Include="..\src\tilearea_func.h" />
     <ClInclude Include="..\src\tilearea_type.h" />
     <ClInclude Include="..\src\tilehighlight_func.h" />
     <ClInclude Include="..\src\tilehighlight_type.h" />
@@ -603,6 +632,9 @@
     <ClInclude Include="..\src\townname_type.h" />
     <ClInclude Include="..\src\track_func.h" />
     <ClInclude Include="..\src\track_type.h" />
+    <ClInclude Include="..\src\trafficlight.h" />
+    <ClInclude Include="..\src\trafficlight_func.h" />
+    <ClInclude Include="..\src\trafficlight_type.h" />
     <ClInclude Include="..\src\train.h" />
     <ClInclude Include="..\src\transparency.h" />
     <ClInclude Include="..\src\transparency_gui.h" />
@@ -616,6 +648,7 @@
     <ClInclude Include="..\src\vehiclelist.h" />
     <ClInclude Include="..\src\viewport_func.h" />
     <ClInclude Include="..\src\viewport_type.h" />
+    <ClInclude Include="..\src\watch_gui.h" />
     <ClInclude Include="..\src\water.h" />
     <ClInclude Include="..\src\waypoint_base.h" />
     <ClInclude Include="..\src\waypoint_func.h" />
@@ -660,7 +693,9 @@
     <ClCompile Include="..\src\bootstrap_gui.cpp" />
     <ClCompile Include="..\src\bridge_gui.cpp" />
     <ClCompile Include="..\src\build_vehicle_gui.cpp" />
+    <ClCompile Include="..\src\cargodest_gui.cpp" />
     <ClCompile Include="..\src\cheat_gui.cpp" />
+    <ClCompile Include="..\src\clipboard_gui.cpp" />
     <ClCompile Include="..\src\company_gui.cpp" />
     <ClCompile Include="..\src\console_gui.cpp" />
     <ClCompile Include="..\src\date_gui.cpp" />
@@ -708,6 +743,7 @@
     <ClCompile Include="..\src\tree_gui.cpp" />
     <ClCompile Include="..\src\vehicle_gui.cpp" />
     <ClCompile Include="..\src\viewport_gui.cpp" />
+    <ClCompile Include="..\src\watch_gui.cpp" />
     <ClCompile Include="..\src\waypoint_gui.cpp" />
     <ClInclude Include="..\src\widgets\airport_widget.h" />
     <ClInclude Include="..\src\widgets\ai_widget.h" />
@@ -716,6 +752,7 @@
     <ClInclude Include="..\src\widgets\bridge_widget.h" />
     <ClInclude Include="..\src\widgets\build_vehicle_widget.h" />
     <ClInclude Include="..\src\widgets\cheat_widget.h" />
+    <ClInclude Include="..\src\widgets\clipboard_widget.h" />
     <ClInclude Include="..\src\widgets\company_widget.h" />
     <ClInclude Include="..\src\widgets\console_widget.h" />
     <ClInclude Include="..\src\widgets\date_widget.h" />
@@ -767,6 +804,7 @@
     <ClCompile Include="..\src\aircraft_cmd.cpp" />
     <ClCompile Include="..\src\autoreplace_cmd.cpp" />
     <ClCompile Include="..\src\clear_cmd.cpp" />
+    <ClCompile Include="..\src\copypaste_cmd.cpp" />
     <ClCompile Include="..\src\company_cmd.cpp" />
     <ClCompile Include="..\src\depot_cmd.cpp" />
     <ClCompile Include="..\src\disaster_cmd.cpp" />
@@ -796,6 +834,7 @@
     <ClCompile Include="..\src\saveload\airport_sl.cpp" />
     <ClCompile Include="..\src\saveload\animated_tile_sl.cpp" />
     <ClCompile Include="..\src\saveload\autoreplace_sl.cpp" />
+    <ClCompile Include="..\src\saveload\cargodest_sl.cpp" />
     <ClCompile Include="..\src\saveload\cargomonitor_sl.cpp" />
     <ClCompile Include="..\src\saveload\cargopacket_sl.cpp" />
     <ClCompile Include="..\src\saveload\cheat_sl.cpp" />
@@ -830,6 +869,8 @@
     <ClCompile Include="..\src\saveload\town_sl.cpp" />
     <ClCompile Include="..\src\saveload\vehicle_sl.cpp" />
     <ClCompile Include="..\src\saveload\waypoint_sl.cpp" />
+    <ClCompile Include="..\src\saveload\aaa_template_replacement_sl.cpp" />
+    <ClCompile Include="..\src\saveload\aaa_template_veh_sl.cpp" />
     <ClInclude Include="..\src\table\airport_defaults.h" />
     <ClInclude Include="..\src\table\airport_movement.h" />
     <ClInclude Include="..\src\table\airporttile_ids.h" />
@@ -1191,6 +1232,7 @@
     <ClInclude Include="..\src\pathfinder\yapf\yapf.hpp" />
     <ClInclude Include="..\src\pathfinder\yapf\yapf_base.hpp" />
     <ClInclude Include="..\src\pathfinder\yapf\yapf_cache.h" />
+    <ClCompile Include="..\src\pathfinder\yapf\yapf_cargo.cpp" />
     <ClInclude Include="..\src\pathfinder\yapf\yapf_common.hpp" />
     <ClInclude Include="..\src\pathfinder\yapf\yapf_costbase.hpp" />
     <ClInclude Include="..\src\pathfinder\yapf\yapf_costcache.hpp" />
diff -urNad openttd-1.3.2/projects/openttd_vs100.vcxproj.filters openttd-1.3.2-DC3.0RC3/projects/openttd_vs100.vcxproj.filters
--- openttd-1.3.2/projects/openttd_vs100.vcxproj.filters	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/projects/openttd_vs100.vcxproj.filters	2013-11-22 05:49:06.000000000 +0100
@@ -22,86 +22,125 @@
     <Filter Include="Save/Load handlers">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000006}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Tables">
+    <Filter Include="MYGUI SL HANDLERS">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000007}</UniqueIdentifier>
     </Filter>
-    <Filter Include="MD5">
+    <Filter Include="Tables">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000008}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Script">
+    <Filter Include="MD5">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000009}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Squirrel">
+    <Filter Include="Script">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000010}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Squirrel headers">
+    <Filter Include="Squirrel">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000011}</UniqueIdentifier>
     </Filter>
-    <Filter Include="AI Core">
+    <Filter Include="Squirrel headers">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000012}</UniqueIdentifier>
     </Filter>
-    <Filter Include="AI API">
+    <Filter Include="AI Core">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000013}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Game API">
+    <Filter Include="AI API">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000014}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Game Core">
+    <Filter Include="Game API">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000015}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Script API">
+    <Filter Include="Game Core">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000016}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Script API Implementation">
+    <Filter Include="Script API">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000017}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Blitters">
+    <Filter Include="Script API Implementation">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000018}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Drivers">
+    <Filter Include="Blitters">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000019}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Sprite loaders">
+    <Filter Include="Drivers">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000020}</UniqueIdentifier>
     </Filter>
-    <Filter Include="NewGRF">
+    <Filter Include="Sprite loaders">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000021}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Map Accessors">
+    <Filter Include="NewGRF">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000022}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Misc">
+    <Filter Include="Map Accessors">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000023}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Network Core">
+    <Filter Include="Misc">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000024}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Pathfinder">
+    <Filter Include="Network Core">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000025}</UniqueIdentifier>
     </Filter>
-    <Filter Include="NPF">
+    <Filter Include="Pathfinder">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000026}</UniqueIdentifier>
     </Filter>
-    <Filter Include="YAPF">
+    <Filter Include="NPF">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000027}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Video">
+    <Filter Include="YAPF">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000028}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Music">
+    <Filter Include="Video">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000029}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Sound">
+    <Filter Include="Music">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000030}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Windows files">
+    <Filter Include="Sound">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000031}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Threading">
+    <Filter Include="Windows files">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000032}</UniqueIdentifier>
     </Filter>
+    <Filter Include="Threading">
+      <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000033}</UniqueIdentifier>
+    </Filter>
   </ItemGroup>
   <ItemGroup>
+    <ClCompile Include="..\src\aaa_template_gui_main.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\aaa_template_gui_create.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\aaa_template_gui_create_virtualtrain.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\aaa_template_gui_replaceall.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\aaa_template_vehicle.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\aaa_template_vehicle_func.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClInclude Include="..\src\aaa_template_gui_main.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\aaa_template_gui_create.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\aaa_template_gui_create_virtualtrain.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\aaa_template_gui_replaceall.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\aaa_template_vehicle.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\aaa_template_vehicle_func.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
     <ClCompile Include="..\src\airport.cpp">
       <Filter>Source Files</Filter>
     </ClCompile>
@@ -117,6 +156,9 @@
     <ClCompile Include="..\src\bmp.cpp">
       <Filter>Source Files</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\cargodest.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
     <ClCompile Include="..\src\cargomonitor.cpp">
       <Filter>Source Files</Filter>
     </ClCompile>
@@ -129,6 +171,9 @@
     <ClCompile Include="..\src\cheat.cpp">
       <Filter>Source Files</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\clipboard.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
     <ClCompile Include="..\src\command.cpp">
       <Filter>Source Files</Filter>
     </ClCompile>
@@ -348,7 +393,10 @@
     <ClCompile Include="..\src\townname.cpp">
       <Filter>Source Files</Filter>
     </ClCompile>
-    <ClCompile Include="..\src\vehicle.cpp">
+    <ClCompile Include="..\src\triphistory_cmd.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\trafficlight.cpp">
       <Filter>Source Files</Filter>
     </ClCompile>
     <ClCompile Include="..\src\vehiclelist.cpp">
@@ -411,6 +459,18 @@
     <ClInclude Include="..\src\cargo_type.h">
       <Filter>Header Files</Filter>
     </ClInclude>
+    <ClInclude Include="..\src\cargodest_base.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\cargodest_func.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\cargodest_gui.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\cargodest_type.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
     <ClInclude Include="..\src\cargomonitor.h">
       <Filter>Header Files</Filter>
     </ClInclude>
@@ -429,6 +489,15 @@
     <ClInclude Include="..\src\clear_func.h">
       <Filter>Header Files</Filter>
     </ClInclude>
+    <ClInclude Include="..\src\clipboard_func.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\clipboard_gui.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\clipboard_type.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
     <ClInclude Include="..\src\cmd_helper.h">
       <Filter>Header Files</Filter>
     </ClInclude>
@@ -465,6 +534,9 @@
     <ClInclude Include="..\src\console_type.h">
       <Filter>Header Files</Filter>
     </ClInclude>
+    <ClInclude Include="..\src\copypaste_cmd.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
     <ClInclude Include="..\src\crashlog.h">
       <Filter>Header Files</Filter>
     </ClInclude>
@@ -654,6 +726,9 @@
     <ClInclude Include="..\src\mixer.h">
       <Filter>Header Files</Filter>
     </ClInclude>
+    <ClInclude Include="..\src\triphistory.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
     <ClInclude Include="..\src\network\network.h">
       <Filter>Header Files</Filter>
     </ClInclude>
@@ -798,6 +873,9 @@
     <ClInclude Include="..\src\object.h">
       <Filter>Header Files</Filter>
     </ClInclude>
+    <ClCompile Include="..\src\triphistory_gui.cpp">
+      <Filter>Header Files</Filter>
+    </ClCompile>
     <ClInclude Include="..\src\object_base.h">
       <Filter>Header Files</Filter>
     </ClInclude>
@@ -1002,6 +1080,9 @@
     <ClInclude Include="..\src\tile_type.h">
       <Filter>Header Files</Filter>
     </ClInclude>
+    <ClInclude Include="..\src\tilearea_func.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
     <ClInclude Include="..\src\tilearea_type.h">
       <Filter>Header Files</Filter>
     </ClInclude>
@@ -1038,6 +1119,15 @@
     <ClInclude Include="..\src\track_type.h">
       <Filter>Header Files</Filter>
     </ClInclude>
+    <ClInclude Include="..\src\trafficlight.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\trafficlight_func.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\trafficlight_type.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
     <ClInclude Include="..\src\train.h">
       <Filter>Header Files</Filter>
     </ClInclude>
@@ -1077,6 +1167,9 @@
     <ClInclude Include="..\src\viewport_type.h">
       <Filter>Header Files</Filter>
     </ClInclude>
+    <ClInclude Include="..\src\watch_gui.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
     <ClInclude Include="..\src\water.h">
       <Filter>Header Files</Filter>
     </ClInclude>
@@ -1209,9 +1302,15 @@
     <ClCompile Include="..\src\build_vehicle_gui.cpp">
       <Filter>GUI Source Code</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\cargodest_gui.cpp">
+      <Filter>GUI Source Code</Filter>
+    </ClCompile>
     <ClCompile Include="..\src\cheat_gui.cpp">
       <Filter>GUI Source Code</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\clipboard_gui.cpp">
+      <Filter>GUI Source Code</Filter>
+    </ClCompile>
     <ClCompile Include="..\src\company_gui.cpp">
       <Filter>GUI Source Code</Filter>
     </ClCompile>
@@ -1353,6 +1452,9 @@
     <ClCompile Include="..\src\viewport_gui.cpp">
       <Filter>GUI Source Code</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\watch_gui.cpp">
+      <Filter>GUI Source Code</Filter>
+    </ClCompile>
     <ClCompile Include="..\src\waypoint_gui.cpp">
       <Filter>GUI Source Code</Filter>
     </ClCompile>
@@ -1377,6 +1479,9 @@
     <ClInclude Include="..\src\widgets\cheat_widget.h">
       <Filter>Widgets</Filter>
     </ClInclude>
+    <ClInclude Include="..\src\widgets\clipboard_widget.h">
+      <Filter>Widgets</Filter>
+    </ClInclude>
     <ClInclude Include="..\src\widgets\company_widget.h">
       <Filter>Widgets</Filter>
     </ClInclude>
@@ -1530,6 +1635,9 @@
     <ClCompile Include="..\src\clear_cmd.cpp">
       <Filter>Command handlers</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\copypaste_cmd.cpp">
+      <Filter>Command handlers</Filter>
+    </ClCompile>
     <ClCompile Include="..\src\company_cmd.cpp">
       <Filter>Command handlers</Filter>
     </ClCompile>
@@ -1617,6 +1725,9 @@
     <ClCompile Include="..\src\saveload\autoreplace_sl.cpp">
       <Filter>Save/Load handlers</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\saveload\cargodest_sl.cpp">
+      <Filter>Save/Load handlers</Filter>
+    </ClCompile>
     <ClCompile Include="..\src\saveload\cargomonitor_sl.cpp">
       <Filter>Save/Load handlers</Filter>
     </ClCompile>
@@ -1719,6 +1830,12 @@
     <ClCompile Include="..\src\saveload\waypoint_sl.cpp">
       <Filter>Save/Load handlers</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\saveload\aaa_template_replacement_sl.cpp">
+      <Filter>MYGUI SL HANDLERS</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\saveload\aaa_template_veh_sl.cpp">
+      <Filter>MYGUI SL HANDLERS</Filter>
+    </ClCompile>
     <ClInclude Include="..\src\table\airport_defaults.h">
       <Filter>Tables</Filter>
     </ClInclude>
@@ -2802,6 +2919,9 @@
     <ClInclude Include="..\src\pathfinder\yapf\yapf_cache.h">
       <Filter>YAPF</Filter>
     </ClInclude>
+    <ClCompile Include="..\src\pathfinder\yapf\yapf_cargo.cpp">
+      <Filter>YAPF</Filter>
+    </ClCompile>
     <ClInclude Include="..\src\pathfinder\yapf\yapf_common.hpp">
       <Filter>YAPF</Filter>
     </ClInclude>
diff -urNad openttd-1.3.2/projects/openttd_vs80.vcproj openttd-1.3.2-DC3.0RC3/projects/openttd_vs80.vcproj
--- openttd-1.3.2/projects/openttd_vs80.vcproj	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/projects/openttd_vs80.vcproj	2013-11-22 05:49:06.000000000 +0100
@@ -435,6 +435,54 @@
 			Name="Source Files"
 			>
 			<File
+				RelativePath=".\..\src\aaa_template_gui_main.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_create.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_create_virtualtrain.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_replaceall.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_vehicle.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_vehicle_func.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_main.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_create.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_create_virtualtrain.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_replaceall.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_vehicle.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_vehicle_func.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\airport.cpp"
 				>
 			</File>
@@ -455,6 +503,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\cargodest.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\cargomonitor.cpp"
 				>
 			</File>
@@ -471,6 +523,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\clipboard.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\command.cpp"
 				>
 			</File>
@@ -503,6 +559,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\departures.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\depot.cpp"
 				>
 			</File>
@@ -583,6 +643,10 @@
 				>
 			</File>
 			<File
++				RelativePath=".\..\src\infrastructure.cpp"
++				>
++			</File>
++			<File
 				RelativePath=".\..\src\hotkeys.cpp"
 				>
 			</File>
@@ -763,6 +827,14 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\trafficlight.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\triphistory_cmd.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\vehicle.cpp"
 				>
 			</File>
@@ -851,6 +923,22 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\cargodest_base.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\cargodest_func.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\cargodest_gui.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\cargodest_type.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\cargomonitor.h"
 				>
 			</File>
@@ -875,6 +963,18 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\clipboard_func.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\clipboard_gui.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\clipboard_type.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\cmd_helper.h"
 				>
 			</File>
@@ -923,6 +1023,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\copypaste_cmd.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\crashlog.h"
 				>
 			</File>
@@ -951,6 +1055,18 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\departures_func.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\departures_gui.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\departures_type.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\depot_base.h"
 				>
 			</File>
@@ -1143,6 +1259,10 @@
 				>
 			</File>
 			<File
++				RelativePath=".\..\src\infrastructure_func.h"
++				>
++			</File>
++			<File
 				RelativePath=".\..\src\ini_type.h"
 				>
 			</File>
@@ -1175,6 +1295,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\triphistory.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\network\network.h"
 				>
 			</File>
@@ -1367,6 +1491,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\triphistory_gui.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\object_base.h"
 				>
 			</File>
@@ -1639,6 +1767,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\tilearea_func.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\tilearea_type.h"
 				>
 			</File>
@@ -1687,6 +1819,18 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\trafficlight.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\trafficlight_func.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\trafficlight_type.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\train.h"
 				>
 			</File>
@@ -1739,6 +1883,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\watch_gui.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\water.h"
 				>
 			</File>
@@ -1923,10 +2071,18 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\cargodest_gui.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\cheat_gui.cpp"
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\clipboard_gui.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\company_gui.cpp"
 				>
 			</File>
@@ -1939,6 +2095,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\departures_gui.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\depot_gui.cpp"
 				>
 			</File>
@@ -2115,6 +2275,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\watch_gui.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\waypoint_gui.cpp"
 				>
 			</File>
@@ -2151,6 +2315,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\widgets\clipboard_widget.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\widgets\company_widget.h"
 				>
 			</File>
@@ -2359,6 +2527,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\copypaste_cmd.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\company_cmd.cpp"
 				>
 			</File>
@@ -2479,6 +2651,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\saveload\cargodest_sl.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\saveload\cargomonitor_sl.cpp"
 				>
 			</File>
@@ -2616,6 +2792,18 @@
 			</File>
 		</Filter>
 		<Filter
+			Name="MYGUI SL HANDLERS"
+			>
+			<File
+				RelativePath=".\..\src\saveload\aaa_template_replacement_sl.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\saveload\aaa_template_veh_sl.cpp"
+				>
+			</File>
+		</Filter>
+		<Filter
 			Name="Tables"
 			>
 			<File
@@ -4143,6 +4331,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\pathfinder\yapf\yapf_cargo.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\pathfinder\yapf\yapf_common.hpp"
 				>
 			</File>
diff -urNad openttd-1.3.2/projects/openttd_vs90.vcproj openttd-1.3.2-DC3.0RC3/projects/openttd_vs90.vcproj
--- openttd-1.3.2/projects/openttd_vs90.vcproj	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/projects/openttd_vs90.vcproj	2013-11-22 05:49:06.000000000 +0100
@@ -432,6 +432,54 @@
 			Name="Source Files"
 			>
 			<File
+				RelativePath=".\..\src\aaa_template_gui_main.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_create.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_create_virtualtrain.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_replaceall.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_vehicle.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_vehicle_func.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_main.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_create.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_create_virtualtrain.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_replaceall.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_vehicle.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_vehicle_func.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\airport.cpp"
 				>
 			</File>
@@ -452,6 +500,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\cargodest.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\cargomonitor.cpp"
 				>
 			</File>
@@ -468,6 +520,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\clipboard.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\command.cpp"
 				>
 			</File>
@@ -500,6 +556,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\departures.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\depot.cpp"
 				>
 			</File>
@@ -580,6 +640,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\infrastructure.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\hotkeys.cpp"
 				>
 			</File>
@@ -760,6 +824,14 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\trafficlight.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\triphistory_cmd.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\vehicle.cpp"
 				>
 			</File>
@@ -848,6 +920,22 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\cargodest_base.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\cargodest_func.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\cargodest_gui.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\cargodest_type.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\cargomonitor.h"
 				>
 			</File>
@@ -872,6 +960,18 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\clipboard_func.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\clipboard_gui.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\clipboard_type.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\cmd_helper.h"
 				>
 			</File>
@@ -920,6 +1020,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\copypaste_cmd.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\crashlog.h"
 				>
 			</File>
@@ -948,6 +1052,18 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\departures_func.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\departures_gui.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\departures_type.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\depot_base.h"
 				>
 			</File>
@@ -1140,6 +1256,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\infrastructure_func.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\ini_type.h"
 				>
 			</File>
@@ -1172,6 +1292,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\triphistory.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\network\network.h"
 				>
 			</File>
@@ -1364,6 +1488,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\triphistory_gui.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\object_base.h"
 				>
 			</File>
@@ -1636,6 +1764,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\tilearea_func.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\tilearea_type.h"
 				>
 			</File>
@@ -1684,6 +1816,18 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\trafficlight.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\trafficlight_func.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\trafficlight_type.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\train.h"
 				>
 			</File>
@@ -1736,6 +1880,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\watch_gui.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\water.h"
 				>
 			</File>
@@ -1920,10 +2068,18 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\cargodest_gui.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\cheat_gui.cpp"
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\clipboard_gui.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\company_gui.cpp"
 				>
 			</File>
@@ -1936,6 +2092,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\departures_gui.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\depot_gui.cpp"
 				>
 			</File>
@@ -2112,6 +2272,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\watch_gui.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\waypoint_gui.cpp"
 				>
 			</File>
@@ -2148,6 +2312,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\widgets\clipboard_widget.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\widgets\company_widget.h"
 				>
 			</File>
@@ -2356,6 +2524,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\copypaste_cmd.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\company_cmd.cpp"
 				>
 			</File>
@@ -2476,6 +2648,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\saveload\cargodest_sl.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\saveload\cargomonitor_sl.cpp"
 				>
 			</File>
@@ -2613,6 +2789,18 @@
 			</File>
 		</Filter>
 		<Filter
+			Name="MYGUI SL HANDLERS"
+			>
+			<File
+				RelativePath=".\..\src\saveload\aaa_template_replacement_sl.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\saveload\aaa_template_veh_sl.cpp"
+				>
+			</File>
+		</Filter>
+		<Filter
 			Name="Tables"
 			>
 			<File
@@ -4140,6 +4328,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\pathfinder\yapf\yapf_cargo.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\pathfinder\yapf\yapf_common.hpp"
 				>
 			</File>
diff -urNad openttd-1.3.2/source.list openttd-1.3.2-DC3.0RC3/source.list
--- openttd-1.3.2/source.list	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/source.list	2013-11-22 05:49:06.000000000 +0100
@@ -1,13 +1,28 @@
 # Source Files
+aaa_template_gui_main.cpp
+aaa_template_gui_create.cpp
+aaa_template_gui_create_virtualtrain.cpp
+aaa_template_gui_replaceall.cpp
+aaa_template_vehicle.cpp
+aaa_template_vehicle_func.cpp
+aaa_template_gui_main.h
+aaa_template_gui_create.h
+aaa_template_gui_create_virtualtrain.h
+aaa_template_gui_replaceall.h
+aaa_template_vehicle.h
+aaa_template_vehicle_func.h
+
 airport.cpp
 animated_tile.cpp
 articulated_vehicles.cpp
 autoreplace.cpp
 bmp.cpp
+cargodest.cpp
 cargomonitor.cpp
 cargopacket.cpp
 cargotype.cpp
 cheat.cpp
+clipboard.cpp
 command.cpp
 console.cpp
 console_cmds.cpp
@@ -16,6 +31,7 @@
 date.cpp
 debug.cpp
 dedicated.cpp
+departures.cpp
 depot.cpp
 driver.cpp
 economy.cpp
@@ -36,6 +52,7 @@
 ground_vehicle.cpp
 heightmap.cpp
 highscore.cpp
+infrastructure.cpp
 hotkeys.cpp
 ini.cpp
 ini_load.cpp
@@ -83,6 +100,8 @@
 tile_map.cpp
 tilearea.cpp
 townname.cpp
+triphistory_cmd.cpp
+trafficlight.cpp
 #if WIN32
 #else
 	#if WINCE
@@ -127,12 +146,19 @@
 bmp.h
 bridge.h
 cargo_type.h
+cargodest_base.h
+cargodest_func.h
+cargodest_gui.h
+cargodest_type.h
 cargomonitor.h
 cargopacket.h
 cargotype.h
 cheat_func.h
 cheat_type.h
 clear_func.h
+clipboard_func.h
+clipboard_gui.h
+clipboard_type.h
 cmd_helper.h
 command_func.h
 command_type.h
@@ -145,6 +171,7 @@
 console_gui.h
 console_internal.h
 console_type.h
+copypaste_cmd.h
 crashlog.h
 currency.h
 date_func.h
@@ -152,6 +179,9 @@
 date_type.h
 debug.h
 video/dedicated_v.h
+departures_func.h
+departures_gui.h
+departures_type.h
 depot_base.h
 depot_func.h
 depot_map.h
@@ -200,6 +230,7 @@
 industry.h
 industry_type.h
 industrytype.h
+infrastructure_func.h
 ini_type.h
 landscape.h
 landscape_type.h
@@ -208,6 +239,7 @@
 map_func.h
 map_type.h
 mixer.h
+triphistory.h
 network/network.h
 network/network_admin.h
 network/network_base.h
@@ -256,6 +288,7 @@
 sound/null_s.h
 video/null_v.h
 object.h
+triphistory_gui.cpp
 object_base.h
 object_type.h
 openttd.h
@@ -263,6 +296,8 @@
 order_base.h
 order_func.h
 order_type.h
+overlay.h
+overlay_cmd.h
 pbs.h
 progress.h
 querystring_gui.h
@@ -324,6 +359,7 @@
 tgp.h
 tile_cmd.h
 tile_type.h
+tilearea_func.h
 tilearea_type.h
 tilehighlight_func.h
 tilehighlight_type.h
@@ -336,6 +372,9 @@
 townname_type.h
 track_func.h
 track_type.h
+trafficlight.h
+trafficlight_func.h
+trafficlight_type.h
 train.h
 transparency.h
 transparency_gui.h
@@ -349,6 +388,7 @@
 vehiclelist.h
 viewport_func.h
 viewport_type.h
+watch_gui.h
 water.h
 waypoint_base.h
 waypoint_func.h
@@ -412,10 +452,13 @@
 bootstrap_gui.cpp
 bridge_gui.cpp
 build_vehicle_gui.cpp
+cargodest_gui.cpp
 cheat_gui.cpp
+clipboard_gui.cpp
 company_gui.cpp
 console_gui.cpp
 date_gui.cpp
+departures_gui.cpp
 depot_gui.cpp
 dock_gui.cpp
 engine_gui.cpp
@@ -460,6 +503,7 @@
 tree_gui.cpp
 vehicle_gui.cpp
 viewport_gui.cpp
+watch_gui.cpp
 waypoint_gui.cpp
 
 # Widgets
@@ -470,6 +514,7 @@
 widgets/bridge_widget.h
 widgets/build_vehicle_widget.h
 widgets/cheat_widget.h
+widgets/clipboard_widget.h
 widgets/company_widget.h
 widgets/console_widget.h
 widgets/date_widget.h
@@ -523,6 +568,7 @@
 aircraft_cmd.cpp
 autoreplace_cmd.cpp
 clear_cmd.cpp
+copypaste_cmd.cpp
 company_cmd.cpp
 depot_cmd.cpp
 disaster_cmd.cpp
@@ -531,6 +577,7 @@
 misc_cmd.cpp
 object_cmd.cpp
 order_cmd.cpp
+overlay_cmd.cpp
 rail_cmd.cpp
 road_cmd.cpp
 roadveh_cmd.cpp
@@ -554,6 +601,7 @@
 saveload/airport_sl.cpp
 saveload/animated_tile_sl.cpp
 saveload/autoreplace_sl.cpp
+saveload/cargodest_sl.cpp
 saveload/cargomonitor_sl.cpp
 saveload/cargopacket_sl.cpp
 saveload/cheat_sl.cpp
@@ -588,6 +636,9 @@
 saveload/town_sl.cpp
 saveload/vehicle_sl.cpp
 saveload/waypoint_sl.cpp
+# MYGUI SL HANDLERS
+saveload/aaa_template_replacement_sl.cpp
+saveload/aaa_template_veh_sl.cpp
 
 # Tables
 table/airport_defaults.h
@@ -994,6 +1045,7 @@
 pathfinder/yapf/yapf.hpp
 pathfinder/yapf/yapf_base.hpp
 pathfinder/yapf/yapf_cache.h
+pathfinder/yapf/yapf_cargo.cpp
 pathfinder/yapf/yapf_common.hpp
 pathfinder/yapf/yapf_costbase.hpp
 pathfinder/yapf/yapf_costcache.hpp
diff -urNad openttd-1.3.2/src/aaa_template_gui_create.cpp openttd-1.3.2-DC3.0RC3/src/aaa_template_gui_create.cpp
--- openttd-1.3.2/src/aaa_template_gui_create.cpp	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/aaa_template_gui_create.cpp	2013-11-22 05:49:06.000000000 +0100
@@ -0,0 +1,462 @@
+#include "stdafx.h"
+
+#include "gfx_func.h"
+#include "direction_type.h"
+
+#include "strings_func.h"
+#include "window_func.h"
+#include "company_func.h"
+#include "window_gui.h"
+#include "settings_func.h"
+#include "core/geometry_func.hpp"
+#include "table/sprites.h"
+#include "table/strings.h"
+// since setobjtoplacewnd() TODO: del unnecessary
+#include "viewport_func.h"
+#include "window_func.h"
+#include "gui.h"
+#include "textbuf_gui.h"
+#include "command_func.h"
+#include "depot_base.h"
+#include "vehicle_gui.h"
+#include "spritecache.h"
+#include "strings_func.h"
+#include "window_func.h"
+#include "vehicle_func.h"
+#include "company_func.h"
+#include "tilehighlight_func.h"
+#include "window_gui.h"
+#include "vehiclelist.h"
+#include "order_backup.h"
+//
+#include "group.h"
+#include "company_base.h"
+
+#include "aaa_template_gui_create.h"
+#include "aaa_template_vehicle.h"
+#include "aaa_template_vehicle_func.h"
+
+#include "train.h"
+
+// TODO: rm
+
+//Company *_cme = Company::Get(0))
+
+class TemplateReplaceWindow;
+
+// some space in front of the virtual train in the matrix
+uint16 TRAIN_FRONT_SPACE = 16;
+
+enum TemplateReplaceWindowWidgets {
+	TCW_CAPTION,
+	TCW_MATRIX_NEW_TMPL,
+	TCW_INFO_PANEL,
+	TCW_SCROLLBAR_NEW_TMPL,
+	TCW_SELL_TMPL,
+	TCW_NEW,
+	TCW_OK,
+	TCW_CANCEL,
+	TCW_REFIT,
+	TCW_CLONE,
+};
+
+static const NWidgetPart _widgets[] = {
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
+		NWidget(WWT_CAPTION, COLOUR_GREY, TCW_CAPTION), SetDataTip(STR_TMPL_CREATEGUI_TITLE, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_SHADEBOX, COLOUR_GREY),
+		NWidget(WWT_STICKYBOX, COLOUR_GREY),
+	EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(NWID_VERTICAL),
+			NWidget(WWT_MATRIX, COLOUR_GREY, TCW_MATRIX_NEW_TMPL), SetMinimalSize(216, 60), SetFill(1, 0), SetDataTip(0x1, STR_REPLACE_HELP_LEFT_ARRAY), SetResize(1, 0), SetScrollbar(TCW_SCROLLBAR_NEW_TMPL),
+			NWidget(WWT_PANEL, COLOUR_GREY, TCW_INFO_PANEL), SetMinimalSize(216,80), SetResize(1,1), EndContainer(),
+			NWidget(NWID_HSCROLLBAR, COLOUR_GREY, TCW_SCROLLBAR_NEW_TMPL), SetResize(1,0),
+		EndContainer(),
+		NWidget(WWT_IMGBTN, COLOUR_GREY, TCW_SELL_TMPL), SetDataTip(0x0, STR_NULL), SetMinimalSize(23,23), SetResize(0, 1), SetFill(0, 1),
+	EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TCW_OK),		SetMinimalSize(52, 12), SetResize(1,0), SetDataTip(STR_TMPL_CONFIRM, STR_TMPL_CONFIRM),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TCW_NEW),		SetMinimalSize(52, 12), SetResize(1,0), SetDataTip(STR_TMPL_NEW,	 STR_TMPL_NEW),
+		NWidget(WWT_TEXTBTN, COLOUR_GREY, TCW_CLONE),	SetMinimalSize(52, 12), SetResize(1,0), SetDataTip(STR_TMPL_CREATE_CLONE_VEH,	 STR_TMPL_CREATE_CLONE_VEH),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TCW_REFIT),	SetMinimalSize(52, 12), SetResize(1,0), SetDataTip(STR_TMPL_REFIT,	 STR_TMPL_REFIT),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TCW_CANCEL),	SetMinimalSize(52, 12), SetResize(1,0), SetDataTip(STR_TMPL_CANCEL,  STR_TMPL_CANCEL),
+		NWidget(WWT_RESIZEBOX, COLOUR_GREY),
+	EndContainer(),
+};
+
+static const WindowDesc _template_create_window_desc(
+	WDP_AUTO, 456, 100,
+	WC_CREATE_TEMPLATE, WC_NONE,					// TODO change wc_replace_vehicle
+	WDF_CONSTRUCTION,
+	_widgets, lengthof(_widgets)
+);
+
+static void TrainDepotMoveVehicle(const Vehicle *wagon, VehicleID sel, const Vehicle *head)
+{
+	const Vehicle *v = Vehicle::Get(sel);
+
+	if (v == wagon) return;
+
+	if (wagon == NULL) {
+		if (head != NULL) wagon = head->Last();
+	} else {
+		wagon = wagon->Previous();
+		if (wagon == NULL) return;
+	}
+
+	if (wagon == v) return;
+
+	CmdMoveRailVehicle(INVALID_TILE, DC_EXEC, (_ctrl_pressed ? 1:0)<<20 | (1<<21) | v->index, wagon == NULL ? INVALID_VEHICLE : wagon->index, 0);
+}
+
+class TemplateCreateWindow : public Window {
+private:
+	Scrollbar *hscroll;
+	int line_height;
+	Train* virtual_train;
+	bool editMode;
+	bool *noticeParent;
+	bool *createWindowOpen;			/// used to notify main window of progress (dummy way of disabling 'delete' while editing a template)
+	bool virtualTrainChangedNotice;
+	VehicleID sel;
+	VehicleID vehicle_over;
+	TemplateVehicle *editTemplate;
+
+public:
+	TemplateCreateWindow(const WindowDesc* _wdesc, TemplateVehicle *to_edit, bool *notice, bool *windowOpen, int step_h) : Window()
+	{
+		this->line_height = step_h;
+		this->CreateNestedTree(_wdesc);
+		this->hscroll = this->GetScrollbar(TCW_SCROLLBAR_NEW_TMPL);
+		this->FinishInitNested(_wdesc, VEH_TRAIN);
+		/* a sprite */
+		this->GetWidget<NWidgetCore>(TCW_SELL_TMPL)->widget_data = SPR_SELL_TRAIN;
+
+		this->owner = _local_company;
+
+		noticeParent = notice;
+		createWindowOpen = windowOpen;
+		virtualTrainChangedNotice = false;
+		this->editTemplate = to_edit;
+
+		if ( to_edit ) editMode = true;
+		else editMode = false;
+
+		this->sel = INVALID_VEHICLE;
+		this->vehicle_over = INVALID_VEHICLE;
+
+		this->virtual_train = VirtualTrainFromTemplateVehicle(to_edit);
+
+		this->resize.step_height = 1;
+	}
+	~TemplateCreateWindow()
+	{
+		if ( virtual_train )
+			delete virtual_train;
+
+		SetWindowClassesDirty(WC_TRAINS_LIST);
+
+		/* more cleanup */
+		*createWindowOpen = false;
+		DeleteWindowById(WC_BUILD_VIRTUAL_TRAIN, this->window_number);
+
+	}
+
+	virtual void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize)
+	{
+		switch (widget) {
+			case TCW_MATRIX_NEW_TMPL:
+				size->height = 20;
+				break;
+		}
+	}
+	virtual void OnResize()
+	{
+		NWidgetCore *nwi = this->GetWidget<NWidgetCore>(TCW_MATRIX_NEW_TMPL);
+		this->hscroll->SetCapacity(nwi->current_x);
+		nwi->widget_data = (this->hscroll->GetCapacity() << MAT_ROW_START) + (1 << MAT_COL_START);
+	}
+
+
+	virtual void OnInvalidateData(int data = 0, bool gui_scope = true)
+	{
+		virtualTrainChangedNotice = true;
+	}
+	virtual void OnClick(Point pt, int widget, int click_count)
+	{
+		switch(widget) {
+			case TCW_MATRIX_NEW_TMPL: {
+				NWidgetBase *nwi = this->GetWidget<NWidgetBase>(TCW_MATRIX_NEW_TMPL);
+				ClickedOnVehiclePanel(pt.x - nwi->pos_x-TRAIN_FRONT_SPACE, pt.y - nwi->pos_y);
+				break;
+			}
+			case TCW_NEW: {
+				ShowBuildVirtualTrainWindow(&virtual_train, &virtualTrainChangedNotice);
+				break;
+			}
+			case TCW_CLONE: {
+				this->SetWidgetDirty(TCW_CLONE);
+				this->ToggleWidgetLoweredState(TCW_CLONE);
+				if (this->IsWidgetLowered(TCW_CLONE)) {
+					static const CursorID clone_icon =	SPR_CURSOR_CLONE_TRAIN;
+					SetObjectToPlaceWnd(clone_icon, PAL_NONE, HT_VEHICLE, this);
+				} else {
+					ResetObjectToPlace();
+				}
+				break;
+			}
+			case TCW_OK: {
+				TemplateVehicle *tv = NULL;
+				if ( editMode )	tv = DeleteTemplateVehicle(editTemplate);
+				editTemplate = TemplateVehicleFromVirtualTrain(virtual_train);
+				if ( tv ) *noticeParent = true;
+				delete this;
+				break;
+			}
+			case TCW_CANCEL: {
+				delete this;
+				break;
+			}
+			case TCW_REFIT: {
+				ShowVehicleRefitWindow(virtual_train, INVALID_VEH_ORDER_ID, this, false, true);
+				break;
+			}
+		}
+	}
+	virtual bool OnVehicleSelect(const Vehicle *v)
+	{
+		// throw away the current virtual train
+		if ( virtual_train )
+			delete this->virtual_train;
+		// create a new one
+		this->virtual_train = CloneVirtualTrainFromTrain((const Train*)v);
+		this->ToggleWidgetLoweredState(TCW_CLONE);
+		ResetObjectToPlace();
+		this->SetDirty();
+
+		return true;
+	}
+	virtual void DrawWidget(const Rect &r, int widget) const
+	{
+		switch(widget) {
+			case TCW_MATRIX_NEW_TMPL: {
+				if ( this->virtual_train ) {
+					DrawTrainImage(virtual_train, r.left+TRAIN_FRONT_SPACE, r.right, r.top+2, this->sel, EIT_PURCHASE, this->hscroll->GetPosition(), this->vehicle_over);
+					SetDParam(0, CeilDiv(virtual_train->gcache.cached_total_length * 10, TILE_SIZE));
+					SetDParam(1, 1);
+					DrawString(r.left, r.right, r.top, STR_TINY_BLACK_DECIMAL, TC_BLACK, SA_RIGHT);
+				}
+				break;
+			}
+			case TCW_INFO_PANEL: {
+				if ( this->virtual_train ) {
+					/* Draw vehicle performance info */
+					const GroundVehicleCache *gcache = this->virtual_train->GetGroundVehicleCache();
+					SetDParam(2, this->virtual_train->GetDisplayMaxSpeed());
+					SetDParam(1, gcache->cached_power);
+					SetDParam(0, gcache->cached_weight);
+					SetDParam(3, gcache->cached_max_te / 1000);
+					DrawString(r.left+8, r.right, r.top+4, STR_VEHICLE_INFO_WEIGHT_POWER_MAX_SPEED_MAX_TE);
+					/* Draw cargo summary */
+					CargoArray cargo_caps;
+					for ( const Train *tmp=this->virtual_train; tmp; tmp=tmp->Next() )
+						cargo_caps[tmp->cargo_type] += tmp->cargo_cap;
+					int y = r.top+24;
+					for (CargoID i = 0; i < NUM_CARGO; i++) {
+						if ( cargo_caps[i] > 0 ) {
+							SetDParam(0, i);
+							SetDParam(1, cargo_caps[i]);
+							SetDParam(2, _settings_game.vehicle.freight_trains);
+							DrawString(r.left+8, r.right, y, STR_TMPL_CARGO_SUMMARY, TC_WHITE, SA_LEFT);
+							y += this->line_height/2;
+						}
+					}
+				}
+				break;
+			}
+			default:
+				break;
+		}
+	}
+	virtual void OnTick()
+	{
+		if ( virtualTrainChangedNotice ) {
+			this->SetDirty();
+			virtualTrainChangedNotice = false;
+		}
+	}
+	virtual void OnDragDrop(Point pt, int widget)
+	{
+		switch (widget) {
+			case TCW_MATRIX_NEW_TMPL: {
+				const Vehicle *v = NULL;
+				VehicleID sel;
+				if ( virtual_train ) sel = virtual_train->index;
+				else sel = INVALID_VEHICLE;
+
+				this->SetDirty();
+
+				NWidgetBase *nwi = this->GetWidget<NWidgetBase>(TCW_MATRIX_NEW_TMPL);
+				GetDepotVehiclePtData gdvp = { NULL, NULL };
+
+				if (this->GetVehicleFromDepotWndPt(pt.x - nwi->pos_x, pt.y - nwi->pos_y, &v, &gdvp) == MODE_DRAG_VEHICLE && sel != INVALID_VEHICLE) {
+					if (gdvp.wagon == NULL || gdvp.wagon->index != sel) {
+						this->vehicle_over = INVALID_VEHICLE;
+						TrainDepotMoveVehicle(gdvp.wagon, sel, gdvp.head);
+						virtual_train = virtual_train->First();
+					}
+				}
+				break;
+			}
+			case TCW_SELL_TMPL: {
+				if (this->IsWidgetDisabled(widget)) return;
+				if (this->sel == INVALID_VEHICLE) return;
+
+				virtual_train = DeleteVirtualTrain(virtual_train, Train::Get(this->sel));
+
+				this->sel = INVALID_VEHICLE;
+
+				this->SetDirty();
+				break;
+			}
+			default:
+				this->sel = INVALID_VEHICLE;
+				this->SetDirty();
+		}
+		_cursor.vehchain = false;
+		this->sel = INVALID_VEHICLE;
+		this->SetDirty();
+	}
+	virtual void OnMouseDrag(Point pt, int widget)
+	{
+		if (this->sel == INVALID_VEHICLE) return;
+		/* A rail vehicle is dragged.. */
+		if (widget != TCW_MATRIX_NEW_TMPL) { // ..outside of the depot matrix.
+			if (this->vehicle_over != INVALID_VEHICLE) {
+				this->vehicle_over = INVALID_VEHICLE;
+				this->SetWidgetDirty(TCW_MATRIX_NEW_TMPL);
+			}
+			return;
+		}
+
+		NWidgetBase *matrix = this->GetWidget<NWidgetBase>(widget);
+		const Vehicle *v = NULL;
+		GetDepotVehiclePtData gdvp = {NULL, NULL};
+
+		if (this->GetVehicleFromDepotWndPt(pt.x - matrix->pos_x, pt.y - matrix->pos_y, &v, &gdvp) != MODE_DRAG_VEHICLE) return;
+		VehicleID new_vehicle_over = INVALID_VEHICLE;
+		if (gdvp.head != NULL) {
+			if (gdvp.wagon == NULL && gdvp.head->Last()->index != this->sel) { // ..at the end of the train.
+				/* NOTE: As a wagon can't be moved at the begin of a train, head index isn't used to mark a drag-and-drop
+				 * destination inside a train. This head index is then used to indicate that a wagon is inserted at
+				 * the end of the train.
+				 */
+				new_vehicle_over = gdvp.head->index;
+			} else if (gdvp.wagon != NULL && gdvp.head != gdvp.wagon &&
+					gdvp.wagon->index != this->sel &&
+					gdvp.wagon->Previous()->index != this->sel) { // ..over an existing wagon.
+				new_vehicle_over = gdvp.wagon->index;
+			}
+		}
+		if (this->vehicle_over == new_vehicle_over) return;
+
+		this->vehicle_over = new_vehicle_over;
+		this->SetWidgetDirty(widget);
+	}
+	virtual void OnPaint()
+	{
+		uint max_width = 32;
+		uint width = 0;
+		if ( virtual_train )
+			for (Train *v = virtual_train; v != NULL; v = v->Next())
+				width += v->GetDisplayImageWidth();
+
+		max_width = max(max_width, width);
+		this->hscroll->SetCount(max_width+25);
+
+		this->DrawWidgets();
+	}
+	struct GetDepotVehiclePtData {
+		const Vehicle *head;
+		const Vehicle *wagon;
+	};
+
+	enum DepotGUIAction {
+		MODE_ERROR,
+		MODE_DRAG_VEHICLE,
+		MODE_SHOW_VEHICLE,
+		MODE_START_STOP,
+	};
+
+	uint count_width;
+	uint header_width;
+ 	DepotGUIAction GetVehicleFromDepotWndPt(int x, int y, const Vehicle **veh, GetDepotVehiclePtData *d) const
+	{
+		const NWidgetCore *matrix_widget = this->GetWidget<NWidgetCore>(TCW_MATRIX_NEW_TMPL);
+		/* In case of RTL the widgets are swapped as a whole */
+		if (_current_text_dir == TD_RTL) x = matrix_widget->current_x - x;
+
+		uint xm = x;
+
+		bool wagon = false;
+
+		x += this->hscroll->GetPosition();
+		const Train *v = virtual_train;
+		d->head = d->wagon = v;
+
+		if (xm <= this->header_width) {
+
+			if (wagon) return MODE_ERROR;
+
+			return MODE_SHOW_VEHICLE;
+		}
+
+		/* Account for the header */
+		x -= this->header_width;
+
+		/* find the vehicle in this row that was clicked */
+		for (; v != NULL; v = v->Next()) {
+			x -= v->GetDisplayImageWidth();
+			if (x < 0) break;
+		}
+
+		d->wagon = (v != NULL ? v->GetFirstEnginePart() : NULL);
+
+		return MODE_DRAG_VEHICLE;
+	}
+
+	void ClickedOnVehiclePanel(int x, int y)
+	{
+		GetDepotVehiclePtData gdvp = { NULL, NULL };
+		const Vehicle *v = NULL;
+		DepotGUIAction mode = this->GetVehicleFromDepotWndPt(x, y, &v, &gdvp);
+
+		v = gdvp.wagon;
+
+		if (v != NULL && VehicleClicked(v)) return;
+		VehicleID sel = this->sel;
+
+		if (sel != INVALID_VEHICLE) {
+			this->sel = INVALID_VEHICLE;
+		} else if (v != NULL) {
+			int image = v->GetImage(_current_text_dir == TD_RTL ? DIR_E : DIR_W, EIT_PURCHASE);
+			SetObjectToPlaceWnd(image, GetVehiclePalette(v), HT_DRAG, this);
+
+			this->sel = v->index;
+			this->SetDirty();
+
+			_cursor.short_vehicle_offset = v->IsGroundVehicle() ? 16 - v->GetGroundVehicleCache()->cached_veh_length * 2 : 0;
+			_cursor.vehchain = _ctrl_pressed;
+		}
+	}
+
+};
+
+void ShowTemplateCreateWindow(TemplateVehicle *to_edit, bool *noticeParent, bool *createWindowOpen, int step_h)
+{
+	if ( BringWindowToFrontById(WC_CREATE_TEMPLATE, VEH_TRAIN) != NULL ) return;
+	new TemplateCreateWindow(&_template_create_window_desc, to_edit, noticeParent, createWindowOpen, step_h);
+}
+
+
diff -urNad openttd-1.3.2/src/aaa_template_gui_create.h openttd-1.3.2-DC3.0RC3/src/aaa_template_gui_create.h
--- openttd-1.3.2/src/aaa_template_gui_create.h	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/aaa_template_gui_create.h	2013-11-22 05:49:06.000000000 +0100
@@ -0,0 +1,11 @@
+// template creation gui
+
+#ifndef TEMPLATE_GUI_CREATE
+#define TEMPLATE_GUI_CREATE
+
+#include "aaa_template_vehicle.h"
+#include "aaa_template_gui_create_virtualtrain.h"
+
+void ShowTemplateCreateWindow(TemplateVehicle*, bool*, bool*, int);
+
+#endif
diff -urNad openttd-1.3.2/src/aaa_template_gui_create_virtualtrain.cpp openttd-1.3.2-DC3.0RC3/src/aaa_template_gui_create_virtualtrain.cpp
--- openttd-1.3.2/src/aaa_template_gui_create_virtualtrain.cpp	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/aaa_template_gui_create_virtualtrain.cpp	2013-11-22 05:49:06.000000000 +0100
@@ -0,0 +1,839 @@
+/* $Id: build_vehicle_gui.cpp 23792 2012-01-12 19:23:00Z yexo $ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file build_vehicle_gui.cpp GUI for building vehicles. */
+
+#include "stdafx.h"
+#include "engine_base.h"
+#include "engine_func.h"
+#include "station_base.h"
+#include "articulated_vehicles.h"
+#include "textbuf_gui.h"
+#include "command_func.h"
+#include "company_func.h"
+#include "vehicle_gui.h"
+#include "newgrf_engine.h"
+#include "newgrf_text.h"
+#include "group.h"
+#include "string_func.h"
+#include "strings_func.h"
+#include "window_func.h"
+#include "date_func.h"
+#include "vehicle_func.h"
+#include "widgets/dropdown_func.h"
+#include "engine_gui.h"
+#include "cargotype.h"
+#include "core/geometry_func.hpp"
+
+#include "widgets/build_vehicle_widget.h"
+
+#include "table/strings.h"
+
+// MYGUI
+#include "aaa_template_gui_create_virtualtrain.h"
+#include "vehicle_gui.h"
+
+/**
+ * Get the height of a single 'entry' in the engine lists.
+ * @param type the vehicle type to get the height of
+ * @return the height for the entry
+ */
+static uint GetEngineListHeight(VehicleType type)
+{
+	return max<uint>(FONT_HEIGHT_NORMAL + WD_MATRIX_TOP + WD_MATRIX_BOTTOM, GetVehicleHeight(type));
+}
+
+static const NWidgetPart _nested_build_vehicle_widgets[] = {
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
+		NWidget(WWT_CAPTION, COLOUR_GREY, WID_BV_CAPTION), SetDataTip(STR_WHITE_STRING, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_SHADEBOX, COLOUR_GREY),
+		NWidget(WWT_STICKYBOX, COLOUR_GREY),
+	EndContainer(),
+	NWidget(WWT_PANEL, COLOUR_GREY),
+		NWidget(NWID_HORIZONTAL),
+			NWidget(NWID_VERTICAL),
+				NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_BV_SORT_ASSENDING_DESCENDING), SetDataTip(STR_BUTTON_SORT_BY, STR_TOOLTIP_SORT_ORDER), SetFill(1, 0),
+				NWidget(NWID_SPACER), SetFill(1, 1),
+			EndContainer(),
+			NWidget(NWID_VERTICAL),
+				NWidget(WWT_DROPDOWN, COLOUR_GREY, WID_BV_SORT_DROPDOWN), SetResize(1, 0), SetFill(1, 0), SetDataTip(STR_JUST_STRING, STR_TOOLTIP_SORT_CRITERIA),
+				NWidget(WWT_DROPDOWN, COLOUR_GREY, WID_BV_CARGO_FILTER_DROPDOWN), SetResize(1, 0), SetFill(1, 0), SetDataTip(STR_JUST_STRING, STR_TOOLTIP_FILTER_CRITERIA),
+			EndContainer(),
+		EndContainer(),
+	EndContainer(),
+	/* Vehicle list. */
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_MATRIX, COLOUR_GREY, WID_BV_LIST), SetResize(1, 1), SetFill(1, 0), SetDataTip(0x101, STR_NULL), SetScrollbar(WID_BV_SCROLLBAR),
+		NWidget(NWID_VSCROLLBAR, COLOUR_GREY, WID_BV_SCROLLBAR),
+	EndContainer(),
+	/* Panel with details. */
+	NWidget(WWT_PANEL, COLOUR_GREY, WID_BV_PANEL), SetMinimalSize(240, 122), SetResize(1, 0), EndContainer(),
+	/* Build/rename buttons, resize button. */
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_BV_BUILD), SetResize(1, 0), SetFill(1, 0), SetDataTip(STR_TMPL_CONFIRM, STR_TMPL_CONFIRM),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_BV_RENAME), SetResize(1, 0), SetFill(1, 0),
+		NWidget(WWT_RESIZEBOX, COLOUR_GREY),
+	EndContainer(),
+};
+
+/** Special cargo filter criteria */
+static const CargoID CF_ANY  = CT_NO_REFIT; ///< Show all vehicles independent of carried cargo (i.e. no filtering)
+static const CargoID CF_NONE = CT_INVALID;  ///< Show only vehicles which do not carry cargo (e.g. train engines)
+
+static bool _internal_sort_order;           ///< false = descending, true = ascending
+static byte _last_sort_criteria[]      = {0, 0, 0, 0};
+static bool _last_sort_order[]         = {false, false, false, false};
+static CargoID _last_filter_criteria[] = {CF_ANY, CF_ANY, CF_ANY, CF_ANY};
+
+/**
+ * Determines order of engines by engineID
+ * @param *a first engine to compare
+ * @param *b second engine to compare
+ * @return for descending order: returns < 0 if a < b and > 0 for a > b. Vice versa for ascending order and 0 for equal
+ */
+static int CDECL EngineNumberSorter(const EngineID *a, const EngineID *b)
+{
+	int r = Engine::Get(*a)->list_position - Engine::Get(*b)->list_position;
+
+	return _internal_sort_order ? -r : r;
+}
+
+/**
+ * Determines order of engines by introduction date
+ * @param *a first engine to compare
+ * @param *b second engine to compare
+ * @return for descending order: returns < 0 if a < b and > 0 for a > b. Vice versa for ascending order and 0 for equal
+ */
+static int CDECL EngineIntroDateSorter(const EngineID *a, const EngineID *b)
+{
+	const int va = Engine::Get(*a)->intro_date;
+	const int vb = Engine::Get(*b)->intro_date;
+	const int r = va - vb;
+
+	/* Use EngineID to sort instead since we want consistent sorting */
+	if (r == 0) return EngineNumberSorter(a, b);
+	return _internal_sort_order ? -r : r;
+}
+
+/**
+ * Determines order of engines by name
+ * @param *a first engine to compare
+ * @param *b second engine to compare
+ * @return for descending order: returns < 0 if a < b and > 0 for a > b. Vice versa for ascending order and 0 for equal
+ */
+static int CDECL EngineNameSorter(const EngineID *a, const EngineID *b)
+{
+	static EngineID last_engine[2] = { INVALID_ENGINE, INVALID_ENGINE };
+	static char     last_name[2][64] = { "\0", "\0" };
+
+	const EngineID va = *a;
+	const EngineID vb = *b;
+
+	if (va != last_engine[0]) {
+		last_engine[0] = va;
+		SetDParam(0, va);
+		GetString(last_name[0], STR_ENGINE_NAME, lastof(last_name[0]));
+	}
+
+	if (vb != last_engine[1]) {
+		last_engine[1] = vb;
+		SetDParam(0, vb);
+		GetString(last_name[1], STR_ENGINE_NAME, lastof(last_name[1]));
+	}
+
+	int r = strnatcmp(last_name[0], last_name[1]); // Sort by name (natural sorting).
+
+	/* Use EngineID to sort instead since we want consistent sorting */
+	if (r == 0) return EngineNumberSorter(a, b);
+	return _internal_sort_order ? -r : r;
+}
+
+/**
+ * Determines order of engines by reliability
+ * @param *a first engine to compare
+ * @param *b second engine to compare
+ * @return for descending order: returns < 0 if a < b and > 0 for a > b. Vice versa for ascending order and 0 for equal
+ */
+static int CDECL EngineReliabilitySorter(const EngineID *a, const EngineID *b)
+{
+	const int va = Engine::Get(*a)->reliability;
+	const int vb = Engine::Get(*b)->reliability;
+	const int r = va - vb;
+
+	/* Use EngineID to sort instead since we want consistent sorting */
+	if (r == 0) return EngineNumberSorter(a, b);
+	return _internal_sort_order ? -r : r;
+}
+
+/**
+ * Determines order of engines by purchase cost
+ * @param *a first engine to compare
+ * @param *b second engine to compare
+ * @return for descending order: returns < 0 if a < b and > 0 for a > b. Vice versa for ascending order and 0 for equal
+ */
+static int CDECL EngineCostSorter(const EngineID *a, const EngineID *b)
+{
+	Money va = Engine::Get(*a)->GetCost();
+	Money vb = Engine::Get(*b)->GetCost();
+	int r = ClampToI32(va - vb);
+
+	/* Use EngineID to sort instead since we want consistent sorting */
+	if (r == 0) return EngineNumberSorter(a, b);
+	return _internal_sort_order ? -r : r;
+}
+
+/**
+ * Determines order of engines by speed
+ * @param *a first engine to compare
+ * @param *b second engine to compare
+ * @return for descending order: returns < 0 if a < b and > 0 for a > b. Vice versa for ascending order and 0 for equal
+ */
+static int CDECL EngineSpeedSorter(const EngineID *a, const EngineID *b)
+{
+	int va = Engine::Get(*a)->GetDisplayMaxSpeed();
+	int vb = Engine::Get(*b)->GetDisplayMaxSpeed();
+	int r = va - vb;
+
+	/* Use EngineID to sort instead since we want consistent sorting */
+	if (r == 0) return EngineNumberSorter(a, b);
+	return _internal_sort_order ? -r : r;
+}
+
+/**
+ * Determines order of engines by power
+ * @param *a first engine to compare
+ * @param *b second engine to compare
+ * @return for descending order: returns < 0 if a < b and > 0 for a > b. Vice versa for ascending order and 0 for equal
+ */
+static int CDECL EnginePowerSorter(const EngineID *a, const EngineID *b)
+{
+	int va = Engine::Get(*a)->GetPower();
+	int vb = Engine::Get(*b)->GetPower();
+	int r = va - vb;
+
+	/* Use EngineID to sort instead since we want consistent sorting */
+	if (r == 0) return EngineNumberSorter(a, b);
+	return _internal_sort_order ? -r : r;
+}
+
+/**
+ * Determines order of engines by tractive effort
+ * @param *a first engine to compare
+ * @param *b second engine to compare
+ * @return for descending order: returns < 0 if a < b and > 0 for a > b. Vice versa for ascending order and 0 for equal
+ */
+static int CDECL EngineTractiveEffortSorter(const EngineID *a, const EngineID *b)
+{
+	int va = Engine::Get(*a)->GetDisplayMaxTractiveEffort();
+	int vb = Engine::Get(*b)->GetDisplayMaxTractiveEffort();
+	int r = va - vb;
+
+	/* Use EngineID to sort instead since we want consistent sorting */
+	if (r == 0) return EngineNumberSorter(a, b);
+	return _internal_sort_order ? -r : r;
+}
+
+/**
+ * Determines order of engines by running costs
+ * @param *a first engine to compare
+ * @param *b second engine to compare
+ * @return for descending order: returns < 0 if a < b and > 0 for a > b. Vice versa for ascending order and 0 for equal
+ */
+static int CDECL EngineRunningCostSorter(const EngineID *a, const EngineID *b)
+{
+	Money va = Engine::Get(*a)->GetRunningCost();
+	Money vb = Engine::Get(*b)->GetRunningCost();
+	int r = ClampToI32(va - vb);
+
+	/* Use EngineID to sort instead since we want consistent sorting */
+	if (r == 0) return EngineNumberSorter(a, b);
+	return _internal_sort_order ? -r : r;
+}
+
+/**
+ * Determines order of engines by running costs
+ * @param *a first engine to compare
+ * @param *b second engine to compare
+ * @return for descending order: returns < 0 if a < b and > 0 for a > b. Vice versa for ascending order and 0 for equal
+ */
+static int CDECL EnginePowerVsRunningCostSorter(const EngineID *a, const EngineID *b)
+{
+	const Engine *e_a = Engine::Get(*a);
+	const Engine *e_b = Engine::Get(*b);
+
+	/* Here we are using a few tricks to get the right sort.
+	 * We want power/running cost, but since we usually got higher running cost than power and we store the result in an int,
+	 * we will actually calculate cunning cost/power (to make it more than 1).
+	 * Because of this, the return value have to be reversed as well and we return b - a instead of a - b.
+	 * Another thing is that both power and running costs should be doubled for multiheaded engines.
+	 * Since it would be multipling with 2 in both numerator and denumerator, it will even themselves out and we skip checking for multiheaded. */
+	Money va = (e_a->GetRunningCost()) / max(1U, (uint)e_a->GetPower());
+	Money vb = (e_b->GetRunningCost()) / max(1U, (uint)e_b->GetPower());
+	int r = ClampToI32(vb - va);
+
+	/* Use EngineID to sort instead since we want consistent sorting */
+	if (r == 0) return EngineNumberSorter(a, b);
+	return _internal_sort_order ? -r : r;
+}
+
+/* Train sorting functions */
+
+/**
+ * Determines order of train engines by capacity
+ * @param *a first engine to compare
+ * @param *b second engine to compare
+ * @return for descending order: returns < 0 if a < b and > 0 for a > b. Vice versa for ascending order and 0 for equal
+ */
+static int CDECL TrainEngineCapacitySorter(const EngineID *a, const EngineID *b)
+{
+	const RailVehicleInfo *rvi_a = RailVehInfo(*a);
+	const RailVehicleInfo *rvi_b = RailVehInfo(*b);
+
+	int va = GetTotalCapacityOfArticulatedParts(*a) * (rvi_a->railveh_type == RAILVEH_MULTIHEAD ? 2 : 1);
+	int vb = GetTotalCapacityOfArticulatedParts(*b) * (rvi_b->railveh_type == RAILVEH_MULTIHEAD ? 2 : 1);
+	int r = va - vb;
+
+	/* Use EngineID to sort instead since we want consistent sorting */
+	if (r == 0) return EngineNumberSorter(a, b);
+	return _internal_sort_order ? -r : r;
+}
+
+/**
+ * Determines order of train engines by engine / wagon
+ * @param *a first engine to compare
+ * @param *b second engine to compare
+ * @return for descending order: returns < 0 if a < b and > 0 for a > b. Vice versa for ascending order and 0 for equal
+ */
+static int CDECL TrainEnginesThenWagonsSorter(const EngineID *a, const EngineID *b)
+{
+	int val_a = (RailVehInfo(*a)->railveh_type == RAILVEH_WAGON ? 1 : 0);
+	int val_b = (RailVehInfo(*b)->railveh_type == RAILVEH_WAGON ? 1 : 0);
+	int r = val_a - val_b;
+
+	/* Use EngineID to sort instead since we want consistent sorting */
+	if (r == 0) return EngineNumberSorter(a, b);
+	return _internal_sort_order ? -r : r;
+}
+
+// TODO: make this single-dim
+
+static EngList_SortTypeFunction * const _sorter[][11] = {{
+	/* Trains */
+	&EngineNumberSorter,
+	&EngineCostSorter,
+	&EngineSpeedSorter,
+	&EnginePowerSorter,
+	&EngineTractiveEffortSorter,
+	&EngineIntroDateSorter,
+	&EngineNameSorter,
+	&EngineRunningCostSorter,
+	&EnginePowerVsRunningCostSorter,
+	&EngineReliabilitySorter,
+	&TrainEngineCapacitySorter,
+}};
+
+static const StringID _sort_listing[][12] = {{
+	/* Trains */
+	STR_SORT_BY_ENGINE_ID,
+	STR_SORT_BY_COST,
+	STR_SORT_BY_MAX_SPEED,
+	STR_SORT_BY_POWER,
+	STR_SORT_BY_TRACTIVE_EFFORT,
+	STR_SORT_BY_INTRO_DATE,
+	STR_SORT_BY_NAME,
+	STR_SORT_BY_RUNNING_COST,
+	STR_SORT_BY_POWER_VS_RUNNING_COST,
+	STR_SORT_BY_RELIABILITY,
+	STR_SORT_BY_CARGO_CAPACITY,
+	INVALID_STRING_ID
+}};
+
+/** Cargo filter functions */
+static bool CDECL CargoFilter(const EngineID *eid, const CargoID cid)
+{
+	if (cid == CF_ANY) return true;
+	uint32 refit_mask = GetUnionOfArticulatedRefitMasks(*eid, true);
+	return (cid == CF_NONE ? refit_mask == 0 : HasBit(refit_mask, cid));
+}
+
+static GUIEngineList::FilterFunction * const _filter_funcs[] = {
+	&CargoFilter,
+};
+
+/**
+ * Engine drawing loop
+ * @param type Type of vehicle (VEH_*)
+ * @param l The left most location of the list
+ * @param r The right most location of the list
+ * @param y The top most location of the list
+ * @param eng_list What engines to draw
+ * @param min where to start in the list
+ * @param max where in the list to end
+ * @param selected_id what engine to highlight as selected, if any
+ * @param show_count Whether to show the amount of engines or not
+ * @param selected_group the group to list the engines of
+ */
+static void DrawEngineList(VehicleType type, int l, int r, int y, const GUIEngineList *eng_list, uint16 min, uint16 max, EngineID selected_id, bool show_count, GroupID selected_group)
+{
+	static const int sprite_widths[]  = { 60, 60, 76, 67 };
+	static const int sprite_y_offsets[] = { -1, -1, -2, -2 };
+
+	/* Obligatory sanity checks! */
+	assert((uint)type < lengthof(sprite_widths));
+	assert_compile(lengthof(sprite_y_offsets) == lengthof(sprite_widths));
+	assert(max <= eng_list->Length());
+
+	bool rtl = _current_text_dir == TD_RTL;
+	int step_size = GetEngineListHeight(type);
+	int sprite_width = sprite_widths[type];
+
+	int sprite_x        = (rtl ? r - sprite_width / 2 : l + sprite_width / 2) - 1;
+	int sprite_y_offset = sprite_y_offsets[type] + step_size / 2;
+
+	int text_left  = l + (rtl ? WD_FRAMERECT_LEFT : sprite_width);
+	int text_right = r - (rtl ? sprite_width : WD_FRAMERECT_RIGHT);
+
+	int normal_text_y_offset = (step_size - FONT_HEIGHT_NORMAL) / 2;
+	int small_text_y_offset  = step_size - FONT_HEIGHT_SMALL - WD_FRAMERECT_BOTTOM - 1;
+
+	for (; min < max; min++, y += step_size) {
+		const EngineID engine = (*eng_list)[min];
+		/* Note: num_engines is only used in the autoreplace GUI, so it is correct to use _local_company here. */
+		const uint num_engines = GetGroupNumEngines(_local_company, selected_group, engine);
+
+		SetDParam(0, engine);
+		DrawString(text_left, text_right, y + normal_text_y_offset, STR_ENGINE_NAME, engine == selected_id ? TC_WHITE : TC_BLACK);
+		DrawVehicleEngine(l, r, sprite_x, y + sprite_y_offset, engine, (show_count && num_engines == 0) ? PALETTE_CRASH : GetEnginePalette(engine, _local_company), EIT_PURCHASE);
+		if (show_count) {
+			SetDParam(0, num_engines);
+			DrawString(text_left, text_right, y + small_text_y_offset, STR_TINY_BLACK_COMA, TC_FROMSTRING, SA_RIGHT);
+		}
+	}
+}
+
+
+struct BuildVirtualTrainWindow : Window {
+	VehicleType vehicle_type;
+	union {
+		RailTypeByte railtype;
+		RoadTypes roadtypes;
+	} filter;
+	bool descending_sort_order;
+	byte sort_criteria;
+	bool listview_mode;
+	EngineID sel_engine;
+	EngineID rename_engine;
+	GUIEngineList eng_list;
+	CargoID cargo_filter[NUM_CARGO + 2];        ///< Available cargo filters; CargoID or CF_ANY or CF_NONE
+	StringID cargo_filter_texts[NUM_CARGO + 3]; ///< Texts for filter_cargo, terminated by INVALID_STRING_ID
+	byte cargo_filter_criteria;                 ///< Selected cargo filter
+	int details_height;                         ///< Minimal needed height of the details panels (found so far).
+	Scrollbar *vscroll;
+	// MYGUI
+	Train **virtual_train;
+	bool *noticeParent;
+
+	BuildVirtualTrainWindow(const WindowDesc *desc, Train **vt, bool *notice) : Window()
+	{
+		this->vehicle_type = VEH_TRAIN; // TODO change type to VEH_TRAIN everywhere
+		this->window_number = 0;//tile == INVALID_TILE ? (int)type : tile;
+
+		this->sel_engine      = INVALID_ENGINE;
+
+		this->sort_criteria         = _last_sort_criteria[VEH_TRAIN];
+		this->descending_sort_order = _last_sort_order[VEH_TRAIN];
+
+		this->filter.railtype = RAILTYPE_END;
+
+		this->listview_mode = (this->window_number <= VEH_END);
+
+		this->CreateNestedTree(desc);
+
+		this->vscroll = this->GetScrollbar(WID_BV_SCROLLBAR);
+
+		NWidgetCore *widget = this->GetWidget<NWidgetCore>(WID_BV_LIST);
+
+		widget = this->GetWidget<NWidgetCore>(WID_BV_BUILD);
+
+		widget = this->GetWidget<NWidgetCore>(WID_BV_RENAME);
+		widget->widget_data = STR_BUY_VEHICLE_TRAIN_RENAME_BUTTON + VEH_TRAIN;
+		widget->tool_tip    = STR_BUY_VEHICLE_TRAIN_RENAME_TOOLTIP + VEH_TRAIN;
+
+		this->details_height = ((this->vehicle_type == VEH_TRAIN) ? 10 : 9) * FONT_HEIGHT_NORMAL + WD_FRAMERECT_TOP + WD_FRAMERECT_BOTTOM;
+
+		this->FinishInitNested(desc, VEH_TRAIN);
+
+		this->owner = _local_company;
+
+		this->eng_list.ForceRebuild();
+		this->GenerateBuildList();
+
+		if (this->eng_list.Length() > 0) this->sel_engine = this->eng_list[0];
+
+		this->virtual_train = vt;
+		this->noticeParent = notice;
+	}
+
+	/** Populate the filter list and set the cargo filter criteria. */
+	void SetCargoFilterArray()
+	{
+		uint filter_items = 0;
+
+		/* Add item for disabling filtering. */
+		this->cargo_filter[filter_items] = CF_ANY;
+		this->cargo_filter_texts[filter_items] = STR_PURCHASE_INFO_ALL_TYPES;
+		filter_items++;
+
+		/* Add item for vehicles not carrying anything, e.g. train engines.
+		 * This could also be useful for eyecandy vehicles of other types, but is likely too confusing for joe, */
+		if (this->vehicle_type == VEH_TRAIN) {
+			this->cargo_filter[filter_items] = CF_NONE;
+			this->cargo_filter_texts[filter_items] = STR_LAND_AREA_INFORMATION_LOCAL_AUTHORITY_NONE;
+			filter_items++;
+		}
+
+		/* Collect available cargo types for filtering. */
+		const CargoSpec *cs;
+		FOR_ALL_SORTED_STANDARD_CARGOSPECS(cs) {
+			this->cargo_filter[filter_items] = cs->Index();
+			this->cargo_filter_texts[filter_items] = cs->name;
+			filter_items++;
+		}
+
+		/* Terminate the filter list. */
+		this->cargo_filter_texts[filter_items] = INVALID_STRING_ID;
+
+		/* If not found, the cargo criteria will be set to all cargoes. */
+		this->cargo_filter_criteria = 0;
+
+		/* Find the last cargo filter criteria. */
+		for (uint i = 0; i < filter_items; i++) {
+			if (this->cargo_filter[i] == _last_filter_criteria[this->vehicle_type]) {
+				this->cargo_filter_criteria = i;
+				break;
+			}
+		}
+
+		this->eng_list.SetFilterFuncs(_filter_funcs);
+		this->eng_list.SetFilterState(this->cargo_filter[this->cargo_filter_criteria] != CF_ANY);
+	}
+
+	void OnInit()
+	{
+		this->SetCargoFilterArray();
+	}
+
+	/** Filter the engine list against the currently selected cargo filter */
+	void FilterEngineList()
+	{
+		this->eng_list.Filter(this->cargo_filter[this->cargo_filter_criteria]);
+		if (0 == this->eng_list.Length()) { // no engine passed through the filter, invalidate the previously selected engine
+			this->sel_engine = INVALID_ENGINE;
+		} else if (!this->eng_list.Contains(this->sel_engine)) { // previously selected engine didn't pass the filter, select the first engine of the list
+			this->sel_engine = this->eng_list[0];
+		}
+	}
+
+	/** Filter a single engine */
+	bool FilterSingleEngine(EngineID eid)
+	{
+		CargoID filter_type = this->cargo_filter[this->cargo_filter_criteria];
+		return (filter_type == CF_ANY || CargoFilter(&eid, filter_type));
+	}
+
+	/* Figure out what train EngineIDs to put in the list */
+	void GenerateBuildTrainList()
+	{
+		EngineID sel_id = INVALID_ENGINE;
+		int num_engines = 0;
+		int num_wagons  = 0;
+
+		this->filter.railtype = (this->listview_mode) ? RAILTYPE_END : GetRailType(this->window_number);
+
+		this->eng_list.Clear();
+
+		/* Make list of all available train engines and wagons.
+		 * Also check to see if the previously selected engine is still available,
+		 * and if not, reset selection to INVALID_ENGINE. This could be the case
+		 * when engines become obsolete and are removed */
+		const Engine *e;
+		FOR_ALL_ENGINES_OF_TYPE(e, VEH_TRAIN) {
+			EngineID eid = e->index;
+			const RailVehicleInfo *rvi = &e->u.rail;
+
+			if (this->filter.railtype != RAILTYPE_END && !HasPowerOnRail(rvi->railtype, this->filter.railtype)) continue;
+			if (!IsEngineBuildable(eid, VEH_TRAIN, _local_company)) continue;
+
+			/* Filter now! So num_engines and num_wagons is valid */
+			if (!FilterSingleEngine(eid)) continue;
+
+			*this->eng_list.Append() = eid;
+
+			if (rvi->railveh_type != RAILVEH_WAGON) {
+				num_engines++;
+			} else {
+				num_wagons++;
+			}
+
+			if (eid == this->sel_engine) sel_id = eid;
+		}
+
+		this->sel_engine = sel_id;
+
+		/* make engines first, and then wagons, sorted by ListPositionOfEngine() */
+		_internal_sort_order = false;
+		EngList_Sort(&this->eng_list, TrainEnginesThenWagonsSorter);
+
+		/* and then sort engines */
+		_internal_sort_order = this->descending_sort_order;
+		EngList_SortPartial(&this->eng_list, _sorter[0][this->sort_criteria], 0, num_engines);
+
+		/* and finally sort wagons */
+		EngList_SortPartial(&this->eng_list, _sorter[0][this->sort_criteria], num_engines, num_wagons);
+	}
+
+	// TODO: cleanup this func
+	/* Generate the list of vehicles */
+	void GenerateBuildList()
+	{
+		if (!this->eng_list.NeedRebuild()) return;
+
+		this->GenerateBuildTrainList();
+		this->eng_list.Compact();
+		this->eng_list.RebuildDone();
+		return; // trains should not reach the last sorting
+
+
+		this->FilterEngineList();
+
+		_internal_sort_order = this->descending_sort_order;
+		EngList_Sort(&this->eng_list, _sorter[this->vehicle_type][this->sort_criteria]);
+
+		this->eng_list.Compact();
+		this->eng_list.RebuildDone();
+	}
+
+	virtual	void OnClick(Point pt, int widget, int click_count)
+	{
+		switch (widget) {
+			case WID_BV_SORT_ASSENDING_DESCENDING:
+				this->descending_sort_order ^= true;
+				_last_sort_order[this->vehicle_type] = this->descending_sort_order;
+				this->eng_list.ForceRebuild();
+				this->SetDirty();
+				break;
+
+			case WID_BV_LIST: {
+				uint i = this->vscroll->GetScrolledRowFromWidget(pt.y, this, WID_BV_LIST);
+				size_t num_items = this->eng_list.Length();
+				this->sel_engine = (i < num_items) ? this->eng_list[i] : INVALID_ENGINE;
+				this->SetDirty();
+				if (click_count > 1 && !this->listview_mode) this->OnClick(pt, WID_BV_BUILD, 1);
+				break;
+			}
+			case WID_BV_SORT_DROPDOWN: { // Select sorting criteria dropdown menu
+				uint32 hidden_mask = 0;
+				/* Disable sorting by power or tractive effort when the original acceleration model for road vehicles is being used. */
+				if (this->vehicle_type == VEH_ROAD &&
+						_settings_game.vehicle.roadveh_acceleration_model == AM_ORIGINAL) {
+					SetBit(hidden_mask, 3); // power
+					SetBit(hidden_mask, 4); // tractive effort
+					SetBit(hidden_mask, 8); // power by running costs
+				}
+				/* Disable sorting by tractive effort when the original acceleration model for trains is being used. */
+				if (this->vehicle_type == VEH_TRAIN &&
+						_settings_game.vehicle.train_acceleration_model == AM_ORIGINAL) {
+					SetBit(hidden_mask, 4); // tractive effort
+				}
+				ShowDropDownMenu(this, _sort_listing[this->vehicle_type], this->sort_criteria, WID_BV_SORT_DROPDOWN, 0, hidden_mask);
+				break;
+			}
+
+			case WID_BV_CARGO_FILTER_DROPDOWN: // Select cargo filtering criteria dropdown menu
+				ShowDropDownMenu(this, this->cargo_filter_texts, this->cargo_filter_criteria, WID_BV_CARGO_FILTER_DROPDOWN, 0, 0);
+				break;
+
+			case WID_BV_BUILD: {
+				EngineID sel_eng = this->sel_engine;
+				if (sel_eng != INVALID_ENGINE) {
+					Train *tmp = CmdBuildVirtualRailVehicle(sel_eng);
+					if (tmp) AddVirtualEngine(tmp);
+				}
+				break;
+			}
+		}
+	}
+
+	/**
+	 * Some data on this window has become invalid.
+	 * @param data Information about the changed data.
+	 * @param gui_scope Whether the call is done from GUI scope. You may not do everything when not in GUI scope. See #InvalidateWindowData() for details.
+	 */
+	virtual void OnInvalidateData(int data = 0, bool gui_scope = true)
+	{
+		if (!gui_scope) return;
+		/* When switching to original acceleration model for road vehicles, clear the selected sort criteria if it is not available now. */
+		if (this->vehicle_type == VEH_ROAD &&
+				_settings_game.vehicle.roadveh_acceleration_model == AM_ORIGINAL &&
+				this->sort_criteria > 7) {
+			this->sort_criteria = 0;
+			_last_sort_criteria[VEH_ROAD] = 0;
+		}
+		this->eng_list.ForceRebuild();
+	}
+
+	virtual void SetStringParameters(int widget) const
+	{
+		switch (widget) {
+			case WID_BV_CAPTION:
+				if (this->vehicle_type == VEH_TRAIN && !this->listview_mode) {
+					const RailtypeInfo *rti = GetRailTypeInfo(this->filter.railtype);
+					SetDParam(0, rti->strings.build_caption);
+				} else {
+					SetDParam(0, (this->listview_mode ? STR_VEHICLE_LIST_AVAILABLE_TRAINS : STR_BUY_VEHICLE_TRAIN_ALL_CAPTION) + this->vehicle_type);
+				}
+				break;
+
+			case WID_BV_SORT_DROPDOWN:
+				SetDParam(0, _sort_listing[this->vehicle_type][this->sort_criteria]);
+				break;
+
+			case WID_BV_CARGO_FILTER_DROPDOWN:
+				SetDParam(0, this->cargo_filter_texts[this->cargo_filter_criteria]);
+		}
+	}
+
+	virtual void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize)
+	{
+		switch (widget) {
+			case WID_BV_LIST:
+				resize->height = GetEngineListHeight(this->vehicle_type);
+				size->height = 3 * resize->height;
+				break;
+
+			case WID_BV_PANEL:
+				size->height = this->details_height;
+				break;
+
+			case WID_BV_SORT_ASSENDING_DESCENDING: {
+				Dimension d = GetStringBoundingBox(this->GetWidget<NWidgetCore>(widget)->widget_data);
+				d.width += padding.width + WD_SORTBUTTON_ARROW_WIDTH * 2; // Doubled since the string is centred and it also looks better.
+				d.height += padding.height;
+				*size = maxdim(*size, d);
+				break;
+			}
+		}
+	}
+
+	virtual void DrawWidget(const Rect &r, int widget) const
+	{
+		switch (widget) {
+			case WID_BV_LIST:
+				DrawEngineList(this->vehicle_type, r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP, &this->eng_list, this->vscroll->GetPosition(), min(this->vscroll->GetPosition() + this->vscroll->GetCapacity(), this->eng_list.Length()), this->sel_engine, false, DEFAULT_GROUP);
+				break;
+
+			case WID_BV_SORT_ASSENDING_DESCENDING:
+				this->DrawSortButtonState(WID_BV_SORT_ASSENDING_DESCENDING, this->descending_sort_order ? SBS_DOWN : SBS_UP);
+				break;
+		}
+	}
+
+	virtual void OnPaint()
+	{
+		this->GenerateBuildList();
+		this->vscroll->SetCount(this->eng_list.Length());
+
+		this->DrawWidgets();
+
+		if (!this->IsShaded()) {
+			int needed_height = this->details_height;
+			/* Draw details panels. */
+			if (this->sel_engine != INVALID_ENGINE) {
+				NWidgetBase *nwi = this->GetWidget<NWidgetBase>(WID_BV_PANEL);
+				int text_end = DrawVehiclePurchaseInfo(nwi->pos_x + WD_FRAMETEXT_LEFT, nwi->pos_x + nwi->current_x - WD_FRAMETEXT_RIGHT,
+						nwi->pos_y + WD_FRAMERECT_TOP, this->sel_engine);
+				needed_height = max(needed_height, text_end - (int)nwi->pos_y + WD_FRAMERECT_BOTTOM);
+			}
+			if (needed_height != this->details_height) { // Details window are not high enough, enlarge them.
+				int resize = needed_height - this->details_height;
+				this->details_height = needed_height;
+				this->ReInit(0, resize);
+				return;
+			}
+		}
+	}
+
+	virtual void OnQueryTextFinished(char *str)
+	{
+		if (str == NULL) return;
+
+		DoCommandP(0, this->rename_engine, 0, CMD_RENAME_ENGINE | CMD_MSG(STR_ERROR_CAN_T_RENAME_TRAIN_TYPE + this->vehicle_type), NULL, str);
+	}
+
+	virtual void OnDropdownSelect(int widget, int index)
+	{
+		switch (widget) {
+			case WID_BV_SORT_DROPDOWN:
+				if (this->sort_criteria != index) {
+					this->sort_criteria = index;
+					_last_sort_criteria[this->vehicle_type] = this->sort_criteria;
+					this->eng_list.ForceRebuild();
+				}
+				break;
+
+			case WID_BV_CARGO_FILTER_DROPDOWN: // Select a cargo filter criteria
+				if (this->cargo_filter_criteria != index) {
+					this->cargo_filter_criteria = index;
+					_last_filter_criteria[this->vehicle_type] = this->cargo_filter[this->cargo_filter_criteria];
+					/* deactivate filter if criteria is 'Show All', activate it otherwise */
+					this->eng_list.SetFilterState(this->cargo_filter[this->cargo_filter_criteria] != CF_ANY);
+					this->eng_list.ForceRebuild();
+				}
+				break;
+		}
+		this->SetDirty();
+	}
+
+	virtual void OnResize()
+	{
+		this->vscroll->SetCapacityFromWidget(this, WID_BV_LIST);
+		this->GetWidget<NWidgetCore>(WID_BV_LIST)->widget_data = (this->vscroll->GetCapacity() << MAT_ROW_START) + (1 << MAT_COL_START);
+	}
+
+	void AddVirtualEngine(Train *toadd)
+	{
+		if ( !*virtual_train ) {
+			*virtual_train = toadd;
+		}
+		else {
+			VehicleID target = (*(this->virtual_train))->GetLastUnit()->index;
+			CommandCost movec;
+			movec = CmdMoveRailVehicle(INVALID_TILE, DC_EXEC, (1<<21) | toadd->index, target, 0);
+		}
+		*noticeParent = true;
+	}
+};
+
+static const WindowDesc _build_vehicle_desc(
+	WDP_AUTO, 240, 268,
+	WC_BUILD_VIRTUAL_TRAIN, WC_NONE,
+	WDF_CONSTRUCTION,
+	_nested_build_vehicle_widgets, lengthof(_nested_build_vehicle_widgets)
+);
+
+void ShowBuildVirtualTrainWindow(Train **vt, bool *noticeParent)
+{
+	// '0' as in VEH_TRAIN = Tile=0
+	assert(IsCompanyBuildableVehicleType(VEH_TRAIN));
+
+	DeleteWindowById(WC_BUILD_VEHICLE, 0);
+
+	new BuildVirtualTrainWindow(&_build_vehicle_desc, vt, noticeParent);
+}
diff -urNad openttd-1.3.2/src/aaa_template_gui_create_virtualtrain.h openttd-1.3.2-DC3.0RC3/src/aaa_template_gui_create_virtualtrain.h
--- openttd-1.3.2/src/aaa_template_gui_create_virtualtrain.h	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/aaa_template_gui_create_virtualtrain.h	2013-11-22 05:49:06.000000000 +0100
@@ -0,0 +1,8 @@
+#ifndef BUILD_VIRTUAL_TRAIN_GUI
+#define BUILD_VIRTUAL_TRAIN_GUI
+
+#include "train.h"
+
+void ShowBuildVirtualTrainWindow(Train**, bool*);
+
+#endif
diff -urNad openttd-1.3.2/src/aaa_template_gui_main.cpp openttd-1.3.2-DC3.0RC3/src/aaa_template_gui_main.cpp
--- openttd-1.3.2/src/aaa_template_gui_main.cpp	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/aaa_template_gui_main.cpp	2013-11-22 05:49:06.000000000 +0100
@@ -0,0 +1,740 @@
+// mygui.c
+
+
+//#include "aaa_mygui.h"
+#include <iostream>
+#include <stdio.h>
+
+
+#include "stdafx.h"
+#include "command_func.h"
+#include "vehicle_gui.h"
+#include "newgrf_engine.h"
+#include "group.h"
+#include "rail.h"
+#include "strings_func.h"
+#include "window_func.h"
+#include "autoreplace_func.h"
+#include "company_func.h"
+#include "engine_base.h"
+#include "window_gui.h"
+#include "viewport_func.h"
+#include "tilehighlight_func.h"
+#include "engine_gui.h"
+#include "settings_func.h"
+#include "core/geometry_func.hpp"
+#include "rail_gui.h"
+
+#include "table/sprites.h"
+#include "table/strings.h"
+
+// test creating pool -> creating vehicles
+#include "core/pool_func.hpp"
+
+#include "vehicle_gui_base.h"
+#include "vehicle_base.h"
+#include "train.h"
+#include "vehicle_func.h"
+
+#include "gfx_type.h"
+
+#include "engine_func.h"
+
+// drawing the vehicle length based on occupied tiles
+#include "spritecache.h"
+
+#include "aaa_template_gui_main.h"
+#include "aaa_template_gui_create.h"
+#include "aaa_template_vehicle.h"
+//#include "aaa_template_vehicle_func.h"
+
+
+typedef GUIList<const Group*> GUIGroupList;
+
+
+/* template creation */
+void ShowTemplateCreationWindow(TileIndex);
+void ShowTestWindow();
+
+enum TemplateReplaceWindowWidgets {
+	TRW_CAPTION,
+
+	TRW_WIDGET_INSET_GROUPS,
+	TRW_WIDGET_TOP_MATRIX,
+	TRW_WIDGET_TOP_SCROLLBAR,
+
+	TRW_WIDGET_INSET_TEMPLATES,
+	TRW_WIDGET_BOTTOM_MATRIX,
+	TRW_WIDGET_BOTTOM_SCROLLBAR,
+
+	TRW_WIDGET_TMPL_INFO_INSET,
+	TRW_WIDGET_TMPL_INFO_PANEL,
+
+	TRW_WIDGET_TMPL_PRE_BUTTON_FLUFF,
+
+	TRW_WIDGET_TMPL_BUTTONS_CONFIGTMPL_REUSE,
+	TRW_WIDGET_TMPL_BUTTONS_CONFIGTMPL_KEEP,
+	TRW_WIDGET_TMPL_BUTTONS_CONFIGTMPL_REFIT,
+	TRW_WIDGET_TMPL_BUTTONS_CONFIG_RIGHTPANEL,
+
+	TRW_WIDGET_TMPL_BUTTONS_DEFINE,
+	TRW_WIDGET_TMPL_BUTTONS_EDIT,
+	TRW_WIDGET_TMPL_BUTTONS_CLONE,
+	TRW_WIDGET_TMPL_BUTTONS_DELETE,
+	TRW_WIDGET_TMPL_BUTTONS_RPLALL,
+	TRW_WIDGET_TMPL_BUTTON_FLUFF,
+	TRW_WIDGET_TMPL_BUTTONS_EDIT_RIGHTPANEL,
+
+	TRW_WIDGET_TITLE_INFO_GROUP,
+	TRW_WIDGET_TITLE_INFO_TEMPLATE,
+
+	TRW_WIDGET_INFO_GROUP,
+ 	TRW_WIDGET_INFO_TEMPLATE,
+
+	TRW_WIDGET_TMPL_BUTTONS_SPACER,
+
+	TRW_WIDGET_START,
+	TRW_WIDGET_TRAIN_FLUFF_LEFT,
+	TRW_WIDGET_TRAIN_RAILTYPE_DROPDOWN,
+	TRW_WIDGET_TRAIN_FLUFF_RIGHT,
+	TRW_WIDGET_STOP,
+
+	TRW_WIDGET_SEL_TMPL_DISPLAY_CREATE,
+};
+
+
+static const NWidgetPart _widgets[] = {
+	// Title bar
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
+		NWidget(WWT_CAPTION, COLOUR_GREY, TRW_CAPTION), SetDataTip(STR_TMPL_RPL_TITLE, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_SHADEBOX, COLOUR_GREY),
+		NWidget(WWT_STICKYBOX, COLOUR_GREY),
+	EndContainer(),
+	//Top Matrix
+	NWidget(NWID_VERTICAL),
+		NWidget(WWT_INSET, COLOUR_GREY, TRW_WIDGET_INSET_GROUPS), SetMinimalSize(216,12), SetDataTip(STR_TMPL_MAINGUI_DEFINEDGROUPS, STR_TMPL_MAINGUI_DEFINEDGROUPS), SetResize(1, 0), EndContainer(),
+		NWidget(NWID_HORIZONTAL),
+			NWidget(WWT_MATRIX, COLOUR_GREY, TRW_WIDGET_TOP_MATRIX), SetMinimalSize(216, 0), SetFill(1, 1), SetDataTip(0x1, STR_REPLACE_HELP_LEFT_ARRAY), SetResize(1, 0), SetScrollbar(TRW_WIDGET_TOP_SCROLLBAR),
+			NWidget(NWID_VSCROLLBAR, COLOUR_GREY, TRW_WIDGET_TOP_SCROLLBAR),
+		EndContainer(),
+	EndContainer(),
+	// Template Display
+	NWidget(NWID_VERTICAL),
+		NWidget(WWT_INSET, COLOUR_GREY, TRW_WIDGET_INSET_TEMPLATES), SetMinimalSize(216,12), SetDataTip(STR_TMPL_AVAILABLE_TEMPLATES, STR_TMPL_AVAILABLE_TEMPLATES), SetResize(1, 0), EndContainer(),
+		NWidget(NWID_HORIZONTAL),
+			NWidget(WWT_MATRIX, COLOUR_GREY, TRW_WIDGET_BOTTOM_MATRIX), SetMinimalSize(216, 0), SetFill(1, 1), SetDataTip(0x1, STR_REPLACE_HELP_RIGHT_ARRAY), SetResize(1, 1), SetScrollbar(TRW_WIDGET_BOTTOM_SCROLLBAR),
+			NWidget(NWID_VSCROLLBAR, COLOUR_GREY, TRW_WIDGET_BOTTOM_SCROLLBAR),
+		EndContainer(),
+	EndContainer(),
+	// Info Area
+	NWidget(NWID_VERTICAL),
+		NWidget(WWT_INSET, COLOUR_GREY, TRW_WIDGET_TMPL_INFO_INSET), SetMinimalSize(216,12), SetResize(1,0), SetDataTip(STR_TMPL_AVAILABLE_TEMPLATES, STR_TMPL_AVAILABLE_TEMPLATES), EndContainer(),
+		NWidget(WWT_PANEL, COLOUR_GREY, TRW_WIDGET_TMPL_INFO_PANEL), SetMinimalSize(216,50), SetResize(1,0), EndContainer(),
+	EndContainer(),
+	// Control Area
+	NWidget(NWID_VERTICAL),
+		// Spacing
+		NWidget(WWT_INSET, COLOUR_GREY, TRW_WIDGET_TMPL_PRE_BUTTON_FLUFF), SetMinimalSize(139, 12), SetResize(1,0), EndContainer(),
+		// Config buttons
+		NWidget(NWID_HORIZONTAL),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TRW_WIDGET_TMPL_BUTTONS_CONFIGTMPL_REUSE), SetMinimalSize(150,12), SetResize(0,0), SetDataTip(STR_TMPL_SET_USEDEPOT, STR_TMPL_SET_USEDEPOT_TIP),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TRW_WIDGET_TMPL_BUTTONS_CONFIGTMPL_KEEP), SetMinimalSize(150,12), SetResize(0,0), SetDataTip(STR_TMPL_SET_KEEPREMAINDERS, STR_TMPL_SET_KEEPREMAINDERS_TIP),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TRW_WIDGET_TMPL_BUTTONS_CONFIGTMPL_REFIT), SetMinimalSize(150,12), SetResize(0,0), SetDataTip(STR_TMPL_SET_REFIT, STR_TMPL_SET_REFIT_TIP),
+			NWidget(WWT_PANEL, COLOUR_GREY, TRW_WIDGET_TMPL_BUTTONS_CONFIG_RIGHTPANEL), SetMinimalSize(12,12), SetResize(1,0), EndContainer(),
+		EndContainer(),
+		// Edit buttons
+		NWidget(NWID_HORIZONTAL),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TRW_WIDGET_TMPL_BUTTONS_DEFINE), SetMinimalSize(75,12), SetResize(0,0), SetDataTip(STR_TMPL_DEFINE_TEMPLATE, STR_REPLACE_ENGINE_WAGON_SELECT_HELP),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TRW_WIDGET_TMPL_BUTTONS_EDIT), SetMinimalSize(75,12), SetResize(0,0), SetDataTip(STR_TMPL_EDIT_TEMPLATE, STR_REPLACE_ENGINE_WAGON_SELECT_HELP),
+			NWidget(WWT_TEXTBTN, COLOUR_GREY, TRW_WIDGET_TMPL_BUTTONS_CLONE), SetMinimalSize(75,12), SetResize(0,0), SetDataTip(STR_TMPL_CREATE_CLONE_VEH, STR_REPLACE_ENGINE_WAGON_SELECT_HELP),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TRW_WIDGET_TMPL_BUTTONS_DELETE), SetMinimalSize(75,12), SetResize(0,0), SetDataTip(STR_TMPL_DELETE_TEMPLATE, STR_REPLACE_ENGINE_WAGON_SELECT_HELP),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TRW_WIDGET_TMPL_BUTTONS_RPLALL), SetMinimalSize(150,12), SetResize(0,0), SetDataTip(STR_TMPL_RPL_ALL_TMPL, STR_REPLACE_ENGINE_WAGON_SELECT_HELP),
+			NWidget(WWT_PANEL, COLOUR_GREY, TRW_WIDGET_TMPL_BUTTONS_EDIT_RIGHTPANEL), SetMinimalSize(50,12), SetResize(1,0), EndContainer(),
+		EndContainer(),
+	EndContainer(),
+	// Start/Stop buttons
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TRW_WIDGET_START), SetMinimalSize(150, 12), SetDataTip(STR_TMPL_RPL_START, STR_REPLACE_ENGINE_WAGON_SELECT_HELP),
+		NWidget(WWT_PANEL, COLOUR_GREY, TRW_WIDGET_TRAIN_FLUFF_LEFT), SetMinimalSize(15, 12), EndContainer(),
+		NWidget(WWT_DROPDOWN, COLOUR_GREY, TRW_WIDGET_TRAIN_RAILTYPE_DROPDOWN), SetMinimalSize(150, 12), SetDataTip(0x0, STR_REPLACE_HELP_RAILTYPE), SetResize(1, 0),
+		NWidget(WWT_PANEL, COLOUR_GREY, TRW_WIDGET_TRAIN_FLUFF_RIGHT), SetMinimalSize(16, 12), EndContainer(),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TRW_WIDGET_STOP), SetMinimalSize(150, 12), SetDataTip(STR_TMPL_RPL_STOP, STR_REPLACE_REMOVE_WAGON_HELP),
+		NWidget(WWT_RESIZEBOX, COLOUR_GREY),
+	EndContainer(),
+};
+
+static const WindowDesc _replace_rail_vehicle_desc(
+	WDP_AUTO, 456, 156,
+	WC_TEMPLATEGUI_MAIN, WC_NONE,					// TODO change wc_replace_vehicle
+	WDF_CONSTRUCTION,
+	_widgets, lengthof(_widgets)
+);
+
+class TemplateReplaceWindow : public Window {
+private:
+
+	GUIGroupList groups;  		 ///< List of groups
+	byte unitnumber_digits;
+	//Own
+	short line_height;
+	short matrixContentLeftMargin;
+
+	// from AutoreplaceGUI
+	int details_height;           ///< Minimal needed height of the details panels (found so far).
+	RailType sel_railtype;        ///< Type of rail tracks selected.
+	Scrollbar *vscroll[2];
+	// listing/sorting continued
+	GUITemplateList templates;
+	GUITemplateList::SortFunction **template_sorter_funcs;
+
+	short selected_template_index;
+	short selected_group_index;
+
+	bool templateNotice;
+	bool editInProgress;
+
+public:
+	TemplateReplaceWindow(const WindowDesc *wdesc, byte dig, int step_h) : Window()
+	{
+		// listing/sorting
+		templates.SetSortFuncs(this->template_sorter_funcs);
+
+		// From BaseVehicleListWindow
+		this->unitnumber_digits = dig;
+
+		// from AutoreplaceGUI
+		this->sel_railtype = RAILTYPE_BEGIN;
+		this->details_height   = 10 * FONT_HEIGHT_NORMAL + WD_FRAMERECT_TOP + WD_FRAMERECT_BOTTOM;
+
+		this->line_height = step_h;
+
+		this->CreateNestedTree(wdesc);
+		this->vscroll[0] = this->GetScrollbar(TRW_WIDGET_TOP_SCROLLBAR);
+		this->vscroll[1] = this->GetScrollbar(TRW_WIDGET_BOTTOM_SCROLLBAR);
+		this->vscroll[0]->SetStepSize(step_h / 2);
+		this->vscroll[1]->SetStepSize(step_h);
+		this->FinishInitNested(wdesc, VEH_TRAIN);
+
+		this->owner = _local_company;
+
+// 		this->groups = new GUIGroupList();
+		this->groups.ForceRebuild();
+		this->groups.NeedResort();
+ 		this->BuildGroupList(_local_company);
+		this->groups.Sort(&GroupNameSorter);
+
+
+		this->matrixContentLeftMargin = 40;
+		this->selected_template_index = -1;
+		this->selected_group_index = -1;
+
+		this->templateNotice = false;
+		this->editInProgress = false;
+
+		this->templates.ForceRebuild();
+
+		BuildTemplateGuiList(&this->templates, this->vscroll[1], this->owner, this->sel_railtype);
+
+		//CmdBuildVirtualRailVehicle(20);
+	}
+
+	~TemplateReplaceWindow() {
+		DeleteWindowById(WC_CREATE_TEMPLATE, this->window_number);
+	}
+
+	virtual void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize)
+	{
+		switch (widget) {
+			case TRW_WIDGET_TOP_MATRIX:
+				resize->height = GetVehicleListHeight(VEH_TRAIN, FONT_HEIGHT_NORMAL + WD_MATRIX_TOP) / 2;
+				size->height = 8 * resize->height;
+				break;
+			case TRW_WIDGET_BOTTOM_MATRIX:
+				resize->height = GetVehicleListHeight(VEH_TRAIN, FONT_HEIGHT_NORMAL + WD_MATRIX_TOP);
+				size->height = 4 * resize->height;
+				break;
+			case TRW_WIDGET_TRAIN_RAILTYPE_DROPDOWN: {
+				Dimension d = {0, 0};
+				for (RailType rt = RAILTYPE_BEGIN; rt != RAILTYPE_END; rt++) {
+					const RailtypeInfo *rti = GetRailTypeInfo(rt);
+					// Skip rail type if it has no label
+					if (rti->label == 0) continue;
+					d = maxdim(d, GetStringBoundingBox(rti->strings.replace_text));
+				}
+				d.width += padding.width;
+				d.height += padding.height;
+				*size = maxdim(*size, d);
+				break;
+			}
+		}
+	}
+
+	virtual void SetStringParameters(int widget) const
+	{
+		switch (widget) {
+			// TODO: rm
+			case TRW_CAPTION:
+				SetDParam(0, STR_REPLACE_VEHICLE_TRAIN + this->window_number);
+				break;
+		}
+	}
+
+	virtual void DrawWidget(const Rect &r, int widget) const
+	{
+		// TODO: why -1 ??
+		deleteIllegalTemplateReplacements(-1);
+
+		switch (widget) {
+			case TRW_WIDGET_TOP_MATRIX: {
+				DrawAllGroupsFunction(this->line_height, r);
+				break;
+			}
+			case TRW_WIDGET_BOTTOM_MATRIX: {
+				DrawTemplateList(this->line_height, r);
+				break;
+			}
+			case TRW_WIDGET_TMPL_INFO_PANEL: {
+				DrawTemplateInfo(this->line_height, r);
+				break;
+			}
+		}
+	}
+
+	virtual void OnPaint()
+	{
+		// TODO: only temporary because of allreplacement
+		BuildTemplateGuiList(&this->templates, this->vscroll[1], this->owner, this->sel_railtype);
+
+		this->BuildGroupList(_local_company);
+		this->groups.Sort(&GroupNameSorter);
+
+		if ( templateNotice ) {
+			BuildTemplateGuiList(&this->templates, vscroll[1], _local_company, this->sel_railtype);
+			templateNotice = false;
+			this->SetDirty();
+		}
+		// TODO: rm if ?
+		if (this->window_number == VEH_TRAIN) {
+			/* sets the colour of that art thing */
+			// TODO: use stored company for colors
+			this->GetWidget<NWidgetCore>(TRW_WIDGET_TRAIN_FLUFF_LEFT)->colour  = _company_colours[_local_company];
+			this->GetWidget<NWidgetCore>(TRW_WIDGET_TRAIN_FLUFF_RIGHT)->colour = _company_colours[_local_company];
+
+			/* Show the selected railtype in the pulldown menu */
+			this->GetWidget<NWidgetCore>(TRW_WIDGET_TRAIN_RAILTYPE_DROPDOWN)->widget_data = GetRailTypeInfo(sel_railtype)->strings.replace_text;
+		}
+		this->DrawWidgets();
+	}
+
+	virtual void OnClick(Point pt, int widget, int click_count)
+	{
+		if ( this->editInProgress ) return;
+
+		switch (widget) {
+			case TRW_WIDGET_TMPL_BUTTONS_CONFIGTMPL_REUSE: {
+				if ( this->selected_template_index >= 0 ) {
+					//TemplateVehicle *sel = (TemplateVehicle*)(this->templates)[selected_template_index];
+					//const TemplateVehicle* ctv = ;
+					TemplateVehicle *sel = TemplateVehicle::Get(((this->templates)[selected_template_index])->index);
+					sel->ToggleReuseDepotVehicles();
+				}
+				break;
+			}
+			case TRW_WIDGET_TMPL_BUTTONS_CONFIGTMPL_KEEP: {
+				if ( this->selected_template_index >= 0 ) {
+					//TemplateVehicle *sel = (TemplateVehicle*)(this->templates)[selected_template_index];
+					TemplateVehicle *sel = TemplateVehicle::Get(((this->templates)[selected_template_index])->index);
+					sel->ToggleKeepRemainingVehicles();
+				}
+				break;
+			}
+			case TRW_WIDGET_TMPL_BUTTONS_CONFIGTMPL_REFIT: {
+				if ( this->selected_template_index >= 0 ) {
+					//TemplateVehicle *sel = (TemplateVehicle*)(this->templates)[selected_template_index];
+					TemplateVehicle *sel = TemplateVehicle::Get(((this->templates)[selected_template_index])->index);
+					sel->ToggleRefitAsTemplate();
+				}
+				break;
+			}
+			case TRW_WIDGET_TMPL_BUTTONS_DEFINE:
+				ShowTemplateCreateWindow(0, &templateNotice, &editInProgress, this->line_height);
+				break;
+			case TRW_WIDGET_TMPL_BUTTONS_EDIT: {
+				if ( this->selected_template_index >= 0 ) {
+					editInProgress = true;
+					TemplateVehicle *sel = TemplateVehicle::Get(((this->templates)[selected_template_index])->index);
+					ShowTemplateCreateWindow(sel, &templateNotice, &editInProgress, this->line_height);
+				}
+				break;
+			}
+			case TRW_WIDGET_TMPL_BUTTONS_CLONE: {
+				this->SetWidgetDirty(TRW_WIDGET_TMPL_BUTTONS_CLONE);
+				this->ToggleWidgetLoweredState(TRW_WIDGET_TMPL_BUTTONS_CLONE);
+
+				if (this->IsWidgetLowered(TRW_WIDGET_TMPL_BUTTONS_CLONE)) {
+					static const CursorID clone_icon =	SPR_CURSOR_CLONE_TRAIN;
+					SetObjectToPlaceWnd(clone_icon, PAL_NONE, HT_VEHICLE, this);
+				} else {
+					ResetObjectToPlace();
+				}
+				break;
+			}
+			case TRW_WIDGET_TMPL_BUTTONS_DELETE:
+				if ( selected_template_index >= 0 && !editInProgress ) {
+					// identify template to delete
+					TemplateVehicle *del = TemplateVehicle::Get(((this->templates)[selected_template_index])->index);
+					// remove a corresponding template replacement if existing
+					TemplateReplacement *tr = GetTemplateReplacementByTemplateID(del->index);
+					if ( tr ) {
+						delete tr;
+					}
+					delete del;
+					BuildTemplateGuiList(&this->templates, this->vscroll[1], this->owner, this->sel_railtype);
+					selected_template_index = -1;
+				}
+				break;
+			case TRW_WIDGET_TMPL_BUTTONS_RPLALL: {
+				ShowTemplateReplaceAllGui();
+				//testfunc();
+				break;
+			}
+			case TRW_WIDGET_TRAIN_RAILTYPE_DROPDOWN: // Railtype selection dropdown menu
+				ShowDropDownList(this, GetRailTypeDropDownList(true), sel_railtype, TRW_WIDGET_TRAIN_RAILTYPE_DROPDOWN);
+				break;
+			case TRW_WIDGET_TOP_MATRIX: {
+ 				uint16 newindex = (uint16)((pt.y - this->nested_array[TRW_WIDGET_TOP_MATRIX]->pos_y) / (this->line_height/2) ) + this->vscroll[0]->GetPosition();
+				if ( newindex == this->selected_group_index || newindex >= this->groups.Length() ) {
+					this->selected_group_index = -1;
+				}
+				else if ( newindex < this->groups.Length() ) {
+					this->selected_group_index = newindex;
+				}
+				break;
+			}
+			case TRW_WIDGET_BOTTOM_MATRIX: {
+ 				uint16 newindex = (uint16)((pt.y - this->nested_array[TRW_WIDGET_BOTTOM_MATRIX]->pos_y) / this->line_height) + this->vscroll[1]->GetPosition();
+				if ( newindex == this->selected_template_index || newindex >= templates.Length() ) {
+					this->selected_template_index = -1;
+				}
+				else if ( newindex < templates.Length() ) {
+					this->selected_template_index = newindex;
+				}
+				break;
+			}
+			// TODO: start button dependent on selected template ?
+			case TRW_WIDGET_START: {
+				if ( this->selected_template_index >= 0 && this->selected_group_index >= 0) {
+					uint32 tv_index = ((this->templates)[selected_template_index])->index;
+					int current_group_index = (this->groups)[this->selected_group_index]->index;
+					IssueTemplateReplacement(current_group_index, tv_index);
+				}
+				break;
+			}
+			case TRW_WIDGET_STOP:
+				if ( this->selected_group_index == -1 )
+					return;
+				int current_group_index = (this->groups)[this->selected_group_index]->index;
+				TemplateReplacement *tr = GetTemplateReplacementByGroupID(current_group_index);
+				if ( tr )
+					delete tr;
+				break;
+		}
+		this->SetDirty();
+	}
+
+	virtual bool OnVehicleSelect(const Vehicle *v)
+	{
+		// create a new template from the clicked vehicle
+		TemplateVehicle *tv = CloneTemplateVehicleFromTrain((const Train*)v);
+		if ( !tv )	return false;
+
+		BuildTemplateGuiList(&this->templates, vscroll[1], _local_company, this->sel_railtype);
+		this->ToggleWidgetLoweredState(TRW_WIDGET_TMPL_BUTTONS_CLONE);
+		ResetObjectToPlace();
+		this->SetDirty();
+
+		return true;
+	}
+
+	virtual void OnDropdownSelect(int widget, int index)
+	{
+		RailType temp = (RailType)index;
+		if (temp == this->sel_railtype) return; // we didn't select a new one. No need to change anything
+		this->sel_railtype = temp;
+		/* Reset scrollbar positions */
+		this->vscroll[0]->SetPosition(0);
+		this->vscroll[1]->SetPosition(0);
+		BuildTemplateGuiList(&this->templates, this->vscroll[1], this->owner, this->sel_railtype);
+		this->SetDirty();
+	}
+
+	virtual void OnResize()
+	{
+		/* Top Matrix */
+		NWidgetCore *nwi = this->GetWidget<NWidgetCore>(TRW_WIDGET_TOP_MATRIX);
+		this->vscroll[0]->SetCapacityFromWidget(this, TRW_WIDGET_TOP_MATRIX);
+		nwi->widget_data = (this->vscroll[0]->GetCapacity() << MAT_ROW_START) + (1 << MAT_COL_START);
+		/* Bottom Matrix */
+		NWidgetCore *nwi2 = this->GetWidget<NWidgetCore>(TRW_WIDGET_BOTTOM_MATRIX);
+		this->vscroll[1]->SetCapacityFromWidget(this, TRW_WIDGET_BOTTOM_MATRIX);
+		nwi2->widget_data = (this->vscroll[1]->GetCapacity() << MAT_ROW_START) + (1 << MAT_COL_START);
+	}
+
+	virtual void OnTick()
+	{
+		if ( templateNotice ) {
+			BuildTemplateGuiList(&this->templates, this->vscroll[1], this->owner, this->sel_railtype);
+			this->SetDirty();
+			templateNotice = false;
+		}
+
+	}
+
+	virtual void OnInvalidateData(int data = 0, bool gui_scope = true)
+	{
+		this->groups.ForceRebuild();
+		this->templates.ForceRebuild();
+	}
+	void testfunc() {
+		// replace 764 by 775
+		TemplateVehicle *tmp = (TemplateVehicle*)this->templates[1];
+		Train *t = VirtualTrainFromTemplateVehicle(tmp);
+
+		for ( Train *tt = t; tt; ) {
+			if ( tt->engine_type == 764 ) {
+				Train *n = CmdBuildVirtualRailVehicle(775);
+				// move new after old
+				CommandCost cost = CmdMoveRailVehicle(0, DC_EXEC, n->index | (1<<21), tt->index, 0);
+				// move old away
+				CommandCost cost2 = CmdMoveRailVehicle(0, DC_EXEC, tt->index | (1<<21), INVALID_VEHICLE, 0);
+				tt = n;
+			}
+			else
+				tt = tt->GetNextUnit();
+		}
+
+		delete tmp;
+		TemplateVehicle *ntv = TemplateVehicleFromVirtualTrain(t);
+		BuildTemplateGuiList(&this->templates, this->vscroll[1], this->owner, this->sel_railtype);
+		this->SetDirty();
+
+		printf("finished\n");
+
+	}
+	/** For a given group (id) find the template that is issued for template replacement for this group and return this template's index
+	 *  from the gui list */
+	short FindTemplateIndexForGroup(short gid) const
+	{
+		TemplateReplacement *tr = GetTemplateReplacementByGroupID(gid);
+		if ( !tr )
+			return -1;
+
+		for ( uint32 i=0; i<this->templates.Length(); i++ )
+			if ( templates[i]->index == tr->sel_template )
+				return i;
+		return -1;
+	}
+
+		/** Sort the groups by their name */
+	static int CDECL GroupNameSorter(const Group * const *a, const Group * const *b)
+	{
+		static const Group *last_group[2] = { NULL, NULL };
+		static char         last_name[2][64] = { "", "" };
+
+		if (*a != last_group[0]) {
+			last_group[0] = *a;
+			SetDParam(0, (*a)->index);
+			GetString(last_name[0], STR_GROUP_NAME, lastof(last_name[0]));
+		}
+
+		if (*b != last_group[1]) {
+			last_group[1] = *b;
+			SetDParam(0, (*b)->index);
+			GetString(last_name[1], STR_GROUP_NAME, lastof(last_name[1]));
+		}
+
+		int r = strnatcmp(last_name[0], last_name[1]); // Sort by name (natural sorting).
+		if (r == 0) return (*a)->index - (*b)->index;
+		return r;
+	}
+
+	void BuildGroupList(Owner owner)
+	{
+		if (!this->groups.NeedRebuild()) {
+			return;
+		}
+		this->groups.Clear();
+
+		const Group *g;
+		FOR_ALL_GROUPS(g) {
+			if (g->owner == owner ) {
+				*this->groups.Append() = g;
+			}
+		}
+
+		this->groups.Compact();
+		this->groups.RebuildDone();
+		this->vscroll[0]->SetCount(groups.Length());
+	}
+
+	void DrawAllGroupsFunction(int line_height, const Rect &r) const
+	{
+		int left = r.left + WD_MATRIX_LEFT;
+		int right = r.right - WD_MATRIX_RIGHT;
+		int y = r.top;
+		int max = min(this->vscroll[0]->GetPosition() + this->vscroll[0]->GetCapacity(), this->groups.Length());
+
+		/* Then treat all groups defined by/for the current company */
+		for ( int i=this->vscroll[0]->GetPosition(); i<max; i++ ) {
+			const Group *g = (this->groups)[i];
+			short g_id = g->index;
+
+			/* Fill the background of the current cell in a darker tone for the currently selected template */
+			if ( this->selected_group_index == i ) {
+				GfxFillRect(left, y, right, y+(this->line_height)/2, _colour_gradient[COLOUR_GREY][3]);
+			}
+
+			SetDParam(0, g_id);
+			StringID str = STR_GROUP_NAME;
+			DrawString(left+30, right, y+2, str, TC_BLACK);
+
+			/* Draw the template in use for this group, if there is one */
+			short template_in_use = FindTemplateIndexForGroup(g_id);
+			if ( template_in_use >= 0 ) {
+				SetDParam(0, template_in_use);
+				DrawString ( left, right, y+2, STR_TMPL_GROUP_USES_TEMPLATE, TC_BLACK, SA_HOR_CENTER);
+			}
+			/* If there isn't a template applied from the current group, check if there is one for another rail type */
+			else if ( GetTemplateReplacementByGroupID(g_id) ) {
+				DrawString ( left, right, y+2, STR_TMPL_TMPLRPL_EX_DIFF_RAILTYPE, TC_SILVER, SA_HOR_CENTER);
+			}
+
+			/* Draw the number of trains that still need to be treated by the currently selected template replacement */
+			TemplateReplacement *tr = GetTemplateReplacementByGroupID(g_id);
+			if ( tr ) {
+				TemplateVehicle *tv = TemplateVehicle::Get(tr->sel_template);
+				int num_trains = NumTrainsNeedTemplateReplacement(g_id, tv);
+				// Draw text
+				TextColour color = TC_GREY;
+				if ( num_trains ) color = TC_BLACK;
+				DrawString(left, right-16, y+2, STR_TMPL_NUM_TRAINS_NEED_RPL, color, SA_RIGHT);
+				// Draw number
+				if ( num_trains ) color = TC_ORANGE;
+				else color = TC_GREY;
+				SetDParam(0, num_trains);
+				DrawString(left, right-4, y+2, STR_JUST_INT, color, SA_RIGHT);
+			}
+
+			y+=line_height / 2;
+		}
+	}
+
+	void DrawTemplateList(int line_height, const Rect &r) const
+	{
+		int left = r.left;
+		int right = r.right;
+		int y = r.top;
+
+		Scrollbar *draw_vscroll = vscroll[1];
+		uint max = min(draw_vscroll->GetPosition() + draw_vscroll->GetCapacity(), this->templates.Length());
+
+		const TemplateVehicle *v;
+		for ( uint i = draw_vscroll->GetPosition(); i < max; ++i) {
+
+			v = (this->templates)[i];
+
+			/* Fill the background of the current cell in a darker tone for the currently selected template */
+			if ( this->selected_template_index == i ) {
+				GfxFillRect(left, y, right, y+this->line_height, _colour_gradient[COLOUR_GREY][3]);
+			}
+
+			/* Draw a notification string for chains that are not runnable */
+			if ( v->IsFreeWagonChain() ) {
+				DrawString(left, right-2, y+line_height-FONT_HEIGHT_SMALL-WD_FRAMERECT_BOTTOM - 2, STR_TMPL_WARNING_FREE_WAGON, TC_RED, SA_RIGHT);
+			}
+
+			/* Draw the template's length in tile-units */
+			SetDParam(0, v->GetRealLength());
+			SetDParam(1, 1);
+			DrawString(left, right-4, y+2, STR_TINY_BLACK_DECIMAL, TC_BLACK, SA_RIGHT);
+
+			/* Draw the template */
+			DrawTemplate(v, left+50, right, y);
+
+			/* Buying cost */
+			SetDParam(0, CalculateOverallTemplateCost(v));
+			DrawString(left+35, right, y + line_height - FONT_HEIGHT_SMALL - WD_FRAMERECT_BOTTOM - 2, STR_TMPL_TEMPLATE_OVR_VALUE_notinyfont, TC_BLUE, SA_LEFT);
+
+			/* Index of current template vehicle in the list of all templates for its company */
+			SetDParam(0, i);
+			DrawString(left+5, left+25, y + line_height/2, STR_BLACK_INT, TC_BLACK, SA_RIGHT);
+
+			/* Draw whether the current template is in use by any group */
+			if ( v->NumGroupsUsingTemplate() > 0 ) {
+				DrawString(left+200, right, y + line_height - FONT_HEIGHT_SMALL - WD_FRAMERECT_BOTTOM - 2, STR_TMP_TEMPLATE_IN_USE, TC_GREEN, SA_LEFT);
+			}
+
+			/* Draw information about template configuration settings */
+			TextColour color;
+			if ( v->IsSetReuseDepotVehicles() ) color = TC_LIGHT_BLUE;
+			else color = TC_GREY;
+			DrawString(left+200, right, y+2, STR_TMPL_CONFIG_USEDEPOT, color, SA_LEFT);
+			if ( v->IsSetKeepRemainingVehicles() ) color = TC_LIGHT_BLUE;
+			else color = TC_GREY;
+			DrawString(left+275, right, y+2, STR_TMPL_CONFIG_KEEPREMAINDERS, color, SA_LEFT);
+			if ( v->IsSetRefitAsTemplate() ) color = TC_LIGHT_BLUE;
+			else color = TC_GREY;
+			DrawString(left+350, right, y+2, STR_TMPL_CONFIG_REFIT, color, SA_LEFT);
+
+			y += line_height;
+		}
+	}
+
+	void DrawTemplateInfo(int line_height, const Rect &r) const
+	{
+		if ( this->selected_template_index == -1 || (short)this->templates.Length() <= this->selected_template_index )
+			return;
+
+		const TemplateVehicle *tmp = this->templates[this->selected_template_index];
+
+		/* Draw vehicle performance info */
+		SetDParam(2, tmp->max_speed);
+		SetDParam(1, tmp->power);
+		SetDParam(0, tmp->weight);
+		SetDParam(3, tmp->max_te);
+		DrawString(r.left+8, r.right, r.top+4, STR_VEHICLE_INFO_WEIGHT_POWER_MAX_SPEED_MAX_TE);
+
+		/* Draw cargo summary */
+		short top = r.top + 24;
+		short left = r.left + 8;
+		short count_rows = 0;
+		short max_rows = 2;
+
+		CargoArray cargo_caps;
+		for ( ; tmp; tmp=tmp->Next() )
+			cargo_caps[tmp->cargo_type] += tmp->cargo_cap;
+		int y = top;
+		for (CargoID i = 0; i < NUM_CARGO; i++) {
+			if ( cargo_caps[i] > 0 ) {
+				count_rows++;
+				SetDParam(0, i);
+				SetDParam(1, cargo_caps[i]);
+				SetDParam(2, _settings_game.vehicle.freight_trains);
+				DrawString(left, r.right, y, FreightWagonMult(i) > 1 ? STR_TMPL_CARGO_SUMMARY_MULTI : STR_TMPL_CARGO_SUMMARY, TC_WHITE, SA_LEFT);
+				y += this->line_height/2;
+				if ( count_rows % max_rows == 0 ) {
+					y = top;
+					left += 150;
+				}
+			}
+		}
+	}
+};
+
+void ShowTemplateReplaceWindow(byte dig, int step_h)
+{
+
+	new TemplateReplaceWindow(&_replace_rail_vehicle_desc, dig, step_h);
+}
+
diff -urNad openttd-1.3.2/src/aaa_template_gui_main.h openttd-1.3.2-DC3.0RC3/src/aaa_template_gui_main.h
--- openttd-1.3.2/src/aaa_template_gui_main.h	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/aaa_template_gui_main.h	2013-11-22 05:49:06.000000000 +0100
@@ -0,0 +1,20 @@
+// _template_gui_main.h
+
+#ifndef TEMPLATE_GUI_H
+#define TEMPLATE_GUI_H
+
+#include "engine_type.h"
+#include "group_type.h"
+#include "vehicle_type.h"
+#include "string_func.h"
+#include "strings_func.h"
+
+#include "aaa_template_vehicle.h"
+#include "aaa_template_vehicle_func.h"
+#include "aaa_template_gui_replaceall.h"
+
+typedef GUIList<const Group*> GUIGroupList;
+
+void ShowTemplateReplaceWindow(byte, int);
+
+#endif
diff -urNad openttd-1.3.2/src/aaa_template_gui_replaceall.cpp openttd-1.3.2-DC3.0RC3/src/aaa_template_gui_replaceall.cpp
--- openttd-1.3.2/src/aaa_template_gui_replaceall.cpp	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/aaa_template_gui_replaceall.cpp	2013-11-22 05:49:06.000000000 +0100
@@ -0,0 +1,519 @@
+// replace all gui impl
+
+#include "aaa_template_gui_replaceall.h"
+
+#include <stdio.h>
+
+/*
+ * A wrapper which contains a virtual train and additional info of the template vehicle it is replacing
+ * We will restore this additional info when creating a new template from the changed virtual train
+ */
+struct VirtTrainInfo {
+	// the virtual train
+	Train *vt;
+
+	// additional info from the template
+	VehicleID original_index;
+
+	bool	reuse_depot_vehicles,
+			keep_remaining_vehicles,
+			refit_as_template;
+
+	CargoID cargo_type;
+	byte cargo_subtype;
+
+	// a fancy constructor
+	VirtTrainInfo(Train *t) { this->vt = t; }
+};
+
+typedef AutoFreeSmallVector<VirtTrainInfo*, 64> VirtTrainList;
+enum Widgets {
+	RPLALL_GUI_CAPTION,
+
+	RPLALL_GUI_INSET_1,
+	RPLALL_GUI_INSET_1_1,
+	RPLALL_GUI_INSET_1_2,
+	RPLALL_GUI_MATRIX_TOPLEFT,
+	RPLALL_GUI_MATRIX_TOPRIGHT,
+	RPLALL_GUI_SCROLL_TL,
+	RPLALL_GUI_SCROLL_TR,
+
+	RPLALL_GUI_INSET_2,
+	RPLALL_GUI_MATRIX_BOTTOM,
+	RPLALL_GUI_SCROLL_BO,
+
+	RPLALL_GUI_INSET_3,
+	RPLALL_GUI_BUTTON_RPLALL,
+	RPLALL_GUI_PANEL_BUTTONFLUFF_1,
+	RPLALL_GUI_PANEL_BUTTONFLUFF_2,
+	RPLALL_GUI_BUTTON_APPLY,
+	RPLALL_GUI_PANEL_BUTTONFLUFF_3,
+	RPLALL_GUI_BUTTON_CANCEL,
+
+	RPLALL_GUI_PANEL_RESIZEFLUFF
+};
+
+static const NWidgetPart widgets[] = {
+	// title bar
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
+		NWidget(WWT_CAPTION, COLOUR_GREY, RPLALL_GUI_CAPTION), SetDataTip(STR_TMPL_RPLALLGUI_TITLE, STR_TMPL_RPLALLGUI_TITLE),
+		NWidget(WWT_SHADEBOX, COLOUR_GREY),
+		NWidget(WWT_STICKYBOX, COLOUR_GREY),
+	EndContainer(),
+	// top matrices
+		NWidget(WWT_INSET, COLOUR_GREY, RPLALL_GUI_INSET_1), SetMinimalSize(100,12), SetResize(1,0), SetDataTip(STR_TMPL_RPLALLGUI_INSET_TOP, STR_TMPL_RPLALLGUI_INSET_TOP), EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(NWID_VERTICAL),
+			NWidget(WWT_INSET, COLOUR_GREY, RPLALL_GUI_INSET_1_1), SetMinimalSize(100,12), SetResize(1,0), SetDataTip(STR_TMPL_RPLALLGUI_INSET_TOP_1, STR_TMPL_RPLALLGUI_INSET_TOP_1), EndContainer(),
+			NWidget(NWID_HORIZONTAL),
+				NWidget(WWT_MATRIX, COLOUR_GREY, RPLALL_GUI_MATRIX_TOPLEFT), SetMinimalSize(100, 16), SetFill(1, 1), SetResize(1, 1), SetScrollbar(RPLALL_GUI_SCROLL_TL),// SetDataTip(0x1, STR_REPLACE_HELP_LEFT_ARRAY),
+				NWidget(NWID_VSCROLLBAR, COLOUR_GREY, RPLALL_GUI_SCROLL_TL),
+			EndContainer(),
+		EndContainer(),
+		NWidget(NWID_VERTICAL),
+			NWidget(WWT_INSET, COLOUR_GREY, RPLALL_GUI_INSET_1_2), SetMinimalSize(100,12), SetResize(1,0), SetDataTip(STR_TMPL_RPLALLGUI_INSET_TOP_2, STR_TMPL_RPLALLGUI_INSET_TOP_2), EndContainer(),
+			NWidget(NWID_HORIZONTAL),
+				NWidget(WWT_MATRIX, COLOUR_GREY, RPLALL_GUI_MATRIX_TOPRIGHT), SetMinimalSize(100, 16), SetFill(1, 1), SetResize(1, 1), SetScrollbar(RPLALL_GUI_SCROLL_TR),// SetDataTip(0x1, STR_REPLACE_HELP_LEFT_ARRAY),
+				NWidget(NWID_VSCROLLBAR, COLOUR_GREY, RPLALL_GUI_SCROLL_TR),
+			EndContainer(),
+		EndContainer(),
+	EndContainer(),
+	// bottom matrix
+	NWidget(WWT_INSET, COLOUR_GREY, RPLALL_GUI_INSET_2), SetMinimalSize(200,12), SetResize(1,0), SetDataTip(STR_TMPL_RPLALLGUI_INSET_BOTTOM, STR_TMPL_RPLALLGUI_INSET_BOTTOM), EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_MATRIX, COLOUR_GREY, RPLALL_GUI_MATRIX_BOTTOM), SetMinimalSize(200, 16), SetFill(1, 1), SetResize(1, 1), SetScrollbar(RPLALL_GUI_SCROLL_BO),// SetDataTip(0x1, STR_REPLACE_HELP_LEFT_ARRAY),
+		NWidget(NWID_VSCROLLBAR, COLOUR_GREY, RPLALL_GUI_SCROLL_BO),
+	EndContainer(),
+	// control area
+	NWidget(WWT_INSET, COLOUR_GREY, RPLALL_GUI_INSET_3), SetMinimalSize(200,12), SetResize(1,0), EndContainer(),// SetDataTip(STR_TMPL_MAINGUI_DEFINEDGROUPS, STR_TMPL_MAINGUI_DEFINEDGROUPS),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_PANEL, COLOUR_GREY, RPLALL_GUI_PANEL_BUTTONFLUFF_1), SetMinimalSize(75,12), SetResize(1,0), EndContainer(),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, RPLALL_GUI_BUTTON_RPLALL), SetMinimalSize(150,12), SetResize(0,0), SetDataTip(STR_TMPL_RPLALLGUI_BUTTON_RPLALL, STR_TMPL_RPLALLGUI_BUTTON_RPLALL),
+		NWidget(WWT_PANEL, COLOUR_GREY, RPLALL_GUI_PANEL_BUTTONFLUFF_2), SetMinimalSize(75,12), SetResize(1,0), EndContainer(),
+	EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, RPLALL_GUI_BUTTON_APPLY), SetMinimalSize(75,12), SetResize(1,0), SetDataTip(STR_TMPL_RPLALLGUI_BUTTON_APPLY, STR_TMPL_RPLALLGUI_BUTTON_APPLY),
+		NWidget(WWT_PANEL, COLOUR_GREY, RPLALL_GUI_PANEL_BUTTONFLUFF_3), SetMinimalSize(150,12), SetResize(0,0), EndContainer(),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, RPLALL_GUI_BUTTON_CANCEL), SetMinimalSize(75,12), SetResize(1,0), SetDataTip(STR_TMPL_RPLALLGUI_BUTTON_CANCEL, STR_TMPL_RPLALLGUI_BUTTON_CANCEL),
+	EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_PANEL, COLOUR_GREY, RPLALL_GUI_PANEL_RESIZEFLUFF), SetMinimalSize(100,12), SetResize(1,0), EndContainer(),
+		NWidget(WWT_RESIZEBOX, COLOUR_GREY),
+	EndContainer(),
+};
+
+static const WindowDesc _template_replace_replaceall_desc(
+	WDP_AUTO, 400, 200,
+	WC_TEMPLATEGUI_RPLALL, WC_NONE,
+	WDF_CONSTRUCTION,
+	widgets, lengthof(widgets)
+);
+
+static int CDECL EngineNumberSorter(const EngineID *a, const EngineID *b)
+{
+	int r = Engine::Get(*a)->list_position - Engine::Get(*b)->list_position;
+	return r;
+}
+static int CDECL TrainEnginesThenWagonsSorter(const EngineID *a, const EngineID *b)
+{
+	int val_a = (RailVehInfo(*a)->railveh_type == RAILVEH_WAGON ? 1 : 0);
+	int val_b = (RailVehInfo(*b)->railveh_type == RAILVEH_WAGON ? 1 : 0);
+	int r = val_a - val_b;
+
+	/* Use EngineID to sort instead since we want consistent sorting */
+	if (r == 0) return EngineNumberSorter(a, b);
+	return r;
+}
+
+
+class TemplateReplacementReplaceAllWindow : public Window {
+private:
+	uint16 line_height;
+	Scrollbar	*vscroll_tl,
+				*vscroll_tr,
+				*vscroll_bo;
+	GUIEngineList *engines_left,
+				  *engines_right;
+	short	selected_left,
+			selected_right;
+	VirtTrainList *virtualTrains;
+
+public:
+	TemplateReplacementReplaceAllWindow(const WindowDesc *wdesc) : Window()
+	{
+
+		this->CreateNestedTree(wdesc);
+
+		this->vscroll_tl = this->GetScrollbar(RPLALL_GUI_SCROLL_TL);
+		this->vscroll_tr = this->GetScrollbar(RPLALL_GUI_SCROLL_TR);
+		this->vscroll_bo = this->GetScrollbar(RPLALL_GUI_SCROLL_BO);
+		this->vscroll_tl->SetStepSize(16);
+		this->vscroll_tr->SetStepSize(16);
+		this->vscroll_bo->SetStepSize(16);
+
+		this->FinishInitNested(wdesc, VEH_TRAIN);
+
+		this->owner = _local_company;
+
+		engines_left = new GUIEngineList();
+		engines_right = new GUIEngineList();
+		virtualTrains = new VirtTrainList();
+
+		this->GenerateBuyableEnginesList();
+		this->GenerateIncludedTemplateList();
+
+		this->line_height = 16;
+		this->selected_left = -1;
+		this->selected_right = -1;
+	}
+
+	~TemplateReplacementReplaceAllWindow()
+	{
+		for ( int i=0; i<this->virtualTrains->Length(); i++ )
+			delete (*this->virtualTrains)[i]->vt;
+		SetWindowClassesDirty(WC_TEMPLATEGUI_MAIN);
+	}
+
+	virtual void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize)
+	{
+		switch ( widget ) {
+			case RPLALL_GUI_MATRIX_TOPLEFT:
+			case RPLALL_GUI_MATRIX_TOPRIGHT:
+			case RPLALL_GUI_MATRIX_BOTTOM: {
+				resize->height = 16;
+				size->height = 16;
+				break;
+			}
+		}
+	}
+
+	virtual void OnPaint()
+	{
+ 		this->GetWidget<NWidgetCore>(RPLALL_GUI_PANEL_BUTTONFLUFF_3)->colour  = _company_colours[_local_company];
+
+		this->DrawWidgets();
+	}
+
+	virtual void OnResize()
+	{
+		NWidgetCore *nwi_tl = this->GetWidget<NWidgetCore>(RPLALL_GUI_MATRIX_TOPLEFT);
+		this->vscroll_tl->SetCapacityFromWidget(this, RPLALL_GUI_MATRIX_TOPLEFT);
+		nwi_tl->widget_data = (this->vscroll_tl->GetCapacity() << MAT_ROW_START) + (1 << MAT_COL_START);
+
+		NWidgetCore *nwi_tr = this->GetWidget<NWidgetCore>(RPLALL_GUI_MATRIX_TOPRIGHT);
+		this->vscroll_tr->SetCapacityFromWidget(this, RPLALL_GUI_MATRIX_TOPRIGHT);
+		nwi_tr->widget_data = (this->vscroll_tr->GetCapacity() << MAT_ROW_START) + (1 << MAT_COL_START);
+
+		NWidgetCore *nwi_bo = this->GetWidget<NWidgetCore>(RPLALL_GUI_MATRIX_BOTTOM);
+		this->vscroll_bo->SetCapacityFromWidget(this, RPLALL_GUI_MATRIX_BOTTOM);
+		nwi_bo->widget_data = (this->vscroll_bo->GetCapacity() << MAT_ROW_START) + (1 << MAT_COL_START);
+	}
+
+	virtual void DrawWidget(const Rect &r, int widget) const
+	{
+		switch (widget) {
+			case RPLALL_GUI_MATRIX_TOPLEFT: {
+				this->DrawEngineList(r, true);
+				break;
+			}
+			case RPLALL_GUI_MATRIX_TOPRIGHT: {
+				this->DrawEngineList(r, false);
+				break;
+			}
+			case RPLALL_GUI_MATRIX_BOTTOM: {
+				this->DrawVirtualTrains(r);
+				break;
+			}
+		}
+	}
+
+	virtual void OnClick(Point pt, int widget, int click_count)
+	{
+		switch(widget) {
+			case RPLALL_GUI_MATRIX_TOPLEFT: {
+				uint16 newindex = (uint16)((pt.y - this->nested_array[RPLALL_GUI_MATRIX_TOPLEFT]->pos_y) / this->line_height) + this->vscroll_tl->GetPosition();
+				if ( newindex >= this->engines_left->Length() || newindex==this->selected_left )
+					this->selected_left = -1;
+				else
+					this->selected_left = newindex;
+				this->SetDirty();
+				break;
+			}
+			case RPLALL_GUI_MATRIX_TOPRIGHT: {
+				uint16 newindex = (uint16)((pt.y - this->nested_array[RPLALL_GUI_MATRIX_TOPRIGHT]->pos_y) / this->line_height) + this->vscroll_tr->GetPosition();
+				if ( newindex > this->engines_right->Length() || newindex==this->selected_right )
+					this->selected_right = -1;
+				else
+					this->selected_right = newindex;
+				this->SetDirty();
+				break;
+			}
+			case RPLALL_GUI_BUTTON_RPLALL: {
+				this->ReplaceAll();
+				break;
+			}
+			case RPLALL_GUI_BUTTON_APPLY: {
+				// check if we actually did anything so far, if not, applying is forbidden
+				if ( this->virtualTrains->Length() == 0 )
+					return;
+				// first delete all current templates
+				this->DeleteAllTemplateTrains();
+				// then build a new list from the current virtual trains
+				for ( int i=0; i<this->virtualTrains->Length(); i++ ) {
+					// the relevant info struct
+					VirtTrainInfo *vti = (*this->virtualTrains)[i];
+					// setup template from contained train
+					Train *t = vti->vt;
+					TemplateVehicle *tv = TemplateVehicleFromVirtualTrain(t);
+					// restore template specific stuff
+					tv->reuse_depot_vehicles		= vti->reuse_depot_vehicles;
+					tv->keep_remaining_vehicles		= vti->keep_remaining_vehicles;
+					tv->refit_as_template			= vti->refit_as_template;
+					tv->cargo_type					= vti->cargo_type;
+					tv->cargo_subtype				= vti->cargo_subtype;
+					// use the original_index information to repoint the relevant TemplateReplacement if existing
+					TemplateReplacement *tr = GetTemplateReplacementByTemplateID(vti->original_index);
+					if ( tr )
+						tr->sel_template = tv->index;
+				}
+				// then close this window and return to parent
+				delete this;
+				break;
+			}
+			case RPLALL_GUI_BUTTON_CANCEL: {
+				delete this;
+				break;
+			}
+		}
+	}
+
+	bool HasTemplateWithEngine(EngineID eid) const
+	{
+		const TemplateVehicle *tv;
+		FOR_ALL_TEMPLATES(tv) {
+			if ( tv->Prev() || tv->owner != _local_company ) continue;
+			for ( const TemplateVehicle *tmp=tv; tmp; tmp=tmp->GetNextUnit() ) {
+				if ( tmp->engine_type == eid )
+					return true;
+			}
+		}
+		return false;
+	}
+
+	void GenerateVirtualTrains()
+	{
+		this->virtualTrains->Clear();
+
+		TemplateVehicle *tv;
+		FOR_ALL_TEMPLATES(tv) {
+			if ( !tv->Prev() && tv->owner==this->owner ) {
+				// setup template train
+				Train *newtrain = VirtualTrainFromTemplateVehicle(tv);
+				VirtTrainInfo *vti = new VirtTrainInfo(newtrain);
+				// store template specific stuff
+				vti->original_index				= tv->index;
+				vti->reuse_depot_vehicles		= tv->reuse_depot_vehicles;
+				vti->keep_remaining_vehicles	= tv->keep_remaining_vehicles;
+				vti->refit_as_template			= tv->refit_as_template;
+				vti->cargo_type					= tv->cargo_type;
+				vti->cargo_subtype				= tv->cargo_subtype;
+				// add new info struct
+				*this->virtualTrains->Append() = vti;
+			}
+		}
+
+		this->vscroll_bo->SetCount(this->virtualTrains->Length());
+	}
+
+	// move to func ?
+	void DeleteAllTemplateTrains()
+	{
+		TemplateVehicle *tv, *tmp;
+		FOR_ALL_TEMPLATES(tv) {
+			tmp = tv;
+			if ( tmp->Prev()==0 && tmp->owner==this->owner )
+				delete tmp;
+		}
+	}
+
+	void GenerateIncludedTemplateList()
+	{
+		int num_engines = 0;
+		int num_wagons  = 0;
+
+		this->engines_left->Clear();
+
+		const Engine *e;
+		FOR_ALL_ENGINES_OF_TYPE(e, VEH_TRAIN) {
+			EngineID eid = e->index;
+			const RailVehicleInfo*rvi = &e->u.rail;
+
+			if ( !HasTemplateWithEngine(eid) ) continue;
+
+			*this->engines_left->Append() = eid;
+
+			if (rvi->railveh_type != RAILVEH_WAGON) {
+				num_engines++;
+			} else {
+				num_wagons++;
+			}
+		}
+		this->vscroll_tl->SetCount(this->engines_left->Length());
+	}
+
+	bool VirtualTrainHasEngineID(EngineID eid)
+	{
+// 		printf("called for eid: %d\n", eid);
+
+		for ( int i=0; i<this->virtualTrains->Length(); i++ ) {
+			const Train *tmp = (*this->virtualTrains)[i]->vt;
+// 			printf("checking train:\n"); pvt(tmp);
+			for ( ; tmp; tmp=tmp->Next() )
+				if ( tmp->engine_type == eid )
+					return true;
+// 			printf("_________\n");
+		}
+// 		printf("return false\n______\n");
+		return false;
+	}
+
+	// after 'replace all' we need to replace the currently used templates as well
+	void RebuildIncludedTemplateList() {
+		// first remove all engine ids
+		for ( int i=0; i<this->engines_left->Length(); i++ ) {
+			EngineID entry = (*this->engines_left)[i];
+			if ( !VirtualTrainHasEngineID(entry) )
+				this->engines_left->Erase(&((*this->engines_left)[i]));
+		}
+	}
+
+	void ReplaceAll()
+	{
+
+		if ( this->selected_left==-1 || this->selected_right==-1 )
+			return;
+
+		EngineID eid_orig = (*this->engines_left)[this->selected_left];
+		EngineID eid_repl = (*this->engines_right)[this->selected_right];
+
+		if ( eid_orig == eid_repl )
+			return;
+
+		if ( this->virtualTrains->Length() == 0 )
+			this->GenerateVirtualTrains();
+
+		for ( int i=0; i<this->virtualTrains->Length(); i++ ) {
+			Train *tmp = (*this->virtualTrains)[i]->vt;
+			while ( tmp ) {
+				if ( tmp->engine_type == eid_orig ) {
+					// build a new virtual rail vehicle and test for success
+					Train *nt = CmdBuildVirtualRailVehicle(eid_repl);
+					if ( !nt ) continue;
+					// include the (probably) new engine into the 'included'-list
+					this->engines_left->Include( nt->engine_type );
+					// advance the tmp pointer in the chain, otherwise it would get deleted later on
+					Train *to_del = tmp;
+					tmp = tmp->GetNextUnit();
+					// first move the new virtual rail vehicle behind to_del
+					CommandCost move = CmdMoveRailVehicle(INVALID_TILE, DC_EXEC, nt->index|(1<<21), to_del->index, 0);
+					// then move to_del away from the chain and delete it
+					move = CmdMoveRailVehicle(INVALID_TILE, DC_EXEC, to_del->index|(1<<21), INVALID_VEHICLE, 0);
+					(*this->virtualTrains)[i]->vt = nt->First();
+					delete to_del;
+				} else {
+					tmp = tmp->GetNextUnit();
+				}
+			}
+		}
+		this->selected_left = -1;
+		// rebuild the left engines list as some engines might not be there anymore
+		this->RebuildIncludedTemplateList();
+		this->SetDirty();
+	}
+
+	void GenerateBuyableEnginesList()
+	{
+		int num_engines = 0;
+		int num_wagons  = 0;
+
+		this->engines_right->Clear();
+
+		const Engine *e;
+		FOR_ALL_ENGINES_OF_TYPE(e, VEH_TRAIN) {
+			EngineID eid = e->index;
+			const RailVehicleInfo *rvi = &e->u.rail;
+
+			if (!IsEngineBuildable(eid, VEH_TRAIN, _local_company)) continue;
+
+			*this->engines_right->Append() = eid;
+
+			if (rvi->railveh_type != RAILVEH_WAGON) {
+				num_engines++;
+			} else {
+				num_wagons++;
+			}
+		}
+
+		/* make engines first, and then wagons, sorted by ListPositionOfEngine() */
+		EngList_Sort(this->engines_right, TrainEnginesThenWagonsSorter);
+
+		this->vscroll_tr->SetCount(this->engines_right->Length());
+	}
+
+	void DrawEngineList(const Rect &r, bool left) const//, GUIEngineList el, Scrollbar* sb) const
+	{
+		uint16 y = r.top;
+		uint32 eid;
+
+		Scrollbar *sb;
+		const GUIEngineList *el;
+
+		if ( left ) {
+			sb = this->vscroll_tl;
+			el = this->engines_left;
+		} else {
+			sb = this->vscroll_tr;
+			el = this->engines_right;
+		}
+
+		int maximum = min((int)sb->GetCapacity(), (int)el->Length()) + sb->GetPosition();
+
+		for ( int i=sb->GetPosition(); i<maximum; i++ ) {
+
+			eid = (*el)[i];
+
+			/* Draw a grey background rectangle if the current line is the selected one */
+			if ( (left && this->selected_left == i) || (!left && this->selected_right == i) )
+				GfxFillRect(r.left, y, r.right, y+this->line_height, _colour_gradient[COLOUR_GREY][3]);
+
+			/* Draw a description string of the current engine */
+			SetDParam(0, eid);
+			DrawString(r.left+100, r.right, y+4, STR_ENGINE_NAME, TC_BLACK);
+
+			/* Draw the engine */
+			DrawVehicleEngine( r.left, r.right, r.left+29, y+8, eid, GetEnginePalette(eid, _local_company), EIT_PURCHASE );
+
+			y += this->line_height;
+		}
+	}
+
+	void DrawVirtualTrains(const Rect &r) const
+	{
+		uint16 y = r.top;
+
+		uint16 max = min(virtualTrains->Length(), this->vscroll_bo->GetCapacity());
+
+		for ( uint16 i=vscroll_bo->GetPosition(); i<max+vscroll_bo->GetPosition(); i++ ) {
+			/* Draw a virtual train*/
+			DrawTrainImage( (*this->virtualTrains)[i]->vt, r.left+32, r.right, y, INVALID_VEHICLE, EIT_PURCHASE, 0, -1 );
+
+			y+= this->line_height;
+		}
+	}
+};
+
+void ShowTemplateReplaceAllGui()
+{
+	new TemplateReplacementReplaceAllWindow(&_template_replace_replaceall_desc);
+}
\ No newline at end of file
diff -urNad openttd-1.3.2/src/aaa_template_gui_replaceall.h openttd-1.3.2-DC3.0RC3/src/aaa_template_gui_replaceall.h
--- openttd-1.3.2/src/aaa_template_gui_replaceall.h	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/aaa_template_gui_replaceall.h	2013-11-22 05:49:06.000000000 +0100
@@ -0,0 +1,27 @@
+#ifndef TMPL_RPLALL_GUI
+#define TMPL_RPLALL_GUI
+
+
+
+#include "stdafx.h"
+#include "window_gui.h"
+#include "window_func.h"
+
+#include "company_func.h"
+#include "engine_base.h"
+#include "engine_func.h"
+#include "engine_gui.h"
+#include "train.h"
+#include "strings_func.h"
+#include "vehicle_base.h"
+#include "vehicle_func.h"
+
+#include "aaa_template_vehicle.h"
+#include "aaa_template_vehicle_func.h"
+
+#include "core/math_func.hpp"
+#include "table/strings.h"
+
+void ShowTemplateReplaceAllGui();
+
+#endif
\ No newline at end of file
diff -urNad openttd-1.3.2/src/aaa_template_vehicle.cpp openttd-1.3.2-DC3.0RC3/src/aaa_template_vehicle.cpp
--- openttd-1.3.2/src/aaa_template_vehicle.cpp	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/aaa_template_vehicle.cpp	2013-11-22 05:49:06.000000000 +0100
@@ -0,0 +1,233 @@
+#include "stdafx.h"
+#include "company_func.h"
+#include "train.h"
+#include "command_func.h"
+#include "engine_func.h"
+#include "vehicle_func.h"
+#include "autoreplace_func.h"
+#include "autoreplace_gui.h"
+#include "group.h"
+#include "articulated_vehicles.h"
+#include "core/random_func.hpp"
+#include "core/pool_type.hpp"
+#include "engine_type.h"
+#include "group_type.h"
+#include "core/pool_func.hpp"
+
+#include "table/strings.h"
+
+#include "newgrf.h"
+
+#include "vehicle_type.h"
+#include "vehicle_base.h"
+#include "vehicle_func.h"
+
+#include "table/train_cmd.h"
+
+
+#include "aaa_template_vehicle.h"
+
+// since doing stuff with sprites
+#include "newgrf_spritegroup.h"
+#include "newgrf_engine.h"
+#include "newgrf_cargo.h"
+
+TemplatePool _template_pool("TemplatePool");
+INSTANTIATE_POOL_METHODS(Template)
+
+TemplateReplacementPool _template_replacement_pool("TemplateReplacementPool");
+INSTANTIATE_POOL_METHODS(TemplateReplacement)
+
+
+TemplateVehicle::TemplateVehicle(VehicleType ty, EngineID eid, byte subtypeflag, Owner current_owner)
+{
+	this->type = ty;
+	this->engine_type = eid;
+
+	this->reuse_depot_vehicles = true;
+	this->keep_remaining_vehicles = true;
+
+	this->first = this;
+	this->next = 0x0;
+	this->previous = 0x0;
+	this->owner_b = _current_company;
+
+	this->cur_image = SPR_IMG_QUERY;
+
+	this->owner = current_owner;
+
+	this->real_consist_length = 0;
+}
+
+TemplateVehicle::~TemplateVehicle() {
+	//free(this->name);
+
+	TemplateVehicle *v = this->Next();
+	this->SetNext(NULL);
+
+	delete v;
+}
+
+/** getting */
+void TemplateVehicle::SetNext(TemplateVehicle *v) { this->next = v; }
+void TemplateVehicle::SetPrev(TemplateVehicle *v) { this->previous = v; }
+void TemplateVehicle::SetFirst(TemplateVehicle *v) { this->first = v; }
+
+TemplateVehicle* TemplateVehicle::GetNextUnit() const
+{
+		TemplateVehicle *tv = this->Next();
+		//if ( tv != NULL ) {
+			while ( tv && HasBit(tv->subtype, GVSF_ARTICULATED_PART) ) tv = tv->Next();
+			if ( tv && HasBit(tv->subtype, GVSF_MULTIHEADED) && !HasBit(tv->subtype, GVSF_ENGINE) ) tv = tv->Next();
+		//}
+		return tv;
+}
+
+TemplateVehicle* TemplateVehicle::GetPrevUnit()
+{
+	TemplateVehicle *tv = this->Prev();
+	//if ( tv != NULL ) {
+		while ( tv && HasBit(tv->subtype, GVSF_ARTICULATED_PART|GVSF_ENGINE) ) tv = tv->Prev();
+		if ( tv && HasBit(tv->subtype, GVSF_MULTIHEADED|GVSF_ENGINE) ) tv = tv->Prev();
+	//}
+	return tv;
+}
+
+/** setting */
+void appendTemplateVehicle(TemplateVehicle *orig, TemplateVehicle *newv)
+{
+	if ( !orig ) return;
+	while ( orig->Next() ) orig=orig->Next();
+	orig->SetNext(newv);
+	newv->SetPrev(orig);
+	newv->SetFirst(orig->First());
+}
+
+void insertTemplateVehicle(TemplateVehicle *orig, TemplateVehicle *newv, TemplateVehicle *insert_after)
+{
+	if ( !orig || !insert_after ) return;
+	TemplateVehicle *insert_before = insert_after->Next();
+	insert_after->SetNext(newv);
+	insert_before->SetPrev(newv);
+	newv->SetPrev(insert_after);
+	newv->SetNext(insert_before);
+	newv->SetFirst(insert_after);
+}
+
+/** Length()
+ * @return: length of vehicle, including current part
+ */
+int TemplateVehicle::Length() const
+{
+	int l=1;
+	const TemplateVehicle *tmp=this;
+	while ( tmp->Next() ) { tmp=tmp->Next(); l++; }
+	return l;
+}
+
+TemplateReplacement* GetTemplateReplacementByGroupID(GroupID gid)
+{
+	TemplateReplacement *tr;
+	FOR_ALL_TEMPLATE_REPLACEMENTS(tr) {
+		if ( tr->Group() == gid )
+			return tr;
+	}
+	return 0;
+}
+
+TemplateReplacement* GetTemplateReplacementByTemplateID(TemplateID tid) {
+	TemplateReplacement *tr;
+	FOR_ALL_TEMPLATE_REPLACEMENTS(tr) {
+		if ( tr->Template() == tid )
+			return tr;
+	}
+	return 0;
+}
+
+bool IssueTemplateReplacement(GroupID gid, TemplateID tid) {
+
+	TemplateReplacement *tr = GetTemplateReplacementByGroupID(gid);
+
+	if ( tr ) {
+		/* Then set the new TemplateVehicle and return */
+		tr->SetTemplate(tid);
+		return true;
+	}
+
+	else if ( TemplateReplacement::CanAllocateItem() ) {
+		tr = new TemplateReplacement(gid, tid);
+		return true;
+	}
+
+	else return false;
+}
+
+short TemplateVehicle::NumGroupsUsingTemplate() const
+{
+	short amount = 0;
+	const TemplateReplacement *tr;
+	FOR_ALL_TEMPLATE_REPLACEMENTS(tr) {
+		if ( tr->sel_template == this->index )
+			amount++;
+	}
+	return amount;
+}
+
+short TemplateVehicle::CountEnginesInChain()
+{
+	TemplateVehicle *tv = this->first;
+	short count = 0;
+	for ( ; tv; tv=tv->GetNextUnit() )
+		if ( HasBit(tv->subtype, GVSF_ENGINE ) )
+			count++;
+	return count;
+}
+
+short deleteIllegalTemplateReplacements(GroupID g_id)
+{
+	short del_amount = 0;
+	const TemplateReplacement *tr;
+	FOR_ALL_TEMPLATE_REPLACEMENTS(tr) {
+		if ( tr->group == g_id ) {
+			delete tr;
+			del_amount++;
+		}
+	}
+	return del_amount;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff -urNad openttd-1.3.2/src/aaa_template_vehicle_func.cpp openttd-1.3.2-DC3.0RC3/src/aaa_template_vehicle_func.cpp
--- openttd-1.3.2/src/aaa_template_vehicle_func.cpp	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/aaa_template_vehicle_func.cpp	2013-11-22 05:49:06.000000000 +0100
@@ -0,0 +1,776 @@
+// template_vehicle_func.cpp
+
+#include "stdafx.h"
+#include "window_gui.h"
+#include "gfx_func.h"
+#include "window_func.h"
+#include "command_func.h"
+#include "vehicle_gui.h"
+#include "train.h"
+#include "strings_func.h"
+#include "vehicle_func.h"
+#include "core/geometry_type.hpp"
+#include "debug.h"
+
+#include "table/sprites.h"
+#include "table/strings.h"
+
+#include "train.h"
+#include "company_func.h"
+#include "newgrf.h"
+#include "spritecache.h"
+#include "articulated_vehicles.h"
+#include "autoreplace_func.h"
+
+#include "depot_base.h"
+
+#include "aaa_template_vehicle.h"
+#include "aaa_template_vehicle_func.h"
+
+#include <map>
+#include <stdio.h>
+
+Vehicle *vhead, *vtmp;
+static const uint MAX_ARTICULATED_PARTS = 100;
+
+
+// TODO
+void pat() {
+	TemplateVehicle *tv;
+	FOR_ALL_TEMPLATES(tv) {
+		if ( tv->Prev() ) continue;
+		ptv(tv);
+		printf("__________\n");
+	}
+}
+void pav() {
+	Train *t;
+	FOR_ALL_TRAINS(t) {
+		if ( t->Previous() ) continue;
+		pvt(t);
+		printf("__________\n");
+	}
+}
+void ptv(TemplateVehicle* tv) {
+	if (!tv) return;
+	while (tv->Next() ) {
+		printf("eid:%3d  st:%2d  tv:%x  next:%x  cargo: %d  cargo_sub: %d\n", tv->engine_type, tv->subtype, (uint32)tv, (uint32)tv->Next(), tv->cargo_type, tv->cargo_subtype);
+		tv = tv->Next();
+	}
+	printf("eid:%3d  st:%2d  tv:%x  next:%x  cargo: %d  cargo_sub: %d\n", tv->engine_type, tv->subtype, (uint32)tv, (uint32)tv->Next(),  tv->cargo_type, tv->cargo_subtype);
+}
+
+void pvt (const Train *printme) {
+	for ( const Train *tmp = printme; tmp; tmp=tmp->Next() ) {
+		if ( tmp->index <= 0 ) {
+			printf("train has weird index: %d %d %x\n", tmp->index, tmp->engine_type, tmp);
+			return;
+		}
+		printf("eid:%3d  index:%2d  subtype:%2d  vehstat: %d  cargo_t: %d   cargo_sub: %d  ref:%x\n", tmp->engine_type, tmp->index, tmp->subtype, tmp->vehstatus, tmp->cargo_type, tmp->cargo_subtype, (uint32)tmp);
+	}
+}
+
+// TODO: move this into main_gui.cpp
+void BuildTemplateGuiList(GUITemplateList *list, Scrollbar *vscroll, Owner oid, RailType railtype)
+{
+	//if (!list->NeedRebuild()) return; // TODO: reactivate ?
+	list->Clear();
+	const TemplateVehicle *tv;
+
+	FOR_ALL_TEMPLATES(tv) {
+		if (tv->owner == oid && (tv->IsPrimaryVehicle() || tv->IsFreeWagonChain()) && TemplateVehicleContainsEngineOfRailtype(tv, railtype))
+			*list->Append() = tv;
+
+	}
+
+	list->RebuildDone();
+	if (vscroll) vscroll->SetCount(list->Length());
+}
+
+Money CalculateOverallTemplateCost(const TemplateVehicle *tv)
+{
+	Money val = 0;
+
+	for (; tv; tv = tv->Next())
+		val += (Engine::Get(tv->engine_type))->GetCost();
+	return val;
+}
+
+void DrawTemplate(const TemplateVehicle *tv, int left, int right, int y)
+{
+	if ( !tv ) return;
+
+	const TemplateVehicle *t = tv;
+	int offset=left;
+
+	while (t) {
+		PaletteID pal = GetEnginePalette(t->engine_type, _current_company);
+		DrawSprite(t->cur_image, pal, offset, y+12);
+
+		offset += t->image_width;
+		t = t->Next();
+	}
+	//_cur_dpi = old_dpi;
+}
+
+// copy important stuff from the virtual vehicle to the template
+inline void SetupTemplateVehicleFromVirtual(TemplateVehicle *tmp, TemplateVehicle *prev, Train *virt)
+{
+	if (prev) {
+		prev->SetNext(tmp);
+		tmp->SetPrev(prev);
+		tmp->SetFirst(prev->First());
+	}
+	tmp->railtype = virt->railtype;
+	tmp->owner = virt->owner;
+	tmp->value = virt->value;
+
+	// set the subtype but also clear the virtual flag while doing it
+	tmp->subtype = virt->subtype & ~(1 << GVSF_VIRTUAL);
+	// set the cargo type and capacity
+	tmp->cargo_type = virt->cargo_type;
+	tmp->cargo_subtype = virt->cargo_subtype;
+	tmp->cargo_cap = virt->cargo_cap;
+
+	const GroundVehicleCache *gcache = virt->GetGroundVehicleCache();
+	tmp->max_speed = virt->GetDisplayMaxSpeed();
+	tmp->power = gcache->cached_power;
+	tmp->weight = gcache->cached_weight;
+	tmp->max_te = gcache->cached_max_te / 1000;
+
+	tmp->spritenum = virt->spritenum;
+	tmp->cur_image = virt->GetImage(DIR_W, EIT_PURCHASE);
+	Point *p = new Point();
+	tmp->image_width = virt->GetDisplayImageWidth(p);
+}
+
+// create a new virtual train as clone of a real train TODO
+Train* CloneVirtualTrainFromTrain(const Train *clicked)
+{
+	if ( !clicked ) return 0;
+	CommandCost c;
+	Train *tmp, *head, *tail;
+
+	head = CmdBuildVirtualRailVehicle(clicked->engine_type);
+	if ( !head ) return 0;
+
+	tail = head;
+	clicked = clicked->GetNextUnit();
+	while ( clicked ) {
+		tmp = CmdBuildVirtualRailVehicle(clicked->engine_type);
+		if ( tmp ) {
+			tmp->cargo_type = clicked->cargo_type;
+			tmp->cargo_subtype = clicked->cargo_subtype;
+			CmdMoveRailVehicle(0, DC_EXEC, (1<<21) | tmp->index, tail->index, 0);
+			tail = tmp;
+		}
+		clicked = clicked->GetNextUnit();
+	}
+	return head;
+}
+TemplateVehicle* CloneTemplateVehicleFromTrain(const Train *t)
+{
+	Train *clicked = Train::Get(t->index);
+	if ( !clicked )
+		return 0;
+
+	Train *init_clicked = clicked;
+
+	int len = CountVehiclesInChain(clicked);
+	if ( !TemplateVehicle::CanAllocateItem(len) )
+		// TODO: error message box ?
+		return 0;
+
+	TemplateVehicle *tmp, *prev=0;
+	for ( ; clicked; clicked=clicked->Next() ) {
+		tmp = new TemplateVehicle(clicked->engine_type);
+		SetupTemplateVehicleFromVirtual(tmp, prev, clicked);
+		prev = tmp;
+	}
+
+	tmp->First()->SetRealLength(CeilDiv(init_clicked->gcache.cached_total_length * 10, TILE_SIZE));
+	return tmp->First();
+}
+// create a full TemplateVehicle based train according to a virtual train
+TemplateVehicle* TemplateVehicleFromVirtualTrain(Train *virt)
+{
+	if ( !virt )
+		return 0;
+
+	Train *init_virt = virt;
+
+	int len = CountVehiclesInChain(virt);
+	if ( !TemplateVehicle::CanAllocateItem(len) )
+		// TODO: error message box ?
+		return 0;
+
+	TemplateVehicle *tmp, *prev=0;
+	for ( ; virt; virt=virt->Next() ) {
+		tmp = new TemplateVehicle(virt->engine_type);
+		SetupTemplateVehicleFromVirtual(tmp, prev, virt);
+		prev = tmp;
+	}
+
+	tmp->First()->SetRealLength(CeilDiv(init_virt->gcache.cached_total_length * 10, TILE_SIZE));
+	return tmp->First();
+}
+
+// attempt to buy a train after a given template vehicle
+// this might fail if the template e.g. deprecated and contains engines that are not sold anymore
+Train* VirtualTrainFromTemplateVehicle(TemplateVehicle *tv)
+{
+	if ( !tv ) return 0;
+	CommandCost c;
+	Train *tmp, *head, *tail;
+
+	head = CmdBuildVirtualRailVehicle(tv->engine_type);
+	if ( !head ) return 0;
+
+	tail = head;
+	tv = tv->GetNextUnit();
+	while ( tv ) {
+		tmp = CmdBuildVirtualRailVehicle(tv->engine_type);
+		if ( tmp ) {
+			tmp->cargo_type = tv->cargo_type;
+			tmp->cargo_subtype = tv->cargo_subtype;
+			CmdMoveRailVehicle(INVALID_TILE, DC_EXEC, (1<<21) | tmp->index, tail->index, 0);
+			tail = tmp;
+		}
+		tv = tv->GetNextUnit();
+	}
+	return head;
+}
+
+// return last in a chain (really last, so even a singular articulated part of a vehicle if the last one is artic)
+inline TemplateVehicle* Last(TemplateVehicle *chain) {
+	if ( !chain ) return 0;
+	while ( chain->Next() ) chain = chain->Next();
+	return chain;
+}
+
+inline Train* Last(Train *chain) {
+	if ( !chain ) return 0;
+	while ( chain->GetNextUnit() ) chain = chain->GetNextUnit();
+	return chain;
+}
+
+// return: pointer to former vehicle
+TemplateVehicle *DeleteTemplateVehicle(TemplateVehicle *todel)
+{
+	if ( !todel )
+		return 0;
+	TemplateVehicle *cur = todel;
+	delete todel;
+	return cur;
+}
+
+Train* DeleteVirtualTrain(Train *chain, Train *to_del) {
+	if ( chain != to_del ) {
+		CommandCost sellc = CmdSellRailWagon(DC_EXEC, to_del, 0, 0);
+		return chain;
+	}
+	else {
+		chain = chain->GetNextUnit();
+		//CommandCost cost=CmdMoveRailVehicle(0, DC_EXEC, (1<<20) | (1<<21) | to_del->index, INVALID_VEHICLE, 0);
+		CommandCost sellc = CmdSellRailWagon(DC_EXEC, to_del, 0, 0);
+		return chain;
+	}
+}
+
+// retrieve template vehicle from templatereplacement that belongs to the given group
+TemplateVehicle* GetTemplateVehicleByGroupID(GroupID gid) {
+	TemplateReplacement *tr;
+	// first try to find a templatereplacement issued for the given groupid
+	FOR_ALL_TEMPLATE_REPLACEMENTS(tr) {
+		if ( tr->Group() == gid )
+			return TemplateVehicle::GetIfValid(tr->Template());		// there can be only one
+	}
+	// if that didn't work, try to find a templatereplacement for ALL_GROUP
+	if ( gid != ALL_GROUP )
+		FOR_ALL_TEMPLATE_REPLACEMENTS(tr) {
+			if ( tr->Group() == ALL_GROUP )
+				return TemplateVehicle::GetIfValid(tr->Template());
+		}
+	// if all failed, just return null
+	return 0;
+}
+
+/**
+ * Check a template consist whether it contains any engine of the given railtype
+ */
+bool TemplateVehicleContainsEngineOfRailtype(const TemplateVehicle *tv, RailType type)
+{
+	/* For standard rail engines, allow only those */
+	if ( type == RAILTYPE_BEGIN || type == RAILTYPE_RAIL ) {
+		while ( tv ) {
+		if ( tv->railtype != type )
+			return false;
+		tv = tv->GetNextUnit();
+		}
+		return true;
+	}
+	/* For electrified rail engines, standard wagons or engines are allowed to be included */
+	while ( tv ) {
+		if ( tv->railtype == type )
+			return true;
+		tv = tv->GetNextUnit();
+	}
+	return false;
+}
+
+//helper
+bool ChainContainsVehicle(Train *chain, Train *mem) {
+	for (; chain; chain=chain->Next())
+		if ( chain == mem )
+			return true;
+	return false;
+}
+
+// has O(n)
+Train* ChainContainsEngine(EngineID eid, Train *chain) {
+	for (; chain; chain=chain->GetNextUnit())
+		if (chain->engine_type == eid)
+			return chain;
+	return 0;
+}
+
+// has O(n^2)
+// TODO: switch to trains
+Train* DepotContainsEngine(TileIndex tile, EngineID eid, Train *not_in=0) {
+	Train *t;
+	FOR_ALL_TRAINS(t) {
+		// conditions: v is stopped in the given depot, has the right engine and if 'not_in' is given v must not be contained within 'not_in'
+ 		// if 'not_in' is NULL, no check is needed
+		if ( t->tile==tile
+				// If the veh belongs to a chain, wagons will not return true on IsStoppedInDepot(), only primary vehicles will
+				// in case of t not a primary veh, we demand it to be a free wagon to consider it for replacement
+				&& ((t->IsPrimaryVehicle() && t->IsStoppedInDepot()) || t->IsFreeWagon())
+				&& t->engine_type==eid
+				&& (not_in==0 || ChainContainsVehicle(not_in, t)==0))
+			return t;
+	}
+	return 0;
+}
+
+void CopyStatus(Train *from, Train *to) {
+	// TODO: remove ? used ?
+	//to->group_id = from->group_id;
+	DoCommand(to->tile, from->group_id, to->index, DC_EXEC, CMD_ADD_VEHICLE_GROUP);
+	to->cargo_type = from->cargo_type;
+	to->cargo_subtype = from->cargo_subtype;
+
+	//to->orders = from->orders;
+	//to->current_order = from->current_order;
+	//to->cur_implicit_order_index = from->cur_implicit_order_index;
+
+	// swap names
+	char *tmp = to->name;
+	to->name = from->name;
+	from->name = tmp;
+	/*if ( !from->name || !to->name ) {
+		int tmpind = from->index;
+		from->index = to->index;
+		to->index = tmpind;
+	}*/
+}
+void NeutralizeStatus(Train *t) {
+	DoCommand(t->tile, DEFAULT_GROUP, t->index, DC_EXEC, CMD_ADD_VEHICLE_GROUP);
+
+	//t->orders.list = 0;
+	//t->cur_implicit_order_index = 0;
+
+	t->name = 0;
+}
+bool TrainMatchesTemplate(const Train *t, TemplateVehicle *tv) {
+	while ( t && tv ) {
+		if ( t->engine_type != tv->engine_type )
+			return false;
+		t = t->GetNextUnit();
+		tv = tv->GetNextUnit();
+	}
+	if ( (t && !tv) || (!t && tv) )
+		return false;
+	return true;
+}
+
+
+bool TrainMatchesTemplateRefit(const Train *t, TemplateVehicle *tv)
+{
+	if ( !tv->refit_as_template )
+		return true;
+
+	while ( t && tv ) {
+		if ( t->cargo_type != tv->cargo_type || t->cargo_subtype != tv->cargo_subtype )
+			return false;
+		t = t->GetNextUnit();
+		tv = tv->GetNextUnit();
+	}
+	return true;
+}
+void BreakUpRemainders(Train *t) {
+	while ( t ) {
+		Train *move;
+		if ( HasBit(t->subtype, GVSF_ENGINE) ) {
+			move = t;
+			t = t->Next();
+			DoCommand(move->tile, move->index, INVALID_VEHICLE, DC_EXEC, CMD_MOVE_RAIL_VEHICLE);
+			NeutralizeStatus( move );
+		}
+		else
+			t = t->Next();
+	}
+}
+
+short CountEnginesInChain(Train *t)
+{
+	short count = 0;
+	for ( ; t; t=t->GetNextUnit() )
+		if ( HasBit(t->subtype, GVSF_ENGINE) )
+			count++;
+	return count;
+}
+
+int countOccurrencesInTrain(Train *t, EngineID eid) {
+	int count = 0;
+	Train *tmp = t;
+	for ( ; tmp; tmp=tmp->GetNextUnit() )
+		if ( tmp->engine_type == eid )
+			count++;
+	return count;
+}
+
+int countOccurrencesInTemplateVehicle(TemplateVehicle *contain, EngineID eid) {
+	int count = 0;
+	for ( ; contain; contain=contain->GetNextUnit() )
+		if ( contain->engine_type == eid )
+			count++;
+	return count;
+}
+
+int countOccurrencesInDepot(TileIndex tile, EngineID eid, Train *not_in=0) {
+	int count = 0;
+	Vehicle *v;
+	FOR_ALL_VEHICLES(v) {
+		// conditions: v is stopped in the given depot, has the right engine and if 'not_in' is given v must not be contained within 'not_in'
+ 		// if 'not_in' is NULL, no check is needed
+		if ( v->tile==tile && v->IsStoppedInDepot() && v->engine_type==eid &&
+				(not_in==0 || ChainContainsVehicle(not_in, (Train*)v)==0))
+			count++;
+	}
+	return count;
+}
+
+// basically does the same steps as CmdTemplateReplaceVehicle but without actually moving things around
+CommandCost CalculateTemplateReplacementCost(Train *incoming) {
+	TileIndex tile = incoming->tile;
+	TemplateVehicle *tv = GetTemplateVehicleByGroupID(incoming->group_id);
+	CommandCost estimate(EXPENSES_NEW_VEHICLES);
+
+	// count for each different eid in the incoming train
+	std::map<EngineID, short> unique_eids;
+	for ( TemplateVehicle *tmp=tv; tmp; tmp=tmp->GetNextUnit() )
+		unique_eids[tmp->engine_type]++;
+	std::map<EngineID, short>::iterator it = unique_eids.begin();
+	for ( ; it!=unique_eids.end(); it++ ) {
+		it->second -= countOccurrencesInTrain(incoming, it->first);
+		it->second -= countOccurrencesInDepot(incoming->tile, it->first, incoming);
+		if ( it->second < 0 ) it->second = 0;
+	}
+
+	// get overall buying cost
+	for ( it=unique_eids.begin(); it!=unique_eids.end(); it++ ) {
+		for ( int j=0; j<it->second; j++ ) {
+			estimate.AddCost(DoCommand(tile, it->first, 0, DC_NONE, CMD_BUILD_VEHICLE));
+		}
+	}
+
+	return estimate;
+}
+
+// make sure the real train wagon has the right cargo
+void CopyWagonStatus(TemplateVehicle *from, Train *to) {
+	to->cargo_type = from->cargo_type;
+	to->cargo_subtype = from->cargo_subtype;
+}
+
+int NumTrainsNeedTemplateReplacement(GroupID g_id, TemplateVehicle *tv)
+{
+	int count = 0;
+	if ( !tv ) return count;
+
+	const Train *t;
+	FOR_ALL_TRAINS(t) {
+		if ( t->IsPrimaryVehicle() && t->group_id == g_id && (!TrainMatchesTemplate(t, tv) || !TrainMatchesTemplateRefit(t, tv)) )
+			count++;
+	}
+	return count;
+}
+// refit each vehicle in t as is in tv, assume t and tv contain the same types of vehicles
+static void RefitTrainFromTemplate(Train *t, TemplateVehicle *tv)
+{
+	while ( t && tv ) {
+		// refit t as tv
+		uint32 cb = GetCmdRefitVeh(t);
+
+		DoCommandP(t->tile, t->index, tv->cargo_type | tv->cargo_subtype << 8 | 1 << 16 , cb);
+		//CommandCost c = CmdRefitVehicle ( t->tile, DC_EXEC, t->index, tv->cargo_type | tv->cargo_subtype << 8 | 1 << 16, "" );
+
+		// next
+		t = t->GetNextUnit();
+		tv = tv->GetNextUnit();
+	}
+}
+
+/** using cmdtemplatereplacevehicle as test-function (i.e. with flag DC_NONE) is not a good idea as that function relies on
+ *  actually moving vehicles around to work properly.
+ *  We do this worst-cast test instead.
+ */
+CommandCost TestBuyAllTemplateVehiclesInChain(TemplateVehicle *tv, TileIndex tile)
+{
+	CommandCost cost(EXPENSES_NEW_VEHICLES);
+
+	for ( ; tv; tv=tv->GetNextUnit() )
+		cost.AddCost( DoCommand(tile, tv->engine_type, 0, DC_NONE, CMD_BUILD_VEHICLE) );
+
+	return cost;
+}
+
+
+void TransferCargoForTrain(Train *old_veh, Train *new_head, bool part_of_chain)
+{
+	assert(!part_of_chain || new_head->IsPrimaryVehicle());
+	/* Loop through source parts */
+	for (Train *src = old_veh; src != NULL; src = src->Next()) {
+		if (!part_of_chain &&  src != old_veh && src != old_veh->other_multiheaded_part && !src->IsArticulatedPart()) {
+			/* Skip vehicles, which do not belong to old_veh */
+			src = src->GetLastEnginePart();
+			continue;
+		}
+		if (src->cargo_type >= NUM_CARGO || src->cargo.Count() == 0) continue;
+
+		/* Find free space in the new chain */
+		for (Train *dest = new_head; dest != NULL && src->cargo.Count() > 0; dest = dest->Next()) {
+			if (!part_of_chain  && dest != new_head && dest != new_head->other_multiheaded_part && !dest->IsArticulatedPart()) {
+				/* Skip vehicles, which do not belong to new_head */
+				dest = dest->GetLastEnginePart();
+				continue;
+			}
+			if (dest->cargo_type != src->cargo_type) continue;
+
+			uint amount = min(src->cargo.Count(), dest->cargo_cap - dest->cargo.Count());
+			if (amount <= 0) continue;
+
+			src->cargo.MoveTo(&dest->cargo, amount, VehicleCargoList::MTA_UNLOAD, NULL);
+		}
+	}
+
+	/* Update train weight etc., the old vehicle will be sold anyway */
+	if (part_of_chain ) new_head->ConsistChanged(true);
+}
+
+// TODO: fit signature to regular cmd-structure
+//		 do something with move_cost, it is not used right now
+// if exec==DC_EXEC, test first and execute if sucessful
+CommandCost CmdTemplateReplaceVehicle(Train *incoming, bool stayInDepot, DoCommandFlag flags) {
+	Train	*new_chain=0,
+			*remainder_chain=0,
+			*tmp_chain=0;
+	TileIndex tile = incoming->tile;
+	TemplateVehicle *tv = GetTemplateVehicleByGroupID(incoming->group_id);
+	EngineID eid = tv->engine_type;
+
+	CommandCost buy(EXPENSES_NEW_VEHICLES);
+	CommandCost move_cost(EXPENSES_NEW_VEHICLES);
+	CommandCost tmp_result(EXPENSES_NEW_VEHICLES);
+
+
+	/* first some tests on necessity and sanity */
+	if ( !tv )
+		return buy;
+	bool need_replacement = !TrainMatchesTemplate(incoming, tv);
+	bool need_refit = !TrainMatchesTemplateRefit(incoming, tv);
+	bool use_refit = tv->refit_as_template;
+	CargoID store_refit_ct = CT_INVALID;
+	short store_refit_csubt = 0;
+	// if a train shall keep its old refit, store the refit setting of its first vehicle
+	if ( !use_refit ) {
+		for ( Train *getc=incoming; getc; getc=getc->GetNextUnit() )
+			if ( getc->cargo_type != CT_INVALID ) {
+				store_refit_ct = getc->cargo_type;
+				break;
+			}
+	}
+
+	// TODO: set result status to success/no success before returning
+	if ( !need_replacement ) {
+		if ( !need_refit || !use_refit ) {
+			/* before returning, release incoming train first if 2nd param says so */
+			if ( !stayInDepot ) incoming->vehstatus &= ~VS_STOPPED;
+			return buy;
+		}
+	} else {
+		CommandCost buyCost = TestBuyAllTemplateVehiclesInChain(tv, tile);
+		if ( !buyCost.Succeeded() || !CheckCompanyHasMoney(buyCost) ) {
+			if ( !stayInDepot ) incoming->vehstatus &= ~VS_STOPPED;
+			return buy;
+		}
+	}
+
+	/* define replacement behaviour */
+	bool reuseDepot = tv->IsSetReuseDepotVehicles();
+	bool keepRemainders = tv->IsSetKeepRemainingVehicles();
+
+	if ( need_replacement ) {
+		/// step 1: generate primary for newchain and generate remainder_chain
+			// 1. primary of incoming might already fit the template
+				// leave incoming's primary as is and move the rest to a free chain = remainder_chain
+			// 2. needed primary might be one of incoming's member vehicles
+			// 3. primary might be available as orphan vehicle in the depot
+			// 4. we need to buy a new engine for the primary
+			// all options other than 1. need to make sure to copy incoming's primary's status
+		if ( eid == incoming->engine_type ) {													// 1
+			new_chain = incoming;
+			remainder_chain = incoming->GetNextUnit();
+			if ( remainder_chain )
+				move_cost.AddCost(CmdMoveRailVehicle(tile, flags, remainder_chain->index|(1<<20), INVALID_VEHICLE, 0));
+		}
+		else if ( (tmp_chain = ChainContainsEngine(eid, incoming)) && tmp_chain!=NULL )	{		// 2
+			// new_chain is the needed engine, move it to an empty spot in the depot
+			new_chain = tmp_chain;
+			move_cost.AddCost(DoCommand(tile, new_chain->index, INVALID_VEHICLE, flags,CMD_MOVE_RAIL_VEHICLE));
+			remainder_chain = incoming;
+		}
+		else if ( reuseDepot && (tmp_chain = DepotContainsEngine(tile, eid, incoming)) && tmp_chain!=NULL ) {	// 3
+			new_chain = tmp_chain;
+			move_cost.AddCost(DoCommand(tile, new_chain->index, INVALID_VEHICLE, flags, CMD_MOVE_RAIL_VEHICLE));
+			remainder_chain = incoming;
+		}
+		else {																				// 4
+			tmp_result = DoCommand(tile, eid, 0, flags, CMD_BUILD_VEHICLE);
+			/* break up in case buying the vehicle didn't succeed */
+			if ( !tmp_result.Succeeded() )
+				return tmp_result;
+			buy.AddCost(tmp_result);
+			new_chain = Train::Get(_new_vehicle_id);
+			/* make sure the newly built engine is not attached to any free wagons inside the depot */
+			move_cost.AddCost ( DoCommand(tile, new_chain->index, INVALID_VEHICLE, flags, CMD_MOVE_RAIL_VEHICLE) );
+			/* prepare the remainder chain */
+			remainder_chain = incoming;
+		}
+		// If we bought a new engine or reused one from the depot, copy some parameters from the incoming primary engine
+		if ( incoming != new_chain && flags == DC_EXEC) {
+			CopyHeadSpecificThings(incoming, new_chain, flags);
+			NeutralizeStatus(incoming);
+			// additionally, if we don't want to use the template refit, refit as incoming
+			// the template refit will be set further down, if we use it at all
+			if ( !use_refit ) {
+				uint32 cb = GetCmdRefitVeh(new_chain);
+				DoCommandP(new_chain->tile, new_chain->index, store_refit_ct | store_refit_csubt << 8 | 1 << 16 , cb);
+			}
+
+		}
+
+		/// step 2: fill up newchain according to the template
+			// foreach member of template (after primary):
+				// 1. needed engine might be within remainder_chain already
+				// 2. needed engine might be orphaned within the depot (copy status)
+				// 3. we need to buy (again)						   (copy status)
+		TemplateVehicle *cur_tmpl = tv->GetNextUnit();
+		Train *last_veh = new_chain;
+		while (cur_tmpl) {
+			// 1. engine contained in remainder chain
+			if ( (tmp_chain = ChainContainsEngine(cur_tmpl->engine_type, remainder_chain)) && tmp_chain!=NULL )	{
+				// advance remainder_chain (if necessary) to not lose track of it
+				if ( tmp_chain == remainder_chain )
+					remainder_chain = remainder_chain->GetNextUnit();
+				move_cost.AddCost(CmdMoveRailVehicle(tile, flags, tmp_chain->index, last_veh->index, 0));
+			}
+			// 2. engine contained somewhere else in the depot
+			else if ( reuseDepot && (tmp_chain = DepotContainsEngine(tile, cur_tmpl->engine_type, new_chain)) && tmp_chain!=NULL ) {
+				move_cost.AddCost(CmdMoveRailVehicle(tile, flags, tmp_chain->index, last_veh->index, 0));
+			}
+			// 3. must buy new engine
+			else {
+				tmp_result = DoCommand(tile, cur_tmpl->engine_type, 0, flags, CMD_BUILD_VEHICLE);
+				if ( !tmp_result.Succeeded() )
+					return tmp_result;
+				buy.AddCost(tmp_result);
+				tmp_chain = Train::Get(_new_vehicle_id);
+				move_cost.AddCost(CmdMoveRailVehicle(tile, flags, tmp_chain->index, last_veh->index, 0));
+			}
+			// TODO: is this enough ? might it be that we bought a new wagon here and it now has std refit ?
+			if ( need_refit && flags == DC_EXEC ) {
+				if ( use_refit ) {
+					uint32 cb = GetCmdRefitVeh(tmp_chain);
+					DoCommandP(tmp_chain->tile, tmp_chain->index, cur_tmpl->cargo_type | cur_tmpl->cargo_subtype << 8 | 1 << 16 , cb);
+					// old
+					// CopyWagonStatus(cur_tmpl, tmp_chain);
+				} else {
+					uint32 cb = GetCmdRefitVeh(tmp_chain);
+					DoCommandP(tmp_chain->tile, tmp_chain->index, store_refit_ct | store_refit_csubt << 8 | 1 << 16 , cb);
+				}
+			}
+			cur_tmpl = cur_tmpl->GetNextUnit();
+			last_veh = tmp_chain;
+		}
+	}
+	/* no replacement done */
+	else {
+		new_chain = incoming;
+	}
+	/// step 3: reorder and neutralize the remaining vehicles from incoming
+		// wagons remaining from remainder_chain should be filled up in as few freewagonchains as possible
+		// each locos might be left as singular in the depot
+		// neutralize each remaining engine's status
+
+	// refit, only if the template option is set so
+	if ( use_refit && (need_refit || need_replacement) ) {
+		RefitTrainFromTemplate(new_chain, tv);
+	}
+
+	if ( new_chain && remainder_chain )
+		for ( Train *ct=remainder_chain; ct; ct=ct->GetNextUnit() )
+			TransferCargoForTrain(ct, new_chain, true);
+
+	// point incoming to the newly created train so that starting/stopping from the calling function can be done
+	incoming = new_chain;
+	if ( !stayInDepot && flags == DC_EXEC )
+		new_chain->vehstatus &= ~VS_STOPPED;
+
+	if ( remainder_chain && keepRemainders && flags == DC_EXEC )
+		BreakUpRemainders(remainder_chain);
+	else if ( remainder_chain ) {
+		buy.AddCost(DoCommand(tile, remainder_chain->index | (1<<20), 0, flags, CMD_SELL_VEHICLE));
+	}
+	return buy;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff -urNad openttd-1.3.2/src/aaa_template_vehicle_func.h openttd-1.3.2-DC3.0RC3/src/aaa_template_vehicle_func.h
--- openttd-1.3.2/src/aaa_template_vehicle_func.h	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/aaa_template_vehicle_func.h	2013-11-22 05:49:06.000000000 +0100
@@ -0,0 +1,68 @@
+// template_vehicle_func.h
+#ifndef TEMPLATE_VEHICLE_FUNC_H
+#define TEMPLATE_VEHICLE_FUNC_H
+
+#include "stdafx.h"
+#include "window_gui.h"
+
+#include "aaa_template_vehicle.h"
+
+static bool REPLACEMENT_IN_PROGRESS = false;
+
+//void DrawTemplateVehicle(TemplateVehicle*, int, const Rect&);
+void DrawTemplateVehicle(const TemplateVehicle*, int, int, int, VehicleID, int, VehicleID);
+
+void BuildTemplateGuiList(GUITemplateList*, Scrollbar*, Owner, RailType);
+
+Money CalculateOverallTemplateCost(const TemplateVehicle*);
+
+void DrawTemplateTrain(const TemplateVehicle*, int, int, int);
+
+SpriteID GetSpriteID(EngineID, bool);
+
+void DrawTemplate(const TemplateVehicle*, int, int, int);
+
+int GetTemplateDisplayImageWidth(EngineID);
+
+TemplateVehicle *CreateNewTemplateVehicle(EngineID);
+
+void setupVirtTrain(const TemplateVehicle*, Train*);
+
+TemplateVehicle* TemplateVehicleFromVirtualTrain(Train*);
+
+Train* VirtualTrainFromTemplateVehicle(TemplateVehicle*);
+
+inline TemplateVehicle* Last(TemplateVehicle*);
+
+TemplateVehicle *DeleteTemplateVehicle(TemplateVehicle*);
+
+Train* DeleteVirtualTrainPart(Train*, Train*);
+Train* DeleteVirtualTrain(Train*, Train *);
+
+CommandCost CmdTemplateReplaceVehicle(Train*, bool, DoCommandFlag);
+
+void pat();
+void pav();
+void ptv(TemplateVehicle*);
+void pvt(const Train*);
+// for testing
+TemplateVehicle* GetTemplateVehicleByGroupID(GroupID);
+bool ChainContainsVehicle(Train*, Train*);
+Train* ChainContainsEngine(EngineID, Train*);
+Train* DepotContainsEngine(TileIndex, EngineID, Train*);
+
+int NumTrainsNeedTemplateReplacement(GroupID, TemplateVehicle*);
+
+CommandCost TestBuyAllTemplateVehiclesInChain(Train*);
+CommandCost CalculateTemplateReplacementCost(Train*);
+
+short CountEnginesInChain(Train*);
+
+bool TemplateVehicleContainsEngineOfRailtype(const TemplateVehicle*, RailType);
+
+Train* CloneVirtualTrainFromTrain(const Train *);
+TemplateVehicle* CloneTemplateVehicleFromTrain(const Train *);
+
+void TransferCargoForTrain(Train*, Train*, bool);
+
+#endif
diff -urNad openttd-1.3.2/src/aaa_template_vehicle.h openttd-1.3.2-DC3.0RC3/src/aaa_template_vehicle.h
--- openttd-1.3.2/src/aaa_template_vehicle.h	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/aaa_template_vehicle.h	2013-11-22 05:49:06.000000000 +0100
@@ -0,0 +1,229 @@
+#ifndef TEMPLATE_VEH_H
+#define TEMPLATE_VEH_H
+
+#include "vehicle_type.h"
+#include "vehicle_base.h"
+#include "vehicle_func.h"
+
+#include "articulated_vehicles.h"
+#include "newgrf_callbacks.h"
+#include "newgrf_engine.h"
+#include "newgrf_spritegroup.h"
+
+#include "engine_base.h"
+#include "engine_type.h"
+#include "engine_func.h"
+
+#include "sortlist_type.h"
+
+#define FOR_ALL_TEMPLATES_FROM(var, start) FOR_ALL_ITEMS_FROM(TemplateVehicle, template_index, var, start)
+#define FOR_ALL_TEMPLATES(var) FOR_ALL_TEMPLATES_FROM(var, 0)
+
+#define FOR_ALL_TEMPLATE_REPLACEMENTS_FROM(var, start) FOR_ALL_ITEMS_FROM(TemplateReplacement, template_replacement_index, var, start)
+#define FOR_ALL_TEMPLATE_REPLACEMENTS(var) FOR_ALL_TEMPLATE_REPLACEMENTS_FROM(var, 0)
+
+struct TemplateVehicle;
+struct TemplateReplacement;
+
+CommandCost CmdBuildTemplateVehicle(uint i, DoCommandFlag flags, uint p1, uint p2, char const* text);
+CommandCost CmdTemplateReplaceVehicle(uint i, DoCommandFlag flags, uint p1, uint p2, char const* text);
+typedef uint16 TemplateID;
+
+
+static const uint16 CONSIST_HEAD = 0x0;
+static const uint16 CONSIST_TAIL = 0xffff;
+
+/** A pool allowing to store up to ~64k templates */
+typedef Pool<TemplateVehicle, TemplateID, 512, 0x10000> TemplatePool;
+extern TemplatePool _template_pool;
+
+/// listing/sorting templates
+typedef GUIList<const TemplateVehicle*> GUITemplateList;
+
+/* TODO: rearrange attribs -.- care fore saveload as well */
+struct TemplateVehicle : TemplatePool::PoolItem<&_template_pool>, BaseVehicle {
+private:
+	TemplateVehicle *next;                      ///< pointer to the next vehicle in the chain
+	TemplateVehicle *previous;                  ///< NOSAVE: pointer to the previous vehicle in the chain
+	TemplateVehicle *first;                     ///< NOSAVE: pointer to the first vehicle in the chain
+
+public:
+	friend const SaveLoad* GTD();
+	friend void AfterLoadTemplateVehicles();
+
+	// Template usage configuration
+	bool reuse_depot_vehicles;
+	bool keep_remaining_vehicles;
+	bool refit_as_template;
+
+	// Things derived from a virtual train
+	TemplateVehicle *other_multiheaded_part;	///< Multiheaded Engine support
+	Money value;                        ///< Value of the vehicle
+	Owner owner;
+	OwnerByte owner_b;
+
+	EngineID engine_type;               ///< The type of engine used for this vehicle.
+	CargoID cargo_type;                 ///< type of cargo this vehicle is carrying
+	uint16 cargo_cap;                   ///< total capacity
+	byte cargo_subtype;
+
+	byte subtype;
+	RailTypeByte railtype;
+
+	VehicleID index;
+
+	uint16 real_consist_length;
+
+	uint16 max_speed;
+	uint32 power;
+	uint32 weight;
+	uint32 max_te;
+
+	byte spritenum;
+	SpriteID cur_image;
+	int image_width;
+	const SpriteGroup *sgroup;
+
+	TemplateVehicle(VehicleType type=VEH_INVALID,  EngineID e=INVALID_ENGINE, byte B=0, Owner=OWNER_BEGIN); // TODO:owner_begin not a good choice for the default
+	TemplateVehicle(EngineID, RailVehicleInfo*);
+	TemplateVehicle(EngineID eid) {
+		next=0;
+		previous=0;
+		first=this;
+		engine_type=eid;
+		this->reuse_depot_vehicles = true;
+		this->keep_remaining_vehicles = true;
+		this->refit_as_template = true;
+	}
+	~TemplateVehicle();
+
+	inline TemplateVehicle* Next() const { return this->next; }
+	inline TemplateVehicle* Prev() const { return this->previous; }
+	inline TemplateVehicle* First() const { return this->first; }
+
+	void SetNext(TemplateVehicle*);
+	void SetPrev(TemplateVehicle*);
+	void SetFirst(TemplateVehicle*);
+
+	// TODO
+	TemplateVehicle* GetNextUnit() const;
+	TemplateVehicle* GetPrevUnit();
+
+	bool IsSetReuseDepotVehicles() const { return this->reuse_depot_vehicles; }
+	bool IsSetKeepRemainingVehicles() const { return this->keep_remaining_vehicles; }
+	bool IsSetRefitAsTemplate() const { return this->refit_as_template; }
+	void ToggleReuseDepotVehicles() { this->reuse_depot_vehicles = !this->reuse_depot_vehicles; }
+	void ToggleKeepRemainingVehicles() { this->keep_remaining_vehicles = !this->keep_remaining_vehicles; }
+	void ToggleRefitAsTemplate() { this->refit_as_template = !this->refit_as_template; }
+
+	bool IsPrimaryVehicle() const { return this->IsFrontEngine(); }
+	inline bool IsFrontEngine() const { return HasBit(this->subtype, GVSF_FRONT); }
+	inline bool HasArticulatedPart() const { return this->Next() != NULL && this->Next()->IsArticulatedPart(); }
+
+	inline bool IsArticulatedPart() const { return HasBit(this->subtype, GVSF_ARTICULATED_PART); }
+	inline bool IsMultiheaded() const { return HasBit(this->subtype, GVSF_MULTIHEADED); }
+
+	inline bool IsFreeWagonChain() const { return HasBit(this->subtype, GVSF_FREE_WAGON); }
+
+	// since CmdBuildTemplateVehicle(...)
+	inline void SetFrontEngine() 		{ SetBit(this->subtype, GVSF_FRONT); }
+	inline void SetEngine()			{ SetBit(this->subtype, GVSF_ENGINE); }
+	inline void SetArticulatedPart()	{ SetBit(this->subtype, GVSF_ARTICULATED_PART); }
+	inline void SetMultiheaded()	 	{ SetBit(this->subtype, GVSF_MULTIHEADED); }
+
+	inline void SetWagon() { SetBit(this->subtype, GVSF_WAGON); }
+	inline void SetFreeWagon() { SetBit(this->subtype, GVSF_FREE_WAGON); }
+
+	inline uint16 GetRealLength() const { return this->real_consist_length; }
+	inline void SetRealLength(uint16 len) { this->real_consist_length = len; }
+
+	int Length() const;
+
+	SpriteID GetImage(Direction) const;
+	//int GetDisplayImageWidth(Point *offset = NULL) const;
+	SpriteID GetSpriteID() const;
+
+	short NumGroupsUsingTemplate() const;
+
+	short CountEnginesInChain();
+
+};
+
+void appendTemplateVehicle(TemplateVehicle*, TemplateVehicle*);
+void insertTemplateVehicle(TemplateVehicle*, TemplateVehicle*, TemplateVehicle*);
+
+void NeutralizeVehicleStatus(Train*);
+void SplitVehicleRemainders(Train*);
+
+// TemplateReplacement stuff
+
+typedef Pool<TemplateReplacement, uint16, 16, 1024> TemplateReplacementPool;
+extern TemplateReplacementPool _template_replacement_pool;
+
+struct TemplateReplacement : TemplateReplacementPool::PoolItem<&_template_replacement_pool> {
+	GroupID group;
+	TemplateID sel_template;
+
+	TemplateReplacement(GroupID gid, TemplateID tid) { this->group=gid; this->sel_template=tid; }
+	TemplateReplacement() {}
+	~TemplateReplacement() {}
+
+	inline GroupID Group() { return this->group; }
+	inline GroupID Template() { return this->sel_template; }
+
+ 	inline void SetGroup(GroupID gid) { this->group = gid; }
+ 	inline void SetTemplate(TemplateID tid) { this->sel_template = tid; }
+
+ 	inline TemplateID GetTemplateVehicleID() { return sel_template; }
+ 	inline const TemplateVehicle* GetTemplateVehicle() {
+		const TemplateVehicle *tv;
+		FOR_ALL_TEMPLATES(tv) {
+			if ( tv->index == this->sel_template )
+				return tv;
+		}
+		return NULL;
+	}
+};
+
+TemplateReplacement* GetTemplateReplacementByGroupID(GroupID);
+TemplateReplacement* GetTemplateReplacementByTemplateID(TemplateID);
+bool IssueTemplateReplacement(GroupID, TemplateID);
+
+short deleteIllegalTemplateReplacements(GroupID);
+
+#endif /* TEMPLATE_VEH_H */
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff -urNad openttd-1.3.2/src/aircraft_cmd.cpp openttd-1.3.2-DC3.0RC3/src/aircraft_cmd.cpp
--- openttd-1.3.2/src/aircraft_cmd.cpp	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/aircraft_cmd.cpp	2013-11-22 05:49:06.000000000 +0100
@@ -35,16 +35,15 @@
 #include "engine_base.h"
 #include "core/random_func.hpp"
 #include "core/backup_type.hpp"
+#include "infrastructure_func.h"
 #include "zoom_func.h"
+#include "cargotype.h"
+#include "tile_map.h"
 
 #include "table/strings.h"
 
 static const int ROTOR_Z_OFFSET         = 5;    ///< Z Offset between helicopter- and rotorsprite.
 
-static const int PLANE_HOLDING_ALTITUDE = 150;  ///< Altitude of planes in holding pattern (= lowest flight altitude).
-static const int HELI_FLIGHT_ALTITUDE   = 184;  ///< Normal flight altitude of helicopters.
-
-
 void Aircraft::UpdateDeltaXY(Direction direction)
 {
 	this->x_offs = -1;
@@ -123,7 +122,7 @@
 	const AircraftVehicleInfo *avi = AircraftVehInfo(v->engine_type);
 
 	FOR_ALL_STATIONS(st) {
-		if (st->owner != v->owner || !(st->facilities & FACIL_AIRPORT)) continue;
+		if (!IsInfraUsageAllowed(VEH_AIRCRAFT, v->owner, st->owner) || !(st->facilities & FACIL_AIRPORT)) continue;
 
 		const AirportFTAClass *afc = st->airport.GetFTA();
 		if (!st->airport.HasHangar() || (
@@ -149,6 +148,27 @@
 	return index;
 }
 
+#if 0
+/** Check if given vehicle has a goto hangar in his orders
+ * @param v vehicle to inquiry
+ * @return true if vehicle v has an airport in the schedule, that has a hangar */
+static bool HaveHangarInOrderList(Aircraft *v)
+{
+	const Order *order;
+
+	FOR_VEHICLE_ORDERS(v, order) {
+		const Station *st = Station::Get(order->station);
+		if (IsInfraUsageAllowed(VEH_AIRCRAFT, v->owner, st->owner) && (st->facilities & FACIL_AIRPORT)) {
+			/* If an airport doesn't have a hangar, skip it */
+			if (st->Airport()->nof_depots != 0)
+				return true;
+		}
+	}
+
+	return false;
+}
+#endif
+
 SpriteID Aircraft::GetImage(Direction direction, EngineImageType image_type) const
 {
 	uint8 spritenum = this->spritenum;
@@ -300,6 +320,8 @@
 		v->state = HANGAR;
 		v->previous_pos = v->pos;
 		v->targetairport = GetStationIndex(tile);
+		v->in_min_height_correction = false;
+		v->in_max_height_correction = false;
 		v->SetNext(u);
 
 		v->SetServiceInterval(Company::Get(_current_company)->settings.vehicle.servint_aircraft);
@@ -575,6 +597,13 @@
 		/* Squared it now so we don't have to do it later all the time. */
 		v->acache.cached_max_range_sqr = v->acache.cached_max_range * v->acache.cached_max_range;
 	}
+
+	/* Cache carried cargo types. */
+	uint32 cargo_mask = 0;
+	for (Aircraft *u = v; u != NULL; u = u->Next()) {
+		if (u->cargo_type != INVALID_CARGO && u->cargo_cap > 0) SetBit(cargo_mask, u->cargo_type);
+	}
+	v->vcache.cached_cargo_mask = cargo_mask;
 }
 
 
@@ -652,20 +681,22 @@
 }
 
 /**
- * Gets the cruise altitude of an aircraft.
- * The cruise altitude is determined by the velocity of the vehicle
- * and the direction it is moving
- * @param v The vehicle. Should be an aircraft
- * @returns Altitude in pixel units
+ * Get the offset in pixels to be added to the AIRCRAFT_MIN_FLYING_ALTITUDE,
+ * AIRCRAFT_MAX_FLYING_ALTITUDE constants, in order to make collisions less probable.
+ * The offset is determined by the velocity of the vehicle and the direction it is moving.
+ *
+ * @param v The aircraft that needs an offset.
+ * @return Offset in pixels to be added to the flying altitude.
  */
-int GetAircraftFlyingAltitude(const Aircraft *v)
+int GetAircraftFlyingAltitudeOffset(const Aircraft *v)
 {
-	if (v->subtype == AIR_HELICOPTER) return HELI_FLIGHT_ALTITUDE;
+	uint offset = 0;
 
-	/* Make sure Aircraft fly no lower so that they don't conduct
-	 * CFITs (controlled flight into terrain)
-	 */
-	int base_altitude = PLANE_HOLDING_ALTITUDE;
+	if (v->subtype == AIR_HELICOPTER) {
+		offset = HELICOPTER_HOLD_MAX_FLYING_ALTITUDE - PLANE_HOLD_MAX_FLYING_ALTITUDE;	
+	} else {
+		offset = 0;
+	}
 
 	/* Make sure eastbound and westbound planes do not "crash" into each
 	 * other by providing them with vertical separation
@@ -675,16 +706,92 @@
 		case DIR_NE:
 		case DIR_E:
 		case DIR_SE:
-			base_altitude += 10;
+			offset += 10;
 			break;
 
 		default: break;
 	}
 
 	/* Make faster planes fly higher so that they can overtake slower ones */
-	base_altitude += min(20 * (v->vcache.cached_max_speed / 200), 90);
+	offset += min(20 * (v->vcache.cached_max_speed / 200), 90);
+	return offset;
+}
 
-	return base_altitude;
+/**
+ * Get the tile height below the aircraft.
+ * This function is needed because aircraft can leave the mapborders.
+ * The game would crash if an aircraft leaves the northeast or southeast border.
+ * Just for completeness we check all four map edges.
+ *
+ * @param x_pos x position of the aircraft's shadow on the map.
+ * @param y_pos y position of the aircraft's shadow on the map.
+ * @return the tileheight below the aircaft's shadow.
+ */
+int GetTileHeightBelowAircraft(int x_pos, int y_pos) {
+	TileIndex tile = TileVirtXY(x_pos, y_pos);
+	int tile_height;
+
+	/* Check for being inside the map. If not call TileHeightOutsideMap() instead of TileHeight(). */
+	if (IsInsideMM(x_pos, 0, (int)MapSizeX() * (int)TILE_SIZE)
+			&& IsInsideMM(y_pos, 0, (int)MapSizeY() * (int)TILE_SIZE)) {
+		tile_height = TileHeight(tile) * TILE_HEIGHT;
+	} else {
+		tile_height = TileHeightOutsideMap(x_pos, y_pos) * TILE_HEIGHT;
+	}
+
+	return tile_height;
+}
+
+/**
+ * Get the height in pixels, from level 0, dependant on terrain below,
+ * at wich an aircraft should start increasing it's altitude,
+ * to prevent aircraft crashing in higher terrain ahead.
+ *
+ * @param x_pos x position of the aircraft's shadow on the map.
+ * @param y_pos y position of the aircraft's shadow on the map.
+ * @param offset offset to add to returned altitude.
+ * @return Minimal aircraft flying altitude above ground, while in normal flight, in pixels.
+ */
+int GetAircraftMinAltitude(int x_pos, int y_pos, int offset)
+{
+	int tile_height = GetTileHeightBelowAircraft(x_pos, y_pos);
+
+	return tile_height + AIRCRAFT_MIN_FLYING_ALTITUDE + offset;
+}
+
+/**
+ * Get the height in pixels, from level 0, dependant on terrain below,
+ * at wich an aircraft should start decreasing it's altitude,
+ * to prevent aircraft taking off to space.
+ *
+ * @param x_pos x position of the aircraft's shadow on the map.
+ * @param y_pos y position of the aircraft's shadow on the map.
+ * @param offset offset to add to returned altitude.
+ * @return Maximal aircraft flying altitude above ground, while in normal flight, in pixels.
+ */
+int GetAircraftMaxAltitude(int x_pos, int y_pos, int offset)
+{
+	int tile_height = GetTileHeightBelowAircraft(x_pos, y_pos);
+
+	return tile_height + AIRCRAFT_MAX_FLYING_ALTITUDE + offset;
+}
+
+/**
+ * Checks the flightpath height of the aircraft, in pixels, from level 0, dependant on terrain below,
+ * after adjusting height.
+ *
+ * @param v The aircraft that may or may not need to decrease its altitude.
+ * @return Maximal aircraft holding altitude, while in normal flight, in pixels.
+ */
+int GetAircraftHoldMaxAltitude(const Aircraft *v)
+{
+	int tile_height = GetTileHeightBelowAircraft(v->x_pos, v->y_pos);
+
+	if (v->subtype == AIR_HELICOPTER) {
+		return tile_height + HELICOPTER_HOLD_MAX_FLYING_ALTITUDE;
+	} else {
+		return tile_height + PLANE_HOLD_MAX_FLYING_ALTITUDE;
+	}
 }
 
 /**
@@ -699,7 +806,7 @@
  * @param v   The vehicle that is approaching the airport
  * @param apc The Airport Class being approached.
  * @param rotation The rotation of the airport.
- * @returns   The index of the entry point
+ * @return   The index of the entry point
  */
 static byte AircraftGetEntryPoint(const Aircraft *v, const AirportFTAClass *apc, Direction rotation)
 {
@@ -776,7 +883,8 @@
 			UpdateAircraftCache(v);
 			AircraftNextAirportPos_and_Order(v);
 			/* get aircraft back on running altitude */
-			SetAircraftPosition(v, v->x_pos, v->y_pos, GetAircraftFlyingAltitude(v));
+			int new_z_pos = GetAircraftMaxAltitude(v->x_pos, v->y_pos, GetAircraftFlyingAltitudeOffset(v));
+			SetAircraftPosition(v, v->x_pos, v->y_pos, new_z_pos);
 			return false;
 		}
 	}
@@ -804,14 +912,15 @@
 			count = UpdateAircraftSpeed(v);
 			if (count > 0) {
 				v->tile = 0;
-				int z_dest = GetAircraftFlyingAltitude(v);
+
+				int aircraft_max_altitude = GetAircraftMaxAltitude(v->x_pos, v->y_pos, GetAircraftFlyingAltitudeOffset(v));
 
 				/* Reached altitude? */
-				if (v->z_pos >= z_dest) {
+				if (v->z_pos >= (int)aircraft_max_altitude) {
 					v->cur_speed = 0;
 					return true;
 				}
-				SetAircraftPosition(v, v->x_pos, v->y_pos, min(v->z_pos + count, z_dest));
+				SetAircraftPosition(v, v->x_pos, v->y_pos, min(v->z_pos + count, aircraft_max_altitude));
 			}
 		}
 		return false;
@@ -874,6 +983,9 @@
 		if (!UpdateAircraftSpeed(v, SPEED_LIMIT_TAXI)) return false;
 
 		v->direction = ChangeDir(v->direction, dirdiff > DIRDIFF_REVERSE ? DIRDIFF_45LEFT : DIRDIFF_45RIGHT);
+
+		DEBUG(misc, 9, "New direction: %i", (int)v->direction);
+
 		v->cur_speed >>= 1;
 
 		SetAircraftPosition(v, v->x_pos, v->y_pos, v->z_pos);
@@ -961,11 +1073,63 @@
 		int z = v->z_pos;
 
 		if (amd.flag & AMED_TAKEOFF) {
-			z = min(z + 2, GetAircraftFlyingAltitude(v));
+			int aircraft_max_altitude = GetAircraftMaxAltitude(v->x_pos, v->y_pos, GetAircraftFlyingAltitudeOffset(v));
+
+			if (aircraft_max_altitude >= z) {
+				/* The aircraft rises or has reached its flying altitude. */
+				z = min(z + 2, GetAircraftMaxAltitude(v->x_pos, v->y_pos, GetAircraftFlyingAltitudeOffset(v)));
+			} else {
+				/* Aircraft has reached its flying altitude, but then the terrain
+				 * gets lower. So, its flying altitude also decreases.
+				 * We ignore this effect here, as lowering altitude during takeoff
+				 * would be a bit strange. */
+			}
 		}
 
-		/* Let the plane drop from normal flight altitude to holding pattern altitude */
-		if ((amd.flag & AMED_HOLD) && (z > PLANE_HOLDING_ALTITUDE)) z--;
+		if ((amd.flag & AMED_SLOWTURN) && (amd.flag & AMED_NOSPDCLAMP)) {
+			/* Aircraft is in flight. We want to enforce it being somewhere
+			 * between the minimum and the maximum allowed altitude. */
+			int aircraft_min_altitude = GetAircraftMinAltitude(v->x_pos, v->y_pos, GetAircraftFlyingAltitudeOffset(v));
+			int aircraft_max_altitude = GetAircraftMaxAltitude(v->x_pos, v->y_pos, GetAircraftFlyingAltitudeOffset(v));
+			int aircraft_middle_altitude = aircraft_min_altitude + (aircraft_max_altitude - aircraft_min_altitude) / 2;
+
+			/* If those assumptions would be violated, aircrafts would behave
+			 * fairly strange. */
+			assert(aircraft_min_altitude < aircraft_max_altitude);
+			assert(aircraft_min_altitude < aircraft_middle_altitude);
+			assert(aircraft_middle_altitude < aircraft_max_altitude);
+
+			if (z < aircraft_min_altitude
+					|| (v->in_min_height_correction && z < aircraft_middle_altitude)) {
+				/* Rise. And don't fly into that mountain right ahead.
+				 * And avoid our aircraft become a stairclimber, so if we start
+				 * correcting altitude, then we stop correction not too early. */
+				v->in_min_height_correction = true;
+				z += 2;
+
+			} else if (z > aircraft_max_altitude
+					|| (v->in_max_height_correction && z > aircraft_middle_altitude)) {
+				/* Fly lower. You are an aircraft, not an UFO.
+				 * And again, don't stop correcting altitude too early. */
+				v->in_max_height_correction = true;
+				z--;
+
+			} else if (v->in_min_height_correction && z >= aircraft_middle_altitude) {
+				/* Now, we have corrected altitude enough. */
+				v->in_min_height_correction = false;
+
+			} else if (v->in_max_height_correction && z <= aircraft_middle_altitude) {
+				/* Now, we have corrected altitude enough. */
+				v->in_max_height_correction = false;
+			}
+		}
+
+		if (amd.flag & AMED_HOLD) {
+			int aircraft_max_hold_altitude = GetAircraftHoldMaxAltitude(v);
+			if (z > aircraft_max_hold_altitude) {
+				z--;
+			}
+		}
 
 		if (amd.flag & AMED_LAND) {
 			if (st->airport.tile == INVALID_TILE) {
@@ -974,7 +1138,8 @@
 				UpdateAircraftCache(v);
 				AircraftNextAirportPos_and_Order(v);
 				/* get aircraft back on running altitude */
-				SetAircraftPosition(v, gp.x, gp.y, GetAircraftFlyingAltitude(v));
+				int new_z_pos = GetAircraftMaxAltitude(v->x_pos, v->y_pos, GetAircraftFlyingAltitudeOffset(v));
+				SetAircraftPosition(v, gp.x, gp.y, new_z_pos);
 				continue;
 			}
 
@@ -989,6 +1154,9 @@
 			if (delta >= t) {
 				z -= CeilDiv(z - curz, t);
 			}
+
+			DEBUG(misc, 9, "AMED_LAND: New z is %i", z);
+
 			if (z < curz) z = curz;
 		}
 
@@ -1023,7 +1191,7 @@
 	if (v->crashed_counter < 500 && st == NULL && ((v->crashed_counter % 3) == 0) ) {
 		int z = GetSlopePixelZ(v->x_pos, v->y_pos);
 		v->z_pos -= 1;
-		if (v->z_pos == z) {
+		if (v->z_pos == (int32)z) {
 			v->crashed_counter = 500;
 			v->z_pos++;
 		}
@@ -1048,14 +1216,15 @@
 	} else if (v->crashed_counter >= 10000) {
 		/*  remove rubble of crashed airplane */
 
-		/* clear runway-in on all airports, set by crashing plane
-		 * small airports use AIRPORT_BUSY, city airports use RUNWAY_IN_OUT_block, etc.
-		 * but they all share the same number */
-		if (st != NULL) {
-			CLRBITS(st->airport.flags, RUNWAY_IN_block);
-			CLRBITS(st->airport.flags, RUNWAY_IN_OUT_block); // commuter airport
-			CLRBITS(st->airport.flags, RUNWAY_IN2_block);    // intercontinental
-		}
+    /*  blocks are cleared in vehicle.cpp  (on line 694 of file version r23050), so this makes only bug on airports with 2+ landing runways*/
+//		/* clear runway-in on all airports, set by crashing plane
+//		 * small airports use AIRPORT_BUSY, city airports use RUNWAY_IN_OUT_block, etc.
+//		 * but they all share the same number */
+//		if (st != NULL) {
+//			CLRBITS(st->airport.flags, RUNWAY_IN_block);
+//			CLRBITS(st->airport.flags, RUNWAY_IN_OUT_block); // commuter airport
+//			CLRBITS(st->airport.flags, RUNWAY_IN2_block);    // intercontinental
+//		}
 
 		delete v;
 
@@ -1235,7 +1404,6 @@
 	if (v->current_order.IsType(OT_GOTO_DEPOT)) return;
 
 	Station *st = Station::Get(v->targetairport);
-	v->last_station_visited = v->targetairport;
 
 	/* Check if station was ever visited before */
 	if (!(st->had_vehicle_of_type & HVOT_AIRCRAFT)) {
@@ -1252,7 +1420,7 @@
 		Game::NewEvent(new ScriptEventStationFirstVehicle(st->index, v->index));
 	}
 
-	v->BeginLoading();
+	v->BeginLoading(v->targetairport);
 }
 
 /**
@@ -1484,7 +1652,7 @@
 	Station *st = Station::Get(v->targetairport);
 
 	/* Runway busy, not allowed to use this airstation or closed, circle. */
-	if (CanVehicleUseStation(v, st) && (st->owner == OWNER_NONE || st->owner == v->owner) && !(st->airport.flags & AIRPORT_CLOSED_block)) {
+	if (CanVehicleUseStation(v, st) && IsInfraUsageAllowed(VEH_AIRCRAFT, v->owner, st->owner) && !(st->airport.flags & AIRPORT_CLOSED_block)) {
 		/* {32,FLYING,NOTHING_block,37}, {32,LANDING,N,33}, {32,HELILANDING,N,41},
 		 * if it is an airplane, look for LANDING, for helicopter HELILANDING
 		 * it is possible to choose from multiple landing runways, so loop until a free one is found */
@@ -1504,6 +1672,7 @@
 					 * they all have heading LANDING). And also occupy that block! */
 					v->pos = current->next_position;
 					SETBITS(st->airport.flags, apc->layout[v->pos].block);
+          SETBITS(st->airport.flags2, apc->layout[v->pos].block2);
 					return;
 				}
 				v->cur_speed = tcur_speed;
@@ -1599,15 +1768,33 @@
 	AircraftEventHandler_AtTerminal,     // TERM7          = 19
 	AircraftEventHandler_AtTerminal,     // TERM8          = 20
 	AircraftEventHandler_AtTerminal,     // HELIPAD3       = 21
+	AircraftEventHandler_AtTerminal,     // TERM9          = 22
+	AircraftEventHandler_AtTerminal,     // TERM10         = 23
+	AircraftEventHandler_AtTerminal,     // TERM11         = 24
+	AircraftEventHandler_AtTerminal,     // TERM12         = 25
+	AircraftEventHandler_AtTerminal,     // TERM13         = 26
+	AircraftEventHandler_AtTerminal,     // TERM14         = 27
+	AircraftEventHandler_AtTerminal,     // TERM15         = 28
+	AircraftEventHandler_AtTerminal,     // TERM16         = 29
+	AircraftEventHandler_AtTerminal,     // TERM17         = 30
+	AircraftEventHandler_AtTerminal,     // TERM18         = 31
+	AircraftEventHandler_AtTerminal,     // TERM19         = 32
+	AircraftEventHandler_AtTerminal,     // TERM20         = 33
 };
 
 static void AirportClearBlock(const Aircraft *v, const AirportFTAClass *apc)
 {
 	/* we have left the previous block, and entered the new one. Free the previous block */
-	if (apc->layout[v->previous_pos].block != apc->layout[v->pos].block) {
+	if ((apc->layout[v->previous_pos].block != apc->layout[v->pos].block)||(apc->layout[v->previous_pos].block2 != apc->layout[v->pos].block2)) {
 		Station *st = Station::Get(v->targetairport);
 
-		CLRBITS(st->airport.flags, apc->layout[v->previous_pos].block);
+    /* if we have left circle block, then make space for another aircrafts in circle area of airport */
+    if ((apc->layout[v->previous_pos].block2 & (apc->layout[v->previous_pos].block2 ^ apc->layout[v->pos].block2)) & CIRCLE_block) {
+    st->airport.num_circle--;
+    }
+    
+		CLRBITS(st->airport.flags, apc->layout[v->previous_pos].block & (apc->layout[v->previous_pos].block ^ apc->layout[v->pos].block));
+    CLRBITS(st->airport.flags2, apc->layout[v->previous_pos].block2 & (apc->layout[v->previous_pos].block2 ^ apc->layout[v->pos].block2));
 	}
 }
 
@@ -1661,6 +1848,19 @@
 				v->pos = current->next_position;
 				UpdateAircraftCache(v);
 			} // move to next position
+      
+      /* if way is occupied, check if airport is offering us another way */
+      else {  
+        if( current->next != NULL) {
+          if (current->heading == current->next->heading){
+            current = current->next;
+            if (AirportSetBlocks(v, current, apc)) {
+				      v->pos = current->next_position;
+				      UpdateAircraftCache(v);
+            } // move to next position
+          }
+        }  
+      }
 			return false;
 		}
 		current = current->next;
@@ -1677,16 +1877,18 @@
 	const AirportFTA *next = &apc->layout[current_pos->next_position];
 
 	/* same block, then of course we can move */
-	if (apc->layout[current_pos->position].block != next->block) {
+	if ((apc->layout[current_pos->position].block != next->block)||(apc->layout[current_pos->position].block != next->block)){
 		const Station *st = Station::Get(v->targetairport);
 		uint64 airport_flags = next->block;
+    uint64 airport_flags2 = next->block2;
 
 		/* check additional possible extra blocks */
 		if (current_pos != reference && current_pos->block != NOTHING_block) {
 			airport_flags |= current_pos->block;
+      airport_flags2 |= current_pos->block2;
 		}
 
-		if (st->airport.flags & airport_flags) {
+		if ((st->airport.flags & airport_flags) || (st->airport.flags2 & airport_flags2)) {
 			v->cur_speed = 0;
 			v->subspeed = 0;
 			return true;
@@ -1708,15 +1910,19 @@
 	const AirportFTA *reference = &apc->layout[v->pos];
 
 	/* if the next position is in another block, check it and wait until it is free */
-	if ((apc->layout[current_pos->position].block & next->block) != next->block) {
+	if ((apc->layout[current_pos->position].block != next->block) || (apc->layout[current_pos->position].block2 != next->block2)) {
 		uint64 airport_flags = next->block;
+    uint64 airport_flags2 = next->block2;
 		/* search for all all elements in the list with the same state, and blocks != N
 		 * this means more blocks should be checked/set */
 		const AirportFTA *current = current_pos;
 		if (current == reference) current = current->next;
 		while (current != NULL) {
-			if (current->heading == current_pos->heading && current->block != 0) {
-				airport_flags |= current->block;
+			if (current->heading == current_pos->heading ) {
+        if (( current->block != 0) || ( current->block2 != 0)) {
+	  			airport_flags |= current->block;
+          airport_flags2 |= current->block2;
+        }
 				break;
 			}
 			current = current->next;
@@ -1724,17 +1930,26 @@
 
 		/* if the block to be checked is in the next position, then exclude that from
 		 * checking, because it has been set by the airplane before */
-		if (current_pos->block == next->block) airport_flags ^= next->block;
+		if ((current_pos->block & next->block) || (current_pos->block2 & next->block2)) { 
+      airport_flags ^= (current_pos->block & next->block);
+      airport_flags2 ^= (current_pos->block2 & next->block2);
+    }
 
 		Station *st = Station::Get(v->targetairport);
-		if (st->airport.flags & airport_flags) {
+		if (((st->airport.flags & airport_flags) || (st->airport.flags2 & airport_flags2)) || ((airport_flags2 & CIRCLE_block) && (st->airport.num_circle == st->airport.GetMaxCircle(v->tile)))){
 			v->cur_speed = 0;
 			v->subspeed = 0;
 			return false;
 		}
 
+    if (airport_flags2 & CIRCLE_block) {
+      st->airport.num_circle++;
+      airport_flags2 ^= CIRCLE_block;
+		}
+
 		if (next->block != NOTHING_block) {
 			SETBITS(st->airport.flags, airport_flags); // occupy next block
+      SETBITS(st->airport.flags2, airport_flags2); // occupy next block2
 		}
 	}
 	return true;
@@ -1759,6 +1974,18 @@
 	{TERM6, TERM6_block},
 	{TERM7, TERM7_block},
 	{TERM8, TERM8_block},
+	{TERM9, TERM9_block},
+	{TERM10, TERM10_block},
+	{TERM11, TERM11_block},
+	{TERM12, TERM12_block},
+	{TERM13, TERM13_block},
+	{TERM14, TERM14_block},
+	{TERM15, TERM15_block},
+	{TERM16, TERM16_block},
+	{TERM17, TERM17_block},
+	{TERM18, TERM18_block},
+	{TERM19, TERM19_block},
+	{TERM20, TERM20_block},
 	{HELIPAD1, HELIPAD1_block},
 	{HELIPAD2, HELIPAD2_block},
 	{HELIPAD3, HELIPAD3_block},
@@ -1824,7 +2051,7 @@
 
 		while (temp != NULL) {
 			if (temp->heading == 255) {
-				if (!(st->airport.flags & temp->block)) {
+				if ((!(st->airport.flags & temp->block)) && (!(st->airport.flags2 & temp->block2))){
 					/* read which group do we want to go to?
 					 * (the first free group) */
 					uint target_group = temp->next_position + 1;
diff -urNad openttd-1.3.2/src/aircraft_gui.cpp openttd-1.3.2-DC3.0RC3/src/aircraft_gui.cpp
--- openttd-1.3.2/src/aircraft_gui.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/aircraft_gui.cpp	2013-11-22 05:49:06.000000000 +0100
@@ -33,6 +33,9 @@
 {
 	int y_offset = (v->Next()->cargo_cap != 0) ? -(FONT_HEIGHT_NORMAL + 1): 0;
 	Money feeder_share = 0;
+        CargoArray act_cargo;
+        CargoDestSummary dests[NUM_CARGO];
+        CargoArray max_cargo;
 
 	for (const Aircraft *u = v; u != NULL; u = u->Next()) {
 		if (u->IsNormalAircraft()) {
@@ -60,12 +63,39 @@
 				SetDParam(2, u->cargo.Source());
 				DrawString(left, right, y + 2 * FONT_HEIGHT_NORMAL + 1 + y_offset, STR_VEHICLE_DETAILS_CARGO_FROM);
 				feeder_share += u->cargo.FeederShare();
+                                act_cargo[u->cargo_type] += u->cargo.Count();
+                                AddVehicleCargoDestSummary(u, &dests[u->cargo_type]);
 			}
 		}
 	}
 
 	SetDParam(0, feeder_share);
 	DrawString(left, right, y + 3 * FONT_HEIGHT_NORMAL + 3 + y_offset, STR_VEHICLE_INFO_FEEDER_CARGO_VALUE);
+
+        y_offset += 3 * FONT_HEIGHT_NORMAL + 6;
+        max_cargo[v->cargo_type] += v->cargo_cap;
+       DrawString(left, right, y + FONT_HEIGHT_NORMAL + y_offset, STR_STATION_VIEW_WAITING_TO_BUTTON);
+
+                for (CargoID i = 0; i < NUM_CARGO; i++) {
+                        if (max_cargo[i] > 0) {
+                                SetDParam(0, i);            // {CARGO} #1
+                                SetDParam(1, act_cargo[i]); // {CARGO} #2
+                                SetDParam(2, i);            // {SHORTCARGO} #1
+                                SetDParam(3, max_cargo[i]); // {SHORTCARGO} #2
+                                SetDParam(4, _settings_game.vehicle.freight_trains);
+                                DrawString(left, right, y + 2 * FONT_HEIGHT_NORMAL + 1 + y_offset, STR_VEHICLE_DETAILS_TRAIN_TOTAL_CAPACITY);
+                               y_offset += FONT_HEIGHT_NORMAL + 1;
+                        }
+                        for (CargoDestSummary::const_iterator row = dests[i].begin(); row != dests[i].end(); ++row) {
+                                        SetDParam(0, i);          // {SHORTCARGO} #1
+                                        SetDParam(1, row->count); // {SHORTCARGO} #2
+                                        SetDParam(2, row->type == ST_INDUSTRY ? STR_INDUSTRY_NAME : (row->type == ST_TOWN ? STR_TOWN_NAME : STR_COMPANY_NAME)); // {STRING1}
+                                        SetDParam(3, row->dest);  // Parameter of {STRING1}
+                                        DrawString(left + 2 * WD_PAR_VSEP_WIDE, right, y + 2 * FONT_HEIGHT_NORMAL + 1 + y_offset, STR_VEHICLE_DETAILS_CARGO_TO);
+                                       y_offset += FONT_HEIGHT_NORMAL + 1;
+                        }
+                }
+
 }
 
 
diff -urNad openttd-1.3.2/src/aircraft.h openttd-1.3.2-DC3.0RC3/src/aircraft.h
--- openttd-1.3.2/src/aircraft.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/aircraft.h	2013-11-22 05:49:06.000000000 +0100
@@ -15,6 +15,19 @@
 #include "station_map.h"
 #include "vehicle_base.h"
 
+/**
+ * Minimal, Maximal and Holding flying altitude above ground while a plane is in flight
+ * and not starting or landing, i.e. in the state SLOWTURN & NOSPDCLAMP.
+ * Under certain circumstances, the actual flying altitude is
+ * higher, because certain offsets are added.
+ */
+enum AircraftFlyingAltitude {
+	AIRCRAFT_MIN_FLYING_ALTITUDE        = 120, ///< minimal flying altitude above tile
+	AIRCRAFT_MAX_FLYING_ALTITUDE        = 360, ///< maximal flying altitude above tile
+	PLANE_HOLD_MAX_FLYING_ALTITUDE      = 150, ///< holding flying altitude above tile of planes.
+	HELICOPTER_HOLD_MAX_FLYING_ALTITUDE = 184  ///< holding flying altitude above tile of helicopters.
+};
+
 struct Aircraft;
 
 /** An aircraft can be one of those types. */
@@ -38,6 +51,9 @@
 
 void AircraftLeaveHangar(Aircraft *v, Direction exit_dir);
 void AircraftNextAirportPos_and_Order(Aircraft *v);
+int GetAircraftMinAltitude(int x_pos, int y_pos, int offset);
+int GetAircraftMaxAltitude(int x_pos, int y_pos, int offset);
+int GetAircraftHoldMaxAltitude(const Aircraft *v);
 void SetAircraftPosition(Aircraft *v, int x, int y, int z);
 int GetAircraftFlyingAltitude(const Aircraft *v);
 
@@ -63,6 +79,22 @@
 
 	AircraftCache acache;
 
+	/**
+	 * True if an only if the aircraft has touched its upper altitude limit
+	 * and currently corrects its altitude. Used in order to avoid the
+	 * aircraft "stairclimbing". When an aircraft starts correcting
+	 * altitude it should make a rather big correction in one step.
+	 */
+	bool in_max_height_correction;
+
+	/**
+	 * True if an only if the aircraft has touched its lower altitude limit
+	 * and currently corrects its altitude. Used in order to avoid the
+	 * aircraft "stairclimbing". When an aircraft starts correcting
+	 * altitude it should make a rather big correction in one step.
+	 */
+	bool in_min_height_correction;
+
 	/** We don't want GCC to zero our struct! It already is zeroed and has an index! */
 	Aircraft() : SpecializedVehicleBase() {}
 	/** We want to 'destruct' the right class. */
diff -urNad openttd-1.3.2/src/airport.cpp openttd-1.3.2-DC3.0RC3/src/airport.cpp
--- openttd-1.3.2/src/airport.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/airport.cpp	2013-11-22 05:49:06.000000000 +0100
@@ -55,6 +55,8 @@
 HELIPORT(helidepot, 1, 0)
 AIRPORT(intercontinental, 2, false)
 HELIPORT(helistation, 3, 0)
+AIRPORT(intercontinental2, 2, false)
+AIRPORT(circle, 0, false)
 HELIPORT(oilrig, 1, 54)
 AIRPORT_GENERIC(dummy, NULL, 0, AirportFTAClass::ALL, 0)
 
@@ -178,6 +180,7 @@
 		current->position      = apFA[internalcounter].position;
 		current->heading       = apFA[internalcounter].heading;
 		current->block         = apFA[internalcounter].block;
+		current->block2        = apFA[internalcounter].block2;
 		current->next_position = apFA[internalcounter].next;
 
 		/* outgoing nodes from the same position, create linked list */
@@ -187,6 +190,7 @@
 			newNode->position      = apFA[internalcounter + 1].position;
 			newNode->heading       = apFA[internalcounter + 1].heading;
 			newNode->block         = apFA[internalcounter + 1].block;
+	   	newNode->block2        = apFA[internalcounter + 1].block2;
 			newNode->next_position = apFA[internalcounter + 1].next;
 			/* create link */
 			current->next = newNode;
diff -urNad openttd-1.3.2/src/airport.h openttd-1.3.2-DC3.0RC3/src/airport.h
--- openttd-1.3.2/src/airport.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/airport.h	2013-11-22 05:49:06.000000000 +0100
@@ -16,30 +16,32 @@
 #include "tile_type.h"
 
 /** Some airport-related constants */
-static const uint MAX_TERMINALS =   8;                       ///< maximum number of terminals per airport
+static const uint MAX_TERMINALS =  20;                       ///< maximum number of terminals per airport
 static const uint MAX_HELIPADS  =   3;                       ///< maximum number of helipads per airport
-static const uint MAX_ELEMENTS  = 255;                       ///< maximum number of aircraft positions at airport
+static const uint MAX_ELEMENTS  = 767;                       ///< maximum number of aircraft positions at airport
 
 static const uint NUM_AIRPORTTILES       = 256;              ///< total number of airport tiles
-static const uint NEW_AIRPORTTILE_OFFSET = 74;               ///< offset of first newgrf airport tile
+static const uint NEW_AIRPORTTILE_OFFSET = 96;               ///< offset of first newgrf airport tile
 static const uint INVALID_AIRPORTTILE    = NUM_AIRPORTTILES; ///< id for an invalid airport tile
 
 /** Airport types */
 enum AirportTypes {
-	AT_SMALL           =   0, ///< Small airport.
-	AT_LARGE           =   1, ///< Large airport.
-	AT_HELIPORT        =   2, ///< Heli port.
-	AT_METROPOLITAN    =   3, ///< Metropolitan airport.
-	AT_INTERNATIONAL   =   4, ///< International airport.
-	AT_COMMUTER        =   5, ///< Commuter airport.
-	AT_HELIDEPOT       =   6, ///< Heli depot.
-	AT_INTERCON        =   7, ///< Intercontinental airport.
-	AT_HELISTATION     =   8, ///< Heli station airport.
-	AT_OILRIG          =   9, ///< Oilrig airport.
-	NEW_AIRPORT_OFFSET =  10, ///< Number of the first newgrf airport.
-	NUM_AIRPORTS       = 128, ///< Maximal number of airports.
-	AT_INVALID         = 254, ///< Invalid airport.
-	AT_DUMMY           = 255, ///< Dummy airport.
+	AT_SMALL              =   0, ///< Small airport.
+	AT_LARGE              =   1, ///< Large airport.
+	AT_HELIPORT           =   2, ///< Heli port.
+	AT_METROPOLITAN       =   3, ///< Metropolitan airport.
+	AT_INTERNATIONAL      =   4, ///< International airport.
+	AT_COMMUTER           =   5, ///< Commuter airport.
+	AT_HELIDEPOT          =   6, ///< Heli depot.
+	AT_INTERCON           =   7, ///< Intercontinental airport.
+	AT_HELISTATION        =   8, ///< Heli station airport.
+  AT_INTERCONTINENTAL2  =   9, ///< Intercontinental airport 2.
+  AT_CIRCLE             =  10, ///< Circle airport.
+	AT_OILRIG             =  11, ///< Oilrig airport.
+	NEW_AIRPORT_OFFSET    =  12, ///< Number of the first newgrf airport.  
+	NUM_AIRPORTS          = 128, ///< Maximal number of airports.
+	AT_INVALID            = 254, ///< Invalid airport.
+	AT_DUMMY              = 255, ///< Dummy airport.
 };
 
 /** Flags for airport movement data. */
@@ -79,7 +81,19 @@
 	TERM7          = 19, ///< Heading for terminal 7.
 	TERM8          = 20, ///< Heading for terminal 8.
 	HELIPAD3       = 21, ///< Heading for helipad 3.
-	MAX_HEADINGS   = 21, ///< Last valid target to head for.
+	TERM9          = 22, ///< Heading for terminal 9.
+	TERM10         = 23, ///< Heading for terminal 10.
+	TERM11         = 24, ///< Heading for terminal 11.
+	TERM12         = 25, ///< Heading for terminal 12.
+	TERM13         = 26, ///< Heading for terminal 13.
+	TERM14         = 27, ///< Heading for terminal 14.
+	TERM15         = 28, ///< Heading for terminal 15.
+	TERM16         = 29, ///< Heading for terminal 16.
+	TERM17         = 30, ///< Heading for terminal 17.
+	TERM18         = 31, ///< Heading for terminal 18.
+	TERM19         = 32, ///< Heading for terminal 19.
+	TERM20         = 33, ///< Heading for terminal 20.
+	MAX_HEADINGS   = 33, ///< Last valid target to head for.
 };
 
 /** Movement Blocks on Airports blocks (eg_airport_flags). */
@@ -120,9 +134,42 @@
 	RUNWAY_OUT2_block        = 1ULL << 10, ///< @note re-uses #TAXIWAY_BUSY_block
 	HELIPAD_GROUP_block      = 1ULL << 13, ///< @note re-uses #AIRPORT_ENTRANCE_block
 	OUT_WAY_block2           = 1ULL << 31,
+       NEW_block                = 1ULL << 32,
+       NEW2_block               = 1ULL << 33,
+       NEW3_block               = 1ULL << 34,
+       NEW4_block               = 1ULL << 35,
+       NEW5_block               = 1ULL << 36,
+       NEW6_block               = 1ULL << 37,
+       NEW7_block               = 1ULL << 38,
+       NEW8_block               = 1ULL << 39,
+       NEW9_block               = 1ULL << 40,
+       NEW10_block              = 1ULL << 41,
+       NEW11_block              = 1ULL << 42,
+       NEW12_block              = 1ULL << 43,
+       NEW13_block              = 1ULL << 44,
+       NEW14_block              = 1ULL << 45,
+       NEW15_block              = 1ULL << 46,
+       NEW16_block              = 1ULL << 47,
+       NEW17_block              = 1ULL << 48,
+       NEW18_block              = 1ULL << 49,
+       NEW19_block              = 1ULL << 50,
+       NEW20_block              = 1ULL << 51,
+       TERM9_block              = 1ULL << 52,
+       TERM10_block             = 1ULL << 53,
+       TERM11_block             = 1ULL << 54,
+       TERM12_block             = 1ULL << 55,
+       TERM13_block             = 1ULL << 56,
+       TERM14_block             = 1ULL << 57,
+       TERM15_block             = 1ULL << 58,
+       TERM16_block             = 1ULL << 59,
+       TERM17_block             = 1ULL << 60,
+       TERM18_block             = 1ULL << 61,
+       TERM19_block             = 1ULL << 62,
+       TERM20_block             = 1ULL << 63,
 	/* end of new blocks */
 
-	NOTHING_block            = 1ULL << 30,
+       NOTHING_block            = 1ULL << 30,
+       CIRCLE_block             = 1ULL << 30, ///< @note re-uses #NOTHING_block. Uses in block2 on circle airport(s) as condition of counter st->num_circle
 	AIRPORT_CLOSED_block     = 1ULL << 63; ///< Dummy block for indicating a closed airport.
 
 /** A single location on an airport where aircraft can move to. */
@@ -188,6 +235,7 @@
 struct AirportFTA {
 	AirportFTA *next;        ///< possible extra movement choices from this position
 	uint64 block;            ///< 64 bit blocks (st->airport.flags), should be enough for the most complex airports
+  uint64 block2;           ///< additional 64 bit blocks for everytile-block airports 8*8 up to 11*11 every-tile
 	byte position;           ///< the position that an airplane is at
 	byte next_position;      ///< next position from this position
 	byte heading;            ///< heading (current orders), guiding an airplane to its target on an airport
diff -urNad openttd-1.3.2/src/articulated_vehicles.cpp openttd-1.3.2-DC3.0RC3/src/articulated_vehicles.cpp
--- openttd-1.3.2/src/articulated_vehicles.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/articulated_vehicles.cpp	2013-11-22 05:49:06.000000000 +0100
@@ -323,6 +323,7 @@
 	Vehicle *v = first;
 	for (uint i = 1; i < MAX_ARTICULATED_PARTS; i++) {
 		bool flip_image;
+		EngineID eid = GetNextArticulatedPart(i, first->engine_type);
 		EngineID engine_type = GetNextArticulatedPart(i, first->engine_type, first, &flip_image);
 		if (engine_type == INVALID_ENGINE) return;
 
diff -urNad openttd-1.3.2/src/autoreplace_cmd.cpp openttd-1.3.2-DC3.0RC3/src/autoreplace_cmd.cpp
--- openttd-1.3.2/src/autoreplace_cmd.cpp	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/autoreplace_cmd.cpp	2013-11-22 05:49:06.000000000 +0100
@@ -335,7 +335,7 @@
  * @param new_head The new head of the completely replaced vehicle chain
  * @param flags the command flags to use
  */
-static CommandCost CopyHeadSpecificThings(Vehicle *old_head, Vehicle *new_head, DoCommandFlag flags)
+CommandCost CopyHeadSpecificThings(Vehicle *old_head, Vehicle *new_head, DoCommandFlag flags)
 {
 	CommandCost cost = CommandCost();
 
diff -urNad openttd-1.3.2/src/autoreplace_func.h openttd-1.3.2-DC3.0RC3/src/autoreplace_func.h
--- openttd-1.3.2/src/autoreplace_func.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/autoreplace_func.h	2013-11-22 05:49:06.000000000 +0100
@@ -99,4 +99,7 @@
 
 bool CheckAutoreplaceValidity(EngineID from, EngineID to, CompanyID company);
 
+// MYGUI
+CommandCost CopyHeadSpecificThings(Vehicle*, Vehicle*, DoCommandFlag);
+
 #endif /* AUTOREPLACE_FUNC_H */
diff -urNad openttd-1.3.2/src/base_consist.h openttd-1.3.2-DC3.0RC3/src/base_consist.h
--- openttd-1.3.2/src/base_consist.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/base_consist.h	2013-11-22 05:49:06.000000000 +0100
@@ -14,6 +14,7 @@
 
 #include "order_type.h"
 #include "date_type.h"
+#include "timetable.h"
 
 /** Various front vehicle properties that are preserved when autoreplacing, using order-backup or switching front engines within a consist. */
 struct BaseConsist {
@@ -22,7 +23,11 @@
 	/* Used for timetabling. */
 	uint32 current_order_time;          ///< How many ticks have passed since this order started.
 	int32 lateness_counter;             ///< How many ticks late (or early if negative) this vehicle is.
+#if WALLCLOCK_NETWORK_COMPATIBLE
 	Date timetable_start;               ///< When the vehicle is supposed to start the timetable.
+#else
+	DateTicks timetable_start;          ///< When the vehicle is supposed to start the timetable.
+#endif
 
 	uint16 service_interval;            ///< The interval for (automatic) servicing; either in days or %.
 
diff -urNad openttd-1.3.2/src/base_station_base.h openttd-1.3.2-DC3.0RC3/src/base_station_base.h
--- openttd-1.3.2/src/base_station_base.h	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/base_station_base.h	2013-11-22 05:49:06.000000000 +0100
@@ -39,6 +39,7 @@
 	StationRect();
 	void MakeEmpty();
 	bool PtInExtendedRect(int x, int y, int distance = 0) const;
+	bool AreaInExtendedRect(const TileArea& area, int distance = 0) const;
 	bool IsEmpty() const;
 	CommandCost BeforeAddTile(TileIndex tile, StationRectMode mode);
 	CommandCost BeforeAddRect(TileIndex tile, int w, int h, StationRectMode mode);
diff -urNad openttd-1.3.2/src/bridge_gui.cpp openttd-1.3.2-DC3.0RC3/src/bridge_gui.cpp
--- openttd-1.3.2/src/bridge_gui.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/bridge_gui.cpp	2013-11-22 05:49:06.000000000 +0100
@@ -24,6 +24,7 @@
 #include "cmd_helper.h"
 #include "tunnelbridge_map.h"
 #include "road_gui.h"
+#include "tilehighlight_func.h"
 
 #include "widgets/bridge_widget.h"
 
@@ -116,8 +117,10 @@
 			case TRANSPORT_ROAD: _last_roadbridge_type = this->bridges->Get(i)->index; break;
 			default: break;
 		}
-		DoCommandP(this->end_tile, this->start_tile, this->type | this->bridges->Get(i)->index,
-					CMD_BUILD_BRIDGE | CMD_MSG(STR_ERROR_CAN_T_BUILD_BRIDGE_HERE), CcBuildBridge);
+		if (DoCommandP(this->end_tile, this->start_tile, this->type | this->bridges->Get(i)->index,
+				CMD_BUILD_BRIDGE | CMD_MSG(STR_ERROR_CAN_T_BUILD_BRIDGE_HERE), CcBuildBridge)) {
+			StoreRailPlacementEndpoints(this->start_tile, this->end_tile, (TileX(this->start_tile) == TileX(this->end_tile)) ? TRACK_Y : TRACK_X, false);
+		}
 	}
 
 	/** Sort the builable bridges */
diff -urNad openttd-1.3.2/src/bridge.h openttd-1.3.2-DC3.0RC3/src/bridge.h
--- openttd-1.3.2/src/bridge.h	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/bridge.h	2013-11-22 05:49:06.000000000 +0100
@@ -73,6 +73,7 @@
 void DrawBridgeMiddle(const TileInfo *ti);
 
 CommandCost CheckBridgeAvailability(BridgeType bridge_type, uint bridge_len, DoCommandFlag flags = DC_NONE);
+BridgeType FastestAvailableBridgeType(uint bridge_len);
 int CalcBridgeLenCostFactor(int x);
 
 void ResetBridges();
diff -urNad openttd-1.3.2/src/bridge_map.cpp openttd-1.3.2-DC3.0RC3/src/bridge_map.cpp
--- openttd-1.3.2/src/bridge_map.cpp	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/bridge_map.cpp	2013-11-22 05:49:06.000000000 +0100
@@ -19,9 +19,10 @@
  * @param tile the bridge tile to find the bridge ramp for
  * @param dir  the direction to search in
  */
-static TileIndex GetBridgeEnd(TileIndex tile, DiagDirection dir)
+template <bool Tgeneric>
+static typename TileIndexT<Tgeneric>::T GetBridgeEnd(typename TileIndexT<Tgeneric>::T tile, DiagDirection dir)
 {
-	TileIndexDiff delta = TileOffsByDiagDir(dir);
+	TileIndexDiff delta = TileOffsByDiagDir<Tgeneric>(dir, MapOf(tile));
 
 	dir = ReverseDiagDir(dir);
 	do {
@@ -30,6 +31,10 @@
 
 	return tile;
 }
+/** @copydoc GetBridgeEnd(TileIndexT<Tgeneric>::T,DiagDirection) */
+static inline TileIndex GetBridgeEnd(TileIndex t, DiagDirection dir) { return GetBridgeEnd<false>(t, dir); }
+/** @copydoc GetBridgeEnd(TileIndexT<Tgeneric>::T,DiagDirection) */
+static inline GenericTileIndex GetBridgeEnd(GenericTileIndex t, DiagDirection dir) { return GetBridgeEnd<true>(t, dir); }
 
 
 /**
@@ -56,18 +61,23 @@
  * Starting at one bridge end finds the other bridge end
  * @param t the bridge ramp tile to find the other bridge ramp for
  */
-TileIndex GetOtherBridgeEnd(TileIndex tile)
+template <bool Tgeneric>
+typename TileIndexT<Tgeneric>::T GetOtherBridgeEnd(typename TileIndexT<Tgeneric>::T tile)
 {
 	assert(IsBridgeTile(tile));
 	return GetBridgeEnd(tile, GetTunnelBridgeDirection(tile));
 }
+/* instantiate */
+template TileIndex GetOtherBridgeEnd<false>(TileIndex tile);
+template GenericTileIndex GetOtherBridgeEnd<true>(GenericTileIndex tile);
 
 /**
  * Get the height ('z') of a bridge.
  * @param tile the bridge ramp tile to get the bridge height from
  * @return the height of the bridge.
  */
-int GetBridgeHeight(TileIndex t)
+template <bool Tgeneric>
+int GetBridgeHeight(typename TileIndexT<Tgeneric>::T t)
 {
 	int h;
 	Slope tileh = GetTileSlope(t, &h);
@@ -76,3 +86,6 @@
 	/* one height level extra for the ramp */
 	return h + 1 + ApplyFoundationToSlope(f, &tileh);
 }
+/* instantiate */
+template int GetBridgeHeight<false>(TileIndex t);
+template int GetBridgeHeight<true>(GenericTileIndex t);
diff -urNad openttd-1.3.2/src/bridge_map.h openttd-1.3.2-DC3.0RC3/src/bridge_map.h
--- openttd-1.3.2/src/bridge_map.h	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/bridge_map.h	2013-11-22 05:49:06.000000000 +0100
@@ -21,21 +21,31 @@
  * @pre IsTileType(t, MP_TUNNELBRIDGE)
  * @return true if the structure is a bridge one
  */
-static inline bool IsBridge(TileIndex t)
+template <bool Tgeneric>
+static inline bool IsBridge(typename TileIndexT<Tgeneric>::T t)
 {
 	assert(IsTileType(t, MP_TUNNELBRIDGE));
-	return HasBit(_m[t].m5, 7);
+	return HasBit(GetTile(t)->m5, 7);
 }
+/** @copydoc IsBridge(TileIndexT<Tgeneric>::T) */
+static inline bool IsBridge(TileIndex t) { return IsBridge<false>(t); }
+/** @copydoc IsBridge(TileIndexT<Tgeneric>::T) */
+static inline bool IsBridge(GenericTileIndex t) { return IsBridge<true>(t); }
 
 /**
  * checks if there is a bridge on this tile
  * @param t The tile to analyze
  * @return true if a bridge is present
  */
-static inline bool IsBridgeTile(TileIndex t)
+template <bool Tgeneric>
+static inline bool IsBridgeTile(typename TileIndexT<Tgeneric>::T t)
 {
 	return IsTileType(t, MP_TUNNELBRIDGE) && IsBridge(t);
 }
+/** @copydoc IsBridgeTile(TileIndexT<Tgeneric>::T) */
+static inline bool IsBridgeTile(TileIndex t) { return IsBridgeTile<false>(t); }
+/** @copydoc IsBridgeTile(TileIndexT<Tgeneric>::T) */
+static inline bool IsBridgeTile(GenericTileIndex t) { return IsBridgeTile<true>(t); }
 
 /**
  * checks for the possibility that a bridge may be on this tile
@@ -43,11 +53,16 @@
  * @param t The tile to analyze
  * @return true if a bridge might be present
  */
-static inline bool MayHaveBridgeAbove(TileIndex t)
+template <bool Tgeneric>
+static inline bool MayHaveBridgeAbove(typename TileIndexT<Tgeneric>::T t)
 {
 	return IsTileType(t, MP_CLEAR) || IsTileType(t, MP_RAILWAY) || IsTileType(t, MP_ROAD) ||
 			IsTileType(t, MP_WATER) || IsTileType(t, MP_TUNNELBRIDGE) || IsTileType(t, MP_OBJECT);
 }
+/** @copydoc MayHaveBridgeAbove(TileIndexT<Tgeneric>::T) */
+static inline bool MayHaveBridgeAbove(TileIndex t) { return MayHaveBridgeAbove<false>(t); }
+/** @copydoc MayHaveBridgeAbove(TileIndexT<Tgeneric>::T) */
+static inline bool MayHaveBridgeAbove(GenericTileIndex t) { return MayHaveBridgeAbove<true>(t); }
 
 /**
  * checks if a bridge is set above the ground of this tile
@@ -55,11 +70,16 @@
  * @pre MayHaveBridgeAbove(t)
  * @return true if a bridge is detected above
  */
-static inline bool IsBridgeAbove(TileIndex t)
+template <bool Tgeneric>
+static inline bool IsBridgeAbove(typename TileIndexT<Tgeneric>::T t)
 {
 	assert(MayHaveBridgeAbove(t));
-	return GB(_m[t].m6, 6, 2) != 0;
+	return GB(GetTileEx(t)->m6, 6, 2) != 0;
 }
+/** @copydoc IsBridgeAbove(TileIndexT<Tgeneric>::T) */
+static inline bool IsBridgeAbove(TileIndex t) { return IsBridgeAbove<false>(t); }
+/** @copydoc IsBridgeAbove(TileIndexT<Tgeneric>::T) */
+static inline bool IsBridgeAbove(GenericTileIndex t) { return IsBridgeAbove<true>(t); }
 
 /**
  * Determines the type of bridge on a tile
@@ -67,11 +87,16 @@
  * @pre IsBridgeTile(t)
  * @return The bridge type
  */
-static inline BridgeType GetBridgeType(TileIndex t)
+template <bool Tgeneric>
+static inline BridgeType GetBridgeType(typename TileIndexT<Tgeneric>::T t)
 {
 	assert(IsBridgeTile(t));
-	return GB(_m[t].m6, 2, 4);
+	return GB(GetTileEx(t)->m6, 2, 4);
 }
+/** @copydoc GetBridgeType(TileIndexT<Tgeneric>::T) */
+static inline BridgeType GetBridgeType(TileIndex t) { return GetBridgeType<false>(t); }
+/** @copydoc GetBridgeType(TileIndexT<Tgeneric>::T) */
+static inline BridgeType GetBridgeType(GenericTileIndex t) { return GetBridgeType<true>(t); }
 
 /**
  * Get the axis of the bridge that goes over the tile. Not the axis or the ramp.
@@ -79,17 +104,34 @@
  * @pre IsBridgeAbove(t)
  * @return the above mentioned axis
  */
-static inline Axis GetBridgeAxis(TileIndex t)
+template <bool Tgeneric>
+static inline Axis GetBridgeAxis(typename TileIndexT<Tgeneric>::T t)
 {
 	assert(IsBridgeAbove(t));
-	return (Axis)(GB(_m[t].m6, 6, 2) - 1);
+	return (Axis)(GB(GetTileEx(t)->m6, 6, 2) - 1);
 }
+/** @copydoc GetBridgeAxis(TileIndexT<Tgeneric>::T) */
+static inline Axis GetBridgeAxis(TileIndex t) { return GetBridgeAxis<false>(t); }
+/** @copydoc GetBridgeAxis(TileIndexT<Tgeneric>::T) */
+static inline Axis GetBridgeAxis(GenericTileIndex t) { return GetBridgeAxis<true>(t); }
 
 TileIndex GetNorthernBridgeEnd(TileIndex t);
 TileIndex GetSouthernBridgeEnd(TileIndex t);
-TileIndex GetOtherBridgeEnd(TileIndex t);
 
-int GetBridgeHeight(TileIndex tile);
+template <bool Tgeneric>
+typename TileIndexT<Tgeneric>::T GetOtherBridgeEnd(typename TileIndexT<Tgeneric>::T t);
+/** @copydoc GetOtherBridgeEnd(TileIndexT<Tgeneric>::T) */
+static inline TileIndex GetOtherBridgeEnd(TileIndex t) { return GetOtherBridgeEnd<false>(t); }
+/** @copydoc GetOtherBridgeEnd(TileIndexT<Tgeneric>::T) */
+static inline GenericTileIndex GetOtherBridgeEnd(GenericTileIndex t) { return GetOtherBridgeEnd<true>(t); }
+
+template <bool Tgeneric>
+int GetBridgeHeight(typename TileIndexT<Tgeneric>::T tile);
+/** @copydoc GetBridgeHeight(TileIndexT<Tgeneric>::T) */
+static inline int GetBridgeHeight(TileIndex t) { return GetBridgeHeight<false>(t); }
+/** @copydoc GetBridgeHeight(TileIndexT<Tgeneric>::T) */
+static inline int GetBridgeHeight(GenericTileIndex t) { return GetBridgeHeight<true>(t); }
+
 /**
  * Get the height ('z') of a bridge in pixels.
  * @param tile the bridge ramp tile to get the bridge height from
@@ -109,7 +151,7 @@
 static inline void ClearSingleBridgeMiddle(TileIndex t, Axis a)
 {
 	assert(MayHaveBridgeAbove(t));
-	ClrBit(_m[t].m6, 6 + a);
+	ClrBit(GetTileEx(t)->m6, 6 + a);
 }
 
 /**
@@ -129,11 +171,16 @@
  * @param a the axis of the bridge to add
  * @pre MayHaveBridgeAbove(t)
  */
-static inline void SetBridgeMiddle(TileIndex t, Axis a)
+template <bool Tgeneric>
+static inline void SetBridgeMiddle(typename TileIndexT<Tgeneric>::T t, Axis a)
 {
 	assert(MayHaveBridgeAbove(t));
-	SetBit(_m[t].m6, 6 + a);
+	SetBit(GetTileEx(t)->m6, 6 + a);
 }
+/** @copydoc SetBridgeMiddle(TileIndexT<Tgeneric>::T,Axis) */
+static inline void SetBridgeMiddle(TileIndex t, Axis a) { return SetBridgeMiddle<false>(t, a); }
+/** @copydoc SetBridgeMiddle(TileIndexT<Tgeneric>::T,Axis) */
+static inline void SetBridgeMiddle(GenericTileIndex t, Axis a) { return SetBridgeMiddle<true>(t, a); }
 
 /**
  * Generic part to make a bridge ramp for both roads and rails.
@@ -145,17 +192,22 @@
  * @param rt         the road or rail type
  * @note this function should not be called directly.
  */
-static inline void MakeBridgeRamp(TileIndex t, Owner o, BridgeType bridgetype, DiagDirection d, TransportType tt, uint rt)
+template <bool Tgeneric>
+static inline void MakeBridgeRamp(typename TileIndexT<Tgeneric>::T t, Owner o, BridgeType bridgetype, DiagDirection d, TransportType tt, uint rt)
 {
 	SetTileType(t, MP_TUNNELBRIDGE);
 	SetTileOwner(t, o);
-	_m[t].m2 = 0;
-	_m[t].m3 = rt;
-	_m[t].m4 = 0;
-	_m[t].m5 = 1 << 7 | tt << 2 | d;
-	SB(_m[t].m6, 2, 4, bridgetype);
-	_me[t].m7 = 0;
+	GetTile(t)->m2 = 0;
+	GetTile(t)->m3 = rt;
+	GetTile(t)->m4 = 0;
+	GetTile(t)->m5 = 1 << 7 | tt << 2 | d;
+	SB(GetTileEx(t)->m6, 2, 4, bridgetype);
+	GetTileEx(t)->m7 = 0;
 }
+/** @copydoc MakeBridgeRamp(TileIndexT<Tgeneric>::T,Owner,BridgeType,DiagDirection,TransportType,uint)*/
+static inline void MakeBridgeRamp(TileIndex t, Owner o, BridgeType bridgetype, DiagDirection d, TransportType tt, uint rt) { return MakeBridgeRamp<false>(t, o, bridgetype, d, tt, rt); }
+/** @copydoc MakeBridgeRamp(TileIndexT<Tgeneric>::T,Owner,BridgeType,DiagDirection,TransportType,uint)*/
+static inline void MakeBridgeRamp(GenericTileIndex t, Owner o, BridgeType bridgetype, DiagDirection d, TransportType tt, uint rt) { return MakeBridgeRamp<true>(t, o, bridgetype, d, tt, rt); }
 
 /**
  * Make a bridge ramp for roads.
@@ -167,13 +219,18 @@
  * @param d          the direction this ramp must be facing
  * @param r          the road type of the bridge
  */
-static inline void MakeRoadBridgeRamp(TileIndex t, Owner o, Owner owner_road, Owner owner_tram, BridgeType bridgetype, DiagDirection d, RoadTypes r)
+template <bool Tgeneric>
+static inline void MakeRoadBridgeRamp(typename TileIndexT<Tgeneric>::T t, Owner o, Owner owner_road, Owner owner_tram, BridgeType bridgetype, DiagDirection d, RoadTypes r)
 {
 	MakeBridgeRamp(t, o, bridgetype, d, TRANSPORT_ROAD, 0);
 	SetRoadOwner(t, ROADTYPE_ROAD, owner_road);
 	if (owner_tram != OWNER_TOWN) SetRoadOwner(t, ROADTYPE_TRAM, owner_tram);
 	SetRoadTypes(t, r);
 }
+/** @copydoc MakeRoadBridgeRamp(TileIndexT<Tgeneric>::T,Owner,Owner,Owner,BridgeType,DiagDirection,RoadTypes) */
+static inline void MakeRoadBridgeRamp(TileIndex t, Owner o, Owner owner_road, Owner owner_tram, BridgeType bridgetype, DiagDirection d, RoadTypes r) { return MakeRoadBridgeRamp<false>(t, o, owner_road, owner_tram, bridgetype, d, r); }
+/** @copydoc MakeRoadBridgeRamp(TileIndexT<Tgeneric>::T,Owner,Owner,Owner,BridgeType,DiagDirection,RoadTypes) */
+static inline void MakeRoadBridgeRamp(GenericTileIndex t, Owner o, Owner owner_road, Owner owner_tram, BridgeType bridgetype, DiagDirection d, RoadTypes r) { return MakeRoadBridgeRamp<true>(t, o, owner_road, owner_tram, bridgetype, d, r); }
 
 /**
  * Make a bridge ramp for rails.
@@ -183,10 +240,15 @@
  * @param d          the direction this ramp must be facing
  * @param r          the rail type of the bridge
  */
-static inline void MakeRailBridgeRamp(TileIndex t, Owner o, BridgeType bridgetype, DiagDirection d, RailType r)
+template <bool Tgeneric>
+static inline void MakeRailBridgeRamp(typename TileIndexT<Tgeneric>::T t, Owner o, BridgeType bridgetype, DiagDirection d, RailType r)
 {
 	MakeBridgeRamp(t, o, bridgetype, d, TRANSPORT_RAIL, r);
 }
+/** @copydoc MakeRailBridgeRamp(TileIndexT<Tgeneric>::T,Owner,BridgeType,DiagDirection,RailType) */
+static inline void MakeRailBridgeRamp(TileIndex t, Owner o, BridgeType bridgetype, DiagDirection d, RailType r) { return MakeRailBridgeRamp<false>(t, o, bridgetype, d, r); }
+/** @copydoc MakeRailBridgeRamp(TileIndexT<Tgeneric>::T,Owner,BridgeType,DiagDirection,RailType) */
+static inline void MakeRailBridgeRamp(GenericTileIndex t, Owner o, BridgeType bridgetype, DiagDirection d, RailType r) { return MakeRailBridgeRamp<true>(t, o, bridgetype, d, r); }
 
 /**
  * Make a bridge ramp for aqueducts.
@@ -194,9 +256,14 @@
  * @param o          the new owner of the bridge ramp
  * @param d          the direction this ramp must be facing
  */
-static inline void MakeAqueductBridgeRamp(TileIndex t, Owner o, DiagDirection d)
+template <bool Tgeneric>
+static inline void MakeAqueductBridgeRamp(typename TileIndexT<Tgeneric>::T t, Owner o, DiagDirection d)
 {
 	MakeBridgeRamp(t, o, 0, d, TRANSPORT_WATER, 0);
 }
+/** @copydoc MakeAqueductBridgeRamp(TileIndexT<Tgeneric>::T,Owner,DiagDirection) */
+static inline void MakeAqueductBridgeRamp(TileIndex t, Owner o, DiagDirection d) { return MakeAqueductBridgeRamp<false>(t, o, d); }
+/** @copydoc MakeAqueductBridgeRamp(TileIndexT<Tgeneric>::T,Owner,DiagDirection) */
+static inline void MakeAqueductBridgeRamp(GenericTileIndex t, Owner o, DiagDirection d) { return MakeAqueductBridgeRamp<true>(t, o, d); }
 
 #endif /* BRIDGE_MAP_H */
diff -urNad openttd-1.3.2/src/build_vehicle_gui.cpp openttd-1.3.2-DC3.0RC3/src/build_vehicle_gui.cpp
--- openttd-1.3.2/src/build_vehicle_gui.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/build_vehicle_gui.cpp	2013-11-22 05:49:06.000000000 +0100
@@ -73,6 +73,12 @@
 	EndContainer(),
 	/* Panel with details. */
 	NWidget(WWT_PANEL, COLOUR_GREY, WID_BV_PANEL), SetMinimalSize(240, 122), SetResize(1, 0), EndContainer(),
+       /* Build and refit button. */
+       NWidget(NWID_HORIZONTAL),
+               NWidget(NWID_SELECTION, INVALID_COLOUR, WID_BV_BUILD_REFIT_SEL),
+                       NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_BV_BUILD_REFIT), SetResize(1, 0), SetFill(1, 0), 
+               EndContainer(),
+       EndContainer(),
 	/* Build/rename buttons, resize button. */
 	NWidget(NWID_HORIZONTAL),
 		NWidget(NWID_SELECTION, INVALID_COLOUR, WID_BV_BUILD_SEL),
@@ -970,6 +976,10 @@
 		/* If we are just viewing the list of vehicles, we do not need the Build button.
 		 * So we just hide it, and enlarge the Rename button by the now vacant place. */
 		if (this->listview_mode) this->GetWidget<NWidgetStacked>(WID_BV_BUILD_SEL)->SetDisplayedPlane(SZSP_NONE);
+//               if (this->listview_mode) {
+//                       this->GetWidget<NWidgetStacked>(WID_BV_BUILD_SEL)->SetDisplayedPlane(SZSP_NONE);
+//                       this->GetWidget<NWidgetStacked>(WID_BV_BUILD_SEL)->SetDisplayedPlane(SZSP_HORIZONTAL);
+//               }
 
 		/* disable renaming engines in network games if you are not the server */
 		this->SetWidgetDisabledState(WID_BV_RENAME, _networking && !_network_server);
@@ -977,6 +987,10 @@
 		NWidgetCore *widget = this->GetWidget<NWidgetCore>(WID_BV_LIST);
 		widget->tool_tip = STR_BUY_VEHICLE_TRAIN_LIST_TOOLTIP + type;
 
+		widget = this->GetWidget<NWidgetCore>(WID_BV_BUILD_REFIT);
+		widget->widget_data = STR_BUY_REFIT_VEHICLE_TRAIN_BUY_VEHICLE_BUTTON + type;
+		widget->tool_tip    = STR_BUY_REFIT_VEHICLE_TRAIN_BUY_VEHICLE_TOOLTIP + type;
+
 		widget = this->GetWidget<NWidgetCore>(WID_BV_BUILD);
 		widget->widget_data = STR_BUY_VEHICLE_TRAIN_BUY_VEHICLE_BUTTON + type;
 		widget->tool_tip    = STR_BUY_VEHICLE_TRAIN_BUY_VEHICLE_TOOLTIP + type;
@@ -1250,6 +1264,17 @@
 				ShowDropDownMenu(this, this->cargo_filter_texts, this->cargo_filter_criteria, WID_BV_CARGO_FILTER_DROPDOWN, 0, 0);
 				break;
 
+                       case WID_BV_BUILD_REFIT: {
+                               EngineID sel_eng = this->sel_engine;
+                               if (sel_eng != INVALID_ENGINE) {
+                                       CommandCallback *callback = (this->vehicle_type == VEH_TRAIN && RailVehInfo(sel_eng)->railveh_type == RAILVEH_WAGON) ? CcBuildWagon : CcBuildPrimaryVehicle;
+                                       if(DoCommandP(this->window_number, sel_eng, 0, GetCmdBuildVeh(this->vehicle_type), callback))
+                                               // refit to selected cargo filter
+                                               DoCommandP(this->window_number, _new_vehicle_id, this->cargo_filter[this->cargo_filter_criteria], GetCmdRefitVeh(this->vehicle_type));
+                               }
+                               break;
+                       }
+
 			case WID_BV_BUILD: {
 				EngineID sel_eng = this->sel_engine;
 				if (sel_eng != INVALID_ENGINE) {
@@ -1350,6 +1375,13 @@
 		this->GenerateBuildList();
 		this->vscroll->SetCount(this->eng_list.Length());
 
+		// disable build and refit if all or none cargo type selected
+		if(_networking || this->cargo_filter[this->cargo_filter_criteria] == CF_ANY || this->cargo_filter[this->cargo_filter_criteria] == CF_NONE) {			
+			this->DisableWidget(WID_BV_BUILD_REFIT);
+		} else {
+			this->EnableWidget(WID_BV_BUILD_REFIT);
+		}
+
 		this->DrawWidgets();
 
 		if (!this->IsShaded()) {
diff -urNad openttd-1.3.2/src/cargodest_base.h openttd-1.3.2-DC3.0RC3/src/cargodest_base.h
--- openttd-1.3.2/src/cargodest_base.h	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/cargodest_base.h	2013-11-22 05:49:06.000000000 +0100
@@ -0,0 +1,182 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file cargodest_base.h Classes and types for entities having cargo destinations. */
+
+#ifndef CARGODEST_BASE_H
+#define CARGODEST_BASE_H
+
+#include "cargodest_type.h"
+#include "cargo_type.h"
+#include "town_type.h"
+#include "core/smallvec_type.hpp"
+#include "core/pool_type.hpp"
+#include "order_type.h"
+#include "station_type.h"
+#include "company_type.h"
+#include "vehicle_type.h"
+
+struct CargoSourceSink;
+
+/** Information about a demand link for cargo. */
+struct CargoLink {
+	CargoSourceSink                *dest;      ///< Destination of the link.
+	TransportedCargoStat<uint32>   amount;     ///< Transported cargo statistics.
+	uint                           weight;     ///< Weight of this link.
+	byte                           weight_mod; ///< Weight modifier.
+
+	CargoLink(CargoSourceSink *d, byte mod) : dest(d), weight(1), weight_mod(mod) {}
+
+	/* Compare two cargo links for inequality. */
+	bool operator !=(const CargoLink &other) const
+	{
+		return other.dest != dest;
+	}
+};
+
+/** An entity producing or accepting cargo with a destination. */
+struct CargoSourceSink {
+	/** List of destinations for each cargo type. */
+	SmallVector<CargoLink, 8> cargo_links[NUM_CARGO];
+	/** Sum of the destination weights for each cargo type. */
+	uint cargo_links_weight[NUM_CARGO];
+
+	/** NOSAVE: Desired link count for each cargo. */
+	uint16 num_links_expected[NUM_CARGO];
+
+	/** NOSAVE: Incoming link count for each cargo. */
+	uint num_incoming_links[NUM_CARGO];
+
+	virtual ~CargoSourceSink();
+
+	/** Get the type of this entity. */
+	virtual SourceType GetType() const = 0;
+	/** Get the source ID corresponding with this entity. */
+	virtual SourceID GetID() const = 0;
+
+	/**
+	 * Test if a demand link to a destination exists.
+	 * @param cid Cargo type for which a link should be searched.
+	 * @param dest Destination to search for.
+	 * @return True if a link to the destination is present.
+	 */
+	bool HasLinkTo(CargoID cid, const CargoSourceSink *dest) const
+	{
+		return this->cargo_links[cid].Contains(CargoLink(const_cast<CargoSourceSink *>(dest), 1));
+	}
+
+	/** Is this cargo accepted? */
+	virtual bool AcceptsCargo(CargoID cid) const = 0;
+	/** Is this cargo produced? */
+	virtual bool SuppliesCargo(CargoID cid) const = 0;
+
+	/** Get the link weight for this as a destination for a specific cargo. */
+	virtual uint GetDestinationWeight(CargoID cid, byte weight_mod) const = 0;
+
+	CargoLink *GetRandomLink(CargoID cid, bool allow_self);
+
+	/** Create the special cargo links for a cargo if not already present. */
+	virtual void CreateSpecialLinks(CargoID cid);
+
+	/** Get a random destination tile index for this cargo. */
+	virtual TileArea GetTileForDestination(CargoID cid) = 0;
+
+	void SaveCargoSourceSink();
+	void LoadCargoSourceSink();
+	void PtrsCargoSourceSink();
+};
+
+
+/** Pool of route links. */
+typedef Pool<RouteLink, RouteLinkID, 512, 262144> RouteLinkPool;
+extern RouteLinkPool _routelink_pool;
+
+/** Holds information about a route service between two stations. */
+struct RouteLink : public RouteLinkPool::PoolItem<&_routelink_pool> {
+private:
+	friend const struct SaveLoad *GetRouteLinkDescription(); ///< Saving and loading of route links.
+	friend void ChangeOwnershipOfCompanyItems(Owner old_owner, Owner new_owner);
+	friend void AgeRouteLinks(Station *st);
+
+	StationID       dest;            ///< Destination station id.
+	OrderID         prev_order;      ///< Id of the order the vehicle had when arriving at the origin.
+	OrderID         next_order;      ///< Id of the order the vehicle will leave the station with.
+	OwnerByte       owner;           ///< Owner of the vehicle of the link.
+	VehicleTypeByte vtype;           ///< Vehicle type traveling this link.
+	uint32          travel_time;     ///< Average travel duration of this link.
+	uint16          wait_time;       ///< Days since the last vehicle traveled this link.
+
+public:
+	/** Constructor */
+	RouteLink(StationID dest = INVALID_STATION, OrderID prev_order = INVALID_ORDER, OrderID next_order = INVALID_ORDER, Owner owner = INVALID_OWNER, uint32 travel_time = 0, VehicleType vtype = VEH_INVALID)
+		: dest(dest), prev_order(prev_order), next_order(next_order), travel_time(travel_time), wait_time(0)
+	{
+		this->owner = owner;
+		this->vtype = vtype;
+	}
+
+	~RouteLink();
+
+	/** Get the target station of this link. */
+	inline StationID GetDestination() const { return this->dest; }
+
+	/** Get the order id that lead to the origin station. */
+	inline OrderID GetOriginOrderId() const { return this->prev_order; }
+
+	/** Get the order id that lead to the destination station. */
+	inline OrderID GetDestOrderId() const { return this->next_order; }
+
+	/** Get the owner of this link. */
+	inline Owner GetOwner() const { return this->owner; }
+
+	/** Get the type of the vehicles on this link. */
+	inline VehicleType GetVehicleType() const { return this->vtype; }
+
+	/** Get the travel time of this link. */
+	inline uint32 GetTravelTime() const { return this->travel_time; }
+
+	/** Get the wait time at the origin station. */
+	inline uint16 GetWaitTime() const { return this->wait_time; }
+
+	/** Update the destination of the route link. */
+	inline void SetDestination(StationID dest_id, OrderID dest_order_id)
+	{
+		this->dest = dest_id;
+		this->next_order = dest_order_id;
+	}
+
+	/** Update the travel time with a new travel time.  */
+	void UpdateTravelTime(uint32 new_time)
+	{
+		/* Weighted average so that a single late vehicle will not skew the time. */
+		this->travel_time = (3 * this->travel_time + new_time) / 4;
+	}
+
+	/** A vehicle arrived at the origin of the link, reset waiting time. */
+	void VehicleArrived()
+	{
+		this->wait_time = 0;
+	}
+};
+
+
+/**
+ * Iterate over all valid route links from a given start.
+ * @param var   The variable to use as the "iterator".
+ * @param start The #RouteLinkID to start the iteration from.
+ */
+#define FOR_ALL_ROUTELINKS_FROM(var, start) FOR_ALL_ITEMS_FROM(RouteLink, routelink_index, var, start)
+
+/**
+ * Iterate over all valid route links.
+ * @param var   The variable to use as the "iterator".
+ */
+#define FOR_ALL_ROUTELINKS(var) FOR_ALL_ROUTELINKS_FROM(var, 0)
+
+#endif /* CARGODEST_BASE_H */
diff -urNad openttd-1.3.2/src/cargodest.cpp openttd-1.3.2-DC3.0RC3/src/cargodest.cpp
--- openttd-1.3.2/src/cargodest.cpp	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/cargodest.cpp	2013-11-22 05:49:06.000000000 +0100
@@ -0,0 +1,1197 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file cargodest.cpp Implementation of cargo destinations. */
+
+#include "stdafx.h"
+#include "cargodest_type.h"
+#include "cargodest_base.h"
+#include "cargodest_func.h"
+#include "core/bitmath_func.hpp"
+#include "core/random_func.hpp"
+#include "core/pool_func.hpp"
+#include "cargotype.h"
+#include "settings_type.h"
+#include "town.h"
+#include "industry.h"
+#include "window_func.h"
+#include "vehicle_base.h"
+#include "station_base.h"
+#include "pathfinder/yapf/yapf.h"
+#include "company_base.h"
+
+
+/* Possible link weight modifiers. */
+static const byte LWM_ANYWHERE      = 1; ///< Weight modifier for undetermined destinations.
+static const byte LWM_TONY_ANY      = 2; ///< Default weight modifier for towns.
+static const byte LWM_TONY_BIG      = 3; ///< Weight modifier for big towns.
+static const byte LWM_TONY_CITY     = 4; ///< Weight modifier for cities.
+static const byte LWM_TONY_NEARBY   = 5; ///< Weight modifier for nearby towns.
+static const byte LWM_INTOWN        = 8; ///< Weight modifier for in-town links.
+static const byte LWM_IND_ANY       = 2; ///< Default weight modifier for industries.
+static const byte LWM_IND_NEARBY    = 3; ///< Weight modifier for nearby industries.
+static const byte LWM_IND_PRODUCING = 4; ///< Weight modifier for producing industries.
+
+static const uint MAX_EXTRA_LINKS       = 2; ///< Number of extra links allowed.
+static const uint MAX_IND_STOCKPILE     = 1000; ///< Maximum stockpile to consider for industry link weight.
+
+static const uint BASE_TOWN_LINKS       = 0; ///< Index into _settings_game.economy.cargodest.base_town_links for normal cargo
+static const uint BASE_TOWN_LINKS_SYMM  = 1; ///< Index into _settings_game.economy.cargodest.base_town_links for symmteric cargoes
+static const uint BASE_IND_LINKS        = 0; ///< Index into _settings_game.economy.cargodest.base_ind_links for normal cargo
+static const uint BASE_IND_LINKS_TOWN   = 1; ///< Index into _settings_game.economy.cargodest.base_ind_links for town cargoes
+static const uint BASE_IND_LINKS_SYMM   = 2; ///< Index into _settings_game.economy.cargodest.base_ind_links for symmetric cargoes
+static const uint BIG_TOWN_POP_MAIL     = 0; ///< Index into _settings_game.economy.cargodest.big_town_pop for mail
+static const uint BIG_TOWN_POP_PAX      = 1; ///< Index into _settings_game.economy.cargodest.big_town_pop for passengers
+static const uint SCALE_TOWN            = 0; ///< Index into _settings_game.economy.cargodest.pop_scale_town/weight_scale_town for normal cargo
+static const uint SCALE_TOWN_BIG        = 1; ///< Index into _settings_game.economy.cargodest.pop_scale_town/weight_scale_town for normal cargo of big towns
+static const uint SCALE_TOWN_PAX        = 2; ///< Index into _settings_game.economy.cargodest.pop_scale_town/weight_scale_town for passengers
+static const uint SCALE_TOWN_BIG_PAX    = 3; ///< Index into _settings_game.economy.cargodest.pop_scale_town/weight_scale_town for passengers of big towns
+static const uint CARGO_SCALE_IND       = 0; ///< Index into _settings_game.economy.cargodest.cargo_scale_ind for normal cargo
+static const uint CARGO_SCALE_IND_TOWN  = 1; ///< Index into _settings_game.economy.cargodest.cargo_scale_ind for town cargoes
+static const uint MIN_WEIGHT_TOWN       = 0; ///< Index into _settings_game.economy.cargodest.min_weight_town for normal cargo
+static const uint MIN_WEIGHT_TOWN_PAX   = 1; ///< Index into _settings_game.economy.cargodest.min_weight_town for passengers
+static const uint WEIGHT_SCALE_IND_PROD = 0; ///< Index into _settings_game.economy.cargodest.weight_scale_ind for produced cargo
+static const uint WEIGHT_SCALE_IND_PILE = 1; ///< Index into _settings_game.economy.cargodest.weight_scale_ind for stockpiled cargo
+
+/** Are cargo destinations for this cargo type enabled? */
+bool CargoHasDestinations(CargoID cid)
+{
+	const CargoSpec *spec = CargoSpec::Get(cid);
+	switch (spec->town_effect) {
+		case TE_PASSENGERS:
+		case TE_MAIL:
+			return _settings_game.economy.cargodest.mode_pax_mail != CRM_OFF;
+
+		case TE_GOODS:
+		case TE_WATER:
+		case TE_FOOD:
+			return _settings_game.economy.cargodest.mode_town_cargo != CRM_OFF;
+
+		default:
+			return _settings_game.economy.cargodest.mode_others != CRM_OFF;
+	}
+}
+
+/** Are cargo destinations for all cargo types disabled? */
+bool CargoDestinationsDisabled()
+{
+	return _settings_game.economy.cargodest.mode_pax_mail == CRM_OFF && _settings_game.economy.cargodest.mode_town_cargo == CRM_OFF && _settings_game.economy.cargodest.mode_others == CRM_OFF;
+}
+
+/** Should this cargo type primarily have towns as a destination? */
+static bool IsTownCargo(CargoID cid)
+{
+	const CargoSpec *spec = CargoSpec::Get(cid);
+	return spec->town_effect != TE_NONE;
+}
+
+/** Does this cargo have a symmetric demand?  */
+static bool IsSymmetricCargo(CargoID cid)
+{
+	const CargoSpec *spec = CargoSpec::Get(cid);
+	return spec->town_effect == TE_PASSENGERS;
+}
+
+/** Is this a passenger cargo. */
+static bool IsPassengerCargo(CargoID cid)
+{
+	const CargoSpec *spec = CargoSpec::Get(cid);
+	return spec->town_effect == TE_PASSENGERS;
+}
+
+
+/** Information for the town/industry enumerators. */
+struct EnumRandomData {
+	CargoSourceSink *source;
+	TileIndex       source_xy;
+	CargoID         cid;
+	bool            limit_links;
+};
+
+/**
+ * Test whether two tiles are nearby with map-size scaling.
+ * @param t1 First tile.
+ * @param t2 Second tile.
+ * @param dist_square Allowed squared distance between the tiles.
+ * @return True if the tiles are nearby.
+ */
+static bool IsNearby(TileIndex t1, TileIndex t2, uint32 dist_square)
+{
+	/* Scale distance by 1D map size to make sure that there are still
+	 * candidates left on larger maps with few towns, but don't scale
+	 * by 2D map size so the map still feels bigger. */
+	return DistanceSquare(t1, t2) < ScaleByMapSize1D(dist_square);
+}
+
+/**
+ * Test whether a tiles is near a town.
+ * @param t The town.
+ * @param ti The tile to test.
+ * @return True if the tiles is near the town.
+ */
+static bool IsTownNearby(const Town *t, TileIndex ti)
+{
+	return IsNearby(t->xy, ti, _settings_game.economy.cargodest.town_nearby_dist);
+}
+
+/**
+ * Test whether a tiles is near an industry.
+ * @param ind The industry.
+ * @param ti The tile to test.
+ * @return True if the tiles is near the town.
+ */
+static bool IsIndustryNearby(const Industry *ind, TileIndex ti)
+{
+	return IsNearby(ind->location.tile, ti, _settings_game.economy.cargodest.ind_nearby_dist);
+}
+
+/** Common helper for town/industry enumeration. */
+static bool EnumAnyDest(const CargoSourceSink *dest, EnumRandomData *erd)
+{
+	/* Already a destination? */
+	if (erd->source->HasLinkTo(erd->cid, dest)) return false;
+
+	/* Destination already has too many links? */
+	if (erd->limit_links && dest->cargo_links[erd->cid].Length() > dest->num_links_expected[erd->cid] + MAX_EXTRA_LINKS) return false;
+
+	return true;
+}
+
+/** Enumerate any town not already a destination and accepting a specific cargo.*/
+static bool EnumAnyTown(const Town *t, void *data)
+{
+	EnumRandomData *erd = (EnumRandomData *)data;
+	return EnumAnyDest(t, erd) && t->AcceptsCargo(erd->cid);
+}
+
+/** Enumerate cities. */
+static bool EnumCity(const Town *t, void *data)
+{
+	return EnumAnyTown(t, data) && t->larger_town;
+}
+
+/** Enumerate towns with a big population. */
+static bool EnumBigTown(const Town *t, void *data)
+{
+	EnumRandomData *erd = (EnumRandomData *)data;
+	return EnumAnyTown(t, erd) && (IsPassengerCargo(erd->cid) ? t->supplied[CT_PASSENGERS].old_max > _settings_game.economy.cargodest.big_town_pop[BIG_TOWN_POP_PAX] : t->supplied[CT_MAIL].old_max > _settings_game.economy.cargodest.big_town_pop[BIG_TOWN_POP_MAIL]);
+}
+
+/** Enumerate nearby towns. */
+static bool EnumNearbyTown(const Town *t, void *data)
+{
+	EnumRandomData *erd = (EnumRandomData *)data;
+	return EnumAnyTown(t, data) && IsTownNearby(t, erd->source_xy);
+}
+
+/** Enumerate any industry not already a destination and accepting a specific cargo. */
+static bool EnumAnyIndustry(const Industry *ind, void *data)
+{
+	EnumRandomData *erd = (EnumRandomData *)data;
+	return EnumAnyDest(ind, erd) && ind->AcceptsCargo(erd->cid);
+}
+
+/** Enumerate nearby industries. */
+static bool EnumNearbyIndustry(const Industry *ind, void *data)
+{
+	EnumRandomData *erd = (EnumRandomData *)data;
+	return EnumAnyIndustry(ind, data) && IsIndustryNearby(ind, erd->source_xy);
+}
+
+/** Enumerate industries that are producing cargo. */
+static bool EnumProducingIndustry(const Industry *ind, void *data)
+{
+	return EnumAnyIndustry(ind, data) && (ind->produced_cargo[0] != CT_INVALID || ind->produced_cargo[1] != CT_INVALID);
+}
+
+/** Enumerate cargo sources supplying a specific cargo. */
+template <typename T>
+static bool EnumAnySupplier(const T *css, void *data)
+{
+	return css->SuppliesCargo(((EnumRandomData *)data)->cid);
+}
+
+/** Enumerate nearby cargo sources supplying a specific cargo. */
+static bool EnumNearbySupplier(const Industry *ind, void *data)
+{
+	EnumRandomData *erd = (EnumRandomData *)data;
+	return EnumAnySupplier(ind, data) && IsIndustryNearby(ind, erd->source_xy);
+}
+
+/** Enumerate nearby cargo sources supplying a specific cargo. */
+static bool EnumNearbySupplier(const Town *t, void *data)
+{
+	EnumRandomData *erd = (EnumRandomData *)data;
+	return EnumAnySupplier(t, data) && IsTownNearby(t, erd->source_xy);
+}
+
+
+/** Find a town as a destination. */
+static CargoSourceSink *FindTownDestination(byte &weight_mod, CargoSourceSink *source, TileIndex source_xy, CargoID cid, const uint8 destclass_chance[4], TownID skip = INVALID_TOWN)
+{
+	/* Enum functions for: nearby town, city, big town, and any town. */
+	static const Town::EnumTownProc destclass_enum[] = {
+		&EnumNearbyTown, &EnumCity, &EnumBigTown, &EnumAnyTown
+	};
+	static const byte weight_mods[] = {LWM_TONY_NEARBY, LWM_TONY_CITY, LWM_TONY_BIG, LWM_TONY_ANY};
+	assert_compile(lengthof(destclass_enum) == lengthof(weight_mods));
+
+	EnumRandomData erd = {source, source_xy, cid, IsSymmetricCargo(cid)};
+
+	/* Determine destination class. If no town is found in this class,
+	 * the search falls through to the following classes. */
+	byte destclass = RandomRange(destclass_chance[3]);
+
+	weight_mod = LWM_ANYWHERE;
+	Town *dest = NULL;
+	for (uint i = 0; i < lengthof(destclass_enum) && dest == NULL; i++) {
+		/* Skip if destination class not reached. */
+		if (destclass > destclass_chance[i]) continue;
+
+		dest = Town::GetRandom(destclass_enum[i], skip, &erd);
+		weight_mod = weight_mods[i];
+	}
+
+	return dest;
+}
+
+/** Find an industry as a destination. */
+static CargoSourceSink *FindIndustryDestination(byte &weight_mod, CargoSourceSink *source, TileIndex source_xy, CargoID cid, IndustryID skip = INVALID_INDUSTRY)
+{
+	/* Enum functions for: nearby industry, producing industry, and any industry. */
+	static const Industry::EnumIndustryProc destclass_enum[] = {
+		&EnumNearbyIndustry, &EnumProducingIndustry, &EnumAnyIndustry
+	};
+	static const byte weight_mods[] = {LWM_IND_NEARBY, LWM_IND_PRODUCING, LWM_IND_ANY};
+	assert_compile(lengthof(destclass_enum) == lengthof(_settings_game.economy.cargodest.ind_chances));
+
+	EnumRandomData erd = {source, source_xy, cid, IsSymmetricCargo(cid)};
+
+	/* Determine destination class. If no industry is found in this class,
+	 * the search falls through to the following classes. */
+	byte destclass = RandomRange(*lastof(_settings_game.economy.cargodest.ind_chances));
+
+	weight_mod = LWM_ANYWHERE;
+	Industry *dest = NULL;
+	for (uint i = 0; i < lengthof(destclass_enum) && dest == NULL; i++) {
+		/* Skip if destination class not reached. */
+		if (destclass > _settings_game.economy.cargodest.ind_chances[i]) continue;
+
+		dest = Industry::GetRandom(destclass_enum[i], skip, &erd);
+		weight_mod = weight_mods[i];
+	}
+
+	return dest;
+}
+
+/** Find a supply for a cargo type. */
+static CargoSourceSink *FindSupplySource(Industry *dest, CargoID cid)
+{
+	EnumRandomData erd = {dest, dest->location.tile, cid, false};
+
+	CargoSourceSink *source = NULL;
+
+	/* Even chance for industry source first, town second and vice versa.
+	 * Try a nearby supplier first, then check all suppliers. */
+	if (Chance16(1, 2)) {
+		source = Industry::GetRandom(&EnumNearbySupplier, dest->index, &erd);
+		if (source == NULL) source = Town::GetRandom(&EnumNearbySupplier, INVALID_TOWN, &erd);
+		if (source == NULL) source = Industry::GetRandom(&EnumAnySupplier, dest->index, &erd);
+		if (source == NULL) source = Town::GetRandom(&EnumAnySupplier, INVALID_TOWN, &erd);
+	} else {
+		source = Town::GetRandom(&EnumNearbySupplier, INVALID_TOWN, &erd);
+		if (source == NULL) source = Industry::GetRandom(&EnumNearbySupplier, dest->index, &erd);
+		if (source == NULL) source = Town::GetRandom(&EnumAnySupplier, INVALID_TOWN, &erd);
+		if (source == NULL) source = Industry::GetRandom(&EnumAnySupplier, dest->index, &erd);
+	}
+
+	return source;
+}
+
+/* virtual */ void CargoSourceSink::CreateSpecialLinks(CargoID cid)
+{
+	/* First link is for undetermined destinations. */
+	if (this->cargo_links[cid].Length() == 0) {
+		*this->cargo_links[cid].Append() = CargoLink(NULL, LWM_ANYWHERE);
+	}
+	if (this->cargo_links[cid].Get(0)->dest != NULL) {
+		/* Insert link at first place. */
+		*this->cargo_links[cid].Append() = *this->cargo_links[cid].Get(0);
+		*this->cargo_links[cid].Get(0) = CargoLink(NULL, LWM_ANYWHERE);
+	}
+}
+
+/* virtual */ void Town::CreateSpecialLinks(CargoID cid)
+{
+	CargoSourceSink::CreateSpecialLinks(cid);
+
+	if (this->AcceptsCargo(cid)) {
+		/* Add special link for town-local demand if not already present. */
+		if (this->cargo_links[cid].Length() < 2) *this->cargo_links[cid].Append() = CargoLink(this, LWM_INTOWN);
+		if (this->cargo_links[cid].Get(1)->dest != this) {
+			/* Insert link at second place. */
+			*this->cargo_links[cid].Append() = *this->cargo_links[cid].Get(1);
+			*this->cargo_links[cid].Get(1) = CargoLink(this, LWM_INTOWN);
+		}
+	} else {
+		/* Remove link for town-local demand if present. */
+		if (this->cargo_links[cid].Length() > 1 && this->cargo_links[cid].Get(1)->dest == this) {
+			this->cargo_links[cid].Erase(this->cargo_links[cid].Get(1));
+		}
+	}
+}
+
+/**
+ * Remove the link with the lowest weight from a cargo source. The
+ * reverse link is removed as well if the cargo has symmetric demand.
+ * @param source Remove the link from this cargo source.
+ * @param cid Cargo type of the link to remove.
+ */
+static void RemoveLowestLink(CargoSourceSink *source, CargoID cid)
+{
+	uint lowest_weight = UINT_MAX;
+	CargoLink *lowest_link = NULL;
+
+	for (CargoLink *l = source->cargo_links[cid].Begin(); l != source->cargo_links[cid].End(); l++) {
+		/* Don't remove special links. */
+		if (l->dest == NULL || l->dest == source) continue;
+
+		if (l->weight < lowest_weight) {
+			lowest_weight = l->weight;
+			lowest_link = l;
+		}
+	}
+
+	if (lowest_link != NULL) {
+		/* If this is a symmetric cargo, also remove the reverse link. */
+		if (IsSymmetricCargo(cid) && lowest_link->dest->HasLinkTo(cid, source)) {
+			source->num_incoming_links[cid]--;
+			lowest_link->dest->cargo_links[cid].Erase(lowest_link->dest->cargo_links[cid].Find(CargoLink(source, LWM_ANYWHERE)));
+		}
+		lowest_link->dest->num_incoming_links[cid]--;
+		source->cargo_links[cid].Erase(lowest_link);
+	}
+}
+
+/** Create missing cargo links for a source. */
+static void CreateNewLinks(CargoSourceSink *source, TileIndex source_xy, CargoID cid, uint chance_a, uint chance_b, const uint8 town_chance[], TownID skip_town, IndustryID skip_ind)
+{
+	uint num_links = source->num_links_expected[cid];
+
+	/* Remove the link with the lowest weight if the
+	 * town has more than links more than expected. */
+	if (source->cargo_links[cid].Length() > num_links + MAX_EXTRA_LINKS) {
+		RemoveLowestLink(source, cid);
+	}
+
+	/* Add new links until the expected link count is reached. */
+	while (source->cargo_links[cid].Length() < num_links) {
+		CargoSourceSink *dest = NULL;
+		byte weight_mod = LWM_ANYWHERE;
+
+		/* Chance for town/industry is chance_a/chance_b, otherwise try industry/town. */
+		if (Chance16(chance_a, chance_b)) {
+			dest = FindTownDestination(weight_mod, source, source_xy, cid, town_chance, skip_town);
+			/* No town found? Try an industry. */
+			if (dest == NULL) dest = FindIndustryDestination(weight_mod, source, source_xy, cid, skip_ind);
+		} else {
+			dest = FindIndustryDestination(weight_mod, source, source_xy, cid, skip_ind);
+			/* No industry found? Try a town. */
+			if (dest == NULL) dest = FindTownDestination(weight_mod, source, source_xy, cid, town_chance, skip_town);
+		}
+
+		/* If we didn't find a destination, break out of the loop because no
+		 * more destinations are left on the map. */
+		if (dest == NULL) break;
+
+		/* If this is a symmetric cargo and we accept it as well, create a back link. */
+		if (IsSymmetricCargo(cid) && dest->SuppliesCargo(cid) && source->AcceptsCargo(cid)) {
+			*dest->cargo_links[cid].Append() = CargoLink(source, weight_mod);
+			source->num_incoming_links[cid]++;
+		}
+
+		*source->cargo_links[cid].Append() = CargoLink(dest, weight_mod);
+		dest->num_incoming_links[cid]++;
+	}
+}
+
+/** Remove invalid links from a cargo source/sink. */
+static void RemoveInvalidLinks(CargoSourceSink *css)
+{
+	for (CargoID cid = 0; cid < NUM_CARGO; cid++) {
+		/* Remove outgoing links if cargo isn't supplied anymore. */
+		if (!css->SuppliesCargo(cid)) {
+			for (CargoLink *l = css->cargo_links[cid].Begin(); l != css->cargo_links[cid].End(); l++) {
+				if (l->dest != NULL && l->dest != css) l->dest->num_incoming_links[cid]--;
+			}
+			css->cargo_links[cid].Clear();
+			css->cargo_links_weight[cid] = 0;
+		}
+
+		/* Remove outgoing links if the dest doesn't accept the cargo anymore. */
+		for (CargoLink *l = css->cargo_links[cid].Begin(); l != css->cargo_links[cid].End(); ) {
+			if (l->dest != NULL && !l->dest->AcceptsCargo(cid)) {
+				if (l->dest != css) l->dest->num_incoming_links[cid]--;
+				css->cargo_links[cid].Erase(l);
+			} else {
+				l++;
+			}
+		}
+	}
+}
+
+/** Updated the desired link count for each cargo. */
+void UpdateExpectedLinks(Town *t)
+{
+	CargoID cid;
+
+	FOR_EACH_SET_CARGO_ID(cid, t->cargo_produced) {
+		if (CargoHasDestinations(cid)) {
+			t->CreateSpecialLinks(cid);
+
+			uint max_amt = IsPassengerCargo(cid) ? t->supplied[CT_PASSENGERS].old_max : t->supplied[CT_MAIL].old_max;
+			uint big_amt = _settings_game.economy.cargodest.big_town_pop[IsPassengerCargo(cid) ? BIG_TOWN_POP_PAX : BIG_TOWN_POP_MAIL];
+
+			uint num_links = _settings_game.economy.cargodest.base_town_links[IsSymmetricCargo(cid) ? BASE_TOWN_LINKS_SYMM : BASE_TOWN_LINKS];
+			/* Add links based on the available cargo amount. */
+			num_links += min(max_amt, big_amt) / _settings_game.economy.cargodest.pop_scale_town[IsPassengerCargo(cid) ? SCALE_TOWN_PAX : SCALE_TOWN];
+			if (max_amt > big_amt) num_links += (max_amt - big_amt) / _settings_game.economy.cargodest.pop_scale_town[IsPassengerCargo(cid) ? SCALE_TOWN_BIG_PAX : SCALE_TOWN_BIG];
+			/* Ensure a city has at least city_town_links more than the base value.
+			 * This improves the link distribution at the beginning of a game when
+			 * the towns are still small. */
+			if (t->larger_town) num_links = max<uint>(num_links, _settings_game.economy.cargodest.city_town_links + _settings_game.economy.cargodest.base_town_links[IsSymmetricCargo(cid) ? BASE_TOWN_LINKS_SYMM : BASE_TOWN_LINKS]);
+
+			/* Account for the two special links. */
+			num_links++;
+			if (t->cargo_links[cid].Length() > 1 && t->cargo_links[cid].Get(1)->dest == t) num_links++;
+
+			t->num_links_expected[cid] = ClampToU16(num_links);
+		}
+	}
+}
+
+/** Updated the desired link count for each cargo. */
+void UpdateExpectedLinks(Industry *ind)
+{
+	for (uint i = 0; i < lengthof(ind->produced_cargo); i++) {
+		CargoID cid = ind->produced_cargo[i];
+		if (cid == INVALID_CARGO) continue;
+
+		if (CargoHasDestinations(cid)) {
+			ind->CreateSpecialLinks(cid);
+
+			uint num_links;
+			/* Use different base values for symmetric cargoes, cargoes
+			 * with a town effect and all other cargoes. */
+			num_links = _settings_game.economy.cargodest.base_ind_links[IsSymmetricCargo(cid) ? BASE_IND_LINKS_SYMM : (IsTownCargo(cid) ? BASE_IND_LINKS_TOWN : BASE_IND_LINKS)];
+			/* Add links based on the average industry production. */
+			num_links += ind->average_production[i] / _settings_game.economy.cargodest.cargo_scale_ind[IsTownCargo(cid) ? CARGO_SCALE_IND_TOWN : CARGO_SCALE_IND];
+
+			/* Account for the one special link. */
+			num_links++;
+
+			ind->num_links_expected[cid] = ClampToU16(num_links);
+		}
+	}
+}
+
+/** Make sure an industry has at least one incoming link for each accepted cargo. */
+void AddMissingIndustryLinks(Industry *ind)
+{
+	for (uint i = 0; i < lengthof(ind->accepts_cargo); i++) {
+		CargoID cid = ind->accepts_cargo[i];
+		if (cid == INVALID_CARGO) continue;
+
+		/* Do we already have at least one cargo source? */
+		if (ind->num_incoming_links[cid] > 0) continue;
+
+		CargoSourceSink *source = FindSupplySource(ind, cid);
+		if (source == NULL) continue; // Too bad...
+
+		if (source->cargo_links[cid].Length() >= source->num_links_expected[cid] + MAX_EXTRA_LINKS) {
+			/* Increase the expected link count if adding another link would
+			 * exceed the count, as otherwise this (or another) link would
+			 * get removed right again. */
+			source->num_links_expected[cid]++;
+		}
+
+		*source->cargo_links[cid].Append() = CargoLink(ind, LWM_IND_ANY);
+		ind->num_incoming_links[cid]++;
+
+		/* If this is a symmetric cargo and we produce it as well, create a back link. */
+		if (IsSymmetricCargo(cid) && ind->SuppliesCargo(cid) && source->AcceptsCargo(cid)) {
+			*ind->cargo_links[cid].Append() = CargoLink(source, LWM_IND_ANY);
+			source->num_incoming_links[cid]++;
+		}
+	}
+}
+
+/** Update the demand links. */
+void UpdateCargoLinks(Town *t)
+{
+	CargoID cid;
+
+	FOR_EACH_SET_CARGO_ID(cid, t->cargo_produced) {
+		if (CargoHasDestinations(cid)) {
+			/* If this is a town cargo, 95% chance for town/industry destination and
+			 * 5% for industry/town. The reverse chance otherwise. */
+			CreateNewLinks(t, t->xy, cid, IsTownCargo(cid) ? 19 : 1, 20, t->larger_town ? _settings_game.economy.cargodest.town_chances_city : _settings_game.economy.cargodest.town_chances_town, t->index, INVALID_INDUSTRY);
+		}
+	}
+}
+
+/** Update the demand links. */
+void UpdateCargoLinks(Industry *ind)
+{
+	for (uint i = 0; i < lengthof(ind->produced_cargo); i++) {
+		CargoID cid = ind->produced_cargo[i];
+		if (cid == INVALID_CARGO) continue;
+
+		if (CargoHasDestinations(cid)) {
+			/* If this is a town cargo, 75% chance for town/industry destination and
+			 * 25% for industry/town. The reverse chance otherwise. */
+			CreateNewLinks(ind, ind->location.tile, cid, IsTownCargo(cid) ? 3 : 1, 4, _settings_game.economy.cargodest.town_chances_town, INVALID_TOWN, ind->index);
+		}
+	}
+}
+
+/* virtual */ uint Town::GetDestinationWeight(CargoID cid, byte weight_mod) const
+{
+	uint max_amt = IsPassengerCargo(cid) ? this->supplied[CT_PASSENGERS].old_max : this->supplied[CT_PASSENGERS].old_max;
+	uint big_amt = _settings_game.economy.cargodest.big_town_pop[IsPassengerCargo(cid) ? BIG_TOWN_POP_PAX : BIG_TOWN_POP_MAIL];
+
+	/* The weight is calculated by a piecewise function. We start with a predefined
+	 * minimum weight and then add the weight for the cargo amount up to the big
+	 * town amount. If the amount is more than the big town amount, this is also
+	 * added to the weight with a different scale factor to make sure that big towns
+	 * don't siphon the cargo away too much from the smaller destinations. */
+	uint weight = _settings_game.economy.cargodest.min_weight_town[IsPassengerCargo(cid) ? MIN_WEIGHT_TOWN_PAX : MIN_WEIGHT_TOWN];
+	weight += min(max_amt, big_amt) * weight_mod / _settings_game.economy.cargodest.weight_scale_town[IsPassengerCargo(cid) ? SCALE_TOWN_PAX : SCALE_TOWN];
+	if (max_amt > big_amt) weight += (max_amt - big_amt) * weight_mod / _settings_game.economy.cargodest.weight_scale_town[IsPassengerCargo(cid) ? SCALE_TOWN_BIG_PAX : SCALE_TOWN_BIG];
+
+	return weight;
+}
+
+/* virtual */ uint Industry::GetDestinationWeight(CargoID cid, byte weight_mod) const
+{
+	uint weight = _settings_game.economy.cargodest.min_weight_ind;
+
+	for (uint i = 0; i < lengthof(this->accepts_cargo); i++) {
+		if (this->accepts_cargo[i] != cid) continue;
+		/* Empty stockpile means more weight for the link. Stockpiles
+		 * above a fixed maximum have no further effect. */
+		uint stockpile = ClampU(this->incoming_cargo_waiting[i], 0, MAX_IND_STOCKPILE);
+		weight += (MAX_IND_STOCKPILE - stockpile) * weight_mod / _settings_game.economy.cargodest.weight_scale_ind[WEIGHT_SCALE_IND_PILE];
+	}
+
+	/* Add a weight for the produced cargo. Use the average production
+	 * here so the weight isn't fluctuating that much when the input
+	 * cargo isn't delivered regularly. */
+	weight += (this->average_production[0] + this->average_production[1]) * weight_mod / _settings_game.economy.cargodest.weight_scale_ind[WEIGHT_SCALE_IND_PROD];
+
+	return weight;
+}
+
+/** Recalculate the link weights. */
+void UpdateLinkWeights(Town *t)
+{
+	for (CargoID cid = 0; cid < NUM_CARGO; cid++) {
+		uint weight_sum = 0;
+
+		if (t->cargo_links[cid].Length() == 0) continue;
+
+		t->cargo_links[cid].Begin()->amount.NewMonth();
+
+		/* Skip the special link for undetermined destinations. */
+		for (CargoLink *l = t->cargo_links[cid].Begin() + 1; l != t->cargo_links[cid].End(); l++) {
+			l->weight = l->dest->GetDestinationWeight(cid, l->weight_mod);
+			weight_sum += l->weight;
+
+			l->amount.NewMonth();
+		}
+
+		/* Limit the weight of the in-town link to at most 1/3 of the total weight. */
+		if (t->cargo_links[cid].Length() > 1 && t->cargo_links[cid].Get(1)->dest == t) {
+			uint new_weight = min(t->cargo_links[cid].Get(1)->weight, weight_sum / 3);
+			weight_sum -= t->cargo_links[cid].Get(1)->weight - new_weight;
+			t->cargo_links[cid].Get(1)->weight = new_weight;
+		}
+
+		/* Set weight for the undetermined destination link to random_dest_chance%. */
+		t->cargo_links[cid].Begin()->weight = weight_sum == 0 ? 1 : (weight_sum * _settings_game.economy.cargodest.random_dest_chance) / (100 - _settings_game.economy.cargodest.random_dest_chance);
+
+		t->cargo_links_weight[cid] = weight_sum + t->cargo_links[cid].Begin()->weight;
+	}
+}
+
+/** Recalculate the link weights. */
+void UpdateLinkWeights(CargoSourceSink *css)
+{
+	for (uint cid = 0; cid < NUM_CARGO; cid++) {
+		uint weight_sum = 0;
+
+		if (css->cargo_links[cid].Length() == 0) continue;
+
+		css->cargo_links[cid].Begin()->amount.NewMonth();
+
+		for (CargoLink *l = css->cargo_links[cid].Begin() + 1; l != css->cargo_links[cid].End(); l++) {
+			l->weight = l->dest->GetDestinationWeight(cid, l->weight_mod);
+			weight_sum += l->weight;
+
+			l->amount.NewMonth();
+		}
+
+		/* Set weight for the undetermined destination link to random_dest_chance%. */
+		css->cargo_links[cid].Begin()->weight = weight_sum == 0 ? 1 : (weight_sum * _settings_game.economy.cargodest.random_dest_chance) / (100 - _settings_game.economy.cargodest.random_dest_chance);
+
+		css->cargo_links_weight[cid] = weight_sum + css->cargo_links[cid].Begin()->weight;
+	}
+}
+
+/* virtual */ CargoSourceSink::~CargoSourceSink()
+{
+	if (Town::CleaningPool() || Industry::CleaningPool()) return;
+
+	/* Remove all demand links having us as a destination. */
+	Town *t;
+	FOR_ALL_TOWNS(t) {
+		for (CargoID cid = 0; cid < NUM_CARGO; cid++) {
+			if (t->HasLinkTo(cid, this)) {
+				t->cargo_links[cid].Erase(t->cargo_links[cid].Find(CargoLink(this, LWM_ANYWHERE)));
+				InvalidateWindowData(WC_TOWN_VIEW, t->index, 1);
+			}
+		}
+	}
+
+	Industry *ind;
+	FOR_ALL_INDUSTRIES(ind) {
+		for (CargoID cid = 0; cid < NUM_CARGO; cid++) {
+			if (ind->HasLinkTo(cid, this)) {
+				ind->cargo_links[cid].Erase(ind->cargo_links[cid].Find(CargoLink(this, LWM_ANYWHERE)));
+				InvalidateWindowData(WC_INDUSTRY_VIEW, ind->index, 1);
+			}
+		}
+	}
+
+	/* Decrement incoming link count for all link destinations. */
+	for (CargoID cid = 0; cid < NUM_CARGO; cid++) {
+		for (CargoLink *l = this->cargo_links[cid].Begin(); l != this->cargo_links[cid].End(); l++) {
+			if (l->dest != NULL) l->dest->num_incoming_links[cid]--;
+		}
+	}
+}
+
+/** Rebuild the cached count of incoming cargo links. */
+void RebuildCargoLinkCounts()
+{
+	/* Clear incoming link count of all towns and industries. */
+	CargoSourceSink *source;
+	FOR_ALL_TOWNS(source) MemSetT(source->num_incoming_links, 0, lengthof(source->num_incoming_links));
+	FOR_ALL_INDUSTRIES(source) MemSetT(source->num_incoming_links, 0, lengthof(source->num_incoming_links));
+
+	/* Count all incoming links. */
+	FOR_ALL_TOWNS(source) {
+		for (CargoID cid = 0; cid < NUM_CARGO; cid++) {
+			for (CargoLink *l = source->cargo_links[cid].Begin(); l != source->cargo_links[cid].End(); l++) {
+				if (l->dest != NULL && l->dest != source) l->dest->num_incoming_links[cid]++;
+			}
+		}
+	}
+	FOR_ALL_INDUSTRIES(source) {
+		for (CargoID cid = 0; cid < NUM_CARGO; cid++) {
+			for (CargoLink *l = source->cargo_links[cid].Begin(); l != source->cargo_links[cid].End(); l++) {
+				if (l->dest != NULL && l->dest != source) l->dest->num_incoming_links[cid]++;
+			}
+		}
+	}
+}
+
+/** Update the demand links of all towns and industries. */
+void UpdateCargoLinks()
+{
+	if (CargoDestinationsDisabled()) return;
+
+	Town *t;
+	Industry *ind;
+
+	/* Remove links that have become invalid. */
+	FOR_ALL_TOWNS(t) RemoveInvalidLinks(t);
+	FOR_ALL_INDUSTRIES(ind) RemoveInvalidLinks(ind);
+
+	/* Recalculate the number of expected links. */
+	FOR_ALL_TOWNS(t) UpdateExpectedLinks(t);
+	FOR_ALL_INDUSTRIES(ind) UpdateExpectedLinks(ind);
+
+	/* Make sure each industry gets at at least some input cargo. */
+	FOR_ALL_INDUSTRIES(ind) AddMissingIndustryLinks(ind);
+
+	/* Update the demand link list. */
+	FOR_ALL_TOWNS(t) UpdateCargoLinks(t);
+	FOR_ALL_INDUSTRIES(ind) UpdateCargoLinks(ind);
+
+	/* Recalculate links weights. */
+	FOR_ALL_TOWNS(t) UpdateLinkWeights(t);
+	FOR_ALL_INDUSTRIES(ind) UpdateLinkWeights(ind);
+
+	InvalidateWindowClassesData(WC_TOWN_VIEW, 1);
+	InvalidateWindowClassesData(WC_INDUSTRY_VIEW, 1);
+}
+
+/**
+ * Get a random demand link.
+ * @param cid Cargo type
+ * @param allow_self Indicates if the local link is acceptable as a result.
+ * @return Pointer to a demand link or this->cargo_links[cid].End() if no link found.
+ */
+CargoLink *CargoSourceSink::GetRandomLink(CargoID cid, bool allow_self)
+{
+	/* Randomly choose a cargo link. */
+	uint weight = RandomRange(this->cargo_links_weight[cid] - 1);
+	uint cur_sum = 0;
+
+	CargoLink *l;
+	for (l = this->cargo_links[cid].Begin(); l != this->cargo_links[cid].End(); ++l) {
+		cur_sum += l->weight;
+		if (weight < cur_sum) {
+			/* Link is valid if it is random destination or only the
+			 * local link if allowed and accepts the cargo. */
+			if (l->dest == NULL || ((allow_self || l->dest != this) && l->dest->AcceptsCargo(cid))) break;
+		}
+	}
+
+	return l;
+}
+
+
+/** Get a random destination tile index for this cargo. */
+/* virtual */ TileArea Town::GetTileForDestination(CargoID cid)
+{
+	assert(this->cargo_accepted_weights[cid] != 0);
+
+	/* Randomly choose a target square. */
+	uint32 weight = RandomRange(this->cargo_accepted_weights[cid] - 1);
+
+	/* Iterate over all grid squares till the chosen square is found. */
+	uint32 weight_sum = 0;
+	const TileArea &area = this->cargo_accepted.GetArea();
+	TILE_AREA_LOOP(tile, area) {
+		if (TileX(tile) % AcceptanceMatrix::GRID == 0 && TileY(tile) % AcceptanceMatrix::GRID == 0) {
+			weight_sum += this->cargo_accepted_max_weight - (DistanceMax(this->xy_aligned, tile) / AcceptanceMatrix::GRID) * 2;
+			/* Return tile area inside the grid square if this is the chosen square. */
+			if (weight < weight_sum) return TileArea(tile + TileDiffXY(1, 1), 2, 2);
+		}
+	}
+
+	/* Something went wrong here... */
+	NOT_REACHED();
+}
+
+/** Enumerate all towns accepting a specific cargo. */
+static bool EnumAcceptingTown(const Town *t, void *data)
+{
+	return t->AcceptsCargo((CargoID)(size_t)data);
+}
+
+/** Enumerate all industries accepting a specific cargo. */
+static bool EnumAcceptingIndustry(const Industry *ind, void *data)
+{
+	return ind->AcceptsCargo((CargoID)(size_t)data);
+}
+
+/**
+ * Move a single packet of cargo to a station with destination information.
+ * @param cid Cargo type.
+ * @param amount[in,out] Cargo amount, return is actually moved cargo.
+ * @param source_type Type of the cargo source.
+ * @param source_id ID of the cargo source.
+ * @param all_stations List of possible target stations.
+ * @param src_tile Source tile.
+ * @return True if the cargo was handled has having destinations.
+ */
+bool MoveCargoWithDestinationToStationWorker(CargoID cid, uint *amount, SourceType source_type, SourceID source_id, const StationList *all_stations, TileIndex src_tile)
+{
+	CargoSourceSink *source = NULL;
+	CargoSourceSink *dest = NULL;
+	CargoLink *l = NULL;
+
+	/* Company HQ doesn't have cargo links. */
+	if (source_type != ST_HEADQUARTERS) {
+		source = (source_type == ST_TOWN) ? static_cast<CargoSourceSink *>(Town::Get(source_id)) : static_cast<CargoSourceSink *>(Industry::Get(source_id));
+		/* No links yet? Create cargo without destination. */
+		if (source->cargo_links[cid].Length() == 0) return false;
+
+		/* Randomly choose a cargo link. */
+		l = source->GetRandomLink(cid, true);
+
+		if (l != source->cargo_links[cid].End()) {
+			l->amount.new_max += *amount;
+			dest = l->dest;
+		}
+	}
+
+	/* No destination or random destination? Try a random town. */
+	if (dest == NULL) dest = Town::GetRandom(&EnumAcceptingTown, INVALID_TOWN, (void *)(size_t)cid);
+	/* No luck? Try a random industry. */
+	if (dest == NULL) dest = Industry::GetRandom(&EnumAcceptingIndustry, INVALID_INDUSTRY, (void *)(size_t)cid);
+	/* Still no luck, nothing left to try. */
+	if (dest == NULL) return false;
+
+	/* Pick a tile that belongs to the destination. */
+	TileArea dest_area = dest->GetTileForDestination(cid);
+
+	/* Maximum pathfinder penalty based on distance. */
+	uint r = RandomRange(_settings_game.economy.cargodest.max_route_penalty[1]);
+	uint max_cost = _settings_game.economy.cargodest.max_route_penalty[0] + r;
+	max_cost *= DistanceSquare(src_tile, dest_area.tile);
+
+	/* Randomly determine the routing flags for the packet.
+	 * Right now only the two lowest bits are defined. */
+	byte flags = r & 0x3;
+
+	/* Find a route to the destination. */
+	StationID st, st_unload;
+	bool found = false;
+	RouteLink *route_link = YapfChooseRouteLink(cid, all_stations, src_tile, dest_area, &st, &st_unload, flags, &found, INVALID_ORDER, max_cost);
+
+	if (route_link == NULL) {
+		/* No suitable link found (or direct delivery), nothing is
+		 * moved to the station, but count it as transported anyway. */
+		if (found && l != NULL) l->amount.new_act += *amount;
+		*amount = 0;
+		return true;
+	}
+
+	/* Move cargo to the station. */
+	Station *from = Station::Get(st);
+	*amount = UpdateStationWaiting(from, cid, *amount * from->goods[cid].rating, source_type, source_id, dest_area.tile, dest->GetType(), dest->GetID(), route_link->GetOriginOrderId(), st_unload, flags);
+	if (found && l != NULL) l->amount.new_act += *amount;
+
+	/* If this is a symmetric cargo type, try to generate some cargo going from
+	 * destination to source as well. It's no error if that is not possible. */
+	if (IsSymmetricCargo(cid)) {
+		/* Try to find the matching cargo link back to the source. If no
+		 * link is found, don't generate return traffic. */
+		CargoLink *back_link = dest->cargo_links[cid].Find(CargoLink(source, LWM_ANYWHERE));
+		if (back_link == dest->cargo_links[cid].End()) return true;
+
+		back_link->amount.new_max += *amount;
+
+		/* Find stations around the new source area. */
+		StationFinder stf(dest_area);
+		TileIndex tile = dest_area.tile;
+
+		/* The the new destination area. */
+		switch (source_type) {
+			case ST_INDUSTRY:
+				dest_area = static_cast<Industry *>(source)->location;
+				break;
+			case ST_TOWN:
+				dest_area = TileArea(src_tile, 2, 2);
+				break;
+			case ST_HEADQUARTERS:
+				dest_area = TileArea(Company::Get(source_id)->location_of_HQ, 2, 2);
+				break;
+		}
+
+		/* Find a route and update transported amount if found. */
+		route_link = YapfChooseRouteLink(cid, stf.GetStations(), tile, dest_area, &st, &st_unload, flags, &found, INVALID_ORDER, max_cost);
+		if (found) back_link->amount.new_act += *amount;
+
+		if (route_link != NULL) {
+			/* Found a back link, move to station. */
+			UpdateStationWaiting(Station::Get(st), cid, *amount * 256, dest->GetType(), dest->GetID(), dest_area.tile, source_type, source_id, route_link->GetOriginOrderId(), st_unload, flags);
+		}
+	}
+
+	return true;
+}
+
+/**
+ * Move cargo to a station with destination information.
+ * @param cid Cargo type.
+ * @param amount[in,out] Cargo amount, return is actually moved cargo.
+ * @param source_type Type of the cargo source.
+ * @param source_id ID of the cargo source.
+ * @param all_stations List of possible target stations.
+ * @param src_tile Source tile.
+ * @return True if the cargo was handled has having destinations.
+ */
+bool MoveCargoWithDestinationToStation(CargoID cid, uint *amount, SourceType source_type, SourceID source_id, const StationList *all_stations, TileIndex src_tile)
+{
+	if (!CargoHasDestinations(cid)) return false;
+
+	/* Split the cargo into multiple destinations for industries. */
+	int num_packets = 1;
+	if (source_type == ST_INDUSTRY) {
+		if (*amount > 5) num_packets++;
+		if (*amount > 50) num_packets += 2;
+	}
+
+	/* Generate num_packets different destinations while making
+	 * sure no cargo is lost due to rounding. */
+	uint amount_packet = *amount / num_packets;
+	uint last_packet = *amount - (num_packets - 1) * amount_packet;
+	uint moved = 0;
+	for (; num_packets > 0; num_packets--) {
+		uint cur_amount = (num_packets == 1) ? last_packet : amount_packet;
+
+		/* If we fail once, we will fail always. */
+		if (!MoveCargoWithDestinationToStationWorker(cid, &cur_amount, source_type, source_id, all_stations, src_tile)) return false;
+		moved += cur_amount;
+	}
+
+	*amount = moved;
+	return true;
+}
+
+/**
+ * Get the current best route link for a cargo packet at a station.
+ * @param st Station the route starts at.
+ * @param cid Cargo type.
+ * @param cp Cargo packet with destination information.
+ * @param order Incoming order of the cargo packet.
+ * @param[out] found Set to true if a route was found.
+ * @return The preferred route link or NULL if either no suitable link found or the station is the final destination.
+ */
+RouteLink *FindRouteLinkForCargo(Station *st, CargoID cid, const CargoPacket *cp, StationID *next_unload, OrderID order, bool *found)
+{
+	if (cp->DestinationID() == INVALID_SOURCE) return NULL;
+
+	StationList sl;
+	*sl.Append() = st;
+
+	TileArea area = (cp->DestinationType() == ST_INDUSTRY) ? Industry::Get(cp->DestinationID())->location : TileArea(cp->DestinationXY(), 2, 2);
+	return YapfChooseRouteLink(cid, &sl, st->xy, area, NULL, next_unload, cp->Flags(), found, order);
+}
+
+
+/* Initialize the RouteLink-pool */
+RouteLinkPool _routelink_pool("RouteLink");
+INSTANTIATE_POOL_METHODS(RouteLink)
+
+/**
+ * Invalidate some stuff on destruction.
+ */
+RouteLink::~RouteLink()
+{
+	if (RouteLink::CleaningPool()) return;
+
+	if (this->GetOriginOrderId() != INVALID_ORDER) StationCargoList::InvalidateAllTo(this->GetOriginOrderId(), this->GetDestination());
+}
+
+/**
+ * Update or create a single route link for a specific vehicle and cargo.
+ * @param v The vehicle.
+ * @param cargoes Create links for the cargo types whose bit is set.
+ * @param clear_others Should route links for cargo types nor carried be cleared?
+ * @param from Originating station.
+ * @param from_oid Originating order.
+ * @param to_id Destination station ID.
+ * @param to_oid Destination order.
+ * @param travel_time Travel time for the route.
+ */
+void UpdateVehicleRouteLinks(const Vehicle *v, uint32 cargoes, bool clear_others, Station *from, OrderID from_oid, StationID to_id, OrderID to_oid, uint32 travel_time)
+{
+	for (CargoID cid = 0; cid < NUM_CARGO; cid++) {
+		bool has_cargo = HasBit(cargoes, cid);
+		/* Skip if cargo not carried and we aren't supposed to clear other links. */
+		if (!clear_others && !has_cargo) continue;
+		/* Skip cargo types that don't have destinations enabled. */
+		if (!CargoHasDestinations(cid)) continue;
+
+		RouteLinkList::iterator link;
+		for (link = from->goods[cid].routes.begin(); link != from->goods[cid].routes.end(); ++link) {
+			if ((*link)->GetOriginOrderId() == from_oid) {
+				if (has_cargo) {
+					/* Update destination if necessary. */
+					(*link)->SetDestination(to_id, to_oid);
+					(*link)->UpdateTravelTime(travel_time);
+				} else {
+					/* Remove link. */
+					delete *link;
+					from->goods[cid].routes.erase(link);
+				}
+				break;
+			}
+		}
+
+		/* No link found? Append a new one. */
+		if (has_cargo && link == from->goods[cid].routes.end() && RouteLink::CanAllocateItem()) {
+			from->goods[cid].routes.push_back(new RouteLink(to_id, from_oid, to_oid, v->owner, travel_time, v->type));
+		}
+	}
+}
+
+/**
+ * Update route links after a vehicle has arrived at a station.
+ * @param v The vehicle.
+ * @param arrived_at The station the vehicle arrived at.
+ */
+void UpdateVehicleRouteLinks(const Vehicle *v, StationID arrived_at)
+{
+	/* Only update links if we have valid previous station and orders. */
+	if (v->last_station_loaded == INVALID_STATION || v->last_order_id == INVALID_ORDER || v->current_order.index == INVALID_ORDER) return;
+	/* Loop? Not good. */
+	if (v->last_station_loaded == arrived_at) return;
+
+	Station *from = Station::Get(v->last_station_loaded);
+	Station *to = Station::Get(arrived_at);
+
+	/* Update incoming route link. */
+	UpdateVehicleRouteLinks(v, v->vcache.cached_cargo_mask, false, from, v->last_order_id, arrived_at, v->current_order.index, v->travel_time);
+
+	/* Update outgoing links. */
+	CargoID cid;
+	FOR_EACH_SET_CARGO_ID(cid, v->vcache.cached_cargo_mask) {
+		/* Skip cargo types that don't have destinations enabled. */
+		if (!CargoHasDestinations(cid)) continue;
+
+		for (RouteLinkList::iterator link = to->goods[cid].routes.begin(); link != to->goods[cid].routes.end(); ++link) {
+			if ((*link)->GetOriginOrderId() == v->current_order.index) {
+				(*link)->VehicleArrived();
+				break;
+			}
+		}
+	}
+}
+
+/**
+ * Pre-fill the route links from the orders of a vehicle.
+ * @param v The vehicle to get the orders from.
+ */
+void PrefillRouteLinks(const Vehicle *v)
+{
+	if (CargoDestinationsDisabled()) return;
+	if (v->orders.list == NULL || v->orders.list->GetNumOrders() < 2) return;
+
+	/* Can't pre-fill if the vehicle has refit or conditional orders. */
+	uint count = 0;
+	Order *order;
+	FOR_VEHICLE_ORDERS(v, order) {
+		if (order->IsType(OT_GOTO_DEPOT) && order->IsRefit()) return;
+		if (order->IsType(OT_CONDITIONAL)) return;
+		if ((order->IsType(OT_IMPLICIT) || order->IsType(OT_GOTO_STATION)) && (order->GetNonStopType() & ONSF_NO_STOP_AT_DESTINATION_STATION) == 0) count++;
+	}
+
+	/* Increment count by one to account for the circular nature of the order list. */
+	if (count > 0) count++;
+
+	/* Collect cargo types carried by all vehicles in the shared order list. */
+	uint32 transported_cargoes = 0;
+	for (Vehicle *u = v->FirstShared(); u != NULL; u = u->NextShared()) {
+		transported_cargoes |= u->vcache.cached_cargo_mask;
+	}
+
+	/* Loop over all orders to update/pre-fill the route links. */
+	order = v->orders.list->GetFirstOrder();
+	Order *prev_order = NULL;
+	do {
+		/* Goto station or implicit order and not a go via-order, consider as destination. */
+		if ((order->IsType(OT_IMPLICIT) || order->IsType(OT_GOTO_STATION)) && (order->GetNonStopType() & ONSF_NO_STOP_AT_DESTINATION_STATION) == 0) {
+			/* Previous destination is set and the new destination is different, create/update route links. */
+			if (prev_order != NULL && prev_order != order && prev_order->GetDestination() != order->GetDestination()) {
+				Station *from = Station::Get(prev_order->GetDestination());
+				Station *to = Station::Get(order->GetDestination());
+				/* A vehicle with the speed of 128 km/h-ish would take one tick for each of the
+				 * #TILE_SIZE steps per tile. For aircraft, the time needs to be scaled with the
+				 * plane speed factor. */
+				uint time = DistanceManhattan(from->xy, to->xy) * TILE_SIZE * 128 / v->GetDisplayMaxSpeed();
+				if (v->type == VEH_AIRCRAFT) time *= _settings_game.vehicle.plane_speed;
+				UpdateVehicleRouteLinks(v, transported_cargoes, true, from, prev_order->index, order->GetDestination(), order->index, time);
+			}
+
+			prev_order = order;
+			count--;
+		}
+
+		/* Get next order, wrap around if necessary. */
+		order = order->next;
+		if (order == NULL) order = v->orders.list->GetFirstOrder();
+	} while (count > 0);
+}
+
+/**
+ * Remove all route links to and from a station.
+ * @param station Station being removed.
+ */
+void InvalidateStationRouteLinks(Station *station)
+{
+	/* Delete all outgoing links. */
+	for (CargoID cid = 0; cid < NUM_CARGO; cid++) {
+		for (RouteLinkList::iterator link = station->goods[cid].routes.begin(); link != station->goods[cid].routes.end(); ++link) {
+			delete *link;
+		}
+	}
+
+	/* Delete all incoming link. */
+	Station *st_from;
+	FOR_ALL_STATIONS(st_from) {
+		if (st_from == station) continue;
+
+		for (CargoID cid = 0; cid < NUM_CARGO; cid++) {
+			/* Don't increment the iterator directly in the for loop as we don't want to increment when deleting a link. */
+			for (RouteLinkList::iterator link = st_from->goods[cid].routes.begin(); link != st_from->goods[cid].routes.end(); ) {
+				if ((*link)->GetDestination() == station->index) {
+					delete *link;
+					link = st_from->goods[cid].routes.erase(link);
+				} else {
+					++link;
+				}
+			}
+		}
+	}
+}
+
+/**
+ * Remove all route links referencing an order.
+ * @param order The order being removed.
+ */
+void InvalidateOrderRouteLinks(OrderID order)
+{
+	Station *st;
+	FOR_ALL_STATIONS(st) {
+		for (CargoID cid = 0; cid < NUM_CARGO; cid++) {
+			/* Don't increment the iterator directly in the for loop as we don't want to increment when deleting a link. */
+			for (RouteLinkList::iterator link = st->goods[cid].routes.begin(); link != st->goods[cid].routes.end(); ) {
+				if ((*link)->GetOriginOrderId() == order || (*link)->GetDestOrderId() == order) {
+					delete *link;
+					link = st->goods[cid].routes.erase(link);
+				} else {
+					++link;
+				}
+			}
+		}
+	}
+}
+
+/** Age and expire route links of a station. */
+void AgeRouteLinks(Station *st)
+{
+	/* Reset waiting time for all vehicles currently loading. */
+	for (std::list<Vehicle *>::const_iterator v_itr = st->loading_vehicles.begin(); v_itr != st->loading_vehicles.end(); ++v_itr) {
+		CargoID cid;
+		FOR_EACH_SET_CARGO_ID(cid, (*v_itr)->vcache.cached_cargo_mask) {
+			for (RouteLinkList::iterator link = st->goods[cid].routes.begin(); link != st->goods[cid].routes.end(); ++link) {
+				if ((*link)->GetOriginOrderId() == (*v_itr)->last_order_id) (*link)->wait_time = 0;
+			}
+		}
+	}
+
+	for (CargoID cid = 0; cid < NUM_CARGO; cid++) {
+		/* Don't increment the iterator directly in the for loop as we don't want to increment when deleting a link. */
+		for (RouteLinkList::iterator link = st->goods[cid].routes.begin(); link != st->goods[cid].routes.end(); ) {
+			if ((*link)->wait_time++ > _settings_game.economy.cargodest.max_route_age) {
+				delete *link;
+				link = st->goods[cid].routes.erase(link);
+			} else {
+				++link;
+			}
+		}
+	}
+}
diff -urNad openttd-1.3.2/src/cargodest_func.h openttd-1.3.2-DC3.0RC3/src/cargodest_func.h
--- openttd-1.3.2/src/cargodest_func.h	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/cargodest_func.h	2013-11-22 05:49:06.000000000 +0100
@@ -0,0 +1,35 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file cargodest_func.h Functions related to cargo destinations. */
+
+#ifndef CARGODEST_FUNC_H
+#define CARGODEST_FUNC_H
+
+#include "cargodest_type.h"
+#include "cargo_type.h"
+#include "vehicle_type.h"
+#include "station_type.h"
+#include "order_type.h"
+
+bool CargoHasDestinations(CargoID cid);
+
+RouteLink *FindRouteLinkForCargo(Station *st, CargoID cid, const struct CargoPacket *cp, StationID *next_unload, OrderID order = INVALID_ORDER, bool *found = NULL);
+bool MoveCargoWithDestinationToStation(CargoID cid, uint *amount, SourceType source_type, SourceID source_id, const StationList *all_stations, TileIndex src_tile);
+
+void UpdateVehicleRouteLinks(const Vehicle *v, StationID arrived_at);
+void PrefillRouteLinks(const Vehicle *v);
+void InvalidateStationRouteLinks(Station *station);
+void InvalidateOrderRouteLinks(OrderID order);
+void AgeRouteLinks(Station *st);
+
+void RebuildCargoLinkCounts();
+void UpdateCargoLinks();
+
+#endif /* CARGODEST_FUNC_H */
diff -urNad openttd-1.3.2/src/cargodest_gui.cpp openttd-1.3.2-DC3.0RC3/src/cargodest_gui.cpp
--- openttd-1.3.2/src/cargodest_gui.cpp	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/cargodest_gui.cpp	2013-11-22 05:49:06.000000000 +0100
@@ -0,0 +1,176 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file cargodest_gui.cpp GUI for cargo destinations. */
+
+#include "stdafx.h"
+#include "window_gui.h"
+#include "gfx_func.h"
+#include "strings_func.h"
+#include "cargodest_base.h"
+#include "cargodest_gui.h"
+#include "town.h"
+#include "industry.h"
+#include "string_func.h"
+#include "gui.h"
+#include "viewport_func.h"
+
+#include "table/strings.h"
+
+static const CargoSourceSink *_cur_cargo_source;
+
+int CDECL CargoLinkSorter(const GUICargoLink *a, const GUICargoLink *b)
+{
+	/* Sort by cargo type. */
+	if (a->cid != b->cid) return a->cid < b->cid ? -1 : +1;
+
+	/* Sort unspecified destination links always last. */
+	if (a->link->dest == NULL) return +1;
+	if (b->link->dest == NULL) return -1;
+
+	/* Sort link with the current source as destination first. */
+	if (a->link->dest == _cur_cargo_source) return -1;
+	if (b->link->dest == _cur_cargo_source) return +1;
+
+	/* Sort towns before industries. */
+	if (a->link->dest->GetType() != b->link->dest->GetType()) {
+		return a->link->dest->GetType() < b->link->dest->GetType() ? +1 : -1;
+	}
+
+	/* Sort by name. */
+	static const CargoLink *last_b = NULL;
+	static char last_name[128];
+
+	char name[128];
+	SetDParam(0, a->link->dest->GetID());
+	GetString(name, a->link->dest->GetType() == ST_TOWN ? STR_TOWN_NAME : STR_INDUSTRY_NAME, lastof(name));
+
+	/* Cache name lookup of 'b', as the sorter is often called
+	 * multiple times with the same 'b'. */
+	if (b->link != last_b) {
+		last_b = b->link;
+
+		SetDParam(0, b->link->dest->GetID());
+		GetString(last_name, b->link->dest->GetType() == ST_TOWN ? STR_TOWN_NAME : STR_INDUSTRY_NAME, lastof(last_name));
+	}
+
+	return strcmp(name, last_name);
+}
+
+CargoDestinationList::CargoDestinationList(const CargoSourceSink *o) : obj(o)
+{
+	this->InvalidateData();
+}
+
+/** Rebuild the link list from the source object. */
+void CargoDestinationList::RebuildList()
+{
+	if (!this->link_list.NeedRebuild()) return;
+
+	this->link_list.Clear();
+	for (CargoID i = 0; i < lengthof(this->obj->cargo_links); i++) {
+		for (const CargoLink *l = this->obj->cargo_links[i].Begin(); l != this->obj->cargo_links[i].End(); l++) {
+			*this->link_list.Append() = GUICargoLink(i, l);
+		}
+	}
+
+	this->link_list.Compact();
+	this->link_list.RebuildDone();
+}
+
+/** Sort the link list. */
+void CargoDestinationList::SortList()
+{
+	_cur_cargo_source = this->obj;
+	this->link_list.Sort(&CargoLinkSorter);
+}
+
+/** Rebuild the list, e.g. when a new cargo link was added. */
+void CargoDestinationList::InvalidateData()
+{
+	this->link_list.ForceRebuild();
+	this->RebuildList();
+	this->SortList();
+}
+
+/** Resort the list, e.g. when a town is renamed. */
+void CargoDestinationList::Resort()
+{
+	this->link_list.ForceResort();
+	this->SortList();
+}
+
+/**
+ * Get the height needed to display the destination list.
+ * @param obj Object to display the destinations of.
+ * @return Height needed for display.
+ */
+uint CargoDestinationList::GetListHeight() const
+{
+	uint lines = 2 + this->link_list.Length();
+	return lines > 2 ? WD_PAR_VSEP_WIDE + lines * FONT_HEIGHT_NORMAL : 0;
+}
+
+/**
+ * Draw the destination list.
+ * @param left The left most position to draw on.
+ * @param right The right most position to draw on.
+ * @param y The top position to start drawing.
+ * @return New \c y value below the drawn text.
+ */
+uint CargoDestinationList::DrawList(uint left, uint right, uint y) const
+{
+	if (this->link_list.Length() == 0) return y;
+
+	DrawString(left + WD_FRAMERECT_LEFT, right - WD_FRAMERECT_RIGHT, y += WD_PAR_VSEP_WIDE + FONT_HEIGHT_NORMAL, STR_VIEW_CARGO_LAST_MONTH_OUT);
+
+	for (const GUICargoLink *l = this->link_list.Begin(); l != this->link_list.End(); l++) {
+		SetDParam(0, l->cid);
+		SetDParam(1, l->link->amount.old_act);
+		SetDParam(2, l->cid);
+		SetDParam(3, l->link->amount.old_max);
+
+		/* Select string according to the destination type. */
+		if (l->link->dest == NULL) {
+			DrawString(left + 2 * WD_FRAMERECT_LEFT, right - WD_FRAMERECT_RIGHT, y += FONT_HEIGHT_NORMAL, STR_VIEW_CARGO_LAST_MONTH_OTHER);
+		} else if (l->link->dest == obj) {
+			DrawString(left + 2 * WD_FRAMERECT_LEFT, right - WD_FRAMERECT_RIGHT, y += FONT_HEIGHT_NORMAL, STR_VIEW_CARGO_LAST_MONTH_LOCAL);
+		} else {
+			SetDParam(4, l->link->dest->GetID());
+			DrawString(left + 2 * WD_FRAMERECT_LEFT, right - WD_FRAMERECT_RIGHT, y += FONT_HEIGHT_NORMAL, l->link->dest->GetType() == ST_TOWN ? STR_VIEW_CARGO_LAST_MONTH_TOWN : STR_VIEW_CARGO_LAST_MONTH_INDUSTRY);
+		}
+	}
+
+	return y + FONT_HEIGHT_NORMAL;
+}
+
+/**
+ * Handle click event onto the destination list.
+ * @param y Position of the click in relative to the top of the destination list.
+ */
+void CargoDestinationList::OnClick(uint y) const
+{
+	/* Subtract caption height. */
+	y -= WD_PAR_VSEP_WIDE + 2 * FONT_HEIGHT_NORMAL;
+
+	/* Calculate line from click pos. */
+	y /= FONT_HEIGHT_NORMAL;
+	if (y >= this->link_list.Length()) return;
+
+	/* Move viewpoint to the position of the destination. */
+	const CargoLink *l = this->link_list[y].link;
+	if (l->dest == NULL) return;
+
+	TileIndex xy = l->dest->GetType() == ST_TOWN ? static_cast<const Town *>(l->dest)->xy : static_cast<const Industry *>(l->dest)->location.tile;
+	if (_ctrl_pressed) {
+		ShowExtraViewPortWindow(xy);
+	} else {
+		ScrollMainWindowToTile(xy);
+	}
+}
diff -urNad openttd-1.3.2/src/cargodest_gui.h openttd-1.3.2-DC3.0RC3/src/cargodest_gui.h
--- openttd-1.3.2/src/cargodest_gui.h	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/cargodest_gui.h	2013-11-22 05:49:06.000000000 +0100
@@ -0,0 +1,48 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file cargodest_gui.h Functions/types related to the cargodest GUI. */
+
+#ifndef CARGODEST_GUI_H
+#define CARGODEST_GUI_H
+
+#include "cargodest_base.h"
+#include "sortlist_type.h"
+
+/** Helper encapsulating a #CargoLink. */
+struct GUICargoLink {
+	CargoID         cid;   ///< Cargo ID of this link.
+	const CargoLink *link; ///< Pointer to the link.
+
+	GUICargoLink(CargoID c, const CargoLink *l) : cid(c), link(l) {}
+};
+
+/** Sorted list of demand destinations for displaying. */
+class CargoDestinationList
+{
+private:
+	const CargoSourceSink *obj;      ///< The object which destinations are displayed.
+	GUIList<GUICargoLink> link_list; ///< Sorted list of destinations.
+
+	void RebuildList();
+	void SortList();
+
+public:
+	CargoDestinationList(const CargoSourceSink *o);
+
+	void InvalidateData();
+	void Resort();
+
+	uint GetListHeight() const;
+	uint DrawList(uint left, uint right, uint y) const;
+
+	void OnClick(uint y) const;
+};
+
+#endif /* CARGODEST_GUI_H */
diff -urNad openttd-1.3.2/src/cargodest_type.h openttd-1.3.2-DC3.0RC3/src/cargodest_type.h
--- openttd-1.3.2/src/cargodest_type.h	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/cargodest_type.h	2013-11-22 05:49:06.000000000 +0100
@@ -0,0 +1,31 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file cargodest_type.h Type definitions for cargo destinations. */
+
+#ifndef CARGODEST_TYPE_H
+#define CARGODEST_TYPE_H
+
+/** Flags specifying the demand mode for cargo. */
+enum CargoRoutingMode {
+	CRM_OFF,             ///< No routing, original behaviour
+	CRM_FIXED_DEST,      ///< Fixed destinations
+};
+
+/** Flags specifying how cargo should be routed. */
+enum RoutingFlags {
+	RF_WANT_FAST,    ///< Cargo wants to travel as fast as possible.
+	RF_WANT_CHEAP,   ///< Cargo wants to travel as cheap as possible.
+};
+
+/** Unique identifier for a routing link. */
+typedef uint32 RouteLinkID;
+struct RouteLink;
+
+#endif /* CARGODEST_TYPE_H */
diff -urNad openttd-1.3.2/src/cargopacket.cpp openttd-1.3.2-DC3.0RC3/src/cargopacket.cpp
--- openttd-1.3.2/src/cargopacket.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/cargopacket.cpp	2013-11-22 05:49:06.000000000 +0100
@@ -12,6 +12,10 @@
 #include "stdafx.h"
 #include "core/pool_func.hpp"
 #include "economy_base.h"
+#include "station_base.h"
+#include "cargodest_func.h"
+#include "cargodest_base.h"
+#include "settings_type.h"
 
 /* Initialize the cargopacket-pool */
 CargoPacketPool _cargopacket_pool("CargoPacket");
@@ -24,6 +28,12 @@
 {
 	this->source_type = ST_INDUSTRY;
 	this->source_id   = INVALID_SOURCE;
+	this->dest_xy     = INVALID_TILE;
+	this->dest_id     = INVALID_SOURCE;
+	this->dest_type   = ST_INDUSTRY;
+	this->flags       = 0;
+	this->next_order  = INVALID_ORDER;
+	this->next_station = INVALID_STATION;
 }
 
 /**
@@ -33,21 +43,33 @@
  * @param count       Number of cargo entities to put in this packet.
  * @param source_type 'Type' of source the packet comes from (for subsidies).
  * @param source_id   Actual source of the packet (for subsidies).
+ * @param dest_xy     Destination location of the packet.
+ * @param dest_type   'Type' of the destination.
+ * @param dest_id     Actual destination of the packet.
+ * @param next_order  Desired next hop of the packet.
+ * @param next_station Station to unload the packet next.
+ * @param flags       Routing flags of the packet.
  * @pre count != 0
  * @note We have to zero memory ourselves here because we are using a 'new'
  * that, in contrary to all other pools, does not memset to 0.
  */
-CargoPacket::CargoPacket(StationID source, TileIndex source_xy, uint16 count, SourceType source_type, SourceID source_id) :
+CargoPacket::CargoPacket(StationID source, TileIndex source_xy, uint16 count, SourceType source_type, SourceID source_id, TileIndex dest_xy, SourceType dest_type, SourceID dest_id, OrderID next_order, StationID next_station, byte flags) :
 	feeder_share(0),
 	count(count),
 	days_in_transit(0),
 	source_id(source_id),
 	source(source),
 	source_xy(source_xy),
-	loaded_at_xy(0)
+	loaded_at_xy(0),
+	dest_xy(dest_xy),
+	dest_id(dest_id),
+	flags(flags),
+	next_order(next_order),
+	next_station(next_station)
 {
 	assert(count != 0);
 	this->source_type  = source_type;
+	this->dest_type    = dest_type;
 }
 
 /**
@@ -61,20 +83,32 @@
  * @param feeder_share    Feeder share the packet has already accumulated.
  * @param source_type     'Type' of source the packet comes from (for subsidies).
  * @param source_id       Actual source of the packet (for subsidies).
+ * @param dest_xy         Destination location of the packet.
+ * @param dest_type       'Type' of the destination.
+ * @param dest_id         Actual destination of the packet.
+ * @param next_order      Desired next hop of the packet.
+ * @param next_station Station to unload the packet next.
+ * @param flags           Routing flags of the packet.
  * @note We have to zero memory ourselves here because we are using a 'new'
  * that, in contrary to all other pools, does not memset to 0.
  */
-CargoPacket::CargoPacket(uint16 count, byte days_in_transit, StationID source, TileIndex source_xy, TileIndex loaded_at_xy, Money feeder_share, SourceType source_type, SourceID source_id) :
+CargoPacket::CargoPacket(uint16 count, byte days_in_transit, StationID source, TileIndex source_xy, TileIndex loaded_at_xy, Money feeder_share, SourceType source_type, SourceID source_id, TileIndex dest_xy, SourceType dest_type, SourceID dest_id, OrderID next_order, StationID next_station, byte flags) :
 		feeder_share(feeder_share),
 		count(count),
 		days_in_transit(days_in_transit),
 		source_id(source_id),
 		source(source),
 		source_xy(source_xy),
-		loaded_at_xy(loaded_at_xy)
+		loaded_at_xy(loaded_at_xy),
+		dest_xy(dest_xy),
+		dest_id(dest_id),
+		flags(flags),
+		next_order(next_order),
+		next_station(next_station)
 {
 	assert(count != 0);
 	this->source_type = source_type;
+	this->dest_type   = dest_type;
 }
 
 /**
@@ -87,7 +121,7 @@
 	if (!CargoPacket::CanAllocateItem()) return NULL;
 
 	Money fs = this->feeder_share * new_size / static_cast<uint>(this->count);
-	CargoPacket *cp_new = new CargoPacket(new_size, this->days_in_transit, this->source, this->source_xy, this->loaded_at_xy, fs, this->source_type, this->source_id);
+	CargoPacket *cp_new = new CargoPacket(new_size, this->days_in_transit, this->source, this->source_xy, this->loaded_at_xy, fs, this->source_type, this->source_id, this->dest_xy, this->dest_type, this->dest_id, this->next_order, this->next_station, this->flags);
 	this->feeder_share -= fs;
 	this->count -= new_size;
 	return cp_new;
@@ -111,9 +145,16 @@
  */
 /* static */ void CargoPacket::InvalidateAllFrom(SourceType src_type, SourceID src)
 {
+	/* Clear next hop of those packets that loose their destination. */
+	StationCargoList::InvalidateAllTo(src_type, src);
+
 	CargoPacket *cp;
 	FOR_ALL_CARGOPACKETS(cp) {
 		if (cp->source_type == src_type && cp->source_id == src) cp->source_id = INVALID_SOURCE;
+		if (cp->dest_type == src_type && cp->dest_id == src) {
+			cp->dest_id = INVALID_SOURCE;
+			cp->dest_xy = INVALID_TILE;
+		}
 	}
 }
 
@@ -126,6 +167,7 @@
 	CargoPacket *cp;
 	FOR_ALL_CARGOPACKETS(cp) {
 		if (cp->source == sid) cp->source = INVALID_STATION;
+		if (cp->next_station == sid) cp->next_station = INVALID_STATION;
 	}
 }
 
@@ -229,6 +271,7 @@
 			uint diff = local_count - max_remaining;
 			this->count -= diff;
 			this->cargo_days_in_transit -= cp->days_in_transit * diff;
+			static_cast<Tinst *>(this)->RemoveFromCacheLocal(cp, diff);
 			cp->count = max_remaining;
 			max_remaining = 0;
 		} else {
@@ -245,56 +288,121 @@
  *  - MTA_CARGO_LOAD:     Sets the loaded_at_xy value of the moved packets.
  *  - MTA_TRANSFER:       Just move without side effects.
  *  - MTA_UNLOAD:         Just move without side effects.
+ *  - MTA_NO_ACTION:      Does nothing for packets without destination, otherwise either like MTA_TRANSFER or MTA_FINAL_DELIVERY.
  * @param dest  Destination to move the cargo to.
  * @param max_move Amount of cargo entities to move.
  * @param mta   How to handle the moving (side effects).
- * @param data  Depending on mta the data of this variable differs:
- *              - MTA_FINAL_DELIVERY - Station ID of packet's origin not to remove.
- *              - MTA_CARGO_LOAD     - Station's tile index of load.
- *              - MTA_TRANSFER       - Unused.
- *              - MTA_UNLOAD         - Unused.
+ * @param st    Station ID where we are loading/unloading or STATION_INVALID for move from vehicle to vehicle.
  * @param payment The payment helper.
+ * @param cur_order The current order of the loading vehicle.
+ * @param did_transfer Set to true if some cargo was transfered.
  *
  * @pre mta == MTA_FINAL_DELIVERY || dest != NULL
  * @pre mta == MTA_UNLOAD || mta == MTA_CARGO_LOAD || payment != NULL
+ * @pre st != INVALID_STATION || (mta != MTA_CARGO_LOAD && payment == NULL)
  * @return True if there are still packets that might be moved from this cargo list.
  */
 template <class Tinst>
 template <class Tother_inst>
-bool CargoList<Tinst>::MoveTo(Tother_inst *dest, uint max_move, MoveToAction mta, CargoPayment *payment, uint data)
+bool CargoList<Tinst>::MoveTo(Tother_inst *dest, uint max_move, MoveToAction mta, CargoPayment *payment, StationID st, OrderID cur_order, CargoID cid, bool *did_transfer)
 {
 	assert(mta == MTA_FINAL_DELIVERY || dest != NULL);
 	assert(mta == MTA_UNLOAD || mta == MTA_CARGO_LOAD || payment != NULL);
+	assert(st != INVALID_STATION || (mta != MTA_CARGO_LOAD && payment == NULL));
 
+restart:;
 	Iterator it(this->packets.begin());
 	while (it != this->packets.end() && max_move > 0) {
 		CargoPacket *cp = *it;
-		if (cp->source == data && mta == MTA_FINAL_DELIVERY) {
-			/* Skip cargo that originated from this station. */
+		MoveToAction cp_mta = mta;
+		OrderID current_next_order = cp->NextHop();
+		StationID current_next_unload = cp->NextStation();
+
+		if (cp_mta == MTA_CARGO_LOAD) {
+			/* Invalid next hop but valid destination? Recompute next hop. */
+			if (current_next_order == INVALID_ORDER && cp->DestinationID() != INVALID_SOURCE) {
+				if (!this->UpdateCargoNextHop(cp, Station::Get(st), cid)) {
+					/* Failed to find destination, drop packet. */
+					it = this->packets.erase(it);
+					continue;
+				}
+				current_next_order = cp->NextHop();
+				current_next_unload = cp->NextStation();
+			}
+
+			/* Loading and not for the current vehicle? Skip. */
+			if (current_next_order != cur_order) {
+				++it;
+				continue;
+			}
+		}
+
+		/* Has this packet a destination and are we unloading to a station (not autoreplace)? */
+		if (cp->DestinationID() != INVALID_SOURCE && cp_mta != MTA_CARGO_LOAD && payment != NULL) {
+			/* Not forced unload and not for unloading at this station? Skip the packet. */
+			if (cp_mta != MTA_UNLOAD && cp->NextStation() != INVALID_STATION && cp->NextStation() != st) {
+				++it;
+				continue;
+			}
+
+			Station *station = Station::Get(st);
+
+			bool found;
+			StationID next_unload;
+			RouteLink *link = FindRouteLinkForCargo(station, cid, cp, &next_unload, cur_order, &found);
+			if (!found) {
+				/* Sorry, link to destination vanished, make cargo disappear. */
+				static_cast<Tinst *>(this)->RemoveFromCache(cp);
+				delete cp;
+				it = this->packets.erase(it);
+				continue;
+			}
+
+			if (link != NULL) {
+				/* Not final destination. */
+				if (link->GetOriginOrderId() == cur_order && cp_mta != MTA_UNLOAD) {
+					/* Cargo should stay on the vehicle and not forced unloading? Skip. */
+					++it;
+					continue;
+				}
+				/* Force transfer and update next hop. */
+				cp_mta = MTA_TRANSFER;
+				current_next_order = link->GetOriginOrderId();
+				current_next_unload = next_unload;
+			} else {
+				/* Final destination, deliver. */
+				cp_mta = MTA_FINAL_DELIVERY;
+			}
+		} else if (cp_mta == MTA_NO_ACTION || (cp->source == st && cp_mta == MTA_FINAL_DELIVERY)) {
+			/* Skip cargo that is not accepted or originated from this station. */
 			++it;
 			continue;
 		}
 
+		if (did_transfer != NULL && cp_mta == MTA_TRANSFER) *did_transfer = true;
+
 		if (cp->count <= max_move) {
 			/* Can move the complete packet */
 			max_move -= cp->count;
 			it = this->packets.erase(it);
 			static_cast<Tinst *>(this)->RemoveFromCache(cp);
-			switch (mta) {
+			cp->next_order = current_next_order;
+			cp->next_station = current_next_unload;
+			switch (cp_mta) {
 				case MTA_FINAL_DELIVERY:
 					payment->PayFinalDelivery(cp, cp->count);
 					delete cp;
 					continue; // of the loop
 
 				case MTA_CARGO_LOAD:
-					cp->loaded_at_xy = data;
+					cp->loaded_at_xy = Station::Get(st)->xy;
 					break;
 
 				case MTA_TRANSFER:
 					cp->feeder_share += payment->PayTransfer(cp, cp->count);
 					break;
 
-				case MTA_UNLOAD:
+				default:
 					break;
 			}
 			dest->Append(cp);
@@ -302,7 +410,7 @@
 		}
 
 		/* Can move only part of the packet */
-		if (mta == MTA_FINAL_DELIVERY) {
+		if (cp_mta == MTA_FINAL_DELIVERY) {
 			/* Final delivery doesn't need package splitting. */
 			payment->PayFinalDelivery(cp, max_move);
 
@@ -323,12 +431,14 @@
 			if (cp_new == NULL) return false;
 
 			static_cast<Tinst *>(this)->RemoveFromCache(cp_new); // this reflects the changes in cp.
+			cp_new->next_order = current_next_order;
+			cp_new->next_station = current_next_unload;
 
-			if (mta == MTA_TRANSFER) {
+			if (cp_mta == MTA_TRANSFER) {
 				/* Add the feeder share before inserting in dest. */
 				cp_new->feeder_share += payment->PayTransfer(cp_new, max_move);
-			} else if (mta == MTA_CARGO_LOAD) {
-				cp_new->loaded_at_xy = data;
+			} else if (cp_mta == MTA_CARGO_LOAD) {
+				cp_new->loaded_at_xy = Station::Get(st)->xy;
 			}
 
 			dest->Append(cp_new);
@@ -337,6 +447,12 @@
 		max_move = 0;
 	}
 
+	if (max_move > 0 && mta == MTA_CARGO_LOAD && cur_order != INVALID_ORDER && Station::Get(st)->goods[cid].cargo.CountForNextHop(INVALID_ORDER) > 0) {
+		/* We loaded all packets for the next hop, now load all packets without destination. */
+		cur_order = INVALID_ORDER;
+		goto restart;
+	}
+
 	return it != packets.end();
 }
 
@@ -396,6 +512,158 @@
 	this->Parent::InvalidateCache();
 }
 
+/** Invalidate next unload station of all cargo packets. */
+void VehicleCargoList::InvalidateNextStation()
+{
+	for (VehicleCargoList::ConstIterator it = this->packets.begin(); it != this->packets.end(); ++it) {
+		(*it)->next_station = INVALID_STATION;
+	}
+}
+
+/**
+ * Update the local next-hop count cache.
+ * @param cp Packet the be removed.
+ * @param amount Cargo amount to be removed.
+ */
+void StationCargoList::RemoveFromCacheLocal(const CargoPacket *cp, uint amount)
+{
+	this->order_cache[cp->next_order] -= amount;
+	if (this->order_cache[cp->next_order] == 0) this->order_cache.erase(cp->next_order);
+}
+
+/**
+ * Update the cached values to reflect the removal of this packet.
+ * Decreases count and days_in_transit.
+ * @param cp Packet to be removed from cache.
+ */
+void StationCargoList::RemoveFromCache(const CargoPacket *cp)
+{
+	this->RemoveFromCacheLocal(cp, cp->count);
+	this->Parent::RemoveFromCache(cp);
+}
+
+/**
+ * Update the cache to reflect adding of this packet.
+ * Increases count and days_in_transit.
+ * @param cp New packet to be inserted.
+ */
+void StationCargoList::AddToCache(const CargoPacket *cp)
+{
+	this->order_cache[cp->next_order] += cp->count;
+	this->Parent::AddToCache(cp);
+}
+
+/** Invalidates the cached data and rebuild it. */
+void StationCargoList::InvalidateCache()
+{
+	this->order_cache.clear();
+	this->Parent::InvalidateCache();
+}
+
+/**
+ * Recompute the desired next hop of a cargo packet.
+ * @param cp  Cargo packet to update.
+ * @param st  Station of  this list.
+ * @param cid Cargo type of this list.
+ * @return False if the packet was deleted, true otherwise.
+ */
+bool StationCargoList::UpdateCargoNextHop(CargoPacket *cp, Station *st, CargoID cid)
+{
+	StationID next_unload;
+	RouteLink *l = FindRouteLinkForCargo(st, cid, cp, &next_unload);
+
+	if (l == NULL) {
+		/* No link to destination, drop packet. */
+		this->RemoveFromCache(cp);
+		delete cp;
+		return false;
+	}
+
+	/* Update next hop info. */
+	this->RemoveFromCache(cp);
+	cp->next_station = next_unload;
+	cp->next_order = l->GetOriginOrderId();
+	this->AddToCache(cp);
+
+	return true;
+}
+
+/**
+ * Recompute the desired next hop of all cargo packets.
+ * @param st  Station of this list.
+ * @param cid Cargo type of this list.
+ */
+void StationCargoList::UpdateCargoNextHop(Station *st, CargoID cid)
+{
+	uint count = 0;
+	StationCargoList::Iterator iter;
+	for (iter = this->packets.begin(); count < this->next_start + _settings_game.economy.cargodest.route_recalc_chunk && iter != this->packets.end(); count++) {
+		if (count < this->next_start) continue;
+		if ((*iter)->DestinationID() != INVALID_SOURCE) {
+			if (this->UpdateCargoNextHop(*iter, st, cid)) {
+				++iter;
+			} else {
+				iter = this->packets.erase(iter);
+			}
+		} else {
+			++iter;
+		}
+	}
+
+	/* Update start counter for next loop. */
+	this->next_start = count;
+	if (this->next_start >= this->packets.size()) this->next_start = 0;
+}
+
+/**
+ * Invalidates the next hop info of all cargo packets with a given next order or unload station.
+ * @param order Next order to invalidate.
+ * @param st_unload Unload station to invalidate.
+ */
+/* static */ void StationCargoList::InvalidateAllTo(OrderID order, StationID st_unload)
+{
+	Station *st;
+	FOR_ALL_STATIONS(st) {
+		for (CargoID cid = 0; cid < NUM_CARGO; cid++) {
+			for (StationCargoList::Iterator it = st->goods[cid].cargo.packets.begin(); it != st->goods[cid].cargo.packets.end(); ++it) {
+				CargoPacket *cp = *it;
+				if (cp->next_order == order || cp->next_station == st_unload) {
+					/* Invalidate both order and unload station as both likely
+					 * don't make sense anymore. */
+					st->goods[cid].cargo.RemoveFromCache(cp);
+					cp->next_order = INVALID_ORDER;
+					cp->next_station = INVALID_STATION;
+					st->goods[cid].cargo.AddToCache(cp);
+				}
+			}
+		}
+	}
+}
+
+/**
+ * Invalidates the next hop info of all cargo packets for a given destination.
+ * @param order Next order to invalidate.
+ */
+/* static */ void StationCargoList::InvalidateAllTo(SourceType type, SourceID dest)
+{
+	Station *st;
+	FOR_ALL_STATIONS(st) {
+		for (CargoID cid = 0; cid < NUM_CARGO; cid++) {
+			for (StationCargoList::Iterator it = st->goods[cid].cargo.packets.begin(); it != st->goods[cid].cargo.packets.end(); ++it) {
+				CargoPacket *cp = *it;
+				if (cp->dest_id == dest && cp->dest_type == type) {
+					/* Invalidate both next order and unload station as we
+					 * want the packets to be not routed anymore. */
+					st->goods[cid].cargo.RemoveFromCache(cp);
+					cp->next_order = INVALID_ORDER;
+					cp->next_station = INVALID_STATION;
+					st->goods[cid].cargo.AddToCache(cp);
+				}
+			}
+		}
+	}
+}
+
 /*
  * We have to instantiate everything we want to be usable.
  */
@@ -403,8 +671,8 @@
 template class CargoList<StationCargoList>;
 
 /** Autoreplace Vehicle -> Vehicle 'transfer'. */
-template bool CargoList<VehicleCargoList>::MoveTo(VehicleCargoList *, uint max_move, MoveToAction mta, CargoPayment *payment, uint data);
+template bool CargoList<VehicleCargoList>::MoveTo(VehicleCargoList *, uint max_move, MoveToAction mta, CargoPayment *payment, StationID st, OrderID cur_order, CargoID cid, bool *did_transfer);
 /** Cargo unloading at a station. */
-template bool CargoList<VehicleCargoList>::MoveTo(StationCargoList *, uint max_move, MoveToAction mta, CargoPayment *payment, uint data);
+template bool CargoList<VehicleCargoList>::MoveTo(StationCargoList *, uint max_move, MoveToAction mta, CargoPayment *payment, StationID st, OrderID cur_order, CargoID cid, bool *did_transfer);
 /** Cargo loading at a station. */
-template bool CargoList<StationCargoList>::MoveTo(VehicleCargoList *, uint max_move, MoveToAction mta, CargoPayment *payment, uint data);
+template bool CargoList<StationCargoList>::MoveTo(VehicleCargoList *, uint max_move, MoveToAction mta, CargoPayment *payment, StationID st, OrderID cur_order, CargoID cid, bool *did_transfer);
diff -urNad openttd-1.3.2/src/cargopacket.h openttd-1.3.2-DC3.0RC3/src/cargopacket.h
--- openttd-1.3.2/src/cargopacket.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/cargopacket.h	2013-11-22 05:49:06.000000000 +0100
@@ -17,7 +17,10 @@
 #include "station_type.h"
 #include "cargo_type.h"
 #include "vehicle_type.h"
+#include "order_type.h"
+#include "cargotype.h"
 #include <list>
+#include <map>
 
 /** Unique identifier for a single cargo packet. */
 typedef uint32 CargoPacketID;
@@ -44,6 +47,12 @@
 	StationID source;           ///< The station where the cargo came from first.
 	TileIndex source_xy;        ///< The origin of the cargo (first station in feeder chain).
 	TileIndex loaded_at_xy;     ///< Location where this cargo has been loaded into the vehicle.
+	TileIndex dest_xy;          ///< Destination tile or INVALID_TILE if no specific destination
+	SourceID dest_id;           ///< Index of the destination.
+	SourceTypeByte dest_type;   ///< Type of #dest_id.
+	byte flags;                 ///< Flags influencing the routing decision of this packet, see #RouteFlags.
+	OrderID next_order;         ///< Next desired hop.
+	StationID next_station;     ///< Unload at this station next.
 
 	/** The CargoList caches, thus needs to know about it. */
 	template <class Tinst> friend class CargoList;
@@ -51,13 +60,14 @@
 	friend class StationCargoList;
 	/** We want this to be saved, right? */
 	friend const struct SaveLoad *GetCargoPacketDesc();
+	friend bool CargodestModeChanged(int32 p1);
 public:
 	/** Maximum number of items in a single cargo packet. */
 	static const uint16 MAX_COUNT = UINT16_MAX;
 
 	CargoPacket();
-	CargoPacket(StationID source, TileIndex source_xy, uint16 count, SourceType source_type, SourceID source_id);
-	CargoPacket(uint16 count, byte days_in_transit, StationID source, TileIndex source_xy, TileIndex loaded_at_xy, Money feeder_share = 0, SourceType source_type = ST_INDUSTRY, SourceID source_id = INVALID_SOURCE);
+	CargoPacket(StationID source, TileIndex source_xy, uint16 count, SourceType source_type, SourceID source_id, TileIndex dest_xy = INVALID_TILE, SourceType dest_type = ST_INDUSTRY, SourceID dest_id = INVALID_SOURCE, OrderID next_order = INVALID_ORDER, StationID next_station = INVALID_STATION, byte flags = 0);
+	CargoPacket(uint16 count, byte days_in_transit, StationID source, TileIndex source_xy, TileIndex loaded_at_xy, Money feeder_share = 0, SourceType source_type = ST_INDUSTRY, SourceID source_id = INVALID_SOURCE, TileIndex dest_xy = INVALID_TILE, SourceType dest_type = ST_INDUSTRY, SourceID dest_id = INVALID_SOURCE, OrderID next_order = INVALID_ORDER, StationID next_station = INVALID_STATION, byte flags = 0);
 
 	/** Destroy the packet. */
 	~CargoPacket() { }
@@ -140,6 +150,59 @@
 		return this->loaded_at_xy;
 	}
 
+	/**
+	 * Gets the coordinates of the cargo's destination.
+	 * @return The destination tile.
+	 */
+	inline TileIndex DestinationXY() const
+	{
+		return this->dest_xy;
+	}
+
+	/**
+	 * Gets the ID of the destination of the cargo.
+	 * @return The destination ID.
+	 */
+	inline SourceID DestinationID() const
+	{
+		return this->dest_id;
+	}
+
+	/**
+	 * Gets the type of the destination of the cargo.
+	 * @return The destination type.
+	 */
+	inline SourceType DestinationType() const
+	{
+		return this->dest_type;
+	}
+
+	/**
+	 * Gets the routing behaviour flags of this packet.
+	 * @return The routing flags.
+	 */
+	inline byte Flags() const
+	{
+		return this->flags;
+	}
+
+	/**
+	 * Gets the order ID of the next desired hop.
+	 * @return The order ID of the next desired hop.
+	 */
+	inline OrderID NextHop() const
+	{
+		return this->next_order;
+	}
+
+	/**
+	 * Gets the station ID where the packet should be unloaded next.
+	 * @return The station ID where the packet should be unloaded.
+	 */
+	inline StationID NextStation() const
+	{
+		return this->next_station;
+	}
 
 	static void InvalidateAllFrom(SourceType src_type, SourceID src);
 	static void InvalidateAllFrom(StationID sid);
@@ -179,8 +242,11 @@
 		MTA_CARGO_LOAD,     ///< Load the packet onto a vehicle, i.e. set the last loaded station ID.
 		MTA_TRANSFER,       ///< The cargo is moved as part of a transfer.
 		MTA_UNLOAD,         ///< The cargo is moved as part of a forced unload.
+		MTA_NO_ACTION,      ///< The station doesn't accept the cargo, so do nothing (only applicable to cargo without destination)
 	};
 
+	friend bool CargodestModeChanged(int32 p1);
+
 protected:
 	uint count;                 ///< Cache for the number of cargo entities.
 	uint cargo_days_in_transit; ///< Cache for the sum of number of days in transit of each entity; comparable to man-hours.
@@ -191,11 +257,18 @@
 
 	void RemoveFromCache(const CargoPacket *cp);
 
+	void RemoveFromCacheLocal(const CargoPacket *cp, uint amount) {}
+
+	virtual bool UpdateCargoNextHop(CargoPacket *cp, Station *st, CargoID cid)
+	{
+		return true;
+	}
+
 public:
 	/** Create the cargo list. */
 	CargoList() {}
 
-	~CargoList();
+	virtual ~CargoList();
 
 	void OnCleanPool();
 
@@ -249,7 +322,7 @@
 	void Truncate(uint max_remaining);
 
 	template <class Tother_inst>
-	bool MoveTo(Tother_inst *dest, uint count, MoveToAction mta, CargoPayment *payment, uint data = 0);
+	bool MoveTo(Tother_inst *dest, uint count, MoveToAction mta, CargoPayment *payment, StationID st = INVALID_STATION, OrderID cur_order = INVALID_ORDER, CargoID cid = INVALID_CARGO, bool *did_transfer = NULL);
 
 	void InvalidateCache();
 };
@@ -286,6 +359,8 @@
 
 	void InvalidateCache();
 
+	void InvalidateNextStation();
+
 	/**
 	 * Are two the two CargoPackets mergeable in the context of
 	 * a list of CargoPackets for a Vehicle?
@@ -299,7 +374,13 @@
 				cp1->days_in_transit == cp2->days_in_transit &&
 				cp1->source_type     == cp2->source_type &&
 				cp1->source_id       == cp2->source_id &&
-				cp1->loaded_at_xy    == cp2->loaded_at_xy;
+				cp1->loaded_at_xy    == cp2->loaded_at_xy &&
+				cp1->dest_xy         == cp2->dest_xy &&
+				cp1->dest_type       == cp2->dest_type &&
+				cp1->dest_id         == cp2->dest_id &&
+				cp1->next_order      == cp2->next_order &&
+				cp1->next_station    == cp2->next_station &&
+				cp1->flags           == cp2->flags;
 	}
 };
 
@@ -308,11 +389,51 @@
  */
 class StationCargoList : public CargoList<StationCargoList> {
 public:
+	typedef std::map<OrderID, int> OrderMap;
+
+protected:
+	/** The (direct) parent of this class. */
+	typedef CargoList<StationCargoList> Parent;
+
+	OrderMap order_cache;
+	uint32 next_start;        ///< Packet number to start the next hop update loop from.
+
+	void AddToCache(const CargoPacket *cp);
+	void RemoveFromCache(const CargoPacket *cp);
+	void RemoveFromCacheLocal(const CargoPacket *cp, uint amount);
+
+	/* virtual */ bool UpdateCargoNextHop(CargoPacket *cp, Station *st, CargoID cid);
+
+public:
 	/** The super class ought to know what it's doing. */
 	friend class CargoList<StationCargoList>;
 	/** The stations, via GoodsEntry, have a CargoList. */
 	friend const struct SaveLoad *GetGoodsDesc();
 
+	void InvalidateCache();
+
+	void UpdateCargoNextHop(Station *st, CargoID cid);
+
+	/**
+	 * Gets the cargo counts per next hop.
+	 * @return Cargo counts.
+	 */
+	const OrderMap& CountForNextHop() const
+	{
+		return this->order_cache;
+	}
+
+	/**
+	 * Gets the cargo count for a next hop.
+	 * @param order The next hop.
+	 * @return The cargo count for the specified next hop.
+	 */
+	int CountForNextHop(OrderID order) const
+	{
+		OrderMap::const_iterator i = this->order_cache.find(order);
+		return i != this->order_cache.end() ? i->second : 0;
+	}
+
 	/**
 	 * Are two the two CargoPackets mergeable in the context of
 	 * a list of CargoPackets for a Vehicle?
@@ -325,8 +446,17 @@
 		return cp1->source_xy    == cp2->source_xy &&
 				cp1->days_in_transit == cp2->days_in_transit &&
 				cp1->source_type     == cp2->source_type &&
-				cp1->source_id       == cp2->source_id;
+				cp1->source_id       == cp2->source_id &&
+				cp1->dest_xy         == cp2->dest_xy &&
+				cp1->dest_type       == cp2->dest_type &&
+				cp1->dest_id         == cp2->dest_id &&
+				cp1->next_order      == cp2->next_order &&
+				cp1->next_station    == cp2->next_station &&
+				cp1->flags           == cp2->flags;
 	}
+
+	static void InvalidateAllTo(OrderID order, StationID st_unload);
+	static void InvalidateAllTo(SourceType type, SourceID dest);
 };
 
 #endif /* CARGOPACKET_H */
diff -urNad openttd-1.3.2/src/cheat_gui.cpp openttd-1.3.2-DC3.0RC3/src/cheat_gui.cpp
--- openttd-1.3.2/src/cheat_gui.cpp	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/cheat_gui.cpp	2013-11-22 05:49:06.000000000 +0100
@@ -21,11 +21,16 @@
 #include "string_func.h"
 #include "strings_func.h"
 #include "window_func.h"
+#include "newgrf.h"
 #include "rail_gui.h"
 #include "settings_gui.h"
 #include "company_gui.h"
+#include "error.h"
 
 #include "widgets/cheat_widget.h"
+#include "map_func.h"
+#include "tile_map.h"
+
 
 #include "table/sprites.h"
 
@@ -109,6 +114,41 @@
 	return _cur_year;
 }
 
+ /**
+ * Allow (or disallow) a change of the maximal allowed heightlevel.
+ * @param p1 new value
+ * @param p2 unused
+ * @return New value (or unchanged old value) of the maximal
+ *         allowed heightlevel value.
+ */
+static int32 ClickChangeMaxHlCheat(int32 p1, int32 p2) {
+	if (p1 < (int32)MIN_MAX_HEIGHTLEVEL) {
+		// new value too small
+		return _settings_game.construction.max_heightlevel;
+	} else if (p1 > (int32)MAX_MAX_HEIGHTLEVEL) {
+		// new value too big
+		return _settings_game.construction.max_heightlevel;
+	} else {
+		// Check if at least one mountain on the map is higher than the new value.
+		// If yes, disallow the change.
+		for (uint x = 0; x < MapMaxX(); x++) {
+			for (uint y = 0; y < MapMaxY(); y++) {
+				TileIndex tile = TileXY(x, y);
+				if ((int32)TileHeight(tile) > p1) {
+					ShowErrorMessage(STR_CONFIG_SETTING_TOO_HIGH_MOUNTAIN, INVALID_STRING_ID, WL_ERROR);
+					// Return old, unchanged value
+					return _settings_game.construction.max_heightlevel;
+				}
+			}
+		}
+
+		// Execute the change and reload GRF Data
+		_settings_game.construction.max_heightlevel = p1;
+		ReloadNewGRFData();
+		return _settings_game.construction.max_heightlevel;
+	}
+}
+
 /** Available cheats. */
 enum CheatNumbers {
 	CHT_MONEY,           ///< Change amount of money.
@@ -117,6 +157,7 @@
 	CHT_CROSSINGTUNNELS, ///< Allow tunnels to cross each other.
 	CHT_NO_JETCRASH,     ///< Disable jet-airplane crashes.
 	CHT_SETUP_PROD,      ///< Allow manually editing of industry production.
+	CHT_EDIT_MAX_HL,     ///< Edit maximal allowed heightlevel
 	CHT_CHANGE_DATE,     ///< Do time traveling.
 
 	CHT_NUM_CHEATS,      ///< Number of cheats.
@@ -149,6 +190,7 @@
 	{SLE_BOOL,  STR_CHEAT_CROSSINGTUNNELS, &_cheats.crossing_tunnels.value,         &_cheats.crossing_tunnels.been_used, NULL                     },
 	{SLE_BOOL,  STR_CHEAT_NO_JETCRASH,     &_cheats.no_jetcrash.value,              &_cheats.no_jetcrash.been_used,      NULL                     },
 	{SLE_BOOL,  STR_CHEAT_SETUP_PROD,      &_cheats.setup_prod.value,               &_cheats.setup_prod.been_used,       &ClickSetProdCheat       },
+	{SLE_UINT8, STR_CHEAT_EDIT_MAX_HL,     &_settings_game.construction.max_heightlevel, &_cheats.edit_max_hl.been_used, &ClickChangeMaxHlCheat   },
 	{SLE_INT32, STR_CHEAT_CHANGE_DATE,     &_cur_year,                              &_cheats.change_date.been_used,      &ClickChangeDateCheat    },
 };
 
@@ -296,6 +338,12 @@
 			SetDParam(0, value);
 			ShowQueryString(STR_JUST_INT, STR_CHEAT_CHANGE_DATE_QUERY_CAPT, 8, this, CS_NUMERAL, QSF_ACCEPT_UNCHANGED);
 			return;
+		} else if (btn == CHT_EDIT_MAX_HL && x >= 40) {
+			/* Click at the max. heightlevel text directly. */
+// TODO: How to process the result in OnQueryTextFinished / how to find out that we want to change max. heightlevel, not date
+//			SetDParam(0, value);
+//			ShowQueryString(STR_JUST_INT, STR_CHEAT_EDIT_MAX_HL_QUERY_CAPT, 8, this, CS_NUMERAL, QSF_ACCEPT_UNCHANGED);
+//			return;
 		}
 
 		/* Not clicking a button? */
diff -urNad openttd-1.3.2/src/cheat_type.h openttd-1.3.2-DC3.0RC3/src/cheat_type.h
--- openttd-1.3.2/src/cheat_type.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/cheat_type.h	2013-11-22 05:49:06.000000000 +0100
@@ -36,6 +36,7 @@
 	Cheat change_date;      ///< changes date ingame
 	Cheat setup_prod;       ///< setup raw-material production in game
 	Cheat dummy3;           ///< empty cheat (enable running el-engines on normal rail)
+	Cheat edit_max_hl;      ///< edit the maximal heightlevel
 };
 
 extern Cheats _cheats;
diff -urNad openttd-1.3.2/src/clear_cmd.cpp openttd-1.3.2-DC3.0RC3/src/clear_cmd.cpp
--- openttd-1.3.2/src/clear_cmd.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/clear_cmd.cpp	2013-11-22 05:49:06.000000000 +0100
@@ -124,6 +124,7 @@
 			break;
 	}
 
+	DrawOverlay(ti, MP_CLEAR);
 	DrawBridgeMiddle(ti);
 }
 
@@ -183,11 +184,24 @@
 		if (!IsSnowTile(tile)) return;
 	} else {
 		/* At or above the snow line, make snow tile if needed. */
-		if (!IsSnowTile(tile)) {
-			MakeSnow(tile);
-			MarkTileDirtyByTile(tile);
-			return;
-		}
+		switch (_settings_game.game_creation.landscape) {
+		case LT_ARCTIC:
+			if (!IsSnowTile(tile)) {
+				MakeSnow(tile);
+				MarkTileDirtyByTile(tile);
+				return;
+			}
+			break;
+		case LT_TEMPERATE:
+			if (_settings_game.construction.snow_in_temperate) {
+				if (!IsSnowTile(tile)) {
+					MakeSnow(tile);
+					MarkTileDirtyByTile(tile);
+					return;
+				}
+			}
+			break;
+		};
 	}
 	/* Update snow density. */
 	uint current_density = GetClearDensity(tile);
@@ -261,6 +275,7 @@
 	switch (_settings_game.game_creation.landscape) {
 		case LT_TROPIC: TileLoopClearDesert(tile); break;
 		case LT_ARCTIC: TileLoopClearAlps(tile);   break;
+		case LT_TEMPERATE: TileLoopClearAlps(tile); break;
 	}
 
 	switch (GetClearGround(tile)) {
@@ -398,4 +413,5 @@
 	NULL,                     ///< vehicle_enter_tile_proc
 	GetFoundation_Clear,      ///< get_foundation_proc
 	TerraformTile_Clear,      ///< terraform_tile_proc
+	NULL,                     ///< copypaste_tile_proc
 };
diff -urNad openttd-1.3.2/src/clear_map.h openttd-1.3.2-DC3.0RC3/src/clear_map.h
--- openttd-1.3.2/src/clear_map.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/clear_map.h	2013-11-22 05:49:06.000000000 +0100
@@ -37,7 +37,7 @@
 static inline bool IsSnowTile(TileIndex t)
 {
 	assert(IsTileType(t, MP_CLEAR));
-	return HasBit(_m[t].m3, 4);
+	return HasBit(GetTile(t)->m3, 4);
 }
 
 /**
@@ -49,7 +49,7 @@
 static inline ClearGround GetRawClearGround(TileIndex t)
 {
 	assert(IsTileType(t, MP_CLEAR));
-	return (ClearGround)GB(_m[t].m5, 2, 3);
+	return (ClearGround)GB(GetTile(t)->m5, 2, 3);
 }
 
 /**
@@ -85,7 +85,7 @@
 static inline uint GetClearDensity(TileIndex t)
 {
 	assert(IsTileType(t, MP_CLEAR));
-	return GB(_m[t].m5, 0, 2);
+	return GB(GetTile(t)->m5, 0, 2);
 }
 
 /**
@@ -97,7 +97,7 @@
 static inline void AddClearDensity(TileIndex t, int d)
 {
 	assert(IsTileType(t, MP_CLEAR)); // XXX incomplete
-	_m[t].m5 += d;
+	GetTile(t)->m5 += d;
 }
 
 /**
@@ -109,7 +109,7 @@
 static inline void SetClearDensity(TileIndex t, uint d)
 {
 	assert(IsTileType(t, MP_CLEAR));
-	SB(_m[t].m5, 0, 2, d);
+	SB(GetTile(t)->m5, 0, 2, d);
 }
 
 
@@ -122,7 +122,7 @@
 static inline uint GetClearCounter(TileIndex t)
 {
 	assert(IsTileType(t, MP_CLEAR));
-	return GB(_m[t].m5, 5, 3);
+	return GB(GetTile(t)->m5, 5, 3);
 }
 
 /**
@@ -134,7 +134,7 @@
 static inline void AddClearCounter(TileIndex t, int c)
 {
 	assert(IsTileType(t, MP_CLEAR)); // XXX incomplete
-	_m[t].m5 += c << 5;
+	GetTile(t)->m5 += c << 5;
 }
 
 /**
@@ -146,7 +146,7 @@
 static inline void SetClearCounter(TileIndex t, uint c)
 {
 	assert(IsTileType(t, MP_CLEAR)); // XXX incomplete
-	SB(_m[t].m5, 5, 3, c);
+	SB(GetTile(t)->m5, 5, 3, c);
 }
 
 
@@ -160,7 +160,7 @@
 static inline void SetClearGroundDensity(TileIndex t, ClearGround type, uint density)
 {
 	assert(IsTileType(t, MP_CLEAR)); // XXX incomplete
-	_m[t].m5 = 0 << 5 | type << 2 | density;
+	GetTile(t)->m5 = 0 << 5 | type << 2 | density;
 }
 
 
@@ -173,7 +173,7 @@
 static inline uint GetFieldType(TileIndex t)
 {
 	assert(GetClearGround(t) == CLEAR_FIELDS);
-	return GB(_m[t].m3, 0, 4);
+	return GB(GetTile(t)->m3, 0, 4);
 }
 
 /**
@@ -185,7 +185,7 @@
 static inline void SetFieldType(TileIndex t, uint f)
 {
 	assert(GetClearGround(t) == CLEAR_FIELDS); // XXX incomplete
-	SB(_m[t].m3, 0, 4, f);
+	SB(GetTile(t)->m3, 0, 4, f);
 }
 
 /**
@@ -197,7 +197,7 @@
 static inline IndustryID GetIndustryIndexOfField(TileIndex t)
 {
 	assert(GetClearGround(t) == CLEAR_FIELDS);
-	return(IndustryID) _m[t].m2;
+	return(IndustryID) GetTile(t)->m2;
 }
 
 /**
@@ -209,7 +209,7 @@
 static inline void SetIndustryIndexOfField(TileIndex t, IndustryID i)
 {
 	assert(GetClearGround(t) == CLEAR_FIELDS);
-	_m[t].m2 = i;
+	GetTile(t)->m2 = i;
 }
 
 
@@ -222,7 +222,7 @@
 static inline uint GetFenceSE(TileIndex t)
 {
 	assert(IsClearGround(t, CLEAR_FIELDS));
-	return GB(_m[t].m4, 2, 3);
+	return GB(GetTile(t)->m4, 2, 3);
 }
 
 /**
@@ -235,7 +235,7 @@
 static inline void SetFenceSE(TileIndex t, uint h)
 {
 	assert(IsClearGround(t, CLEAR_FIELDS));
-	SB(_m[t].m4, 2, 3, h);
+	SB(GetTile(t)->m4, 2, 3, h);
 }
 
 /**
@@ -247,7 +247,7 @@
 static inline uint GetFenceSW(TileIndex t)
 {
 	assert(IsClearGround(t, CLEAR_FIELDS));
-	return GB(_m[t].m4, 5, 3);
+	return GB(GetTile(t)->m4, 5, 3);
 }
 
 /**
@@ -260,7 +260,7 @@
 static inline void SetFenceSW(TileIndex t, uint h)
 {
 	assert(IsClearGround(t, CLEAR_FIELDS));
-	SB(_m[t].m4, 5, 3, h);
+	SB(GetTile(t)->m4, 5, 3, h);
 }
 
 /**
@@ -272,7 +272,7 @@
 static inline uint GetFenceNE(TileIndex t)
 {
 	assert(IsClearGround(t, CLEAR_FIELDS));
-	return GB(_m[t].m3, 5, 3);
+	return GB(GetTile(t)->m3, 5, 3);
 }
 
 /**
@@ -285,7 +285,7 @@
 static inline void SetFenceNE(TileIndex t, uint h)
 {
 	assert(IsClearGround(t, CLEAR_FIELDS));
-	SB(_m[t].m3, 5, 3, h);
+	SB(GetTile(t)->m3, 5, 3, h);
 }
 
 /**
@@ -297,7 +297,7 @@
 static inline uint GetFenceNW(TileIndex t)
 {
 	assert(IsClearGround(t, CLEAR_FIELDS));
-	return GB(_m[t].m6, 2, 3);
+	return GB(GetTileEx(t)->m6, 2, 3);
 }
 
 /**
@@ -310,7 +310,7 @@
 static inline void SetFenceNW(TileIndex t, uint h)
 {
 	assert(IsClearGround(t, CLEAR_FIELDS));
-	SB(_m[t].m6, 2, 3, h);
+	SB(GetTileEx(t)->m6, 2, 3, h);
 }
 
 
@@ -324,17 +324,17 @@
 {
 	/* If this is a non-bridgeable tile, clear the bridge bits while the rest
 	 * of the tile information is still here. */
-	if (!MayHaveBridgeAbove(t)) SB(_m[t].m6, 6, 2, 0);
+	if (!MayHaveBridgeAbove(t)) SB(GetTileEx(t)->m6, 6, 2, 0);
 
 	SetTileType(t, MP_CLEAR);
-	_m[t].m1 = 0;
+	GetTile(t)->m1 = 0;
 	SetTileOwner(t, OWNER_NONE);
-	_m[t].m2 = 0;
-	_m[t].m3 = 0;
-	_m[t].m4 = 0 << 5 | 0 << 2;
+	GetTile(t)->m2 = 0;
+	GetTile(t)->m3 = 0;
+	GetTile(t)->m4 = 0 << 5 | 0 << 2;
 	SetClearGroundDensity(t, g, density); // Sets m5
-	SB(_m[t].m6, 2, 4, 0); // Other bits are "tropic zone" and "bridge above"
-	_me[t].m7 = 0;
+	SB(GetTileEx(t)->m6, 2, 4, 0); // Other bits are "tropic zone" and "bridge above"
+	GetTileEx(t)->m7 = 0;
 }
 
 
@@ -347,14 +347,14 @@
 static inline void MakeField(TileIndex t, uint field_type, IndustryID industry)
 {
 	SetTileType(t, MP_CLEAR);
-	_m[t].m1 = 0;
+	GetTile(t)->m1 = 0;
 	SetTileOwner(t, OWNER_NONE);
-	_m[t].m2 = industry;
-	_m[t].m3 = field_type;
-	_m[t].m4 = 0 << 5 | 0 << 2;
+	GetTile(t)->m2 = industry;
+	GetTile(t)->m3 = field_type;
+	GetTile(t)->m4 = 0 << 5 | 0 << 2;
 	SetClearGroundDensity(t, CLEAR_FIELDS, 3);
-	SB(_m[t].m6, 2, 4, 0);
-	_me[t].m7 = 0;
+	SB(GetTileEx(t)->m6, 2, 4, 0);
+	GetTileEx(t)->m7 = 0;
 }
 
 /**
@@ -366,7 +366,7 @@
 static inline void MakeSnow(TileIndex t, uint density = 0)
 {
 	assert(GetClearGround(t) != CLEAR_SNOW);
-	SetBit(_m[t].m3, 4);
+	SetBit(GetTile(t)->m3, 4);
 	if (GetRawClearGround(t) == CLEAR_FIELDS) {
 		SetClearGroundDensity(t, CLEAR_GRASS, density);
 	} else {
@@ -382,7 +382,7 @@
 static inline void ClearSnow(TileIndex t)
 {
 	assert(GetClearGround(t) == CLEAR_SNOW);
-	ClrBit(_m[t].m3, 4);
+	ClrBit(GetTile(t)->m3, 4);
 	SetClearDensity(t, 3);
 }
 
diff -urNad openttd-1.3.2/src/clipboard.cpp openttd-1.3.2-DC3.0RC3/src/clipboard.cpp
--- openttd-1.3.2/src/clipboard.cpp	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/clipboard.cpp	2013-11-22 05:49:06.000000000 +0100
@@ -0,0 +1,355 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file clipboard.cpp Implementaion of clipboard related to both copying and pasting. */
+
+#include "stdafx.h"
+#include "core/alloc_func.hpp"
+#include "core/mem_func.hpp"
+#include "clipboard_func.h"
+#include "tilearea_type.h"
+#include "station_map.h"
+#include "void_map.h"
+#include "newgrf_airport.h"
+
+static Map _clipboard_buffers[NUM_CLIPBOARD_BUFFERS];
+static ClipboardStationList _clipboard_stations[NUM_CLIPBOARD_BUFFERS];
+
+/**
+ * Get the list of stations associated to a given clipboard buffer.
+ * @param buffer the buffer
+ * @return the list
+ *
+ * @pre IsClipboardBuffer(buffer)
+ */
+static ClipboardStationList GetClipboardStationList(Map *buffer)
+{
+    uint index = GetClipboardBufferIndex(buffer);
+    assert(index < lengthof(_clipboard_stations));
+    return _clipboard_stations[index];
+}
+
+/**
+ * Associate a list of stations to a given clipboard buffer.
+ * @param list the list
+ * @param buffer the buffer
+ *
+ * @pre IsClipboardBuffer(buffer)
+ */
+static void SetClipboardStationList(ClipboardStationList list, Map *buffer)
+{
+    uint index = GetClipboardBufferIndex(buffer);
+    assert(index < lengthof(_clipboard_stations));
+    FreeClipboardStationList(&_clipboard_stations[index]);
+    _clipboard_stations[index] = list;
+}
+
+/**
+ * Free a list of clipboard stations.
+ * @param list the list
+ */
+void FreeClipboardStationList(ClipboardStationList *list)
+{
+	for (ClipboardStation *item = *list, *next; item != NULL; item = next) {
+		next = item->next;
+		delete item;
+	}
+	*list = NULL;
+}
+
+/**
+ * Test whether a given #Map is a clipboard buffer.
+ * @return if the map a clipboard buffer
+ */
+bool IsClipboardBuffer(const Map *map)
+{
+	return (size_t)(map - _clipboard_buffers) < NUM_CLIPBOARD_BUFFERS;
+}
+
+/**
+ * Get a clipboard buffer by it's index.
+ * @param index the index
+ * @return the buffer
+ *
+ * @pre index < NUM_CLIPBOARD_BUFFERS
+ */
+Map *GetClipboardBuffer(uint index)
+{
+	assert(index < NUM_CLIPBOARD_BUFFERS);
+	return &_clipboard_buffers[index];
+}
+
+/**
+ * Get the index of a clipboard buffer.
+ * @param buffer the buffer
+ * @return the index
+ *
+ * @pre IsClipboardBuffer(buffer)
+ */
+uint GetClipboardBufferIndex(const Map *buffer)
+{
+	assert(IsClipboardBuffer(buffer));
+	return buffer - _clipboard_buffers;
+}
+
+/**
+ * Test if a clipboard buffer is empty.
+ * @param buffer the buffer
+ * @return true iff there is no content in the buffer
+ *
+ * @pre IsClipboardBuffer(buffer)
+ */
+bool IsClipboardBufferEmpty(const Map *buffer)
+{
+	assert(IsClipboardBuffer(buffer));
+	return buffer->m == NULL;
+};
+
+/**
+ * Clear content of a clipboard buffer.
+ * @param buffer the buffer
+ *
+ * @pre IsClipboardBuffer(buffer)
+ */
+void EmptyClipboardBuffer(Map *buffer)
+{
+	if (IsClipboardBufferEmpty(buffer)) return;
+
+	SetClipboardStationList(NULL, buffer);
+
+	buffer->size_x = 0;
+	buffer->size_y = 0;
+	buffer->size = 0;
+
+	free(buffer->m);
+	buffer->m = NULL;
+	free(buffer->me);
+	buffer->me = NULL;
+}
+
+/**
+ * Allocate space in a clipboard buffer.
+ * @param buffer the buffer
+ * @param content_size_x X size of the content (excluding MP_VOID tiles on southern borders)
+ * @param content_size_y Y size of the content (excluding MP_VOID tiles on southern borders)
+ *
+ * @pre IsClipboardBuffer(buffer)
+ */
+void AllocateClipboardBuffer(Map *buffer, uint content_size_x, uint content_size_y)
+{
+	assert(IsClipboardBuffer(buffer));
+	assert(IsInsideMM(content_size_x, 1, INT_MAX - 1));
+	assert(IsInsideMM(content_size_y, 1, INT_MAX - 1));
+
+	SetClipboardStationList(NULL, buffer);
+
+	buffer->size_x = content_size_x + 1;
+	buffer->size_y = content_size_y + 1;
+	buffer->size = buffer->size_x * buffer->size_y;
+
+	free(buffer->m);
+	free(buffer->me);
+	buffer->m = CallocT<Tile>(buffer->size);
+	buffer->me = CallocT<TileExtended>(buffer->size);
+
+	GENERIC_TILE_AREA_LOOP(iter, GenericTileArea(TileXY(buffer->size_x - 1, 0, buffer), 1, buffer->size_y)) {
+		MakeVoid(iter);
+	}
+	GENERIC_TILE_AREA_LOOP(iter, GenericTileArea(TileXY(0, buffer->size_y - 1, buffer), buffer->size_x - 1, 1)) {
+		MakeVoid(iter);
+	}
+}
+
+/**
+ * Get #ClipboardStation by a given ID.
+ * @param id the ID of the station
+ * @param buffer clipboard buffer to get the station from
+ *
+ * @pre IsClipboardBuffer(buffer)
+ */
+/* static */ ClipboardStation *ClipboardStation::Get(StationID id, Map *buffer)
+{
+	for (ClipboardStation *ret = GetClipboardStationList(buffer); ret != NULL; ret = ret->next) {
+		if (ret->id == id) return ret;
+	}
+	return NULL;
+}
+
+/**
+ * Get #ClipboardStation by a given tile.
+ * @param tile any tile that belongs to the station
+ * @return station pointer or NULL if the tile is not a station
+ *
+ * @pre IsClipboardBuffer(MapOf(tile))
+ */
+/* static */ ClipboardStation *ClipboardStation::GetByTile(GenericTileIndex tile)
+{
+	return ClipboardStation::Get(GetStationIndex(tile), MapOf(tile));
+}
+
+/**
+ * Get station specification of a station tile.
+ * @param the tile
+ * @return pointer to specification or NULL if the tile is not a station
+ *
+ * @pre IsClipboardBuffer(MapOf(tile))
+ */
+/* static */ const ClipboardStation::Spec *ClipboardStation::GetSpecByTile(GenericTileIndex tile)
+{
+	ClipboardStation *st = ClipboardStation::GetByTile(tile);
+	if (st == NULL || !IsCustomStationSpecIndex(tile)) return NULL;
+	byte custom_specindex = GetCustomStationSpecIndex(tile);
+	assert(IsInsideBS(custom_specindex, 1, st->num_specs));
+	return &st->speclist[custom_specindex - 1];
+}
+
+ClipboardStation::ClipboardStation()
+{
+	this->id             = INVALID_STATION;
+	this->airport.tile   = INVALID_TILE_INDEX;
+	this->airport.w      = 0;
+	this->airport.h      = 0;
+	this->airport.type   = AT_INVALID;
+	this->airport.layout = 0;
+	this->num_specs      = 0;
+	this->speclist       = NULL;
+	this->next           = NULL;
+}
+
+ClipboardStation::~ClipboardStation()
+{
+	free(this->speclist);
+}
+
+ClipboardStation **ClipboardStationsBuilder::FindStation(StationID sid)
+{
+	ClipboardStation **ret = &this->stations;
+	while (*ret != NULL) {
+		if ((*ret)->id == sid) break;
+		ret = &((*ret)->next);
+	}
+	return ret;
+}
+
+ClipboardStation *ClipboardStationsBuilder::AddStation(StationID sid)
+{
+	ClipboardStation **st_link = this->FindStation(sid);
+	ClipboardStation *st = *st_link;
+	if (st == NULL) {
+		st = new ClipboardStation;
+		st->id = sid;
+		*st_link = st; // put new item on the back of the list
+	}
+	return st;
+}
+
+uint ClipboardStationsBuilder::AddSpecToStation(ClipboardStation *st, StationClassID station_class, byte station_type)
+{
+	if (station_class == STAT_CLASS_DFLT || (station_class == STAT_CLASS_WAYP && station_type == 0)) return 0;
+
+	for (int i = 0; i < st->num_specs; i++) {
+		if (st->speclist[i].spec_class == station_class && st->speclist[i].spec_index == station_type) return i + 1;
+	}
+
+	st->speclist = ReallocT(st->speclist, st->num_specs + 1);
+	st->speclist[st->num_specs].spec_class = station_class;
+	st->speclist[st->num_specs].spec_index = station_type;
+	st->num_specs++;
+
+	return st->num_specs;
+}
+
+/**
+ * Add a rail station part to the set of stations.
+ * @param sid id of the station
+ * @param station_class custom station class
+ * @param station_type type within the custom station class
+ * @return index of the given station spec in the list of specs of this station (aka custom station spec index)
+ */
+uint ClipboardStationsBuilder::AddRailStationPart(StationID sid, StationClassID station_class, byte station_type)
+{
+	return this->AddSpecToStation(this->AddStation(sid), station_class, station_type);
+}
+
+/**
+ * Add a rail waypoint part to the set of stations.
+ * @param sid id of the station
+ * @param station_class custom station class
+ * @param station_type type within the custom station class
+ * @return index of the given station spec in the list of specs of this station (aka custom station spec index)
+ */
+uint ClipboardStationsBuilder::AddWaypointPart(StationID sid, StationClassID station_class, byte station_type)
+{
+	return this->AddSpecToStation(this->AddStation(sid), station_class, station_type);
+}
+
+/**
+ * Add a road stop part to the set of stations.
+ * @param sid id of the station
+ */
+void ClipboardStationsBuilder::AddRoadStopPart(StationID sid)
+{
+	this->AddStation(sid);
+}
+
+/**
+ * Add a dock part to the set of stations.
+ * @param sid id of the station
+ */
+void ClipboardStationsBuilder::AddDockPart(StationID sid)
+{
+	this->AddStation(sid);
+}
+
+/**
+ * Add a buoy part to the set of stations.
+ * @param sid id of the station
+ */
+void ClipboardStationsBuilder::AddBuoyPart(StationID sid)
+{
+	this->AddStation(sid);
+}
+
+/**
+ * Add an airport to the set of stations.
+ *
+ * @param tile northern tile of the airport
+ * @param sid id of the station
+ * @param type airport type
+ * @param layout airport layout
+ */
+void ClipboardStationsBuilder::AddAirportPart(RawTileIndex tile, StationID sid, AirportTypes type, byte layout)
+{
+	ClipboardStation *st = this->AddStation(sid);
+
+	assert(st->airport.type == AT_INVALID);
+	const AirportSpec *spec = AirportSpec::Get(type);
+	st->airport.tile = tile;
+	if (spec->rotation[layout] != DIR_E && spec->rotation[layout] != DIR_W) {
+		st->airport.w = spec->size_x;
+		st->airport.h = spec->size_y;
+	} else {
+		st->airport.w = spec->size_y;
+		st->airport.h = spec->size_x;
+	}
+	st->airport.type = type;
+	st->airport.layout = layout;
+}
+
+/**
+ * Finish building and store results.
+ * @param buffer clipboard buffer to store the list in
+ *
+ * @pre IsClipboardBuffer(MapOf(tile))
+ */
+void ClipboardStationsBuilder::BuildDone(Map *buffer)
+{
+	SetClipboardStationList(this->stations, buffer);
+	this->stations = NULL;
+}
diff -urNad openttd-1.3.2/src/clipboard_func.h openttd-1.3.2-DC3.0RC3/src/clipboard_func.h
--- openttd-1.3.2/src/clipboard_func.h	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/clipboard_func.h	2013-11-22 05:49:06.000000000 +0100
@@ -0,0 +1,52 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file clipboard_func.h Functions related to the clipboad. */
+
+#ifndef CLIPBOARD_FUNC_H
+#define CLIPBOARD_FUNC_H
+
+#include "clipboard_type.h"
+
+void FreeClipboardStationList(ClipboardStationList *list);
+
+/** Helper class to build a station list while copying to the clipboard. */
+class ClipboardStationsBuilder {
+protected:
+	ClipboardStationList stations; ///< the list
+
+	ClipboardStation **FindStation(StationID sid);
+	ClipboardStation *AddStation(StationID sid);
+	uint AddSpecToStation(ClipboardStation *st, StationClassID station_class, byte station_type);
+
+public:
+	ClipboardStationsBuilder() : stations(NULL) {}
+	~ClipboardStationsBuilder() { FreeClipboardStationList(&this->stations); }
+
+	uint AddRailStationPart(StationID sid, StationClassID station_class, byte station_type);
+	uint AddWaypointPart(StationID sid, StationClassID station_class, byte station_type);
+	void AddRoadStopPart(StationID sid);
+	void AddDockPart(StationID sid);
+	void AddBuoyPart(StationID sid);
+	void AddAirportPart(RawTileIndex tile, StationID sid, AirportTypes type, byte layout);
+
+	void BuildDone(Map *clipboard);
+};
+
+static const uint NUM_CLIPBOARD_BUFFERS = 5; ///< Total amount of clipboard buffers
+
+bool IsClipboardBuffer(const Map *map);
+Map *GetClipboardBuffer(uint index);
+uint GetClipboardBufferIndex(const Map *clipboard);
+void AllocateClipboardBuffer(Map *clipboard, uint size_x, uint size_y);
+bool IsClipboardBufferEmpty(const Map *clipboard);
+void EmptyClipboardBuffer(Map *clipboard);
+void ClearClipboard();
+
+#endif /* CLIPBOARD_FUNC_H */
diff -urNad openttd-1.3.2/src/clipboard_gui.cpp openttd-1.3.2-DC3.0RC3/src/clipboard_gui.cpp
--- openttd-1.3.2/src/clipboard_gui.cpp	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/clipboard_gui.cpp	2013-11-22 05:49:06.000000000 +0100
@@ -0,0 +1,752 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file clipboard_gui.cpp GUIs related to the clipboard. */
+
+#include "stdafx.h"
+#include "core/geometry_func.hpp"
+#include "network/network.h"
+#include "widgets/clipboard_widget.h"
+#include "clipboard_func.h"
+#include "clipboard_gui.h"
+#include "command_func.h"
+#include "company_func.h"
+#include "company_base.h"
+#include "copypaste_cmd.h"
+#include "direction_func.h"
+#include "error.h"
+#include "gfx_func.h"
+#include "gui.h"
+#include "hotkeys.h"
+#include "rail.h"
+#include "rail_gui.h"
+#include "rail_map.h"
+#include "road_map.h"
+#include "slope_func.h"
+#include "sound_func.h"
+#include "station_map.h"
+#include "strings_func.h"
+#include "terraform_gui.h"
+#include "tilearea_type.h"
+#include "tilehighlight_func.h"
+#include "track_func.h"
+#include "tunnelbridge_map.h"
+#include "viewport_func.h"
+#include "window_gui.h"
+#include "window_func.h"
+
+#include "table/sprites.h"
+#include "table/strings.h"
+
+static const int CLIPBOARD_ADDITIONAL_HEIGHT_MAX = 7;
+static const int CLIPBOARD_ADDITIONAL_HEIGHT_MIN = -7;
+static const uint NUM_USER_CLIPBOARDS = NUM_CLIPBOARD_BUFFERS - 1; ///< Number of clipboards available
+
+/** Clipboard parameters. */
+struct ClipboardProps {
+	TileArea copy_area; ///< Area on the main map selected as source of a copy operation
+	CopyPasteMode mode; ///< Various flags that will be applied when pasting
+	RailType railtype;  ///< #Railtype to convert to when pasting
+	DirTransformation transformation; ///< Rotation/reflection to apply when pasting
+	int additional_height_delta; ///< Additional amount of tile heights to add when pasting
+
+	ClipboardProps()
+		: copy_area(INVALID_TILE, 0, 0)
+		, mode(CPM_DEFAULT)
+		, railtype(INVALID_RAILTYPE)
+		, transformation(DTR_IDENTITY)
+		, additional_height_delta(0)
+	{ }
+};
+
+ClipboardProps _clipboard_props[NUM_USER_CLIPBOARDS]; ///< Clipboard parameters selected via GUI
+ClipboardProps *_current_clipboard = &_clipboard_props[0]; ///< Currently selected clipboard
+static TileArea _clipboard_paste_area = TileArea(INVALID_TILE, 0, 0); ///< Area on the main map selected as destination for a paste operation
+
+/** Clear entire clipboard. */
+void ClearClipboard()
+{
+	for (uint i = 0; i < NUM_CLIPBOARD_BUFFERS; i++) EmptyClipboardBuffer(GetClipboardBuffer(i));
+	for (uint i = 0; i < NUM_USER_CLIPBOARDS; i++) _clipboard_props[i].copy_area = TileArea(INVALID_TILE, 0, 0);
+}
+
+/**
+ * Whether the copy/paste operations are performed with the clipboard buffer, or instantantly.
+ *
+ * If true, clipboard buffer is on. Each "copy" user action moves selected area to the clipboard
+ * (to the buffer) and each "paste" tries to reproduce contents of the clipboard on the main map.
+ *
+ * If false, clipboard buffer is off. "copy" user action just selects area and
+ * "paste" makes an instant copy&paste from the selected area to pointed place.
+ *
+ * @return whether the clipboard buffer is available for local company
+ */
+static inline bool IsClipboardBufferOn() { return !_networking; }
+
+static inline Map *GetCurrentClipboardBuffer()
+{
+	return IsClipboardBufferOn() ? GetClipboardBuffer(_current_clipboard - _clipboard_props) : NULL;
+}
+
+static inline bool IsClipboardCopyAreaSelected()
+{
+	return _current_clipboard->copy_area.tile != INVALID_TILE;
+}
+
+static inline bool IsClipboardPasteSourceSet()
+{
+	return IsClipboardBufferOn() ? !IsClipboardBufferEmpty(GetCurrentClipboardBuffer()) : IsClipboardCopyAreaSelected();
+}
+
+static void ClipboardRecalcPasteAreaSize()
+{
+	assert(IsClipboardPasteSourceSet());
+
+	Dimension size;
+	if (IsClipboardBufferOn()) {
+		size.width = GetCurrentClipboardBuffer()->size_x - 1;
+		size.height = GetCurrentClipboardBuffer()->size_y - 1;
+	} else {
+		size.width = _current_clipboard->copy_area.w;
+		size.height = _current_clipboard->copy_area.h;
+	}
+	size = TransformDimension(size, _current_clipboard->transformation);
+
+	_clipboard_paste_area.w = size.width;
+	_clipboard_paste_area.h = size.height;
+}
+
+void CcPaste(const CommandCost &result, TileIndex tile, uint32 p1, uint32 p2)
+{
+	if (_paste_err_tile != INVALID_TILE) SetRedErrorSquare(_paste_err_tile);
+
+	if (result.Succeeded()) {
+		if (_settings_client.sound.confirm) SndPlayTileFx(SND_1F_SPLAT, tile);
+		if (!_settings_client.gui.persistent_buildingtools) ResetObjectToPlace();
+	}
+}
+
+void GetTilePastePreview(TileIndex tile, TilePastePreview *ret)
+{
+	_clipboard_paste_area.tile = TileVirtXY(_thd.pos.x, _thd.pos.y);
+
+	extern bool TestRailTileCopyability(GenericTileIndex tile, CopyPasteMode mode, CompanyID company, TileContentPastePreview *preview);
+	extern bool TestRoadTileCopyability(GenericTileIndex tile, CopyPasteMode mode, CompanyID company, TileContentPastePreview *preview);
+	extern bool TestWaterTileCopyability(GenericTileIndex tile, const GenericTileArea &src_area, CopyPasteMode mode, GenericTileArea *object_rect, CompanyID company, TileContentPastePreview *preview);
+	extern bool TestTunnelBridgeTileCopyability(GenericTileIndex tile, const GenericTileArea &src_area, CopyPasteMode mode, GenericTileIndex *other_end, CompanyID company, TileContentPastePreview *preview);
+	extern bool TestStationTileCopyability(GenericTileIndex tile, const GenericTileArea &src_area, CopyPasteMode mode, GenericTileArea *station_part_area, CompanyID company, TileContentPastePreview *preview);
+
+	Map *clipboard = GetCurrentClipboardBuffer();
+
+	/* the area we are copying from */
+	GenericTileArea src_area = IsClipboardBufferOn() ?
+			GenericTileArea(TileXY(0, 0, clipboard), clipboard->size_x - 1, clipboard->size_y - 1) :
+			GenericTileArea(_current_clipboard->copy_area);
+
+	DirTransformation inv_dtr = InvertDirTransform(_current_clipboard->transformation);
+	/* area containing all tile corners (also those at SW and SE borders) */
+	TileArea paste_area_corners(_clipboard_paste_area.tile, _clipboard_paste_area.w + 1, _clipboard_paste_area.h + 1);
+	/* source corner of the most norther corner */
+	GenericTileIndex src_of_north_corner = paste_area_corners.TransformedNorth(src_area.tile, inv_dtr);
+	/* source corner of the tile corner (source of it's height) */
+	GenericTileIndex src_of_tile_corner = paste_area_corners.TransformTile(tile, src_of_north_corner, inv_dtr);
+	/* calculate the height difference between areas */
+	int height_delta = TileHeight(paste_area_corners.tile) - TileHeight(src_of_north_corner) + _current_clipboard->additional_height_delta;
+
+	if (_clipboard_paste_area.Contains(tile)) {
+		/* source tile of the tile */
+		GenericTileIndex src_tile = _clipboard_paste_area.TransformTile(tile, _clipboard_paste_area.TransformedNorth(src_area.tile, inv_dtr), inv_dtr);
+
+		bool has_preview = false;
+		switch(GetTileType(src_tile)) {
+			case MP_RAILWAY:      has_preview = TestRailTileCopyability(src_tile, _current_clipboard->mode, _local_company, ret); break;
+			case MP_ROAD:         has_preview = TestRoadTileCopyability(src_tile, _current_clipboard->mode, _local_company, ret); break;
+			case MP_STATION:      has_preview = TestStationTileCopyability(src_tile, src_area, _current_clipboard->mode, NULL, _local_company, ret); break;
+			case MP_WATER:        has_preview = TestWaterTileCopyability(src_tile, src_area, _current_clipboard->mode, NULL, _local_company, ret); break;
+			case MP_TUNNELBRIDGE: has_preview = TestTunnelBridgeTileCopyability(src_tile, src_area, _current_clipboard->mode, NULL, _local_company, ret); break;
+			default:              MemSetT(ret, 0); break;
+		}
+
+		if (has_preview) ret->highlight_track_bits = TransformTrackBits(ret->highlight_track_bits, _current_clipboard->transformation);
+	} else {
+		assert(paste_area_corners.Contains(tile));
+		MemSetT(ret, 0);
+	}
+
+	ret->tile_height = TileHeight(src_of_tile_corner) + height_delta;
+}
+
+struct ClipboardToolbarWindow : Window {
+	static Hotkey<ClipboardToolbarWindow> hotkeys[];
+
+	static CopyPasteMode FlagButtonToFlagBit(int button)
+	{
+		switch (button) {
+			case WID_CT_WITH_RAIL:        return CPM_WITH_RAIL_TRANSPORT;
+			case WID_CT_WITH_ROAD:        return CPM_WITH_ROAD_TRANSPORT;
+			case WID_CT_WITH_WATER:       return CPM_WITH_WATER_TRANSPORT;
+			case WID_CT_WITH_AIR:         return CPM_WITH_AIR_TRANSPORT;
+			case WID_CT_MIRROR_SIGNALS:   return CPM_MIRROR_SIGNALS;
+			case WID_CT_UPGRADE_BRIDGES:  return CPM_UPGRADE_BRIDGES;
+			default: NOT_REACHED(); break;
+		};
+		return CPM_NONE;
+	}
+
+	ClipboardToolbarWindow(const WindowDesc *desc) : Window()
+	{
+		this->InitNested(desc);
+
+		if (!IsClipboardBufferOn()) {
+			NWidgetCore *button = this->GetWidget<NWidgetCore>(WID_CT_COPY);
+			button->widget_data = SPR_IMG_CLIPBOARD_SELECT_COPY_AREA; // instead of SPR_IMG_CLIPBOARD_COPY
+			button->tool_tip = STR_CLIPBOARD_TOOLTIP_SELECT_COPY_AREA; // instead of STR_CLIPBOARD_TOOLTIP_COPY
+
+			button = this->GetWidget<NWidgetCore>(WID_CT_PASTE);
+			button->widget_data = SPR_IMG_CLIPBOARD_INSTANT_COPY_PASTE; // instead of SPR_IMG_CLIPBOARD_PASTE
+			button->tool_tip = STR_CLIPBOARD_TOOLTIP_INSTANT_COPY_PASTE; // instead of STR_CLIPBOARD_TOOLTIP_PASTE
+		}
+
+		/* select another railtype if the one that was used last time is invalid/unavailable */
+		for (uint i = 0; i < lengthof(_clipboard_props); i++) {
+			if (!IsInsideMM(_clipboard_props[i].railtype, RAILTYPE_BEGIN, RAILTYPE_END)) {
+				_clipboard_props[i].railtype = RAILTYPE_BEGIN;
+			}
+			RailType rt = _clipboard_props[i].railtype;
+			while (!HasRailtypeAvail(_local_company, rt)) {
+				rt++;
+				if (rt >= RAILTYPE_END) rt = RAILTYPE_BEGIN;
+
+				if (rt == _clipboard_props[i].railtype) { // did we get back to the point where we started?
+					rt = INVALID_RAILTYPE;
+					_clipboard_props[i].mode &= ~CPM_CONVERT_RAILTYPE;
+					break;
+				}
+			}
+			_clipboard_props[i].railtype = rt;
+		}
+
+		this->UpdateButtons();
+
+		if (_settings_client.gui.link_terraform_toolbar) ShowTerraformToolbar(this);
+	}
+
+	~ClipboardToolbarWindow()
+	{
+		if (_settings_client.gui.link_terraform_toolbar) DeleteWindowById(WC_SCEN_LAND_GEN, 0, false);
+	}
+
+	void UpdateButtons()
+	{
+		/* lower clipboard index indicator */
+		this->SetWidgetLoweredState(WID_CT_CLIPBOARD_1, _current_clipboard == &_clipboard_props[0]);
+		this->SetWidgetLoweredState(WID_CT_CLIPBOARD_2, _current_clipboard == &_clipboard_props[1]);
+		this->SetWidgetLoweredState(WID_CT_CLIPBOARD_3, _current_clipboard == &_clipboard_props[2]);
+		this->SetWidgetLoweredState(WID_CT_CLIPBOARD_4, _current_clipboard == &_clipboard_props[3]);
+		/* disable the paste button if there is nothing to paste */
+		this->SetWidgetDisabledState(WID_CT_PASTE, !IsClipboardPasteSourceSet());
+		/* lower on/off buttons */
+		for (int widget = WID_CT_PASTE_FLAG_BUTTON_BEGIN; widget < WID_CT_PASTE_FLAG_BUTTON_END; widget++) {
+			this->SetWidgetLoweredState(widget, (_current_clipboard->mode & ClipboardToolbarWindow::FlagButtonToFlagBit(widget)) != 0);
+		}
+		this->SetWidgetLoweredState(WID_CT_TERRAFORM, (_current_clipboard->mode & CPM_TERRAFORM_MASK) != CPM_TERRAFORM_NONE);
+		/* set the sprite on the railtype button */
+		this->GetWidget<NWidgetCore>(WID_CT_CONVERT_RAILTYPE)->widget_data =
+				(_current_clipboard->mode & CPM_CONVERT_RAILTYPE) ?
+				GetRailTypeInfo(_current_clipboard->railtype)->gui_sprites.convert_rail :
+				SPR_IMG_CLIPBOARD_NO_RAIL_CONVERTION;
+
+		this->SetDirty();
+	}
+
+	virtual void DrawWidget(const Rect &r, int widget) const
+	{
+		int offset = this->IsWidgetLowered(widget) ? 2 : 1;
+		switch (widget) {
+			case WID_CT_WITH_RAIL:
+			case WID_CT_WITH_ROAD:
+			case WID_CT_WITH_WATER:
+			case WID_CT_WITH_AIR: {
+				offset++;
+				DrawSprite(SPR_BLOT, this->IsWidgetLowered(widget) ? PALETTE_TO_GREEN : PALETTE_TO_RED, r.left + offset, r.top + offset);
+				break;
+			}
+
+			case WID_CT_TERRAFORM: {
+				offset++;
+				PaletteID pal;
+				switch (_current_clipboard->mode & CPM_TERRAFORM_MASK) {
+					case CPM_TERRAFORM_FULL:    pal = PALETTE_TO_GREEN;  break;
+					case CPM_TERRAFORM_MINIMAL: pal = PALETTE_TO_YELLOW; break;
+					default:                    pal = PALETTE_TO_RED;    break;
+				}
+				DrawSprite(SPR_BLOT, pal, r.left + offset, r.top + offset);
+				break;
+			}
+
+			case WID_CT_TRANSFORMATION:
+				DrawSprite(SPR_IMG_TRANFORMATION_IDENTITY + _current_clipboard->transformation, PAL_NONE, r.left + offset, r.top + offset);
+				break;
+
+			case WID_CT_HEIGHT_DIFF_GLYPH:
+				DrawSprite(SPR_IMG_CLIPBOARD_HEIGHT_PANEL, PAL_NONE, r.left, r.top);
+				break;
+
+			default:
+				break;
+		}
+	}
+
+	virtual void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize)
+	{
+		Dimension d;
+
+		switch (widget) {
+			case WID_CT_CLIPBOARD_1:
+			case WID_CT_CLIPBOARD_2:
+			case WID_CT_CLIPBOARD_3:
+			case WID_CT_CLIPBOARD_4:
+				d.width = GetDigitWidth() + 4;
+				d.height = FONT_HEIGHT_NORMAL;
+				break;
+
+			case WID_CT_HEIGHT_DIFF_GLYPH:
+				d = GetSpriteSize(SPR_IMG_CLIPBOARD_HEIGHT_PANEL);
+				break;
+
+			case WID_CT_HEIGHT_DIFF: {
+				/* Backup the height delta. The variable will be used to calculate the size of the widget. */
+				int backup = _current_clipboard->additional_height_delta;
+				/* calculate the size */
+				d.width = d.height = 0;
+				for (_current_clipboard->additional_height_delta = CLIPBOARD_ADDITIONAL_HEIGHT_MIN; _current_clipboard->additional_height_delta <= CLIPBOARD_ADDITIONAL_HEIGHT_MAX; _current_clipboard->additional_height_delta++) {
+					this->SetStringParameters(WID_CT_HEIGHT_DIFF); // additional_height_delta will be used there
+					d = maxdim(d, GetStringBoundingBox(this->GetWidget<NWidgetCore>(WID_CT_HEIGHT_DIFF)->widget_data));
+				}
+				d.width += 1;
+				/* restore */
+				_current_clipboard->additional_height_delta = backup;
+				break;
+			}
+
+			default:
+				return;
+		}
+
+		d.width += padding.width;
+		d.height += padding.height;
+		*size = maxdim(*size, d);
+	}
+
+	virtual void SetStringParameters(int widget) const
+	{
+		switch (widget) {
+			case WID_CT_CLIPBOARD_1:
+			case WID_CT_CLIPBOARD_2:
+			case WID_CT_CLIPBOARD_3:
+			case WID_CT_CLIPBOARD_4:
+				SetDParam(0, widget - WID_CT_CLIPBOARD_1 + 1);
+				break;
+
+			case WID_CT_HEIGHT_DIFF:
+				SetDParam(0, (StringID)(STR_CLIPBOARD_HEIGHT_DIFF_NEUTRAL + sgn(_current_clipboard->additional_height_delta)));
+				SetDParam(1, abs(_current_clipboard->additional_height_delta));
+				break;
+		}
+	}
+
+	virtual void OnClick(Point pt, int widget, int click_count)
+	{
+		if (this->IsWidgetDisabled(widget)) return;
+
+		DirTransformation add_clipboard_transformation = DTR_IDENTITY; // additional transformation
+
+		switch (widget) {
+			case WID_CT_CLIPBOARD_1:
+			case WID_CT_CLIPBOARD_2:
+			case WID_CT_CLIPBOARD_3:
+			case WID_CT_CLIPBOARD_4:
+				/* switch to another clipboard */
+				assert(IsInsideMM(widget - WID_CT_CLIPBOARD_1, 0, lengthof(_clipboard_props)));
+				_current_clipboard = &_clipboard_props[widget - WID_CT_CLIPBOARD_1];
+				this->UpdateButtons();
+
+				if (this->IsWidgetLowered(WID_CT_PASTE)) {
+					if (IsClipboardPasteSourceSet()) {
+						/* update paste preview */
+						ClipboardRecalcPasteAreaSize();
+						SetTileSelectSize(_clipboard_paste_area.w + 1, _clipboard_paste_area.h + 1);
+						UpdateTileSelection();
+						MarkWholeScreenDirty();
+					} else {
+						ResetObjectToPlace(); // current clipboard is empty!
+					}
+				}
+				break;
+
+			case WID_CT_COPY:
+				if (HandlePlacePushButton(this, widget, SPR_CURSOR_COPY, HT_RECT)) {
+					this->SetWidgetDirty(widget);
+				}
+				return;
+
+			case WID_CT_PASTE:
+				if (HandlePlacePushButton(this, widget, _ctrl_pressed ? SPR_CURSOR_ADJUST_HEIGHT : SPR_CURSOR_PASTE, HT_POINT | HT_PASTE_PREVIEW)) {
+					ClipboardRecalcPasteAreaSize();
+					SetTileSelectSize(_clipboard_paste_area.w + 1, _clipboard_paste_area.h + 1);
+					this->SetWidgetDirty(widget);
+				}
+				return;
+
+			case WID_CT_TERRAFORM: {
+				switch (_current_clipboard->mode & CPM_TERRAFORM_MASK) {
+					case CPM_TERRAFORM_NONE:    (_current_clipboard->mode &= ~CPM_TERRAFORM_MASK) |= CPM_TERRAFORM_FULL;    break;
+					case CPM_TERRAFORM_MINIMAL: (_current_clipboard->mode &= ~CPM_TERRAFORM_MASK) |= CPM_TERRAFORM_NONE;    break;
+					case CPM_TERRAFORM_FULL:    (_current_clipboard->mode &= ~CPM_TERRAFORM_MASK) |= CPM_TERRAFORM_MINIMAL; break;
+					default: NOT_REACHED();
+				}
+				this->UpdateButtons();
+				break;
+			}
+
+			case WID_CT_TRANSFORMATION:
+				/* reset transformation - combined with its inversion will give identity */
+				add_clipboard_transformation = InvertDirTransform(_current_clipboard->transformation);
+				break;
+
+			case WID_CT_ROTATE_LEFT:   add_clipboard_transformation = DTR_ROTATE_90_L;   break;
+			case WID_CT_ROTATE_RIGHT:  add_clipboard_transformation = DTR_ROTATE_90_R;   break;
+			case WID_CT_REFLECT_NE_SW: add_clipboard_transformation = DTR_REFLECT_NE_SW; break;
+			case WID_CT_REFLECT_NW_SE: add_clipboard_transformation = DTR_REFLECT_NW_SE; break;
+
+			case WID_CT_WITH_RAIL:
+			case WID_CT_WITH_ROAD:
+			case WID_CT_WITH_WATER:
+			case WID_CT_WITH_AIR:
+			case WID_CT_MIRROR_SIGNALS:
+			case WID_CT_UPGRADE_BRIDGES:
+				_current_clipboard->mode ^= ClipboardToolbarWindow::FlagButtonToFlagBit(widget);
+				this->UpdateButtons();
+				break;
+
+			case WID_CT_CONVERT_RAILTYPE:
+				ShowDropDownList(this, GetRailTypeDropDownList(),
+						(_current_clipboard->mode & CPM_CONVERT_RAILTYPE) ? INVALID_RAILTYPE : _current_clipboard->railtype,
+						WID_CT_CONVERT_RAILTYPE, 140, true, true);
+				break;
+
+			case WID_CT_HEIGHT_DIFF_INCREASE: this->ModifyAdditionalHeightDelta(+1); break;
+			case WID_CT_HEIGHT_DIFF_DECREASE: this->ModifyAdditionalHeightDelta(-1); break;
+
+			default:
+				return;
+		}
+
+		if (_settings_client.sound.click_beep) SndPlayFx(SND_15_BEEP);
+
+		if (add_clipboard_transformation != DTR_IDENTITY) {
+			_current_clipboard->transformation = CombineDirTransform(_current_clipboard->transformation, add_clipboard_transformation);
+			this->SetWidgetDirty(WID_CT_TRANSFORMATION);
+			if (this->IsWidgetLowered(WID_CT_PASTE)) {
+				ClipboardRecalcPasteAreaSize();
+				SetTileSelectSize(_clipboard_paste_area.w + 1, _clipboard_paste_area.h + 1);
+			}
+		}
+	}
+
+	virtual EventState OnKeyPress(uint16 key, uint16 keycode)
+	{
+               int num = CheckHotkeyMatch(this->hotkeys, keycode, this);
+               if (num == -1) return ES_NOT_HANDLED;
+               this->OnClick(Point(), num, 1);
+               MarkTileDirtyByTile(TileVirtXY(_thd.pos.x, _thd.pos.y)); // redraw tile selection
+               return ES_HANDLED;
+
+/*		switch (hotkey) {
+			case WID_CT_CONVERT_RAILTYPE:
+				this->OnDropdownSelect(WID_CT_CONVERT_RAILTYPE, (_current_clipboard->mode & CPM_CONVERT_RAILTYPE) ? INVALID_RAILTYPE : _current_clipboard->railtype);
+				this->SetWidgetDirty(WID_CT_CONVERT_RAILTYPE);
+				if (_settings_client.sound.click_beep) SndPlayFx(SND_15_BEEP);
+				return ES_HANDLED;
+
+			case WID_CT_WITH_RAIL:
+			case WID_CT_WITH_ROAD:
+			case WID_CT_WITH_WATER:
+			case WID_CT_WITH_AIR:
+				if (this->IsWidgetLowered(WID_CT_PASTE)) MarkWholeScreenDirty(); // redraw tile selection
+				break;
+
+			default:
+				break;
+		}
+		return this->Window::OnHotkey(hotkey);
+*/
+	}
+
+	virtual void OnDropdownSelect(int widget, int index)
+	{
+		assert(widget == WID_CT_CONVERT_RAILTYPE);
+		if (index == INVALID_RAILTYPE) {
+			_current_clipboard->mode &= ~CPM_CONVERT_RAILTYPE;
+		} else {
+			_current_clipboard->mode |= CPM_CONVERT_RAILTYPE;
+			_current_clipboard->railtype = (RailType)index;
+		}
+		this->UpdateButtons();
+	}
+
+	virtual EventState OnCTRLStateChange()
+	{
+		if (this->IsWidgetLowered(WID_CT_PASTE)) SetMouseCursor(_ctrl_pressed ? SPR_CURSOR_ADJUST_HEIGHT : SPR_CURSOR_PASTE, PAL_NONE);
+
+		return ES_NOT_HANDLED;
+	}
+
+	virtual void OnPlaceObject(Point pt, TileIndex tile)
+	{
+		if (this->IsWidgetLowered(WID_CT_COPY)) {
+			/* start copy area dragging */
+			VpStartPlaceSizing(tile, VPM_X_AND_Y_LIMITED, DDSP_COPY_TO_CLIPBOARD);
+			VpSetPlaceSizingLimit(_settings_game.construction.clipboard_capacity);
+		} else {
+			_clipboard_paste_area.tile = tile;
+
+			/* do paste */
+			assert(IsClipboardPasteSourceSet());
+
+			uint32 p1 = 0, p2 = 0;
+			SB(p1, 28, 4, _current_clipboard->railtype);
+			SB(p2, 12, 4, _current_clipboard->additional_height_delta);
+			SB(p2, 16, 3, _current_clipboard->transformation);
+			SB(p2, 19, 9, _current_clipboard->mode);
+			if (IsClipboardBufferOn()) {
+				/* copy/paste clipboard-to-map */
+				SB(p1, 0, 2, GetClipboardBufferIndex(GetCurrentClipboardBuffer()));
+				SetDParam(COPY_PASTE_ERR_SUMMARY_PARAM, STR_ERROR_CAN_T_PASTE_HERE);
+				DoCommandP(tile, p1, p2, CMD_PASTE_FROM_CLIPBOARD | CMD_MSG(STR_COPY_PASTE_ERROR_SUMMARY), CcPaste);
+			} else {
+				/* copy/paste map-to-map */
+				SB(p1, 0, 28, _current_clipboard->copy_area.tile);
+				SB(p2, 0,  6, _current_clipboard->copy_area.w);
+				SB(p2, 6,  6, _current_clipboard->copy_area.h);
+				SetDParam(COPY_PASTE_ERR_SUMMARY_PARAM, STR_ERROR_CAN_T_PASTE_HERE);
+				DoCommandP(tile, p1, p2, CMD_INSTANT_COPY_PASTE | CMD_MSG(STR_COPY_PASTE_ERROR_SUMMARY), CcPaste);
+			}
+
+			MarkWholeScreenDirty(); // redraw tile selection
+		}
+	}
+
+	virtual void OnPlaceDrag(ViewportPlaceMethod select_method, ViewportDragDropSelectionProcess select_proc, Point pt)
+	{
+		VpSelectTilesWithMethod(pt.x, pt.y, select_method);
+	}
+
+	virtual void OnPlaceMouseUp(ViewportPlaceMethod select_method, ViewportDragDropSelectionProcess select_proc, Point pt, TileIndex start_tile, TileIndex end_tile)
+	{
+		if (pt.x != -1) {
+			switch (select_proc) {
+				case DDSP_COPY_TO_CLIPBOARD: {
+					TileArea ta = TileArea(start_tile, end_tile);
+
+					/* do copy */
+					if (IsClipboardBufferOn()) {
+						/* copy into the buffer */
+						uint32 p1 = 0, p2 = 0;
+						SB(p1, 0, 2, GetClipboardBufferIndex(GetCurrentClipboardBuffer()));
+						SB(p2, 0, 6, ta.w); // source area width
+						SB(p2, 6, 6, ta.h); // source area height
+						if (!DoCommandP(ta.tile, p1, p2, CMD_COPY_TO_CLIPBOARD) || _shift_pressed) return; // leave copy tool opened
+					}
+					ResetObjectToPlace();
+
+					/* select copy area */
+					_current_clipboard->copy_area = ta;
+
+					/* reset transformation and update buttons */
+					_current_clipboard->transformation = DTR_IDENTITY;
+					this->ModifyAdditionalHeightDelta(-_current_clipboard->additional_height_delta);
+					this->UpdateButtons();
+					break;
+				}
+
+				default:
+					NOT_REACHED();
+			}
+		}
+	}
+
+	virtual void OnPlaceObjectAbort()
+	{
+		/* Unclick "copy" and "paste" buttons */
+		this->RaiseWidget(WID_CT_COPY);
+		this->RaiseWidget(WID_CT_PASTE);
+		this->SetWidgetDirty(WID_CT_COPY);
+		this->SetWidgetDirty(WID_CT_PASTE);
+	}
+
+	EventState OnPlaceMouseWheel(Point pt, int mousewheel)
+	{
+		if (mousewheel == 0 || !_ctrl_pressed || !this->IsWidgetLowered(WID_CT_PASTE)) return ES_NOT_HANDLED;
+		this->ModifyAdditionalHeightDelta(-sgn(mousewheel));
+		return ES_HANDLED;
+	}
+
+	void ModifyAdditionalHeightDelta(int diff)
+	{
+		_current_clipboard->additional_height_delta = Clamp(_current_clipboard->additional_height_delta + diff, CLIPBOARD_ADDITIONAL_HEIGHT_MIN, CLIPBOARD_ADDITIONAL_HEIGHT_MAX);
+		this->SetWidgetDirty(WID_CT_HEIGHT_DIFF);
+	}
+};
+
+static const uint16 _clipboard_copy_hotkeys[] = { 'C' | WKC_CTRL | WKC_GLOBAL_HOTKEY, WKC_INSERT | WKC_CTRL | WKC_GLOBAL_HOTKEY, 0 };
+static const uint16 _clipboard_paste_hotkeys[] = { 'V' | WKC_CTRL | WKC_GLOBAL_HOTKEY, WKC_INSERT | WKC_SHIFT | WKC_GLOBAL_HOTKEY, 0 };
+Hotkey<ClipboardToolbarWindow> ClipboardToolbarWindow::hotkeys[] = {
+       Hotkey<ClipboardToolbarWindow>(_clipboard_copy_hotkeys,  "copy",            WID_CT_COPY),
+       Hotkey<ClipboardToolbarWindow>(_clipboard_paste_hotkeys, "paste",           WID_CT_PASTE),
+       Hotkey<ClipboardToolbarWindow>('1',                      "clipboard1",      WID_CT_CLIPBOARD_1),
+       Hotkey<ClipboardToolbarWindow>('2',                      "clipboard2",      WID_CT_CLIPBOARD_1),
+       Hotkey<ClipboardToolbarWindow>('3',                      "clipboard3",      WID_CT_CLIPBOARD_1),
+       Hotkey<ClipboardToolbarWindow>('4',                      "clipboard4",      WID_CT_CLIPBOARD_1),
+       Hotkey<ClipboardToolbarWindow>('5',                      "with_rail",       WID_CT_WITH_RAIL),
+       Hotkey<ClipboardToolbarWindow>('6',                      "with_road",       WID_CT_WITH_ROAD),
+       Hotkey<ClipboardToolbarWindow>('7',                      "with_water",           WID_CT_WITH_WATER),
+       Hotkey<ClipboardToolbarWindow>('8',                      "with_air",             WID_CT_WITH_AIR),
+       Hotkey<ClipboardToolbarWindow>('9',                      "terraform",       WID_CT_TERRAFORM),
+       Hotkey<ClipboardToolbarWindow>('0',                      "rail_conversion", WID_CT_CONVERT_RAILTYPE),
+       Hotkey<ClipboardToolbarWindow>('S',                      "signal_mirror",   WID_CT_MIRROR_SIGNALS),
+       Hotkey<ClipboardToolbarWindow>('B',                      "bridge_upgrade",  WID_CT_UPGRADE_BRIDGES),
+       Hotkey<ClipboardToolbarWindow>(WKC_CTRL | ',',           "rotate_l",        WID_CT_ROTATE_LEFT),
+       Hotkey<ClipboardToolbarWindow>(WKC_CTRL | '.',           "rotate_r",        WID_CT_ROTATE_RIGHT),
+       Hotkey<ClipboardToolbarWindow>(WKC_CTRL | '\\',          "reflect_ne_sw",   WID_CT_REFLECT_NE_SW),
+       Hotkey<ClipboardToolbarWindow>(WKC_CTRL | '/',           "reflect_nw_se",   WID_CT_REFLECT_NW_SE),
+       HOTKEY_LIST_END(ClipboardToolbarWindow)
+};
+//EventState ClipboardGlobalHotkeys(int hotkey)
+//{
+//	Window *w = ShowClipboardToolbar();
+//	if (w == NULL) return ES_NOT_HANDLED;
+//	return w->OnHotkey(hotkey);
+//}
+/*
+static Hotkey _clipboard_hotkeys[] = {
+	Hotkey('1', "clipboard1",      WID_CT_CLIPBOARD_1),
+	Hotkey('2', "clipboard2",      WID_CT_CLIPBOARD_2),
+	Hotkey('3', "clipboard3",      WID_CT_CLIPBOARD_3),
+	Hotkey('4', "clipboard4",      WID_CT_CLIPBOARD_4),
+	Hotkey('C' | WKC_CTRL | WKC_GLOBAL_HOTKEY, "copy",  WID_CT_COPY),
+	Hotkey('V' | WKC_CTRL | WKC_GLOBAL_HOTKEY, "paste", WID_CT_PASTE),
+	Hotkey('5', "with_rail",       WID_CT_WITH_RAIL),
+	Hotkey('6', "with_road",       WID_CT_WITH_ROAD),
+	Hotkey('7', "with_water",      WID_CT_WITH_WATER),
+	Hotkey('8', "with_air",        WID_CT_WITH_AIR),
+	Hotkey('9', "terraform",       WID_CT_TERRAFORM),
+	Hotkey('0', "rail_conversion", WID_CT_CONVERT_RAILTYPE),
+	Hotkey('S', "signal_mirror",   WID_CT_MIRROR_SIGNALS),
+	Hotkey('B', "bridge_upgrade",  WID_CT_UPGRADE_BRIDGES),
+	HOTKEY_LIST_END
+};
+HotkeyList ClipboardToolbarWindow::hotkeys("clipboard", _clipboard_hotkeys, ClipboardGlobalHotkeys);
+*/
+static const NWidgetPart _nested_clipboard_toolbar_widgets[] = {
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_CLOSEBOX, COLOUR_DARK_GREEN),
+		NWidget(WWT_CAPTION, COLOUR_DARK_GREEN), SetDataTip(STR_CLIPBOARD_TOOLBAR_CAPTION, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_STICKYBOX, COLOUR_DARK_GREEN),
+	EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		/* CLIPBOARD INDEX BUTTONS */
+		NWidget(WWT_TEXTBTN, COLOUR_DARK_GREEN, WID_CT_CLIPBOARD_1),
+						SetFill(0, 1), SetMinimalSize(8, 22), SetDataTip(STR_BLACK_INT, STR_CLIPBOARD_TOOLTIP_SWITCH_TO_1ST_CLIPBOARD),
+		NWidget(WWT_TEXTBTN, COLOUR_DARK_GREEN, WID_CT_CLIPBOARD_2),
+						SetFill(0, 1), SetMinimalSize(8, 22), SetDataTip(STR_BLACK_INT, STR_CLIPBOARD_TOOLTIP_SWITCH_TO_2ND_CLIPBOARD),
+		NWidget(WWT_TEXTBTN, COLOUR_DARK_GREEN, WID_CT_CLIPBOARD_3),
+						SetFill(0, 1), SetMinimalSize(8, 22), SetDataTip(STR_BLACK_INT, STR_CLIPBOARD_TOOLTIP_SWITCH_TO_3RD_CLIPBOARD),
+		NWidget(WWT_TEXTBTN, COLOUR_DARK_GREEN, WID_CT_CLIPBOARD_4),
+						SetFill(0, 1), SetMinimalSize(8, 22), SetDataTip(STR_BLACK_INT, STR_CLIPBOARD_TOOLTIP_SWITCH_TO_4TH_CLIPBOARD),
+		NWidget(WWT_PANEL, COLOUR_DARK_GREEN),
+						SetFill(0, 1), SetMinimalSize(4, 22), EndContainer(),
+
+		/* COPY / PASTE BUTTONS */
+		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_CT_COPY),
+						SetFill(0, 1), SetMinimalSize(22, 22), SetDataTip(SPR_IMG_CLIPBOARD_COPY, STR_CLIPBOARD_TOOLTIP_COPY),
+		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_CT_PASTE),
+						SetFill(0, 1), SetMinimalSize(22, 22), SetDataTip(SPR_IMG_CLIPBOARD_PASTE, STR_CLIPBOARD_TOOLTIP_PASTE),
+		NWidget(WWT_PANEL, COLOUR_DARK_GREEN),
+						SetFill(0, 1), SetMinimalSize(4, 22), EndContainer(),
+
+		/* COPY/PASTE MODE SELECTORS */
+		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_CT_WITH_RAIL),
+						SetFill(0, 1), SetMinimalSize(22, 22), SetDataTip(SPR_IMG_BUILDRAIL, STR_CLIPBOARD_TOOLTIP_COPY_WITH_RAIL_TRANSPORT),
+		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_CT_WITH_ROAD),
+						SetFill(0, 1), SetMinimalSize(22, 22), SetDataTip(SPR_IMG_BUILDROAD, STR_CLIPBOARD_TOOLTIP_COPY_WITH_ROAD_TRANSPORT),
+		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_CT_WITH_WATER),
+						SetFill(0, 1), SetMinimalSize(22, 22), SetDataTip(SPR_IMG_BUILDWATER, STR_CLIPBOARD_TOOLTIP_COPY_WITH_WATER_TRANSPORT),
+		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_CT_WITH_AIR),
+						SetFill(0, 1), SetMinimalSize(22, 22), SetDataTip(SPR_IMG_BUILDAIR, STR_CLIPBOARD_TOOLTIP_COPY_WITH_AIR_TRANSPORT),
+		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_CT_TERRAFORM),
+						SetFill(0, 1), SetMinimalSize(22, 22), SetDataTip(SPR_IMG_LANDSCAPING, STR_CLIPBOARD_TOOLTIP_TERRAFORM),
+		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_CT_CONVERT_RAILTYPE),
+						SetFill(0, 1), SetMinimalSize(22, 22), SetDataTip(SPR_IMG_CLIPBOARD_NO_RAIL_CONVERTION, STR_CLIPBOARD_TOOLTIP_CONVERT_RAIL),
+		NWidget(WWT_IMGBTN_2, COLOUR_DARK_GREEN, WID_CT_MIRROR_SIGNALS),
+						SetFill(0, 1), SetMinimalSize(22, 22), SetDataTip(SPR_IMG_CLIPBOARD_MIRROR_SIGNALS_OFF, STR_CLIPBOARD_TOOLTIP_MIRROR_SIGNALS),
+		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_CT_UPGRADE_BRIDGES),
+						SetFill(0, 1), SetMinimalSize(22, 22), SetDataTip(SPR_IMG_CLIPBOARD_UPGRADE_BRIDGES, STR_CLIPBOARD_TOOLTIP_UPGRADE_BRIDGES),
+		NWidget(WWT_PANEL, COLOUR_DARK_GREEN),
+						SetFill(0, 1), SetMinimalSize(4, 22), EndContainer(),
+
+		/* TRANSFORMATIONS */
+		NWidget(WWT_PUSHBTN, COLOUR_DARK_GREEN, WID_CT_TRANSFORMATION),
+						SetFill(0, 1), SetMinimalSize(23, 22), SetDataTip(0, STR_CLIPBOARD_TOOLTIP_TRANSFORMATION),
+		NWidget(WWT_PUSHIMGBTN, COLOUR_DARK_GREEN, WID_CT_ROTATE_LEFT),
+						SetFill(0, 1), SetMinimalSize(22, 22), SetDataTip(SPR_IMG_CLIPBOARD_ROTATE_LEFT, STR_CLIPBOARD_TOOLTIP_ROTATE_LEFT),
+		NWidget(WWT_PUSHIMGBTN, COLOUR_DARK_GREEN, WID_CT_ROTATE_RIGHT),
+						SetFill(0, 1), SetMinimalSize(22, 22), SetDataTip(SPR_IMG_CLIPBOARD_ROTATE_RIGHT, STR_CLIPBOARD_TOOLTIP_ROTATE_RIGHT),
+		NWidget(WWT_PUSHIMGBTN, COLOUR_DARK_GREEN, WID_CT_REFLECT_NE_SW),
+						SetFill(0, 1), SetMinimalSize(22, 22), SetDataTip(SPR_IMG_CLIPBOARD_REFLECT_NE_SW, STR_CLIPBOARD_TOOLTIP_REFLECT_NE_SW),
+		NWidget(WWT_PUSHIMGBTN, COLOUR_DARK_GREEN, WID_CT_REFLECT_NW_SE),
+						SetFill(0, 1), SetMinimalSize(22, 22), SetDataTip(SPR_IMG_CLIPBOARD_REFLECT_NW_SE, STR_CLIPBOARD_TOOLTIP_REFLECT_NW_SE),
+		NWidget(WWT_PANEL, COLOUR_DARK_GREEN),
+						SetFill(0, 1), SetMinimalSize(4, 22), EndContainer(),
+
+		/* HEIGHT MANIPULATOR */
+		NWidget(WWT_PANEL, COLOUR_DARK_GREEN), SetMinimalSize(0, 22),
+			NWidget(NWID_HORIZONTAL),
+				NWidget(WWT_TEXT, COLOUR_DARK_GREEN, WID_CT_HEIGHT_DIFF_GLYPH), SetDataTip(STR_EMPTY, STR_NULL), SetFill(0, 1),
+				NWidget(WWT_TEXT, COLOUR_DARK_GREEN, WID_CT_HEIGHT_DIFF), SetDataTip(STR_CLIPBOARD_HEIGHT_DIFF, STR_NULL), SetFill(0, 1),
+				NWidget(NWID_VERTICAL), SetPIP(3, 0, 3),
+					NWidget(NWID_HORIZONTAL), SetPIP(0, 1, 3),
+						NWidget(WWT_PUSHIMGBTN, COLOUR_GREY, WID_CT_HEIGHT_DIFF_INCREASE), SetDataTip(SPR_ARROW_UP, STR_NULL), SetFill(0, 1),
+						NWidget(WWT_PUSHIMGBTN, COLOUR_GREY, WID_CT_HEIGHT_DIFF_DECREASE), SetDataTip(SPR_ARROW_DOWN, STR_NULL), SetFill(0, 1),
+					EndContainer(),
+				EndContainer(),
+			EndContainer(),
+		EndContainer(),
+	EndContainer(),
+};
+
+static const WindowDesc _clipboard_toolbar_desc(
+       WDP_ALIGN_TOOLBAR, 0, 0,
+	WC_BUILD_TOOLBAR, WC_NONE,
+	WDF_CONSTRUCTION,
+	_nested_clipboard_toolbar_widgets, lengthof(_nested_clipboard_toolbar_widgets)
+//	&ClipboardToolbarWindow::hotkeys
+);
+
+
+/**
+ * Open the clipboard toolbar to copy and paste map pieces.
+ * @return newly opened clipboard toolbar, or NULL if the toolbar could not be opened.
+ */
+Window *ShowClipboardToolbar()
+{
+	if (!Company::IsValidID(_local_company)) return NULL;
+	DeleteWindowByClass(WC_BUILD_TOOLBAR);
+	return new ClipboardToolbarWindow(&_clipboard_toolbar_desc);
+}
diff -urNad openttd-1.3.2/src/clipboard_gui.h openttd-1.3.2-DC3.0RC3/src/clipboard_gui.h
--- openttd-1.3.2/src/clipboard_gui.h	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/clipboard_gui.h	2013-11-22 05:49:06.000000000 +0100
@@ -0,0 +1,30 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file clipboard_gui.h GUIs related to the clipboard. */
+
+#ifndef CLIPBOARD_GUI_H
+#define CLIPBOARD_GUI_H
+
+#include "tile_type.h"
+#include "road_type.h"
+#include "track_type.h"
+
+struct TileContentPastePreview {
+	bool highlight_tile_rect; ///< Whether to highlight tile borders
+	TrackBitsByte highlight_track_bits; ///< Rail tracks to highlight
+};
+
+struct TilePastePreview : TileContentPastePreview {
+	int tile_height; ///< Destination height of the tile
+};
+
+void GetTilePastePreview(TileIndex tile, TilePastePreview *ret);
+
+#endif /* CLIPBOARD_GUI_H */
diff -urNad openttd-1.3.2/src/clipboard_type.h openttd-1.3.2-DC3.0RC3/src/clipboard_type.h
--- openttd-1.3.2/src/clipboard_type.h	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/clipboard_type.h	2013-11-22 05:49:06.000000000 +0100
@@ -0,0 +1,47 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file clipboard_type.h Types related to the clipboard. */
+
+#ifndef CLIPBOARD_TYPE_H
+#define CLIPBOARD_TYPE_H
+
+#include "airport.h"
+#include "newgrf_station.h"
+#include "station_type.h"
+#include "tilearea_type.h"
+
+struct ClipboardStation {
+	struct Spec {
+		StationClassIDByte spec_class;
+		byte spec_index;
+	};
+
+	struct AirportPart : RawTileArea {
+		SimpleTinyEnumT<AirportTypes, byte> type; ///< Airport type
+		byte layout;                              ///< Airport layout
+	};
+
+	StationID         id;        ///< ID
+	AirportPart       airport;   ///< Airport details
+	uint8             num_specs; ///< Number of specs in the speclist
+	Spec             *speclist;  ///< List of station specs of this station
+	ClipboardStation *next;      ///< "Next" pointer to make a linked list
+
+	static ClipboardStation *Get(StationID id, Map *clipboard);
+	static ClipboardStation *GetByTile(GenericTileIndex tile);
+	static const Spec *GetSpecByTile(GenericTileIndex tile);
+
+	ClipboardStation();
+	~ClipboardStation();
+};
+
+typedef ClipboardStation *ClipboardStationList;
+
+#endif /* CLIPBOARD_TYPE_H */
diff -urNad openttd-1.3.2/src/command.cpp openttd-1.3.2-DC3.0RC3/src/command.cpp
--- openttd-1.3.2/src/command.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/command.cpp	2013-11-22 05:49:06.000000000 +0100
@@ -25,6 +25,8 @@
 #include "company_base.h"
 #include "signal_func.h"
 #include "core/backup_type.hpp"
+#include "window_func.h"
+#include "watch_gui.h"
 #include "object_base.h"
 
 #include "table/strings.h"
@@ -32,6 +34,7 @@
 CommandProc CmdBuildRailroadTrack;
 CommandProc CmdRemoveRailroadTrack;
 CommandProc CmdBuildSingleRail;
+CommandProc CmdBuildSingleRails;
 CommandProc CmdRemoveSingleRail;
 
 CommandProc CmdLandscapeClear;
@@ -48,6 +51,7 @@
 CommandProc CmdTerraformLand;
 
 CommandProc CmdBuildObject;
+CommandProc CmdBuyLand;
 CommandProc CmdSellLandArea;
 
 CommandProc CmdBuildTunnel;
@@ -168,6 +172,7 @@
 CommandProc CmdDepotMassAutoReplace;
 
 CommandProc CmdCreateGroup;
+CommandProc CmdCreateGroupSpecificName;
 CommandProc CmdRenameGroup;
 CommandProc CmdDeleteGroup;
 CommandProc CmdAddVehicleGroup;
@@ -180,8 +185,17 @@
 CommandProc CmdSetVehicleOnTime;
 CommandProc CmdAutofillTimetable;
 CommandProc CmdSetTimetableStart;
+CommandProc CmdReinitSeparation;
 
 CommandProc CmdOpenCloseAirport;
+CommandProc CmdChangeStationAcceptance;
+
+CommandProc CmdBuildTrafficLights;
+CommandProc CmdRemoveTrafficLights;
+
+CommandProc CmdInstantCopyPaste;
+CommandProc CmdCopyToClipboard;
+CommandProc CmdPasteFromClipboard;
 
 #define DEF_CMD(proc, flags, type) {proc, #proc, (CommandFlags)flags, type}
 
@@ -196,6 +210,7 @@
 	DEF_CMD(CmdBuildRailroadTrack,       CMD_NO_WATER | CMD_AUTO, CMDT_LANDSCAPE_CONSTRUCTION), // CMD_BUILD_RAILROAD_TRACK
 	DEF_CMD(CmdRemoveRailroadTrack,                     CMD_AUTO, CMDT_LANDSCAPE_CONSTRUCTION), // CMD_REMOVE_RAILROAD_TRACK
 	DEF_CMD(CmdBuildSingleRail,          CMD_NO_WATER | CMD_AUTO, CMDT_LANDSCAPE_CONSTRUCTION), // CMD_BUILD_SINGLE_RAIL
+	DEF_CMD(CmdBuildSingleRails,         CMD_NO_WATER | CMD_AUTO, CMDT_LANDSCAPE_CONSTRUCTION), // CMD_BUILD_MULTI_RAIL
 	DEF_CMD(CmdRemoveSingleRail,                        CMD_AUTO, CMDT_LANDSCAPE_CONSTRUCTION), // CMD_REMOVE_SINGLE_RAIL
 	DEF_CMD(CmdLandscapeClear,                                 0, CMDT_LANDSCAPE_CONSTRUCTION), // CMD_LANDSCAPE_CLEAR
 	DEF_CMD(CmdBuildBridge,  CMD_DEITY | CMD_NO_WATER | CMD_AUTO, CMDT_LANDSCAPE_CONSTRUCTION), // CMD_BUILD_BRIDGE
@@ -205,6 +220,7 @@
 	DEF_CMD(CmdRemoveSingleSignal,                      CMD_AUTO, CMDT_LANDSCAPE_CONSTRUCTION), // CMD_REMOVE_SIGNALS
 	DEF_CMD(CmdTerraformLand,           CMD_ALL_TILES | CMD_AUTO, CMDT_LANDSCAPE_CONSTRUCTION), // CMD_TERRAFORM_LAND
 	DEF_CMD(CmdBuildObject,              CMD_NO_WATER | CMD_AUTO, CMDT_LANDSCAPE_CONSTRUCTION), // CMD_BUILD_OBJECT
+	DEF_CMD(CmdBuyLand,                  CMD_NO_WATER | CMD_AUTO, CMDT_LANDSCAPE_CONSTRUCTION), // CMD_BUY_LAND
 	DEF_CMD(CmdBuildTunnel,                 CMD_DEITY | CMD_AUTO, CMDT_LANDSCAPE_CONSTRUCTION), // CMD_BUILD_TUNNEL
 	DEF_CMD(CmdRemoveFromRailStation,                          0, CMDT_LANDSCAPE_CONSTRUCTION), // CMD_REMOVE_FROM_RAIL_STATION
 	DEF_CMD(CmdConvertRail,                                    0, CMDT_LANDSCAPE_CONSTRUCTION), // CMD_CONVERT_RAILD
@@ -313,6 +329,7 @@
 	DEF_CMD(CmdDepotSellAllVehicles,                           0, CMDT_VEHICLE_CONSTRUCTION  ), // CMD_DEPOT_SELL_ALL_VEHICLES
 	DEF_CMD(CmdDepotMassAutoReplace,                           0, CMDT_VEHICLE_CONSTRUCTION  ), // CMD_DEPOT_MASS_AUTOREPLACE
 	DEF_CMD(CmdCreateGroup,                                    0, CMDT_ROUTE_MANAGEMENT      ), // CMD_CREATE_GROUP
+	DEF_CMD(CmdCreateGroupSpecificName,                        0, CMDT_ROUTE_MANAGEMENT      ), // CMD_CREATE_GROUP_SPECIFIC_NAME
 	DEF_CMD(CmdDeleteGroup,                                    0, CMDT_ROUTE_MANAGEMENT      ), // CMD_DELETE_GROUP
 	DEF_CMD(CmdRenameGroup,                                    0, CMDT_OTHER_MANAGEMENT      ), // CMD_RENAME_GROUP
 	DEF_CMD(CmdAddVehicleGroup,                                0, CMDT_ROUTE_MANAGEMENT      ), // CMD_ADD_VEHICLE_GROUP
@@ -324,8 +341,17 @@
 	DEF_CMD(CmdSetVehicleOnTime,                               0, CMDT_ROUTE_MANAGEMENT      ), // CMD_SET_VEHICLE_ON_TIME
 	DEF_CMD(CmdAutofillTimetable,                              0, CMDT_ROUTE_MANAGEMENT      ), // CMD_AUTOFILL_TIMETABLE
 	DEF_CMD(CmdSetTimetableStart,                              0, CMDT_ROUTE_MANAGEMENT      ), // CMD_SET_TIMETABLE_START
+	DEF_CMD(CmdReinitSeparation,                               0, CMDT_ROUTE_MANAGEMENT      ), // CMD_REINIT_SEPARATION
 
 	DEF_CMD(CmdOpenCloseAirport,                               0, CMDT_ROUTE_MANAGEMENT      ), // CMD_OPEN_CLOSE_AIRPORT
+	DEF_CMD(CmdChangeStationAcceptance,                        0, CMDT_OTHER_MANAGEMENT      ), // CMD_CHANGE_STATION_ACCEPTANCE
+
+	DEF_CMD(CmdBuildTrafficLights,                             0, CMDT_LANDSCAPE_CONSTRUCTION), // CMD_BUILD_TRAFFICLIGHTS
+	DEF_CMD(CmdRemoveTrafficLights,                            0, CMDT_LANDSCAPE_CONSTRUCTION), // CMD_REMOVE_TRAFFICLIGHTS
+
+       DEF_CMD(CmdCopyToClipboard,                      CMD_OFFLINE, CMDT_OTHER_MANAGEMENT      ), // CMD_COPY_TO_CLIPBOARD
+       DEF_CMD(CmdPasteFromClipboard,CMD_OFFLINE|CMD_NO_TEST|CMD_AUTO,CMDT_LANDSCAPE_CONSTRUCTION),// CMD_PASTE_FROM_CLIPBOARD
+       DEF_CMD(CmdInstantCopyPaste,          CMD_NO_TEST | CMD_AUTO, CMDT_LANDSCAPE_CONSTRUCTION), // CMD_INSTANT_COPY_PASTE
 };
 
 /*!
@@ -441,6 +467,10 @@
 		SetTownRatingTestMode(true);
 		res = proc(tile, flags & ~DC_EXEC, p1, p2, text);
 		SetTownRatingTestMode(false);
+               /* Multiply command cost according to day length balance type. */
+               if (_settings_game.economy.day_length_balance_type == DBT_ALL_COSTS) {
+                       res.AffectCost(_settings_game.economy.day_length_balance_factor);
+               }
 		if (res.Failed()) {
 			goto error;
 		}
@@ -462,6 +492,12 @@
 	 * themselves to the cost object at some point */
 	if (_docommand_recursive == 1) _cleared_object_areas.Clear();
 	res = proc(tile, flags, p1, p2, text);
+
+       /* Multiply command cost according to day length balance type. */
+       if (_settings_game.economy.day_length_balance_type == DBT_ALL_COSTS) {
+               res.AffectCost(_settings_game.economy.day_length_balance_factor);
+       }
+
 	if (res.Failed()) {
 error:
 		_docommand_recursive--;
@@ -644,6 +680,8 @@
 	ClearStorageChanges(false);
 	CommandCost res = proc(tile, flags, p1, p2, text);
 	SetTownRatingTestMode(false);
+               /* Already multiplied in DoCommand, so just flag that affected by day length. */
+               res.AffectCost();
 
 	/* Make sure we're not messing things up here. */
 	assert(exec_as_spectator ? _current_company == COMPANY_SPECTATOR : cur_company.Verify());
@@ -687,6 +725,8 @@
 	_cleared_object_areas.Clear();
 	ClearStorageChanges(false);
 	CommandCost res2 = proc(tile, flags | DC_EXEC, p1, p2, text);
+       /* Already multiplied in DoCommand, so just flag that affected by day length. */
+       res2.AffectCost();
 
 	if (cmd_id == CMD_COMPANY_CTRL) {
 		cur_company.Trash();
@@ -726,6 +766,16 @@
 		if (c != NULL) c->last_build_coordinate = tile;
 	}
 
+	/* Send Tile Number to Watching Company Windows */
+	int watching_window = 0;
+	WatchCompany *wc;
+	wc = dynamic_cast<WatchCompany*>(FindWindowById(WC_WATCH_COMPANY, watching_window));
+	while (wc!=NULL) {
+		wc->OnDoCommand( _current_company, tile );
+		watching_window++;
+		wc = dynamic_cast<WatchCompany*>(FindWindowById(WC_WATCH_COMPANY, watching_window));
+	}
+
 	SubtractMoneyFromCompany(res2);
 
 	/* update signals if needed */
diff -urNad openttd-1.3.2/src/command_func.h openttd-1.3.2-DC3.0RC3/src/command_func.h
--- openttd-1.3.2/src/command_func.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/command_func.h	2013-11-22 05:49:06.000000000 +0100
@@ -125,4 +125,7 @@
 CommandCallback CcBuildPrimaryVehicle;
 CommandCallback CcStartStopVehicle;
 
+/* clipboard_gui.cpp */
+CommandCallback CcPaste;
+
 #endif /* COMMAND_FUNC_H */
diff -urNad openttd-1.3.2/src/command_type.h openttd-1.3.2-DC3.0RC3/src/command_type.h
--- openttd-1.3.2/src/command_type.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/command_type.h	2013-11-22 05:49:06.000000000 +0100
@@ -25,6 +25,7 @@
 	Money cost;       ///< The cost of this action
 	StringID message; ///< Warning message for when success is unset
 	bool success;     ///< Whether the comment went fine up to this moment
+	bool affected;
 	uint textref_stack_size;   ///< Number of uint32 values to put on the #TextRefStack for the error message.
 
 	static uint32 textref_stack[16];
@@ -33,25 +34,35 @@
 	/**
 	 * Creates a command cost return with no cost and no error
 	 */
-	CommandCost() : expense_type(INVALID_EXPENSES), cost(0), message(INVALID_STRING_ID), success(true), textref_stack_size(0) {}
+//	CommandCost() : expense_type(INVALID_EXPENSES), cost(0), message(INVALID_STRING_ID), success(true), textref_stack_size(0) {}
+	CommandCost() : expense_type(INVALID_EXPENSES), cost(0), message(INVALID_STRING_ID), success(true), affected(false), textref_stack_size(0) {}
 
 	/**
 	 * Creates a command return value the is failed with the given message
 	 */
-	explicit CommandCost(StringID msg) : expense_type(INVALID_EXPENSES), cost(0), message(msg), success(false), textref_stack_size(0) {}
+	explicit CommandCost(StringID msg) : expense_type(INVALID_EXPENSES), cost(0), message(msg), success(false), affected(false), textref_stack_size(0) {}
 
 	/**
 	 * Creates a command cost with given expense type and start cost of 0
 	 * @param ex_t the expense type
 	 */
-	explicit CommandCost(ExpensesType ex_t) : expense_type(ex_t), cost(0), message(INVALID_STRING_ID), success(true), textref_stack_size(0) {}
+	explicit CommandCost(ExpensesType ex_t) : expense_type(ex_t), cost(0), message(INVALID_STRING_ID), success(true), affected(false), textref_stack_size(0) {}
 
 	/**
 	 * Creates a command return value with the given start cost and expense type
 	 * @param ex_t the expense type
 	 * @param cst the initial cost of this command
 	 */
-	CommandCost(ExpensesType ex_t, const Money &cst) : expense_type(ex_t), cost(cst), message(INVALID_STRING_ID), success(true), textref_stack_size(0) {}
+	CommandCost(ExpensesType ex_t, const Money &cst) : expense_type(ex_t), cost(cst), message(INVALID_STRING_ID), success(true), affected(false), textref_stack_size(0) {}
+
+        /**
+        * Creates a command return value with the given start cost, expense type
+        * and if already affected by day length
+        * @param ex_t the expense type
+        * @param cst the initial cost of this command
+        * @param aff if affected by day length
+        */
+       CommandCost(ExpensesType ex_t, Money cst, bool aff) : expense_type(ex_t), cost(cst), message(INVALID_STRING_ID), success(true), affected(aff), textref_stack_size(0) {}
 
 
 	/**
@@ -75,6 +86,33 @@
 	}
 
 	/**
+	 * Multiplies the cost of command by given factor,
+	 * if not modified before.
+	 * Also set, that it was modified.
+	 * @param factor factor to multiply the costs with, if 0 just flag that modified
+	 * @return this class
+	 */
+	CommandCost AffectCost(uint8 factor = 0)
+	{
+		if (this->affected) return *this;
+		if (factor != 0) this->cost *= factor;
+		this->affected = true;
+		return *this;
+	}
+
+	/**
+	* Divides the cost of command by given factor.
+	* @param factor factor to divide the cost with
+	* @return this class
+	*/
+	CommandCost DivideCost(uint8 factor)
+	{
+		if (factor == 0) return *this;
+		this->cost /= factor;
+		return *this;
+	}
+
+	/**
 	 * The costs as made up to this moment
 	 * @return the costs
 	 */
@@ -150,6 +188,21 @@
 	{
 		return !this->success;
 	}
+
+	/**
+	 * Compare equeal.
+	 *
+	 * In case of two successes, money and type of expenses are comapred.
+	 * In case of two failures, error message is comapred.
+	 *
+	 * @param cost the other cost to compare to
+	 * @return whether booth costs are equeal
+	 */
+	bool operator == (const CommandCost &cost) const
+	{
+		if (!this->success) return !cost.success && this->message == cost.message;
+		return cost.success && this->expense_type == cost.expense_type && this->cost == cost.cost;
+	}
 };
 
 /**
@@ -166,6 +219,7 @@
 	CMD_BUILD_RAILROAD_TRACK,         ///< build a rail track
 	CMD_REMOVE_RAILROAD_TRACK,        ///< remove a rail track
 	CMD_BUILD_SINGLE_RAIL,            ///< build a single rail track
+	CMD_BUILD_SINGLE_RAILS,           ///< build a set of rail tracks on a single tile
 	CMD_REMOVE_SINGLE_RAIL,           ///< remove a single rail track
 	CMD_LANDSCAPE_CLEAR,              ///< demolish a tile
 	CMD_BUILD_BRIDGE,                 ///< build a bridge
@@ -175,6 +229,7 @@
 	CMD_REMOVE_SIGNALS,               ///< remove a signal
 	CMD_TERRAFORM_LAND,               ///< terraform a tile
 	CMD_BUILD_OBJECT,                 ///< build an object
+	CMD_BUY_LAND,                     ///< Buy some land
 	CMD_BUILD_TUNNEL,                 ///< build a tunnel
 
 	CMD_REMOVE_FROM_RAIL_STATION,     ///< remove a (rectangle of) tiles from a rail station
@@ -289,6 +344,7 @@
 	CMD_DEPOT_MASS_AUTOREPLACE,       ///< force the autoreplace to take action in a given depot
 
 	CMD_CREATE_GROUP,                 ///< create a new group
+	CMD_CREATE_GROUP_SPECIFIC_NAME,   ///< create a new group
 	CMD_DELETE_GROUP,                 ///< delete a group
 	CMD_RENAME_GROUP,                 ///< rename a group
 	CMD_ADD_VEHICLE_GROUP,            ///< add a vehicle to a group
@@ -301,8 +357,17 @@
 	CMD_SET_VEHICLE_ON_TIME,          ///< set the vehicle on time feature (timetable)
 	CMD_AUTOFILL_TIMETABLE,           ///< autofill the timetable
 	CMD_SET_TIMETABLE_START,          ///< set the date that a timetable should start
+	CMD_REINIT_SEPARATION,            ///< reinit timetable separation with new parameters
 
 	CMD_OPEN_CLOSE_AIRPORT,           ///< open/close an airport to incoming aircraft
+	CMD_CHANGE_STATION_ACCEPTANCE,    ///< stop accepting/remove cargo from nearby industry
+
+	CMD_BUILD_TRAFFICLIGHTS,          ///< place traffic lights on a road crossing
+	CMD_REMOVE_TRAFFICLIGHTS,         ///< remove traffic lights
+
+	CMD_COPY_TO_CLIPBOARD,            ///< copy selected tile area into the clipboard
+	CMD_PASTE_FROM_CLIPBOARD,         ///< paste content of the clipboard onto the map
+	CMD_INSTANT_COPY_PASTE,           ///< copy selected tile area and instantly paste it at a given location
 
 	CMD_END,                          ///< Must ALWAYS be on the end of this list!! (period)
 };
@@ -313,19 +378,20 @@
  * This enums defines some flags which can be used for the commands.
  */
 enum DoCommandFlag {
-	DC_NONE                  = 0x000, ///< no flag is set
-	DC_EXEC                  = 0x001, ///< execute the given command
-	DC_AUTO                  = 0x002, ///< don't allow building on structures
-	DC_QUERY_COST            = 0x004, ///< query cost only,  don't build.
-	DC_NO_WATER              = 0x008, ///< don't allow building on water
-	DC_NO_RAIL_OVERLAP       = 0x010, ///< don't allow overlap of rails (used in buildrail)
-	DC_NO_TEST_TOWN_RATING   = 0x020, ///< town rating does not disallow you from building
-	DC_BANKRUPT              = 0x040, ///< company bankrupts, skip money check, skip vehicle on tile check in some cases
-	DC_AUTOREPLACE           = 0x080, ///< autoreplace/autorenew is in progress, this shall disable vehicle limits when building, and ignore certain restrictions when undoing things (like vehicle attach callback)
-	DC_NO_CARGO_CAP_CHECK    = 0x100, ///< when autoreplace/autorenew is in progress, this shall prevent truncating the amount of cargo in the vehicle to prevent testing the command to remove cargo
-	DC_ALL_TILES             = 0x200, ///< allow this command also on MP_VOID tiles
-	DC_NO_MODIFY_TOWN_RATING = 0x400, ///< do not change town rating
-	DC_FORCE_CLEAR_TILE      = 0x800, ///< do not only remove the object on the tile, but also clear any water left on it
+	DC_NONE                  = 0x0000, ///< no flag is set
+	DC_EXEC                  = 0x0001, ///< execute the given command
+	DC_AUTO                  = 0x0002, ///< don't allow building on structures
+	DC_QUERY_COST            = 0x0004, ///< query cost only,  don't build.
+	DC_NO_WATER              = 0x0008, ///< don't allow building on water
+	DC_NO_RAIL_OVERLAP       = 0x0010, ///< don't allow overlap of rails (used in buildrail)
+	DC_NO_TEST_TOWN_RATING   = 0x0020, ///< town rating does not disallow you from building
+	DC_BANKRUPT              = 0x0040, ///< company bankrupts, skip money check, skip vehicle on tile check in some cases
+	DC_AUTOREPLACE           = 0x0080, ///< autoreplace/autorenew is in progress, this shall disable vehicle limits when building, and ignore certain restrictions when undoing things (like vehicle attach callback)
+	DC_NO_CARGO_CAP_CHECK    = 0x0100, ///< when autoreplace/autorenew is in progress, this shall prevent truncating the amount of cargo in the vehicle to prevent testing the command to remove cargo
+	DC_ALL_TILES             = 0x0200, ///< allow this command also on MP_VOID tiles
+	DC_NO_MODIFY_TOWN_RATING = 0x0400, ///< do not change town rating
+	DC_FORCE_CLEAR_TILE      = 0x0800, ///< do not only remove the object on the tile, but also clear any water left on it
+	DC_PASTE                 = 0x1000, ///< this command is a part of a paste process
 };
 DECLARE_ENUM_AS_BIT_SET(DoCommandFlag)
 
diff -urNad openttd-1.3.2/src/company_cmd.cpp openttd-1.3.2-DC3.0RC3/src/company_cmd.cpp
--- openttd-1.3.2/src/company_cmd.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/company_cmd.cpp	2013-11-22 05:49:06.000000000 +0100
@@ -63,6 +63,7 @@
 
 	for (uint j = 0; j < 4; j++) this->share_owners[j] = COMPANY_SPECTATOR;
 	InvalidateWindowData(WC_PERFORMANCE_DETAIL, 0, INVALID_COMPANY);
+	InvalidateWindowClassesData( WC_WATCH_COMPANY, 0 );
 }
 
 /** Destructor. */
@@ -83,6 +84,7 @@
 	InvalidateWindowData(WC_PERFORMANCE_DETAIL, 0, (int)index);
 	InvalidateWindowData(WC_COMPANY_LEAGUE, 0, 0);
 	/* If the currently shown error message has this company in it, then close it. */
+	InvalidateWindowClassesData( WC_WATCH_COMPANY, 0 );
 	InvalidateWindowData(WC_ERRMSG, 0);
 }
 
@@ -207,22 +209,59 @@
 	if (cost.GetCost() == 0) return;
 	assert(cost.GetExpensesType() != INVALID_EXPENSES);
 
-	c->money -= cost.GetCost();
-	c->yearly_expenses[0][cost.GetExpensesType()] += cost.GetCost();
-
 	if (HasBit(1 << EXPENSES_TRAIN_INC    |
 	           1 << EXPENSES_ROADVEH_INC  |
 	           1 << EXPENSES_AIRCRAFT_INC |
-	           1 << EXPENSES_SHIP_INC, cost.GetExpensesType())) {
+	           1 << EXPENSES_SHIP_INC     |
+			   1 << EXPENSES_SHARING_INC, cost.GetExpensesType())) {
 		c->cur_economy.income -= cost.GetCost();
 	} else if (HasBit(1 << EXPENSES_TRAIN_RUN    |
 	                  1 << EXPENSES_ROADVEH_RUN  |
 	                  1 << EXPENSES_AIRCRAFT_RUN |
-	                  1 << EXPENSES_SHIP_RUN     |
-	                  1 << EXPENSES_PROPERTY     |
-	                  1 << EXPENSES_LOAN_INT, cost.GetExpensesType())) {
-		c->cur_economy.expenses -= cost.GetCost();
-	}
+//	                  1 << EXPENSES_SHIP_RUN     |
+//	                  1 << EXPENSES_LOST_RUN     |
+//	                  1 << EXPENSES_PROPERTY     |
+//	                  1 << EXPENSES_LOAN_INT     |
+                          1 << EXPENSES_SHIP_RUN , cost.GetExpensesType())) {
+               if ((_settings_game.economy.day_length_balance_type == DBT_ALL_COSTS ||
+                         _settings_game.economy.day_length_balance_type == DBT_RUN_COST)) {
+                       cost.MultiplyCost(_settings_game.economy.day_length_balance_factor);
+               }
+                c->cur_economy.expenses -= cost.GetCost();
+       } else if (HasBit(1 << EXPENSES_LOST_RUN, cost.GetExpensesType())) {
+               if (_settings_game.economy.day_length_balance_type == DBT_ALL_COSTS) {
+                       cost.AffectCost(_settings_game.economy.day_length_balance_factor);
+               }
+                c->cur_economy.expenses -= cost.GetCost();
+       } else if (HasBit(1 << EXPENSES_SHARING_COST, cost.GetExpensesType())) {
+               if (_settings_game.economy.day_length_balance_type == DBT_ALL_COSTS) {
+                       cost.AffectCost(_settings_game.economy.day_length_balance_factor);
+               }
+                c->cur_economy.expenses -= cost.GetCost();
+       } else if (HasBit(1 << EXPENSES_LOAN_INT, cost.GetExpensesType())) {
+               if (_settings_game.economy.day_length_balance_type == DBT_ALL_COSTS ||
+                  (_settings_game.economy.day_length_balance_type == DBT_RUN_COST &&
+                       _settings_game.economy.include_loan_int_to_run)) {
+                       cost.AffectCost(_settings_game.economy.day_length_balance_factor);
+               }
+                c->cur_economy.expenses -= cost.GetCost();
+       } else if (HasBit(1 << EXPENSES_PROPERTY, cost.GetExpensesType())) {
+               if (_settings_game.economy.day_length_balance_type == DBT_ALL_COSTS ||
+                  (_settings_game.economy.day_length_balance_type == DBT_RUN_COST &&
+                       _settings_game.economy.include_prop_main_to_run)) {
+                       cost.AffectCost(_settings_game.economy.day_length_balance_factor);
+               }
+               c->cur_economy.expenses -= cost.GetCost();
+       } else if (HasBit(1 << EXPENSES_CONSTRUCTION, cost.GetExpensesType())) {
+               /* Multiply construction costs according to day length balance type. */
+               if (_settings_game.economy.day_length_balance_type == DBT_ALL_COSTS) {
+                       cost.AffectCost(_settings_game.economy.day_length_balance_factor);
+               }
+        }
+
+       /* Subtract money. */
+       c->money -= cost.GetCost();
+       c->yearly_expenses[0][cost.GetExpensesType()] += cost.GetCost();
 
 	InvalidateCompanyWindows(c);
 }
@@ -567,6 +606,8 @@
 	AI::BroadcastNewEvent(new ScriptEventCompanyNew(c->index), c->index);
 	Game::NewEvent(new ScriptEventCompanyNew(c->index));
 
+	if (!is_ai) UpdateAllTownVirtCoords();
+
 	return c;
 }
 
diff -urNad openttd-1.3.2/src/company_gui.cpp openttd-1.3.2-DC3.0RC3/src/company_gui.cpp
--- openttd-1.3.2/src/company_gui.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/company_gui.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -10,6 +10,7 @@
 /** @file company_gui.cpp %Company related GUIs. */
 
 #include "stdafx.h"
+#include "currency.h"
 #include "error.h"
 #include "gui.h"
 #include "window_gui.h"
@@ -60,6 +61,9 @@
 	EXPENSES_AIRCRAFT_INC,
 	EXPENSES_SHIP_INC,
 	EXPENSES_LOAN_INT,
+	EXPENSES_SHARING_INC,
+	EXPENSES_SHARING_COST,
+	EXPENSES_LOST_RUN,
 	EXPENSES_OTHER,
 };
 
@@ -69,13 +73,16 @@
 	EXPENSES_ROADVEH_INC,
 	EXPENSES_AIRCRAFT_INC,
 	EXPENSES_SHIP_INC,
+	EXPENSES_SHARING_INC,
 	INVALID_EXPENSES,
 	EXPENSES_TRAIN_RUN,
 	EXPENSES_ROADVEH_RUN,
 	EXPENSES_AIRCRAFT_RUN,
 	EXPENSES_SHIP_RUN,
+	EXPENSES_LOST_RUN,
 	EXPENSES_PROPERTY,
 	EXPENSES_LOAN_INT,
+	EXPENSES_SHARING_COST,
 	INVALID_EXPENSES,
 	EXPENSES_CONSTRUCTION,
 	EXPENSES_NEW_VEHICLES,
@@ -1914,14 +1921,27 @@
 							NWidget(NWID_SPACER), SetFill(0, 1),
 						EndContainer(),
 					EndContainer(),
+					NWidget(NWID_SPACER), SetFill(1, 0),
+					NWidget(NWID_SELECTION, INVALID_COLOUR, WID_C_SELECT_GIVE_MONEY),
+						NWidget(NWID_VERTICAL),
+							NWidget(NWID_SPACER), SetFill(0, 1), SetMinimalSize(90, 0),
+							NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_C_GIVE_MONEY), SetDataTip(STR_COMPANY_VIEW_GIVE_MONEY_BUTTON, STR_COMPANY_VIEW_GIVE_MONEY_TOOLTIP),
+						EndContainer(),
+					EndContainer(),
+				EndContainer(),
+				/* Multi player buttons. */
+				NWidget(NWID_HORIZONTAL),
+					NWidget(NWID_SPACER), SetFill(1, 0),
 					NWidget(NWID_VERTICAL), SetPIP(4, 2, 4),
-						NWidget(NWID_SPACER), SetMinimalSize(90, 0), SetFill(0, 1),
-						/* Multi player buttons. */
-						NWidget(NWID_HORIZONTAL),
+						NWidget(NWID_SPACER), SetMinimalSize(95, 0), SetFill(0, 1),
+						NWidget(NWID_HORIZONTAL), SetPIP(0, 5, 0),
 							NWidget(WWT_EMPTY, COLOUR_GREY, WID_C_HAS_PASSWORD),
-							NWidget(NWID_SELECTION, INVALID_COLOUR, WID_C_SELECT_MULTIPLAYER),
-								NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_C_COMPANY_PASSWORD), SetFill(1, 0), SetDataTip(STR_COMPANY_VIEW_PASSWORD, STR_COMPANY_VIEW_PASSWORD_TOOLTIP),
-								NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_C_COMPANY_JOIN), SetFill(1, 0), SetDataTip(STR_COMPANY_VIEW_JOIN, STR_COMPANY_VIEW_JOIN_TOOLTIP),
+							NWidget(NWID_VERTICAL),
+								NWidget(NWID_SPACER), SetMinimalSize(90, 0), SetFill(0, 1),
+								NWidget(NWID_SELECTION, INVALID_COLOUR, WID_C_SELECT_MULTIPLAYER),
+									NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_C_COMPANY_PASSWORD), SetFill(1, 0), SetDataTip(STR_COMPANY_VIEW_PASSWORD, STR_COMPANY_VIEW_PASSWORD_TOOLTIP),
+									NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_C_COMPANY_JOIN), SetFill(1, 0), SetDataTip(STR_COMPANY_VIEW_JOIN, STR_COMPANY_VIEW_JOIN_TOOLTIP),
+								EndContainer(),
 							EndContainer(),
 						EndContainer(),
 					EndContainer(),
@@ -2003,8 +2023,7 @@
 			NWidgetStacked *wi = this->GetWidget<NWidgetStacked>(WID_C_SELECT_BUTTONS);
 			if (plane != wi->shown_plane) {
 				wi->SetDisplayedPlane(plane);
-				this->SetDirty();
-				return;
+				reinit = true;
 			}
 
 			/* Build HQ button handling. */
@@ -2012,8 +2031,7 @@
 			wi = this->GetWidget<NWidgetStacked>(WID_C_SELECT_VIEW_BUILD_HQ);
 			if (plane != wi->shown_plane) {
 				wi->SetDisplayedPlane(plane);
-				this->SetDirty();
-				return;
+				reinit = true;
 			}
 
 			this->SetWidgetDisabledState(WID_C_VIEW_HQ, c->location_of_HQ == INVALID_TILE);
@@ -2023,8 +2041,7 @@
 			wi = this->GetWidget<NWidgetStacked>(WID_C_SELECT_RELOCATE);
 			if (plane != wi->shown_plane) {
 				wi->SetDisplayedPlane(plane);
-				this->SetDirty();
-				return;
+				reinit = true;
 			}
 
 			/* Owners of company */
@@ -2041,6 +2058,14 @@
 				reinit = true;
 			}
 
+			/* Enable/disable 'Give money' button. */
+			plane = ((local || (_local_company == COMPANY_SPECTATOR)) ? SZSP_NONE : 0);
+			wi = this->GetWidget<NWidgetStacked>(WID_C_SELECT_GIVE_MONEY);
+			if (plane != wi->shown_plane) {
+				wi->SetDisplayedPlane(plane);
+				reinit = true;
+			}
+
 			/* Multiplayer buttons. */
 			plane = ((!_networking) ? (int)SZSP_NONE : (int)(local ? CWP_MP_C_PWD : CWP_MP_C_JOIN));
 			wi = this->GetWidget<NWidgetStacked>(WID_C_SELECT_MULTIPLAYER);
@@ -2305,6 +2330,11 @@
 				ShowCompanyInfrastructure((CompanyID)this->window_number);
 				break;
 
+			case WID_C_GIVE_MONEY:
+				this->query_widget = WID_C_GIVE_MONEY;
+				ShowQueryString(STR_EMPTY, STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION, 30, this, CS_NUMERAL, QSF_NONE);
+				break;
+
 			case WID_C_BUY_SHARE:
 				DoCommandP(0, this->window_number, 0, CMD_BUY_SHARE_IN_COMPANY | CMD_MSG(STR_ERROR_CAN_T_BUY_25_SHARE_IN_THIS));
 				break;
@@ -2363,6 +2393,10 @@
 		switch (this->query_widget) {
 			default: NOT_REACHED();
 
+			case WID_C_GIVE_MONEY:
+				DoCommandP(0, (atoi(str) / _currency->rate), this->window_number, CMD_GIVE_MONEY | CMD_MSG(STR_ERROR_INSUFFICIENT_FUNDS), CcGiveMoney, str);
+				break;
+
 			case WID_C_PRESIDENT_NAME:
 				DoCommandP(0, 0, 0, CMD_RENAME_PRESIDENT | CMD_MSG(STR_ERROR_CAN_T_CHANGE_PRESIDENT), NULL, str);
 				break;
diff -urNad openttd-1.3.2/src/copypaste_cmd.cpp openttd-1.3.2-DC3.0RC3/src/copypaste_cmd.cpp
--- openttd-1.3.2/src/copypaste_cmd.cpp	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/copypaste_cmd.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -0,0 +1,689 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file clipboard_cmd.cpp Helper functions for copy/paste commands. */
+
+#include "stdafx.h"
+#include "core/alloc_func.hpp"
+#include "core/geometry_func.hpp"
+#include "network/network.h"
+#include "clear_map.h"
+#include "clipboard_func.h"
+#include "command_func.h"
+#include "company_base.h"
+#include "company_func.h"
+#include "copypaste_cmd.h"
+#include "error.h"
+#include "gui.h"
+#include "rail.h"
+#include "rail_map.h"
+#include "strings_func.h"
+#include "tile_cmd.h"
+#include "tilearea_func.h"
+#include "tunnelbridge_map.h"
+#include <cmath>
+
+#include "table/strings.h"
+
+static const uint INSTANT_COPY_PASTE_BUFFER = NUM_CLIPBOARD_BUFFERS - 1; ///< Index of the buffer reserved for the CmdInstantCopyPaste (temporary buffer)
+
+PastingState *_current_pasting = NULL; ///< State of currently executed paste command
+TileIndex _paste_err_tile = INVALID_TILE; ///< Tile where occured error of the last paste command
+
+/**
+ * Importance of an error in context of pasting. Bigger value is bigger importance.
+ *
+ * Various command errors may be encountered when copy/pasting. The importance decides which one
+ * to show to the user - it will be one of most important errors, the one that was encountered
+ * first. Errors with importance PEI_CRITICAL cancel a paste operation e.g. company run out of money.
+ */
+typedef int PasteErrorImportance;
+
+static const PasteErrorImportance PEI_CRITICAL = 0x100; ///< Critical paste error
+
+/**
+ * Get importance of a certain error message.
+ *
+ * @param error_msg The error.
+ * @return Importance of the error.
+ *
+ * @see PastingState::DoCommand
+ * @see PastingState::IsInterrupted
+ */
+static PasteErrorImportance GetPasteErrorImportance(StringID error_msg)
+{
+	switch (error_msg) {
+		/* Ignored errors, these will be newer stored as they are less important then the default error. */
+		case STR_ERROR_ALREADY_LEVELLED:
+		case STR_ERROR_ALREADY_BUILT:
+			return -1;
+
+		/* The default error which is set initially right before copy/pasting. */
+		case STR_ERROR_NOTHING_TO_DO:
+			return 0;
+
+		/* "Can't distant join" must be the least important error among all non-ignored and non-default
+		 * errors. We must be able to reset it to the default one (see AfterPasteingStations). */
+		case STR_ERROR_CAN_T_DISTANT_JOIN:
+			return 1;
+
+		/* Messageless CMD_ERROR, it's not descriptive so it has a very low importance. */
+		case INVALID_STRING_ID:
+			return 2;
+
+		/* Low importance errors */
+		case STR_ERROR_MUST_REMOVE_RAILWAY_STATION_FIRST:
+		case STR_ERROR_BUILDING_MUST_BE_DEMOLISHED:
+		case STR_ERROR_MUST_DEMOLISH_AIRPORT_FIRST:
+		case STR_ERROR_MUST_REMOVE_ROAD_STOP_FIRST:
+		case STR_ERROR_MUST_DEMOLISH_DOCK_FIRST:
+		case STR_ERROR_BUOY_IN_THE_WAY:
+			return 3;
+
+		/* High importance errors */
+		default:
+			return 4;
+
+		/* Critical errors */
+		case STR_ERROR_NOT_ENOUGH_CASH_REQUIRES_CURRENCY:
+			return PEI_CRITICAL;
+	}
+}
+
+/**
+ * Check if the current paste operations is interrupted.
+ *
+ * @return True if pasting is interrupted, false if we can continue pasting.
+ *
+ * @see PasteErrorImportance
+ * @see PastingState::DoCommand
+ */
+bool PastingState::IsInterrupted() const
+{
+	return GetPasteErrorImportance(this->err_message) >= PEI_CRITICAL;
+}
+
+/**
+ * Call a given command as an ingredient of a paste operation.
+ *
+ * Costs and possible errors will be aggregated. After return, call PastingState::IsInterrupted to
+ * test if the paste operation is disallowed to be continued.
+ *
+ * @param tile The tile to apply the command on.
+ * @param p1 Additional data for the command.
+ * @param p2 Additional data for the command.
+ * @param cmd The command-id to execute (a value of the CMD_* enums) and the error summary message (CMD_MSG).
+ * @return The cost of this operation or an error.
+ *
+ * @pre The command is not flagged with CMD_NO_TEST.
+ * @pre The type of the command is CMDT_LANDSCAPE_CONSTRUCTION.
+ *
+ * @see PastingState::IsInterrupted
+ * @see PastingState::CollectCost
+ * @see PastingState::CollectError
+ */
+void PastingState::DoCommand(TileIndex tile, uint32 p1, uint32 p2, uint32 cmd)
+{
+	/* make sure we are still allowed to paste */
+	if (this->IsInterrupted()) {
+		this->last_result = CMD_ERROR; // mark that the command didn't succeed
+		return;
+	}
+
+	/* PastingState::DoCommand can handle only fully predictable commands, those without
+	 * CMD_NO_TEST flag. Unpredictable command have to be handled separately. */
+	assert(!(GetCommandFlags(cmd) & CMD_NO_TEST));
+
+	/* ignore some of the given flags, instead use those from the command proc table */
+	DoCommandFlag flags = this->dc_flags;
+	flags &= ~DC_AUTO & ~DC_NO_WATER & ~DC_ALL_TILES;
+	flags |= CommandFlagsToDCFlags(GetCommandFlags(cmd));
+
+	/* use given error message or the default one */
+	StringID summary_error_msg = GB(cmd, 16, 16);
+	if (summary_error_msg == 0) summary_error_msg = STR_ERROR_CAN_T_PASTE_HERE;
+
+	/* test the command, output is the return value */
+	CommandCost ret = ::DoCommand(tile, p1, p2, flags & ~DC_EXEC, cmd);
+
+	/* apply if exec'ing */
+	if (ret.Succeeded() && (flags & DC_EXEC)) {
+		/* check if there is enough money */
+		if (ret.GetCost() > 0 && this->GetAvailableMoney() < ret.GetCost()) {
+			SetDParam(0, ret.GetCost());
+			ret = CommandCost(STR_ERROR_NOT_ENOUGH_CASH_REQUIRES_CURRENCY);
+		} else {
+			CommandCost ret2 = ::DoCommand(tile, p1, p2, flags, cmd);
+			assert(ret == ret2);
+		}
+	}
+
+	/* aggregate costs */
+	this->CollectCost(ret, tile, summary_error_msg);
+}
+
+/**
+ * Aggreagate paste command costs without calling PastingState::DoCommand.
+ *
+ * The function works similarly to the PastingState::DoCommand but doesn't actually execute any
+ * commands, it just collects a given result.
+ *
+ * When collecting a success, cost must be of type EXPENSES_CONSTRUCTION. A success also makes
+ * STR_ERROR_NOTHING_TO_DO no more applies (we "did" something).
+ *
+ * Call PastingState::IsInterrupted to test whether the paste operation can be continued.
+ *
+ * @param cost The return value of the command, a cost or an error.
+ * @param tile The tile the error concerns.
+ * @param error_message Summary message of the error.
+ *
+ * @pre The company has enough money if DC_EXEC'ing.
+ *
+ * @see PastingState::IsInterrupted
+ * @see PastingState::CollectError
+ * @see PastingState::DoCommand
+ */
+void PastingState::CollectCost(const CommandCost &cost, TileIndex tile, StringID error_summary)
+{
+	if (cost.Succeeded()) {
+		assert(!this->IsInterrupted());
+		/* Currently only EXPENSES_CONSTRUCTION expenses are allowed when copy/pasting. If this
+		 * is not sufficient, some upgrade will be required. To allow proper update of finacial
+		 * statistics, the overal cost of paste operation will have to be stored separatly for
+		 * each supported type of expenses. */
+		assert(cost.GetExpensesType() == EXPENSES_CONSTRUCTION);
+
+		/* make sure we are not expending too much */
+		assert(!(this->dc_flags & DC_EXEC) || cost.GetCost() <= 0 || this->GetAvailableMoney() >= 0);
+
+		this->had_success = true; // mark that we had a succes and STR_ERROR_NOTHING_TO_DO no more applies
+		this->overal_cost += cost.GetCost();
+		this->last_result = cost;
+	} else {
+		this->CollectError(tile, cost.GetErrorMessage(), error_summary);
+	}
+}
+
+/**
+ * Collect a paste error without calling PastingState::DoCommand or PastingState::CollectCost.
+ *
+ * The function works similary to PastingState::DoCommand and PastingState::CollectCost,
+ * but it only generates an error. After return, call PastingState::IsInterrupted to test whether
+ * the paste operation is allowd to be continued.
+ *
+ * @param tile The tile the error concerns.
+ * @param error_message Error message.
+ * @param error_message Summary error message.
+ *
+ * @see PastingState::IsInterrupted
+ * @see PastingState::CollectCost
+ * @see PastingState::DoCommand
+ */
+void PastingState::CollectError(TileIndex tile, StringID error_message, StringID error_summary)
+{
+	/* store the error only if it is more important then the previous one */
+	if (GetPasteErrorImportance(error_message) > GetPasteErrorImportance(this->err_message)) {
+		this->err_tile = IsValidTile(tile) ? tile : INVALID_TILE;
+		this->err_message = error_message;
+		this->err_summary = error_summary;
+		CopyOutDParam(this->err_params, 0, lengthof(this->err_params));
+	}
+
+	this->last_result = CommandCost(error_message);
+}
+
+/**
+ * Calculate how far tiles can be altered beyond a given paste area bound.
+ *
+ * When pasting, some tiles around the paste area may be altered (during terraforming).
+ * The function return the limit on how far it can happen. Calculations are not exact,
+ * the goal is to give a safe range that will include any possible case.
+ *
+ * Result is based on current and desired heights at neighbour corners of the paste area.
+ *
+ * @param curr_h1 Current height on the first corner.
+ * @param curr_h2 Current height on the second corner.
+ * @param new_h1 Desired height on the first corner.
+ * @param new_h2 Desired height on the second corner.
+ * @param length Distance (in tiles) between corners.
+ * @return How far (in tiles) terraforming can reach beyond the given bound.
+ *
+ * @pre Tile heights and the length can't create an impossible layout, heights can't differ
+ *      too much: \n
+ *      <tt> Delta(curr_h1, curr_h2) <= length </tt> \n
+ *      <tt> Delta(new_h1, new_h2) <= length </tt> \n
+ *
+ * @see CopyPasteAreasMayColide
+ */
+static uint CalcMaxPasteRange(uint curr_h1, uint new_h1, uint curr_h2, uint new_h2, uint length)
+{
+	uint min_curr_h = CeilDiv(max<int>(curr_h1 + curr_h2 - length, 0), 2);
+	uint max_curr_h = min((curr_h1 + curr_h2 + length) / 2, MAX_TILE_HEIGHT);
+	uint min_new_h = CeilDiv(max<int>(new_h1 + new_h2 - length, 0), 2);
+	uint max_new_h = min((new_h1 + new_h2 + length) / 2, MAX_TILE_HEIGHT);
+
+	return max(Delta(max_new_h, min_curr_h), Delta(max_curr_h, min_new_h));
+}
+
+/**
+ * Test if this is safe to copy and paste contents of the map instantly, without
+ * using an intermediate buffer.
+ *
+ * If the copy and the paste areas are close enough (especially when they intersect),
+ * sequential copy-pasting may alter at some point of time those tile of the copy
+ * area which hasn't been copied yet. In this case, further copy-pasting will read
+ * modified values, not the original and this is somthing we don't want to happen.
+ * We can deal with it by firstly copying all the content to the clipboard buffer and
+ * then pasting it onto the map. This function tels us whether we should use the
+ * clipboard as an intermediate buffer because there may happen such a colision.
+ *
+ * @param copy_paste What, where and how we are copying.
+ * @return \c true if intermediate buffer might be required, \c false if it's surely not required
+ *
+ * @pre booth the source area and the destination area are on the main map
+ *
+ * @see CalcMaxPasteRange
+ */
+static bool CopyPasteAreasMayColide(const CopyPasteParams &copy_paste)
+{
+	/* No need to check surroundings if we are not terraforming. Just test for content intersection. */
+	if ((copy_paste.mode & CPM_TERRAFORM_MASK) == CPM_TERRAFORM_NONE) return copy_paste.src_area.Intersects(copy_paste.dst_area);
+
+	/* As we are interested in tile heights, increase areas to include all tile
+	 * corners, also these at SW and SE borders. */
+	TileArea src_corner_area(AsMainMapTile(copy_paste.src_area.tile), copy_paste.src_area.w + 1, copy_paste.src_area.h + 1);
+	TileArea dst_corner_area(AsMainMapTile(copy_paste.dst_area.tile), copy_paste.dst_area.w + 1, copy_paste.dst_area.h + 1);
+
+	DirTransformation inv_transformation = InvertDirTransform(copy_paste.transformation);
+	/* source of the destination area most northern tile corner */
+	TileIndex source_of_north = dst_corner_area.TransformedNorth(src_corner_area.tile, inv_transformation);
+
+	/* calculate current and new heights on destination area corners */
+	/* N */
+	TileIndex dst_corner = dst_corner_area.tile;
+	TileIndex src_corner = source_of_north;
+	uint curr_n = TileHeight(dst_corner);
+	uint new_n = TileHeight(src_corner) + copy_paste.height_delta;
+	/* W */
+	dst_corner = TILE_ADDXY(dst_corner_area.tile, dst_corner_area.w, 0);
+	src_corner = dst_corner_area.TransformTile(dst_corner, source_of_north, inv_transformation);
+	uint curr_w = TileHeight(dst_corner);
+	uint new_w = TileHeight(src_corner) + copy_paste.height_delta;
+	/* S */
+	dst_corner = TILE_ADDXY(dst_corner_area.tile, dst_corner_area.w, dst_corner_area.h);
+	src_corner = dst_corner_area.TransformTile(dst_corner, source_of_north, inv_transformation);
+	uint curr_s = TileHeight(dst_corner);
+	uint new_s = TileHeight(src_corner) + copy_paste.height_delta;
+	/* E */
+	dst_corner = TILE_ADDXY(dst_corner_area.tile, 0, dst_corner_area.h);
+	src_corner = dst_corner_area.TransformTile(dst_corner, source_of_north, inv_transformation);
+	uint curr_e = TileHeight(dst_corner);
+	uint new_e = TileHeight(src_corner) + copy_paste.height_delta;
+
+	/* calculate how far tiles can be altered beyon the paste area (safe approximation) */
+	uint range_ne = CalcMaxPasteRange(curr_n, new_n, curr_e, new_e, dst_corner_area.h - 1);
+	uint range_sw = CalcMaxPasteRange(curr_s, new_s, curr_w, new_w, dst_corner_area.h - 1);
+	uint range_nw = CalcMaxPasteRange(curr_n, new_n, curr_w, new_w, dst_corner_area.w - 1);
+	uint range_se = CalcMaxPasteRange(curr_s, new_s, curr_e, new_e, dst_corner_area.w - 1);
+
+	/* calculate the exact area which may be altered by the paste process */
+	uint x = TileX(dst_corner_area.tile);
+	uint y = TileY(dst_corner_area.tile);
+	range_ne = max(range_ne, x); // cut the area at the NE border (don't let x to go below 0)
+	range_nw = max(range_nw, y); // cut the area at the NW border (don't let y to go below 0)
+	TileArea forbidden_area(
+			TileXY(x - range_ne, y - range_nw),
+			dst_corner_area.w + range_ne + range_sw,
+			dst_corner_area.h + range_nw + range_se);
+
+	/* test if the source area is within the paste range */
+	return src_corner_area.Intersects(forbidden_area);
+}
+
+/**
+ * Calculate how much to add to each height of a tile while copy-pasteing.
+ * @param src_area Area we are copying from.
+ * @param dst_area Area we are pasting at.
+ * @param transformation Transformation to perform.
+ * @param additional_height Extra amount of units to add.
+ */
+static inline int CalcCopyPasteHeightDelta(const GenericTileArea &src_area, const GenericTileArea &dst_area, DirTransformation transformation, int additional_height)
+{
+	GenericTileArea dst_corners(dst_area.tile, dst_area.w + 1, dst_area.h + 1);
+	GenericTileIndex source_of_north = dst_corners.TransformedNorth(src_area.tile, InvertDirTransform(transformation));
+	return TileHeight(dst_corners.tile) - TileHeight(source_of_north) + additional_height;
+}
+
+/**
+ * Do a sequential copy-pasting by calling appropriate CopyPasteCommandProc on each selected tile.
+ * @param copy_paste What, where and how we are copying.
+ */
+static inline void DoCopyPaste(const CopyPasteParams &copy_paste)
+{
+	/* Copying to the clipboard buffer should always success.
+	 * Some content may be intransformable (e.g. airport) so we can't use any transformation. */
+	assert(IsMainMapTile(copy_paste.dst_area.tile) || (copy_paste.transformation == DTR_IDENTITY && (copy_paste.mode & CPM_TERRAFORM_MASK) == CPM_TERRAFORM_FULL));
+
+	if ((copy_paste.mode & CPM_TERRAFORM_MASK) == CPM_TERRAFORM_FULL) {
+		CopyPasteHeights(copy_paste.src_area, copy_paste.dst_area.tile, copy_paste.transformation, copy_paste.height_delta);
+		if (IsPastingInterrupted()) return;
+	}
+
+	for (TransformationTileIteratorT<true, true> ti(copy_paste.src_area, copy_paste.src_area.TransformedNorth(copy_paste.dst_area.tile, copy_paste.transformation), copy_paste.transformation); IsValidTileIndex(ti); ++ti) {
+		CopyPasteTileProc *proc = _tile_type_procs[GetTileType(ti.SrcTile())]->copy_paste_tile_proc;
+		if (proc == NULL) continue;
+		proc(ti.SrcTile(), ti.DstTile(), copy_paste);
+		if (IsPastingInterrupted()) break;
+	}
+
+	if (IsMainMapTile(copy_paste.dst_area.tile)) {
+		AfterPastingStations(copy_paste);
+	} else {
+		AfterCopyingStations(copy_paste);
+	}
+}
+
+/**
+ * Test if a given TileArea is valid.
+ * @return \c true if the area is non-empty and fits inside the map, \c false otherwise.
+ */
+static CommandCost ValParamCopyPasteArea(const GenericTileArea &ta)
+{
+	if (!IsValidTile(ta.tile) ||
+			!IsInsideBS(ta.w, 1, _settings_game.construction.clipboard_capacity) ||
+			!IsInsideBS(ta.h, 1, _settings_game.construction.clipboard_capacity)) {
+		return CMD_ERROR;
+	}
+
+	if (TileX(ta.tile) + ta.w > MapMaxX(MapOf(ta.tile)) ||
+			TileY(ta.tile) + ta.h > MapMaxY(MapOf(ta.tile))) {
+		return_cmd_error(STR_ERROR_TOO_CLOSE_TO_EDGE_OF_MAP_SUB);
+	}
+
+	return CommandCost();
+}
+
+/**
+ * Test if a CopyPasteMode is valid.
+ * @return \c true if does, \c false otherwise
+ */
+static bool ValParamCopyPasteMode(CopyPasteMode mode)
+{
+	if (mode & ~CPM_MASK) return false;
+	mode &= CPM_TERRAFORM_MASK;
+	return mode == CPM_TERRAFORM_NONE || mode == CPM_TERRAFORM_MINIMAL || mode == CPM_TERRAFORM_FULL;
+}
+
+/**
+ * Copy content of a given tile area into the clipboard buffer.
+ * @param ta The area to copy
+ * @param buffer Clipboard buffer to copy into
+ */
+static void CopyToClipboard(Map *buffer, const TileArea &ta)
+{
+	AllocateClipboardBuffer(buffer, ta.w, ta.h);
+
+	CopyPasteParams copy_paste = {
+		GenericTileArea(ta),                         // src_area
+		GenericTileArea(TileXY(0, 0, buffer), ta.w, ta.h), // dst_area
+		CPM_ALL_TRANSPORT_MASK | CPM_TERRAFORM_FULL, // mode
+		INVALID_RAILTYPE,                            // railtype
+		DTR_IDENTITY,                                // transformation
+		0                                            // height_delta
+	};
+
+	DoCopyPaste(copy_paste);
+}
+
+/**
+ * Begin a paste process.
+ * @param flags Flags for the command.
+ * @param params What, where and how to paste.
+ */
+static void InitializePasting(DoCommandFlag flags, const CopyPasteParams &params)
+{
+	assert(_current_pasting == NULL);
+	_current_pasting = new PastingState;
+
+	_current_pasting->dc_flags    = flags | DC_PASTE;
+	_current_pasting->overal_cost = 0;
+	_current_pasting->had_success = false;
+	_current_pasting->err_summary = STR_ERROR_CAN_T_PASTE_HERE;
+	_current_pasting->err_message = STR_ERROR_NOTHING_TO_DO;
+	MemSetT(_current_pasting->err_params, 0, lengthof(_current_pasting->err_params));
+	_current_pasting->err_tile    = INVALID_TILE;
+	_current_pasting->last_result = CommandCost(STR_ERROR_NOTHING_TO_DO);
+}
+
+/**
+ * Finish a paste process.
+ * @return Total cost.
+ */
+static CommandCost FinalizePasting()
+{
+	/* Set error string parameters */
+	CopyInDParam(0, _current_pasting->err_params, lengthof(_current_pasting->err_params));
+	/* Set error summary message (see COPY_PASTE_ERR_SUMMARY_PARAM for details). */
+	SetDParam(COPY_PASTE_ERR_SUMMARY_PARAM, _current_pasting->err_summary);
+	/* Store the error tile so the GUI (CcPaste) can highlight it. */
+	_paste_err_tile = _current_pasting->err_tile;
+
+	CommandCost ret;
+	if (_current_pasting->had_success) {
+		/* Return overal cost of the operation */
+		ret = CommandCost(EXPENSES_CONSTRUCTION, _current_pasting->overal_cost);
+		/* Here we are about to return a success. However, there could occured some meaningful
+		 * errors (those except "already built", "already leveled" etc.) and we should inform
+		 * the user that not everything went right. Show the message now. */
+		if ((_current_pasting->dc_flags & DC_EXEC) && IsLocalCompany() && GetPasteErrorImportance(_current_pasting->err_message) > GetPasteErrorImportance(STR_ERROR_NOTHING_TO_DO)) {
+			ShowErrorMessage(_current_pasting->err_summary, _current_pasting->err_message, WL_INFO);
+		} else {
+			/* If we are not showing error message then clear the error tile to prevent GUI
+			 * (CcPaste) from higlighting it. */
+			_paste_err_tile = INVALID_TILE;
+		}
+	} else {
+		/* Return an error if we didn't have any success. */
+		ret = CommandCost(_current_pasting->err_message);
+	}
+
+	/* cleanup */
+	delete _current_pasting;
+	_current_pasting = NULL;
+
+	return ret;
+}
+
+/**
+ * Paste onto the main map content of a clipboard buffer.
+ * @param buffer The buffer.
+ * @param tile Tile where to paste (most northern).
+ * @param flags Flags for the command.
+ * @param mode Copy-paste mode.
+ * @param transformation Transformation to perform.
+ * @param railtype #RailType to convert to.
+ * @param additional_height_delta Additional amount of units to add to each tile height.
+ * @return Total cost.
+ */
+static CommandCost PasteFromClipboard(Map *buffer, TileIndex tile, DoCommandFlag flags, CopyPasteMode mode, DirTransformation transformation, RailType railtype, int additional_height_delta)
+{
+	assert(!IsClipboardBufferEmpty(buffer));
+
+	CopyPasteParams copy_paste;
+
+	/* calculate and validate copy/paste area */
+	copy_paste.src_area = GenericTileArea(TileXY(0, 0, buffer), MapMaxX(buffer), MapMaxY(buffer));
+	copy_paste.dst_area = TransformTileArea(copy_paste.src_area, GenericTileIndex(tile), transformation);
+	CommandCost ret = ValParamCopyPasteArea(copy_paste.dst_area);
+	if (ret.Failed()) return ret;
+
+	copy_paste.mode = mode;
+	copy_paste.railtype = railtype;
+	copy_paste.transformation = transformation;
+	copy_paste.height_delta = CalcCopyPasteHeightDelta(copy_paste.src_area, copy_paste.dst_area, transformation, additional_height_delta);
+
+	/* do sequential copy-pasting */
+	InitializePasting(flags, copy_paste);
+	DoCopyPaste(copy_paste);
+	return FinalizePasting();
+}
+
+/**
+ * Copy tile area into clipboard.
+ *
+ * @param tile Northern tile of the area to copy.
+ * @param flags Command flags.
+ * @param p1 Various bits:
+ *    \li bits  0..1   [2] - clipboard buffer index
+ *    \li bits  2..31 [30] - [ unused ]
+ * @param p2 Various bits:
+ *    \li bits  0..5   [6] - width of area to copy
+ *    \li bits  6..11  [6] - height of area to copy
+ *    \li bits 12..31 [20] - [ unused ]
+ * @param text Unused.
+ * @return The cost of this operation or an error.
+ */
+CommandCost CmdCopyToClipboard(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
+{
+	/* clipboard is available only in a sigle player game and only to the local company */
+	if (_networking || !IsLocalCompany()) return CMD_ERROR;
+
+	/* extract and validate clipboard buffer index */
+	uint index = GB(p1, 0, 2);
+	if (index >= NUM_CLIPBOARD_BUFFERS || index == INSTANT_COPY_PASTE_BUFFER) return CMD_ERROR;
+
+	/* calculate and validate source area */
+	TileArea src_area(tile, GB(p2, 0, 6), GB(p2, 6, 6));
+	CommandCost ret = ValParamCopyPasteArea(src_area);
+	if (ret.Failed()) return ret;
+
+	/* copy to clipboard only when executing (DC_EXEC) */
+	if (flags & DC_EXEC) CopyToClipboard(GetClipboardBuffer(index), src_area);
+
+	/* return the cost */
+	return CommandCost(INVALID_EXPENSES, 0);
+}
+
+/**
+ * Paste clipboard contents onto the map.
+ *
+ * @param tile Tile where to paste (northern).
+ * @param flags Command flags.
+ * @param p1 Various bits:
+ *    \li bits  0..1   [2] - clipboard buffer index
+ *    \li bits  2..27 [26] - [ unused ]
+ *    \li bits 28..31  [4] - rail type (RailType) to convert to, ignored if CPM_CONVERT_RAILTYPE mode is off
+ * @param p2 Various bits:
+ *    \li bits  0..11 [12] - [ unused ]
+ *    \li bits 12..15  [4] - additional amount of tile heights to add to each tile (-8..7)
+ *    \li bits 16..18  [3] - transformation to perform (DirTransformation)
+ *    \li bits 19..27  [9] - mode (CopyPasteMode)
+ *    \li bits 28..31  [4] - [ unused ]
+ * @param text Unused.
+ * @return The cost of this operation or an error.
+ */
+CommandCost CmdPasteFromClipboard(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
+{
+	/* extract and validate clipboard buffer index */
+	uint index = GB(p1, 0, 2);
+	if (index >= NUM_CLIPBOARD_BUFFERS || index == INSTANT_COPY_PASTE_BUFFER) return CMD_ERROR;
+
+	/* clipboard is available only in a sigle player game and only to the local company */
+	if (_networking || !IsLocalCompany() || IsClipboardBufferEmpty(GetClipboardBuffer(index))) return CMD_ERROR;
+
+	/* extract and validate copy/paste mode */
+	CopyPasteMode mode = (CopyPasteMode)GB(p2, 19, 9);
+	if (!ValParamCopyPasteMode(mode)) return CMD_ERROR;
+
+	/* extract and validate rail type */
+	RailType railtype = (RailType)GB(p1, 28,  4);
+	if (!ValParamRailtype(railtype)) return CMD_ERROR;
+
+	/* extract transformation and additional height delta */
+	DirTransformation transformation = (DirTransformation)GB(p2, 16,  3);
+	int additional_height_delta = GB(p2, 12, 4);
+	additional_height_delta |= -(additional_height_delta & (1 << 3)); // propagate sign bit
+
+	return PasteFromClipboard(GetClipboardBuffer(index), tile, flags, mode, transformation, railtype, additional_height_delta);
+}
+
+/**
+ * Copy a piece of map and instantly paste at given location.
+ *
+ * @param tile Tile where to paste (northern).
+ * @param flags Command flags.
+ * @param p1 Various bits:
+ *    \li bits  0..27 [28] - northern tile of the source area
+ *    \li bits 28..31  [4] - rail type (RailType) to convert to, ignored if CPM_CONVERT_RAILTYPE mode is off
+ * @param p2 Various bits:
+ *    \li bits  0..5   [6] - source area width
+ *    \li bits  6..11  [6] - source area height
+ *    \li bits 12..15  [4] - additional amount of tile heights to add to each tile (-8..7)
+ *    \li bits 16..18  [3] - transformation to perform (DirTransformation)
+ *    \li bits 19..27  [9] - mode (CopyPasteMode)
+ *    \li bits 28..31  [4] - [ unused ]
+ * @param text Unused.
+ * @return The cost of this operation or an error.
+ */
+CommandCost CmdInstantCopyPaste(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
+{
+	CopyPasteParams copy_paste;
+
+	/* extract and validate source area */
+	copy_paste.src_area.tile = GenericTileIndex(TileIndex(GB(p1, 0, 28)));
+	copy_paste.src_area.w = GB(p2, 0, 6);
+	copy_paste.src_area.h = GB(p2, 6, 6);
+	CommandCost ret = ValParamCopyPasteArea(copy_paste.src_area);
+	if (ret.Failed()) return ret;
+
+	/* calculate and validate destination area */
+	copy_paste.dst_area = TransformTileArea(copy_paste.src_area, GenericTileIndex(tile), copy_paste.transformation);
+	ret = ValParamCopyPasteArea(copy_paste.dst_area);
+	if (ret.Failed()) return ret;
+
+	/* extract and validate copy/paste mode */
+	copy_paste.mode = (CopyPasteMode)GB(p2, 19, 9);
+	if (!ValParamCopyPasteMode(copy_paste.mode)) return CMD_ERROR;
+
+	/* extract and validate rail type */
+	copy_paste.railtype = (RailType)GB(p1, 28,  4);
+	if (!ValParamRailtype(copy_paste.railtype)) return CMD_ERROR;
+
+	/* extract transformation */
+	copy_paste.transformation = (DirTransformation)GB(p2, 16,  3);
+
+	/* extract the additional number of height units */
+	int additional_height_delta = GB(p2, 12, 4); // this is a 4-bit SIGNED integer (-8..7)
+	additional_height_delta |= -(additional_height_delta & (1 << 3)); // propagate the sign bit
+
+	/* calculate the height */
+	copy_paste.height_delta = CalcCopyPasteHeightDelta(copy_paste.src_area, copy_paste.dst_area, copy_paste.transformation, additional_height_delta);
+
+	/* when copy and paste areas are too close each other, firstly
+	 * copy to the clipboard and then from the clipboard to the map */
+	if (CopyPasteAreasMayColide(copy_paste)) {
+		Map *clipboard = GetClipboardBuffer(INSTANT_COPY_PASTE_BUFFER);
+		/* Copy to a buffer, but only in the first stage of the command.
+		 * In a single player game and also while we are a server, the first one is non-DC_EXEC
+		 * stage (which is fallowed then by a DC_EXEC stage). When we are a client, there is only
+		 * one stage which is either a single non-DC_EXEC stage (shift pressed), or a single DC_EXEC
+		 * stage (command comming from the network). */
+		if ((_networking && !_network_server) || !(flags & DC_EXEC)) {
+			CopyToClipboard(clipboard, copy_paste.src_area);
+		}
+		/* paste from the clipboard */
+		ret = PasteFromClipboard(clipboard, tile, flags, copy_paste.mode, copy_paste.transformation, copy_paste.railtype, additional_height_delta);
+	} else {
+		/* copy/paste directly */
+		InitializePasting(flags, copy_paste);
+		DoCopyPaste(copy_paste);
+		ret = FinalizePasting();
+	}
+	return ret;
+}
diff -urNad openttd-1.3.2/src/copypaste_cmd.h openttd-1.3.2-DC3.0RC3/src/copypaste_cmd.h
--- openttd-1.3.2/src/copypaste_cmd.h	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/copypaste_cmd.h	2013-11-22 05:49:07.000000000 +0100
@@ -0,0 +1,117 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file copypaste_cmd.h Helper functions for copy/paste commands. */
+
+#ifndef COPYPASTE_CMD_H
+#define COPYPASTE_CMD_H
+
+#include "core/enum_type.hpp"
+#include "command_func.h"
+#include "rail_type.h"
+#include "tilearea_type.h"
+#include "track_type.h"
+#include "station_type.h"
+#include "newgrf_station.h"
+#include "water_map.h"
+
+#include "table/strings.h"
+
+/** Pasting modifiers. */
+enum CopyPasteMode {
+	CPM_WITH_RAIL_TRANSPORT  =   1 << 0, ///< copy-paste rail transport infrastructure
+	CPM_WITH_ROAD_TRANSPORT  =   1 << 1, ///< copy-paste road transport infrastructure
+	CPM_WITH_WATER_TRANSPORT =   1 << 2, ///< copy-paste water transport infrastructure
+	CPM_WITH_AIR_TRANSPORT   =   1 << 3, ///< copy-paste air transport infrastructure
+	CPM_ALL_TRANSPORT_MASK   = 0xF << 0, ///< bitmask with all transport types
+
+	CPM_TERRAFORM_NONE       =   0 << 4, ///< do not alter tile heights
+	CPM_TERRAFORM_MINIMAL    =   1 << 4, ///< terraform as less as possible to paste all objects at right heights
+	CPM_TERRAFORM_FULL       =   2 << 4, ///< copy-paste all tile heights
+	CPM_TERRAFORM_MASK       = 0x3 << 4, ///< bitmask to extract terraforming modes
+
+	CPM_CONVERT_RAILTYPE     =   1 << 6, ///< convert rails to a given rail type
+	CPM_MIRROR_SIGNALS       =   1 << 7, ///< mirror signals direction
+	CPM_UPGRADE_BRIDGES      =   1 << 8, ///< upgrade bridge types to fastes possible
+	CPM_FLAGS_MASK           = 0x7 << 6, ///< bitmask to mask all flag-like bits
+
+	CPM_NONE                 =        0, ///< empty set of modes
+	CPM_MASK = CPM_ALL_TRANSPORT_MASK | CPM_FLAGS_MASK | CPM_TERRAFORM_MASK, ///< all possible bits
+	CPM_DEFAULT = CPM_ALL_TRANSPORT_MASK | CPM_TERRAFORM_MINIMAL, ///< defult mode
+};
+DECLARE_ENUM_AS_BIT_SET(CopyPasteMode)
+
+/** Land leveling type used in e.g. #LevelPasteLand. */
+enum CopyPasteLevelVariant {
+	CPLV_LEVEL_ABOVE, ///< Lower the land until a given height reached.
+	CPLV_LEVEL_BELOW, ///< Raise the land until a given height reached.
+};
+
+/** Parameters of a copy/paste command. */
+struct CopyPasteParams {
+	GenericTileArea src_area;         ///< The area we are copying from
+	GenericTileArea dst_area;         ///< The area we are pasting at
+	CopyPasteMode mode;               ///< Various flags telling what to copy and how to paste
+	RailType railtype;                ///< Convert all rails to a given rail type (only in #CPM_CONVERT_RAILTYPE mode)
+	DirTransformation transformation; ///< Transformation to perform on the content while copy-pasting
+	int height_delta;                 ///< Amount of units to add to the height of each tile (appropriate terraforming mode must be set e.g. #CPM_TERRAFORM_FULL)
+};
+
+/** Summary error message for copy/paste command may vary depending on encountered errors.
+ * While firing copy/paste command the summary messsage given with CMD_MSG is expected to
+ * be STR_COPY_PASTE_ERROR_SUMMARY (which is "{8:STRING}") so a true message can be set
+ * later through param #8. The constant below is the index of the param. */
+static const int COPY_PASTE_ERR_SUMMARY_PARAM = 8;
+
+/** Executes commands and gathers results of a paste process. */
+struct PastingState {
+	DoCommandFlag dc_flags;        ///< Flags to use when executing commands
+	Money         overal_cost;     ///< Overal cost of currently executed paste command.
+	CommandCost   last_result;     ///< Result of the most recent PastingState::DoCommand / PastingState::CollectCost / PastingState::CollectError.
+	bool          had_success;     ///< If currently executed paste command had a successful action (at least once).
+	StringID      err_summary;     ///< Summary message of the paste error.
+	StringID      err_message;     ///< Detailed message of the paste error.
+	TileIndex     err_tile;        ///< Tile where the last paste error occured.
+	uint64        err_params[COPY_PASTE_ERR_SUMMARY_PARAM]; ///< Parameters for the paste error
+
+	void DoCommand(TileIndex tile, uint32 p1, uint32 p2, uint32 cmd);
+	void CollectCost(const CommandCost &cost, TileIndex tile, StringID error_summary = STR_ERROR_CAN_T_PASTE_HERE);
+	void CollectError(TileIndex tile, StringID error_message, StringID error_summary = STR_ERROR_CAN_T_PASTE_HERE);
+	bool IsInterrupted() const;
+
+	inline Money GetAvailableMoney() const
+	{
+		return GetAvailableMoneyForCommand() - this->overal_cost;
+	}
+};
+
+extern PastingState *_current_pasting;
+extern TileIndex _paste_err_tile;
+
+/**
+ * Check if it is allowed to continue pasting.
+ * @return True if pasting is interrupted, false otherwise
+ */
+static inline bool IsPastingInterrupted()
+{
+	return _current_pasting != NULL && _current_pasting->IsInterrupted();
+}
+
+void LevelPasteLand(const TileArea &ta, uint height, CopyPasteLevelVariant variant);
+void CopyPasteHeights(const GenericTileArea &src_area, GenericTileIndex dst_area_north, DirTransformation transformation, int height_delta);
+
+void CopyPastePlaceTracks(GenericTileIndex tile, RailType railtype, TrackBits tracks);
+void CopyPastePlaceCannal(GenericTileIndex tile);
+void CopyPastePlaceRailWaypoint(GenericTileIndex tile, StationID sid, Axis axis, byte gfx, StationClassID spec_class, byte spec_index, RailType rt, bool adjacent);
+void CopyPastePlaceBuoy(GenericTileIndex tile, StationID sid, WaterClass wc);
+
+void AfterCopyingStations(const CopyPasteParams &copy_paste);
+void AfterPastingStations(const CopyPasteParams &copy_paste);
+
+#endif /* COPYPASTE_CMD_H */
diff -urNad openttd-1.3.2/src/core/bitmath_func.hpp openttd-1.3.2-DC3.0RC3/src/core/bitmath_func.hpp
--- openttd-1.3.2/src/core/bitmath_func.hpp	2013-07-27 17:09:33.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/core/bitmath_func.hpp	2013-11-22 05:49:07.000000000 +0100
@@ -321,6 +321,39 @@
 }
 
 /**
+ * Swap odd and even bits in a variable.
+ *
+ * Bit 0 is swapped with bit 1, bit 2 with bit 3 and so on.
+ *
+ * @param x The value in which we want to swap bits
+ * @return The bit swapped value
+ */
+template <typename T>
+static inline T SwapOddEvenBits(T x)
+{
+	return (T)(((x >> 1) & (T)0x5555555555555555LL) | ((x & (T)0x5555555555555555LL) << 1));
+}
+
+/**
+ * Interleave bits (a.k.a. Morton code) of two 8-bit integers \c x and \c y.
+ *
+ * The result is computed by putting consecutive \c x bits at even positions and consecutive \c y
+ * bits at odd positions:
+ *
+ * <tt> (X7 X6 ... X1 X0, Y7 Y6 ... Y1 Y0)   ->   Y7 X7 Y6 X6 ... Y1 X1 Y0 X0 </tt>
+ *
+ * @param x The bits to put at even positions.
+ * @param y The bits to put at odd positions.
+ * @return The interleaved value.
+ */
+static inline uint16 InterleaveBits8(uint8 x, uint8 y)
+{
+	/* Found on the "Bit Twiddling Hacks" webpage: http://graphics.stanford.edu/~seander/bithacks.html */
+	return (((x * 0x0101010101010101ULL & 0x8040201008040201ULL) * 0x0102040810204081ULL >> 49) & 0x5555) |
+			(((y * 0x0101010101010101ULL & 0x8040201008040201ULL) * 0x0102040810204081ULL >> 48) & 0xAAAA);
+}
+
+/**
  * Do an operation for each set bit in a value.
  *
  * This macros is used to do an operation for each set
diff -urNad openttd-1.3.2/src/core/geometry_func.cpp openttd-1.3.2-DC3.0RC3/src/core/geometry_func.cpp
--- openttd-1.3.2/src/core/geometry_func.cpp	2013-07-27 17:09:33.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/core/geometry_func.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -12,6 +12,7 @@
 #include "../stdafx.h"
 #include "geometry_func.hpp"
 #include "math_func.hpp"
+#include "../map_func.h"
 
 /**
  * Compute bounding box of both dimensions.
@@ -26,3 +27,24 @@
 	d.height = max(d1.height, d2.height);
 	return d;
 }
+
+/**
+ * Transform a given Point.
+ *
+ * The center point of the transformation is (0, 0).
+ * For example, point (1, 2) rotated 90 degree left is (-2, 1).
+ *
+ * @param point The Point to transform.
+ * @param transformation Transformation to perform.
+ * @return The transformed Point.
+ */
+Point TransformPoint(Point point, DirTransformation transformation)
+{
+	TileIndexDiffC diff_from_x = TileIndexDiffCByDiagDir(TransformDiagDir(DIAGDIR_SW, transformation));
+	TileIndexDiffC diff_from_y = TileIndexDiffCByDiagDir(TransformDiagDir(DIAGDIR_SE, transformation));
+	Point ret = {
+		point.x * diff_from_x.x + point.y * diff_from_y.x,
+		point.x * diff_from_x.y + point.y * diff_from_y.y
+	};
+	return ret;
+}
diff -urNad openttd-1.3.2/src/core/geometry_func.hpp openttd-1.3.2-DC3.0RC3/src/core/geometry_func.hpp
--- openttd-1.3.2/src/core/geometry_func.hpp	2013-07-27 17:09:33.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/core/geometry_func.hpp	2013-11-22 05:49:07.000000000 +0100
@@ -13,7 +13,26 @@
 #define GEOMETRY_FUNC_HPP
 
 #include "geometry_type.hpp"
+#include "math_func.hpp"
+#include "../direction_func.h"
 
 Dimension maxdim(const Dimension &d1, const Dimension &d2);
 
+/**
+ * Transform a given Dimension.
+ *
+ * The width and the height will be swapped or will stay unchanged based on used transformation.
+ *
+ * @param dim The Dimension to transform.
+ * @param transformation Transformation to perform.
+ * @return The transformed Dimension.
+ */
+static inline Dimension TransformDimension(Dimension dim, DirTransformation transformation)
+{
+	if (TransformAxis(AXIS_X, transformation) != AXIS_X) Swap(dim.width, dim.height);
+	return dim;
+}
+
+Point TransformPoint(Point point, DirTransformation transformation);
+
 #endif /* GEOMETRY_FUNC_HPP */
diff -urNad openttd-1.3.2/src/core/math_func.hpp openttd-1.3.2-DC3.0RC3/src/core/math_func.hpp
--- openttd-1.3.2/src/core/math_func.hpp	2013-07-27 17:09:33.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/core/math_func.hpp	2013-11-22 05:49:07.000000000 +0100
@@ -98,6 +98,18 @@
 }
 
 /**
+ * Returns the sign of a value.
+ *
+ * @param x The value
+ * @return -1 if the x is negative, +1 if positive, 0 otherwise
+ */
+template <typename T>
+static inline int sgn(const T x)
+{
+	return (int)(x > (T)0) - (int)(x < (T)0);
+}
+
+/**
  * Return the smallest multiple of n equal or greater than x
  *
  * @note n must be a power of 2
diff -urNad openttd-1.3.2/src/crashlog.cpp openttd-1.3.2-DC3.0RC3/src/crashlog.cpp
--- openttd-1.3.2/src/crashlog.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/crashlog.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -361,7 +361,7 @@
 {
 	/* If the map array doesn't exist, saving will fail too. If the map got
 	 * initialised, there is a big chance the rest is initialised too. */
-	if (_m == NULL) return false;
+	if (_main_map.m == NULL) return false;
 
 	try {
 		GamelogEmergency();
diff -urNad openttd-1.3.2/src/date.cpp openttd-1.3.2-DC3.0RC3/src/date.cpp
--- openttd-1.3.2/src/date.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/date.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -19,12 +19,14 @@
 #include "vehicle_base.h"
 #include "rail_gui.h"
 #include "saveload/saveload.h"
+#include "cargodest_func.h"
 
 Year      _cur_year;   ///< Current year, starting at 0
 Month     _cur_month;  ///< Current month (0..11)
 Date      _date;       ///< Current date in days (day counter)
 DateFract _date_fract; ///< Fractional part of the day.
 uint16 _tick_counter;  ///< Ever incrementing (and sometimes wrapping) tick counter for setting off various events
+uint8 _tick_skip_counter;
 
 /**
  * Set the date.
@@ -154,6 +156,15 @@
 	return DAYS_TILL(year) + days;
 }
 
+/**
+ * Converts the current day counter and date fraction into an absolute tick value.
+ * @returns current time as ticks
+ */
+Ticks GetCurrentTickCount()
+{
+	return _date * DAY_TICKS_DAY_LENGTH + _date_fract;
+}
+
 /** Functions used by the IncreaseDate function */
 
 extern void EnginesDailyLoop();
@@ -238,6 +249,7 @@
 	IndustryMonthlyLoop();
 	SubsidyMonthlyLoop();
 	StationMonthlyLoop();
+	UpdateCargoLinks();
 #ifdef ENABLE_NETWORK
 	if (_network_server) NetworkServerMonthlyLoop();
 #endif /* ENABLE_NETWORK */
@@ -256,7 +268,7 @@
 	IndustryDailyLoop();
 
 	SetWindowWidgetDirty(WC_STATUS_BAR, 0, 0);
-	EnginesDailyLoop();
+	if (_date_fract % DAY_TICKS == 0) EnginesDailyLoop();
 
 	/* Refresh after possible snowline change */
 	SetWindowClassesDirty(WC_TOWN_VIEW);
@@ -274,7 +286,7 @@
 	if (_game_mode == GM_MENU) return;
 
 	_date_fract++;
-	if (_date_fract < DAY_TICKS) return;
+	if (_date_fract < DAY_TICKS_DAY_LENGTH)  return;
 	_date_fract = 0;
 
 	/* increase day counter */
diff -urNad openttd-1.3.2/src/date_func.h openttd-1.3.2-DC3.0RC3/src/date_func.h
--- openttd-1.3.2/src/date_func.h	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/date_func.h	2013-11-22 05:49:07.000000000 +0100
@@ -19,10 +19,14 @@
 extern Date      _date;
 extern DateFract _date_fract;
 extern uint16 _tick_counter;
+extern uint8 _tick_skip_counter;
 
 void SetDate(Date date, DateFract fract);
 void ConvertDateToYMD(Date date, YearMonthDay *ymd);
 Date ConvertYMDToDate(Year year, Month month, Day day);
+Ticks GetCurrentTickCount();
+
+#define YMD_TO_DATE(ymd) (ConvertYMDToDate(ymd.year, ymd.month, ymd.day))
 
 /**
  * Checks whether the given year is a leap year or not.
diff -urNad openttd-1.3.2/src/date_gui.cpp openttd-1.3.2-DC3.0RC3/src/date_gui.cpp
--- openttd-1.3.2/src/date_gui.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/date_gui.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -16,6 +16,7 @@
 #include "window_gui.h"
 #include "date_gui.h"
 #include "core/geometry_func.hpp"
+#include "settings_type.h"
 
 #include "widgets/dropdown_type.h"
 #include "widgets/date_widget.h"
@@ -63,7 +64,7 @@
 	 * Helper function to construct the dropdown.
 	 * @param widget the dropdown widget to create the dropdown for
 	 */
-	void ShowDateDropDown(int widget)
+	virtual void ShowDateDropDown(int widget)
 	{
 		int selected;
 		DropDownList *list = new DropDownList();
@@ -144,9 +145,8 @@
 			case WID_SD_YEAR:
 				ShowDateDropDown(widget);
 				break;
-
 			case WID_SD_SET_DATE:
-				if (this->callback != NULL) this->callback(this->parent, ConvertYMDToDate(this->date.year, this->date.month, this->date.day));
+				if (this->callback != NULL) this->callback(this->parent, ConvertYMDToDate(this->date.year, this->date.month, this->date.day) * DAY_TICKS_DAY_LENGTH);
 				delete this;
 				break;
 		}
@@ -171,6 +171,122 @@
 	}
 };
 
+struct SetMinutesWindow : SetDateWindow
+{
+	Minutes minutes;
+
+	/** Constructor. */
+	SetMinutesWindow(const WindowDesc *desc, WindowNumber window_number, Window *parent, DateTicks initial_date, Year min_year, Year max_year, SetDateCallback *callback) :
+		SetDateWindow(desc, window_number, parent, initial_date, min_year, max_year, callback),
+		minutes(initial_date / _settings_client.gui.ticks_per_minute)
+	{
+	}
+
+	/**
+	 * Helper function to construct the dropdown.
+	 * @param widget the dropdown widget to create the dropdown for
+	 */
+	virtual void ShowDateDropDown(int widget)
+	{
+		int selected;
+		DropDownList *list = new DropDownList();
+
+		switch (widget) {
+			default: NOT_REACHED();
+
+			case WID_SD_DAY:
+				for (uint i = 0; i < 60; i++) {
+					DropDownListParamStringItem *item = new DropDownListParamStringItem(STR_JUST_INT, i, false);
+					item->SetParam(0, i);
+					list->push_back(item);
+				}
+				selected = MINUTES_MINUTE(minutes);
+				break;
+
+			case WID_SD_MONTH:
+				for (uint i = 0; i < 24; i++) {
+					DropDownListParamStringItem *item = new DropDownListParamStringItem(STR_JUST_INT, i, false);
+					item->SetParam(0, i);
+					list->push_back(item);
+				}
+				selected = MINUTES_HOUR(minutes);
+
+				break;
+		}
+
+		ShowDropDownList(this, list, selected, widget);
+	}
+
+	virtual void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize)
+	{
+		Dimension d = {0, 0};
+		switch (widget) {
+			default: return;
+
+			case WID_SD_DAY:
+				for (uint i = 0; i < 60; i++) {
+					SetDParam(0, i);
+					d = maxdim(d, GetStringBoundingBox(STR_JUST_INT));
+				}
+				break;
+
+			case WID_SD_MONTH:
+				for (uint i = 0; i < 24; i++) {
+					SetDParam(0, i);
+					d = maxdim(d, GetStringBoundingBox(STR_JUST_INT));
+				}
+				break;
+		}
+
+		d.width += padding.width;
+		d.height += padding.height;
+		*size = d;
+	}
+
+	virtual void SetStringParameters(int widget) const
+	{
+		switch (widget) {
+			case WID_SD_DAY:   SetDParam(0, MINUTES_MINUTE(minutes)); break;
+			case WID_SD_MONTH: SetDParam(0, MINUTES_HOUR(minutes)); break;
+		}
+	}
+
+	virtual void OnClick(Point pt, int widget, int click_count)
+	{
+		switch (widget) {
+			case WID_SD_DAY:
+			case WID_SD_MONTH:
+			case WID_SD_YEAR:
+				ShowDateDropDown(widget);
+				break;
+
+			case WID_SD_SET_DATE:
+				if (this->callback != NULL) this->callback(this->parent, ((DateTicks)minutes - _settings_client.gui.clock_offset) * _settings_client.gui.ticks_per_minute);
+				delete this;
+				break;
+		}
+	}
+
+	virtual void OnDropdownSelect(int widget, int index)
+	{
+		Minutes current = 0;
+		switch (widget) {
+			case WID_SD_DAY:
+				current = MINUTES_DATE(MINUTES_DAY(CURRENT_MINUTE), MINUTES_HOUR(minutes), index);
+				break;
+
+			case WID_SD_MONTH:
+				current = MINUTES_DATE(MINUTES_DAY(CURRENT_MINUTE), index, MINUTES_MINUTE(minutes));
+				break;
+		}
+
+		if (current < (CURRENT_MINUTE - 60)) current += 60 * 24;
+		minutes = current;
+
+		this->SetDirty();
+	}
+};
+
 /** Widgets for the date setting window. */
 static const NWidgetPart _nested_set_date_widgets[] = {
 	NWidget(NWID_HORIZONTAL),
@@ -193,6 +309,26 @@
 	EndContainer()
 };
 
+static const NWidgetPart _nested_set_minutes_widgets[] = {
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_CLOSEBOX, COLOUR_BROWN),
+		NWidget(WWT_CAPTION, COLOUR_BROWN), SetDataTip(STR_DATE_CAPTION, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+	EndContainer(),
+	NWidget(WWT_PANEL, COLOUR_BROWN),
+		NWidget(NWID_VERTICAL), SetPIP(6, 6, 6),
+			NWidget(NWID_HORIZONTAL, NC_EQUALSIZE), SetPIP(6, 6, 6),
+				NWidget(WWT_DROPDOWN, COLOUR_ORANGE, WID_SD_MONTH), SetFill(1, 0), SetDataTip(STR_JUST_INT, STR_DATE_MINUTES_MONTH_TOOLTIP),
+				NWidget(WWT_DROPDOWN, COLOUR_ORANGE, WID_SD_DAY), SetFill(1, 0), SetDataTip(STR_JUST_INT, STR_DATE_MINUTES_DAY_TOOLTIP),
+			EndContainer(),
+			NWidget(NWID_HORIZONTAL),
+				NWidget(NWID_SPACER), SetFill(1, 0),
+				NWidget(WWT_PUSHTXTBTN, COLOUR_BROWN, WID_SD_SET_DATE), SetMinimalSize(100, 12), SetDataTip(STR_DATE_SET_DATE, STR_DATE_SET_DATE_TOOLTIP),
+				NWidget(NWID_SPACER), SetFill(1, 0),
+			EndContainer(),
+		EndContainer(),
+	EndContainer()
+};
+
 /** Description of the date setting window. */
 static const WindowDesc _set_date_desc(
 	WDP_CENTER, 0, 0,
@@ -201,6 +337,13 @@
 	_nested_set_date_widgets, lengthof(_nested_set_date_widgets)
 );
 
+static const WindowDesc _set_minutes_desc(
+	WDP_CENTER, 0, 0,
+	WC_SET_DATE, WC_NONE,
+	0,
+	_nested_set_minutes_widgets, lengthof(_nested_set_minutes_widgets)
+);
+
 /**
  * Create the new 'set date' window
  * @param window_number number for the window
@@ -210,8 +353,13 @@
  * @param max_year the maximum year (inclusive) to show in the year dropdown
  * @param callback the callback to call once a date has been selected
  */
-void ShowSetDateWindow(Window *parent, int window_number, Date initial_date, Year min_year, Year max_year, SetDateCallback *callback)
+void ShowSetDateWindow(Window *parent, int window_number, DateTicks initial_date, Year min_year, Year max_year, SetDateCallback *callback)
 {
 	DeleteWindowByClass(WC_SET_DATE);
-	new SetDateWindow(&_set_date_desc, window_number, parent, initial_date, min_year, max_year, callback);
+
+	if (!_settings_client.gui.time_in_minutes) {
+		new SetDateWindow(&_set_date_desc, window_number, parent, initial_date / DAY_TICKS_DAY_LENGTH, min_year, max_year, callback);
+	} else {
+		new SetMinutesWindow(&_set_minutes_desc, window_number, parent, initial_date + (_settings_client.gui.clock_offset * _settings_client.gui.ticks_per_minute), min_year, max_year, callback);
+	}
 }
diff -urNad openttd-1.3.2/src/date_gui.h openttd-1.3.2-DC3.0RC3/src/date_gui.h
--- openttd-1.3.2/src/date_gui.h	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/date_gui.h	2013-11-22 05:49:07.000000000 +0100
@@ -20,8 +20,8 @@
  * @param w the window that sends the callback
  * @param date the date that has been chosen
  */
-typedef void SetDateCallback(const Window *w, Date date);
+typedef void SetDateCallback(const Window *w, DateTicks date);
 
-void ShowSetDateWindow(Window *parent, int window_number, Date initial_date, Year min_year, Year max_year, SetDateCallback *callback);
+void ShowSetDateWindow(Window *parent, int window_number, DateTicks initial_date, Year min_year, Year max_year, SetDateCallback *callback);
 
 #endif /* DATE_GUI_H */
diff -urNad openttd-1.3.2/src/date_type.h openttd-1.3.2-DC3.0RC3/src/date_type.h
--- openttd-1.3.2/src/date_type.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/date_type.h	2013-11-22 05:49:07.000000000 +0100
@@ -12,15 +12,18 @@
 #ifndef DATE_TYPE_H
 #define DATE_TYPE_H
 
-
 typedef int32  Date;      ///< The type to store our dates in
 typedef uint16 DateFract; ///< The fraction of a date we're in, i.e. the number of ticks since the last date changeover
 typedef int32  Ticks;     ///< The type to store ticks in
+typedef int64 DateTicks;  ///< The type to store dates in when tick-precision is required
+typedef int32  Minutes;   ///< The type to store minutes in
 
 typedef int32  Year;  ///< Type for the year, note: 0 based, i.e. starts at the year 0.
 typedef uint8  Month; ///< Type for the month, note: 0 based, i.e. 0 = January, 11 = December.
 typedef uint8  Day;   ///< Type for the day of the month, note: 1 based, first day of a month is 1.
 
+#include "settings_type.h"
+
 /**
  * 1 day is 74 ticks; _date_fract used to be uint16 and incremented by 885. On
  *                    an overflow the new day begun and 65535 / 885 = 74.
@@ -31,6 +34,8 @@
 static const int DAYS_IN_YEAR      = 365; ///< days per year
 static const int DAYS_IN_LEAP_YEAR = 366; ///< sometimes, you need one day more...
 
+#define DATE_UNIT_SIZE (_settings_client.gui.time_in_minutes ? _settings_client.gui.ticks_per_minute : DAY_TICKS_DAY_LENGTH)
+
 static const int STATION_RATING_TICKS     = 185; ///< cycle duration for updating station rating
 static const int STATION_ACCEPTANCE_TICKS = 250; ///< cycle duration for updating station acceptance
 static const int CARGO_AGING_TICKS        = 185; ///< cycle duration for aging cargo
@@ -38,6 +43,7 @@
 static const int TOWN_GROWTH_TICKS        = 70;  ///< cycle duration for towns trying to grow. (this originates from the size of the town array in TTD
 static const int INDUSTRY_CUT_TREE_TICKS  = INDUSTRY_PRODUCE_TICKS * 2; ///< cycle duration for lumber mill's extra action
 
+#define DAY_TICKS_DAY_LENGTH (DAY_TICKS * _settings_game.economy.day_length_factor) ///< ticks per day with day length
 
 /*
  * ORIGINAL_BASE_YEAR, ORIGINAL_MAX_YEAR and DAYS_TILL_ORIGINAL_BASE_YEAR are
@@ -95,6 +101,21 @@
 /** The number of days till the last day */
 #define MAX_DAY (DAYS_TILL(MAX_YEAR + 1) - 1)
 
+/** The day when converting to minutes */
+#define MINUTES_DAY(minutes) (minutes / 1440)
+
+/** The hour when converting to minutes */
+#define MINUTES_HOUR(minutes) ((minutes / 60) % 24)
+
+/** The day when converting to minutes */
+#define MINUTES_MINUTE(minutes) (minutes % 60)
+
+/** Convert minutes to a date */
+#define MINUTES_DATE(day, hour, minute) ((day * 1440) + (hour * 60) + minute)
+
+/** Get the current date in minutes */
+#define CURRENT_MINUTE ((((DateTicks)_date * DAY_TICKS_DAY_LENGTH) + _date_fract) / _settings_client.gui.ticks_per_minute)
+
 /**
  * Data structure to convert between Date and triplet (year, month, and day).
  * @see ConvertDateToYMD(), ConvertYMDToDate()
diff -urNad openttd-1.3.2/src/debug.cpp openttd-1.3.2-DC3.0RC3/src/debug.cpp
--- openttd-1.3.2/src/debug.cpp	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/debug.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -39,6 +39,7 @@
 int _debug_gamelog_level;
 int _debug_desync_level;
 int _debug_console_level;
+int _debug_cargodest_level;
 #ifdef RANDOM_DEBUG
 int _debug_random_level;
 #endif
@@ -67,6 +68,7 @@
 	DEBUG_LEVEL(gamelog),
 	DEBUG_LEVEL(desync),
 	DEBUG_LEVEL(console),
+	DEBUG_LEVEL(cargodest),
 #ifdef RANDOM_DEBUG
 	DEBUG_LEVEL(random),
 #endif
diff -urNad openttd-1.3.2/src/debug.h openttd-1.3.2-DC3.0RC3/src/debug.h
--- openttd-1.3.2/src/debug.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/debug.h	2013-11-22 05:49:07.000000000 +0100
@@ -51,6 +51,7 @@
 	extern int _debug_gamelog_level;
 	extern int _debug_desync_level;
 	extern int _debug_console_level;
+	extern int _debug_cargodest_level;
 #ifdef RANDOM_DEBUG
 	extern int _debug_random_level;
 #endif
diff -urNad openttd-1.3.2/src/departures.cpp openttd-1.3.2-DC3.0RC3/src/departures.cpp
--- openttd-1.3.2/src/departures.cpp	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/departures.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -0,0 +1,646 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file departures.cpp Scheduled departures from a station. */
+
+#include "stdafx.h"
+#include "debug.h"
+#include "gui.h"
+#include "textbuf_gui.h"
+#include "strings_func.h"
+#include "window_func.h"
+#include "vehicle_func.h"
+#include "string_func.h"
+#include "window_gui.h"
+#include "timetable.h"
+#include "vehiclelist.h"
+#include "company_base.h"
+#include "date_func.h"
+#include "departures_gui.h"
+#include "station_base.h"
+#include "vehicle_gui_base.h"
+#include "vehicle_base.h"
+#include "vehicle_gui.h"
+#include "order_base.h"
+#include "settings_type.h"
+#include "core/smallvec_type.hpp"
+#include "date_type.h"
+#include "company_type.h"
+#include "cargo_type.h"
+#include "departures_func.h"
+#include "departures_type.h"
+
+/** A scheduled order. */
+typedef struct OrderDate
+{
+	const Order *order;     ///< The order
+	const Vehicle *v;       ///< The vehicle carrying out the order
+	DateTicks expected_date;///< The date on which the order is expected to complete
+	Ticks lateness;         ///< How late this order is expected to finish
+	DepartureStatus status; ///< Whether the vehicle has arrived to carry out the order yet
+} OrderDate;
+
+static bool IsDeparture(const Order *order, StationID station) {
+	return (order->GetType() == OT_GOTO_STATION &&
+			(StationID)order->GetDestination() == station &&
+			(order->GetLoadType() != OLFB_NO_LOAD ||
+			_settings_client.gui.departure_show_all_stops) &&
+			order->wait_time != 0);
+}
+
+static bool IsVia(const Order *order, StationID station) {
+	return ((order->GetType() == OT_GOTO_STATION ||
+			order->GetType() == OT_GOTO_WAYPOINT) &&
+			(StationID)order->GetDestination() == station &&
+			(order->GetNonStopType() == ONSF_NO_STOP_AT_ANY_STATION ||
+			order->GetNonStopType() == ONSF_NO_STOP_AT_DESTINATION_STATION));
+}
+
+static bool IsArrival(const Order *order, StationID station) {
+	return (order->GetType() == OT_GOTO_STATION &&
+			(StationID)order->GetDestination() == station &&
+			(order->GetUnloadType() != OUFB_NO_UNLOAD ||
+			_settings_client.gui.departure_show_all_stops) &&
+			order->wait_time != 0);
+}
+
+/**
+ * Compute an up-to-date list of departures for a station.
+ * @param station the station to compute the departures of
+ * @param show_vehicle_types the types of vehicles to include in the departure list
+ * @param type the type of departures to get (departures or arrivals)
+ * @param show_vehicles_via whether to include vehicles that have this station in their orders but do not stop at it
+ * @return a list of departures, which is empty if an error occurred
+ */
+DepartureList* MakeDepartureList(StationID station, bool show_vehicle_types[5], DepartureType type, bool show_vehicles_via)
+{
+	/* This function is the meat of the departure boards functionality. */
+	/* As an overview, it works by repeatedly considering the best possible next departure to show. */
+	/* By best possible we mean the one expected to arrive at the station first. */
+	/* However, we do not consider departures whose scheduled time is too far in the future, even if they are expected before some delayed ones. */
+	/* This code can probably be made more efficient. I haven't done so in order to keep both its (relative) simplicity and my (relative) sanity. */
+	/* Having written that, it's not exactly slow at the moment. */
+
+	/* The list of departures which will be returned as a result. */
+	SmallVector<Departure*, 32> *result = new SmallVector<Departure*, 32>();
+
+	/* A list of the next scheduled orders to be considered for inclusion in the departure list. */
+	SmallVector<OrderDate*, 32> next_orders;
+
+	/* The maximum possible date for departures to be scheduled to occur. */
+	DateTicks max_date = _settings_client.gui.max_departure_time * DAY_TICKS;
+
+	/* The scheduled order in next_orders with the earliest expected_date field. */
+	OrderDate *least_order = NULL;
+
+	/* Get all the vehicles stopping at this station. */
+	/* We do this to get the order which is the first time they will stop at this station. */
+	/* This order is stored along with some more information. */
+	/* We keep a pointer to the `least' order (the one with the soonest expected completion time). */
+	for (uint i = 0; i < 4; ++i) {
+		VehicleList vehicles;
+
+		if (!show_vehicle_types[i]) {
+			/* Don't show vehicles whose type we're not interested in. */
+			continue;
+		}
+
+        /* MAX_COMPANIES is probably the wrong thing to put here, but it works. GenerateVehicleSortList doesn't check the company when the type of list is VL_STATION_LIST (r20801). */
+		if (!GenerateVehicleSortList(&vehicles, VehicleListIdentifier(VL_STATION_LIST, (VehicleType)(VEH_TRAIN + i), MAX_COMPANIES, station).Pack())) {
+			/* Something went wrong: panic! */
+			return result;
+		}
+
+		/* Get the first order for each vehicle for the station we're interested in that doesn't have No Loading set. */
+		/* We find the least order while we're at it. */
+		for (const Vehicle **v = vehicles.Begin(); v != vehicles.End(); v++) {
+			if (_settings_client.gui.departure_only_passengers) {
+				bool carries_passengers = false;
+
+				const Vehicle *u = *v;
+				while (u != NULL) {
+					if (u->cargo_type == CT_PASSENGERS && u->cargo_cap > 0) {
+						carries_passengers = true;
+						break;
+					}
+					u = u->Next();
+				}
+
+				if (carries_passengers == false) {
+					continue;
+				}
+			}
+
+			const Order *order = (*v)->GetOrder((*v)->cur_implicit_order_index % (*v)->GetNumOrders());
+			DateTicks start_date = (DateTicks)_date_fract - (*v)->current_order_time;
+			DepartureStatus status = D_TRAVELLING;
+
+			/* If the vehicle is stopped in a depot, ignore it. */
+			if ((*v)->IsStoppedInDepot()) {
+				continue;
+			}
+
+			/* If the vehicle is heading for a depot to stop there, then its departures are cancelled. */
+			if ((*v)->current_order.IsType(OT_GOTO_DEPOT) && (*v)->current_order.GetDepotActionType() & ODATFB_HALT) {
+				status = D_CANCELLED;
+			}
+
+			if ((*v)->current_order.IsType(OT_LOADING)) {
+				/* Account for the vehicle having reached the current order and being in the loading phase. */
+				status = D_ARRIVED;
+				start_date -= order->travel_time + (((*v)->lateness_counter < 0) ? (*v)->lateness_counter : 0);
+			}
+
+			/* Loop through the vehicle's orders until we've found a suitable order or we've determined that no such order exists. */
+			/* We only need to consider each order at most once. */
+			bool foundOrder = false;
+			for (int i = (*v)->GetNumOrders(); i > 0; --i) {
+				start_date += order->travel_time + order->wait_time;
+
+				/* If the scheduled departure date is too far in the future, stop. */
+				if (start_date - (*v)->lateness_counter > max_date) {
+					break;
+				}
+
+				/* If the order is a conditional branch, handle it. */
+				if (order->IsType(OT_CONDITIONAL)) {
+					switch(_settings_client.gui.departure_conditionals) {
+							case 0: {
+								/* Give up */
+								break;
+							}
+							case 1: {
+								/* Take the branch */
+								if (status != D_CANCELLED) {
+									status = D_TRAVELLING;
+								}
+								order = (*v)->GetOrder(order->GetConditionSkipToOrder());
+								if (order == NULL) {
+									break;
+								}
+
+								start_date -= order->travel_time;
+
+								continue;
+							}
+							case 2: {
+								/* Do not take the branch */
+								if (status != D_CANCELLED) {
+									status = D_TRAVELLING;
+								}
+								order = (order->next == NULL) ? (*v)->GetFirstOrder() : order->next;
+								continue;
+							}
+					}
+				}
+
+				/* Skip it if it's an automatic order. */
+				if (order->IsType(OT_IMPLICIT)) {
+					order = (order->next == NULL) ? (*v)->GetFirstOrder() : order->next;
+					continue;
+				}
+
+				/* If an order doesn't have a travel time set, then stop. */
+				if (order->travel_time == 0) {
+					break;
+				}
+
+				/* If the vehicle will be stopping at and loading from this station, and its wait time is not zero, then it is a departure. */
+				/* If the vehicle will be stopping at and unloading at this station, and its wait time is not zero, then it is an arrival. */
+				if ((type == D_DEPARTURE && IsDeparture(order, station)) ||
+						(type == D_DEPARTURE && show_vehicles_via && IsVia(order, station)) ||
+						(type == D_ARRIVAL && IsArrival(order, station))) {
+					/* If the departure was scheduled to have already begun and has been cancelled, do not show it. */
+					if (start_date < 0 && status == D_CANCELLED) {
+						break;
+					}
+
+					OrderDate *od = new OrderDate();
+					od->order = order;
+					od->v = *v;
+					/* We store the expected date for now, so that vehicles will be shown in order of expected time. */
+					od->expected_date = start_date;
+					od->lateness = (*v)->lateness_counter > 0 ? (*v)->lateness_counter : 0;
+					od->status = status;
+
+					/* If we are early, use the scheduled date as the expected date. We also take lateness to be zero. */
+					if ((*v)->lateness_counter < 0 && !(*v)->current_order.IsType(OT_LOADING)) {
+						od->expected_date -= (*v)->lateness_counter;
+					}
+
+					/* Update least_order if this is the current least order. */
+					if (least_order == NULL) {
+						least_order = od;
+					} else if (least_order->expected_date - least_order->lateness - (type == D_ARRIVAL ? least_order->order->wait_time : 0) > od->expected_date - od->lateness - (type == D_ARRIVAL ? od->order->wait_time : 0)) {
+						least_order = od;
+					}
+
+					*(next_orders.Append(1)) = od;
+
+					foundOrder = true;
+					/* We're done with this vehicle. */
+					break;
+				} else {
+					/* Go to the next order in the list. */
+					if (status != D_CANCELLED) {
+						status = D_TRAVELLING;
+					}
+					order = (order->next == NULL) ? (*v)->GetFirstOrder() : order->next;
+				}
+			}
+		}
+	}
+
+	/* No suitable orders found? Then stop. */
+	if (next_orders.Length() == 0) {
+		return result;
+	}
+
+	/* We now find as many departures as we can. It's a little involved so I'll try to explain each major step. */
+	/* The countdown from 10000 is a safeguard just in case something nasty happens. 10000 seemed large enough. */
+	for(int i = 10000; i > 0; --i) {
+		/* I should probably try to convince you that this loop always terminates regardless of the safeguard. */
+		/* 1. next_orders contains at least one element. */
+		/* 2. The loop terminates if result->Length() exceeds a fixed (for this loop) value, or if the least order's scheduled date is later than max_date. */
+		/*    (We ignore the case that the least order's scheduled date has overflown, as it is a relative rather than absolute date.) */
+		/* 3. Every time we loop round, either result->Length() will have increased -OR- we will have increased the expected_date of one of the elements of next_orders. */
+		/* 4. Therefore the loop must eventually terminate. */
+
+		/* least_order is the best candidate for the next departure. */
+
+		/* First, we check if we can stop looking for departures yet. */
+		if (result->Length() >= _settings_client.gui.max_departures ||
+				least_order->expected_date - least_order->lateness > max_date) {
+			break;
+		}
+
+		/* We already know the least order and that it's a suitable departure, so make it into a departure. */
+		Departure *d = new Departure();
+		d->scheduled_date = (DateTicks)_date * DAY_TICKS + least_order->expected_date - least_order->lateness;
+		d->lateness = least_order->lateness;
+		d->status = least_order->status;
+		d->vehicle = least_order->v;
+		d->type = type;
+		d->order = least_order->order;
+
+		/* We'll be going through the order list later, so we need a separate variable for it. */
+		const Order *order = least_order->order;
+
+		if (type == D_ARRIVAL) {
+			/* Computing departures: */
+			/* We want to find out where it will terminate, making a list of the stations it calls at along the way. */
+			/* We only count stations where unloading happens as being called at - i.e. pickup-only stations are ignored. */
+			/* Where the vehicle terminates is defined as the last unique station called at by the vehicle from the current order. */
+
+			/* If the vehicle loops round to the current order without a terminus being found, then it terminates upon reaching its current order again. */
+
+			/* We also determine which station this departure is going via, if any. */
+			/* A departure goes via a station if it is the first station for which the vehicle has an order to go via or non-stop via. */
+			/* Multiple departures on the same journey may go via different stations. That a departure can go via at most one station is intentional. */
+
+			/* We keep track of potential via stations along the way. If we call at a station immediately after going via it, then it is the via station. */
+			StationID candidate_via = INVALID_STATION;
+
+			/* Go through the order list, looping if necessary, to find a terminus. */
+			/* Get the next order, which may be the vehicle's first order. */
+			order = (order->next == NULL) ? least_order->v->GetFirstOrder() : order->next;
+			/* We only need to consider each order at most once. */
+			bool found_terminus = false;
+			CallAt c = CallAt((StationID)order->GetDestination(), d->scheduled_date);
+			for (int i = least_order->v->GetNumOrders(); i > 0; --i) {
+				/* If we reach the order at which the departure occurs again, then use the departure station as the terminus. */
+				if (order == least_order->order) {
+					/* If we're not calling anywhere, then skip this departure. */
+					found_terminus = (d->calling_at.Length() > 0);
+					break;
+				}
+
+				/* If the order is a conditional branch, handle it. */
+				if (order->IsType(OT_CONDITIONAL)) {
+					switch(_settings_client.gui.departure_conditionals) {
+							case 0: {
+								/* Give up */
+								break;
+							}
+							case 1: {
+								/* Take the branch */
+								order = least_order->v->GetOrder(order->GetConditionSkipToOrder());
+								if (order == NULL) {
+									break;
+								}
+								continue;
+							}
+							case 2: {
+								/* Do not take the branch */
+								order = (order->next == NULL) ? least_order->v->GetFirstOrder() : order->next;
+								continue;
+							}
+					}
+				}
+
+				/* If we reach the original station again, then use it as the terminus. */
+				if (order->GetType() == OT_GOTO_STATION &&
+						(StationID)order->GetDestination() == station &&
+						(order->GetUnloadType() != OUFB_NO_UNLOAD ||
+						_settings_client.gui.departure_show_all_stops) &&
+						order->GetNonStopType() != ONSF_NO_STOP_AT_ANY_STATION &&
+						order->GetNonStopType() != ONSF_NO_STOP_AT_DESTINATION_STATION) {
+					/* If we're not calling anywhere, then skip this departure. */
+					found_terminus = (d->calling_at.Length() > 0);
+					break;
+				}
+
+				/* Check if we're going via this station. */
+				if ((order->GetNonStopType() == ONSF_NO_STOP_AT_ANY_STATION ||
+						order->GetNonStopType() == ONSF_NO_STOP_AT_DESTINATION_STATION) &&
+						order->GetType() == OT_GOTO_STATION &&
+						d->via == INVALID_STATION) {
+					candidate_via = (StationID)order->GetDestination();
+				}
+
+				if (c.scheduled_date != 0 && order->travel_time != 0) {
+					c.scheduled_date += order->travel_time;
+				} else {
+					c.scheduled_date = 0;
+				}
+
+				c.station = (StationID)order->GetDestination();
+
+				/* We're not interested in this order any further if we're not calling at it. */
+				if ((order->GetUnloadType() == OUFB_NO_UNLOAD &&
+						!_settings_client.gui.departure_show_all_stops) ||
+						(order->GetType() != OT_GOTO_STATION &&
+						order->GetType() != OT_IMPLICIT) ||
+						order->GetNonStopType() == ONSF_NO_STOP_AT_ANY_STATION ||
+						order->GetNonStopType() == ONSF_NO_STOP_AT_DESTINATION_STATION) {
+					c.scheduled_date += order->wait_time;
+					order = (order->next == NULL) ? least_order->v->GetFirstOrder() : order->next;
+					continue;
+				}
+
+				/* If this order's station is already in the calling, then the previous called at station is the terminus. */
+				if (d->calling_at.Contains(c)) {
+					found_terminus = true;
+					break;
+				}
+
+				/* If appropriate, add the station to the calling at list and make it the candidate terminus. */
+				if ((order->GetType() == OT_GOTO_STATION ||
+						order->GetType() == OT_IMPLICIT) &&
+						order->GetNonStopType() != ONSF_NO_STOP_AT_ANY_STATION &&
+						order->GetNonStopType() != ONSF_NO_STOP_AT_DESTINATION_STATION) {
+					if (d->via == INVALID_STATION && candidate_via == (StationID)order->GetDestination()) {
+						d->via = (StationID)order->GetDestination();
+					}
+					d->terminus = c;
+					*(d->calling_at.Append(1)) = c;
+				}
+
+				/* If we unload all at this station, then it is the terminus. */
+				if (order->GetType() == OT_GOTO_STATION &&
+						order->GetUnloadType() == OUFB_UNLOAD) {
+					if (d->calling_at.Length() > 0) {
+						found_terminus = true;
+					}
+					break;
+				}
+
+				c.scheduled_date += order->wait_time;
+
+				/* Get the next order, which may be the vehicle's first order. */
+				order = (order->next == NULL) ? least_order->v->GetFirstOrder() : order->next;
+			}
+
+			if (found_terminus) {
+				/* Add the departure to the result list. */
+                bool duplicate = false;
+
+                if (_settings_client.gui.departure_merge_identical) {
+                    for (uint i = 0; i < result->Length(); ++i) {
+                        if (*d == **(result->Get(i))) {
+                            duplicate = true;
+                            break;
+                        }
+                    }
+                }
+
+                if (!duplicate) {
+                    *(result->Append(1)) = d;
+
+                    if (_settings_client.gui.departure_smart_terminus && type == D_DEPARTURE) {
+                        for (uint i = 0; i < result->Length()-1; ++i) {
+                            Departure *d_first = *(result->Get(i));
+                            uint k = d_first->calling_at.Length()-2;
+                            for (uint j = d->calling_at.Length(); j > 0; --j) {
+                                CallAt c = CallAt(*(d->calling_at.Get(j-1)));
+
+                                if (d_first->terminus >= c && d_first->calling_at.Length() >= 2) {
+                                    d_first->terminus = CallAt(*(d_first->calling_at.Get(k)));
+
+                                    if (k == 0) break;
+
+                                    k--;
+                                }
+                            }
+                        }
+                    }
+
+                    /* If the vehicle is expected to be late, we want to know what time it will arrive rather than depart. */
+                    /* This is done because it looked silly to me to have a vehicle not be expected for another few days, yet it be at the same time pulling into the station. */
+                    if (d->status != D_ARRIVED &&
+                            d->lateness > 0) {
+                        d->lateness -= least_order->order->wait_time;
+                    }
+                }
+			}
+		} else {
+			/* Computing arrivals: */
+			/* First we need to find the origin of the order. This is somewhat like finding a terminus, but a little more involved since order lists are singly linked. */
+			/* The next stage is simpler. We just need to add all the stations called at on the way to the current station. */
+			/* Again, we define a station as being called at if the vehicle loads from it. */
+
+			/* However, the very first thing we do is use the arrival time as the scheduled time instead of the departure time. */
+			d->scheduled_date -= order->wait_time;
+
+			const Order *candidate_origin = (order->next == NULL) ? least_order->v->GetFirstOrder() : order->next;
+			bool found_origin = false;
+
+			while (candidate_origin != least_order->order) {
+				if ((candidate_origin->GetLoadType() != OLFB_NO_LOAD ||
+						_settings_client.gui.departure_show_all_stops) &&
+						(candidate_origin->GetType() == OT_GOTO_STATION ||
+						candidate_origin->GetType() == OT_IMPLICIT) &&
+						candidate_origin->GetDestination() != station) {
+					const Order *o = (candidate_origin->next == NULL) ? least_order->v->GetFirstOrder() : candidate_origin->next;
+					bool found_collision = false;
+
+					/* Check if the candidate origin's destination appears again before the original order or the station does. */
+					while (o != least_order->order) {
+						if (o->GetUnloadType() == OUFB_UNLOAD) {
+							found_collision = true;
+							break;
+						}
+
+						if ((o->GetType() == OT_GOTO_STATION ||
+								o->GetType() == OT_IMPLICIT) &&
+								(o->GetDestination() == candidate_origin->GetDestination() ||
+								o->GetDestination() == station)) {
+							found_collision = true;
+							break;
+						}
+
+						o = (o->next == NULL) ? least_order->v->GetFirstOrder() : o->next;
+					}
+
+					/* If it doesn't, then we have found the origin. */
+					if (!found_collision) {
+						found_origin = true;
+						break;
+					}
+				}
+
+				candidate_origin = (candidate_origin->next == NULL) ? least_order->v->GetFirstOrder() : candidate_origin->next;
+			}
+
+			order = (candidate_origin->next == NULL) ? least_order->v->GetFirstOrder() : candidate_origin->next;
+
+			while (order != least_order->order) {
+				if (order->GetType() == OT_GOTO_STATION &&
+						(order->GetLoadType() != OLFB_NO_LOAD ||
+						_settings_client.gui.departure_show_all_stops)) {
+					*(d->calling_at.Append(1)) = CallAt((StationID)order->GetDestination());
+				}
+
+				order = (order->next == NULL) ? least_order->v->GetFirstOrder() : order->next;
+			}
+
+			d->terminus = CallAt((StationID)candidate_origin->GetDestination());
+
+			if (found_origin) {
+                bool duplicate = false;
+
+                if (_settings_client.gui.departure_merge_identical) {
+                    for (uint i = 0; i < result->Length(); ++i) {
+                        if (*d == **(result->Get(i))) {
+                            duplicate = true;
+                            break;
+                        }
+                    }
+                }
+
+                if (!duplicate) {
+                    *(result->Append(1)) = d;
+                }
+			}
+		}
+
+		/* Save on pointer dereferences in the coming loop. */
+		order = least_order->order;
+
+		/* Now we find the next suitable order for being a departure for this vehicle. */
+		/* We do this in a similar way to finding the first suitable order for the vehicle. */
+
+		/* Go to the next order so we don't add the current order again. */
+		order = (order->next == NULL) ? least_order->v->GetFirstOrder() : order->next;
+		least_order->expected_date += order->travel_time + order->wait_time;
+
+		/* Go through the order list to find the next candidate departure. */
+		/* We only need to consider each order at most once. */
+		bool found_next_order = false;
+		for (int i = least_order->v->GetNumOrders(); i > 0; --i) {
+			/* If the order is a conditional branch, handle it. */
+			if (order->IsType(OT_CONDITIONAL)) {
+				switch(_settings_client.gui.departure_conditionals) {
+						case 0: {
+							/* Give up */
+							break;
+						}
+						case 1: {
+							/* Take the branch */
+							order = least_order->v->GetOrder(order->GetConditionSkipToOrder());
+							if (order == NULL) {
+								break;
+							}
+
+							least_order->expected_date += order->wait_time;
+
+							continue;
+						}
+						case 2: {
+							/* Do not take the branch */
+							order = (order->next == NULL) ? least_order->v->GetFirstOrder() : order->next;
+							least_order->expected_date += order->travel_time + order->wait_time;
+							continue;
+						}
+				}
+			}
+
+			/* Skip it if it's an automatic order. */
+			if (order->IsType(OT_IMPLICIT)) {
+				order = (order->next == NULL) ? least_order->v->GetFirstOrder() : order->next;
+				continue;
+			}
+
+			/* If an order doesn't have a travel time set, then stop. */
+			if (order->travel_time == 0) {
+				break;
+			}
+
+			/* If the departure is scheduled to be too late, then stop. */
+			if (least_order->expected_date - least_order->lateness > max_date) {
+				break;
+			}
+
+			/* If the order loads from this station (or unloads if we're computing arrivals) and has a wait time set, then it is suitable for being a departure. */
+			if ((type == D_DEPARTURE && IsDeparture(order, station)) ||
+						(type == D_DEPARTURE && show_vehicles_via && IsVia(order, station)) ||
+						(type == D_ARRIVAL && IsArrival(order, station))) {
+				least_order->order = order;
+				found_next_order = true;
+				break;
+			}
+
+			order = (order->next == NULL) ? least_order->v->GetFirstOrder() : order->next;
+			least_order->expected_date += order->travel_time + order->wait_time;
+		}
+
+		/* If we didn't find a suitable order for being a departure, then we can ignore this vehicle from now on. */
+		if (!found_next_order) {
+			/* Make sure we don't try to get departures out of this order. */
+			/* This is cheaper than deleting it from next_orders. */
+			/* If we ever get to a state where _date * DAY_TICKS is close to INT_MAX, then we'll have other problems anyway as departures' scheduled dates will wrap around. */
+			least_order->expected_date = INT64_MAX;
+		}
+
+		/* The vehicle can't possibly have arrived at its next candidate departure yet. */
+		if (least_order->status == D_ARRIVED) {
+			least_order->status = D_TRAVELLING;
+		}
+
+		/* Find the new least order. */
+		for (uint i = 0; i < next_orders.Length(); ++i) {
+			OrderDate *od = *(next_orders.Get(i));
+
+			DateTicks lod = least_order->expected_date - least_order->lateness;
+			DateTicks odd = od->expected_date - od->lateness;
+
+			if (type == D_ARRIVAL) {
+				lod -= least_order->order->wait_time;
+				odd -= od->order->wait_time;
+			}
+
+			if (lod > odd && od->expected_date - od->lateness < max_date) {
+				least_order = od;
+			}
+		}
+	}
+
+	/* Done. Phew! */
+	return result;
+}
diff -urNad openttd-1.3.2/src/departures_func.h openttd-1.3.2-DC3.0RC3/src/departures_func.h
--- openttd-1.3.2/src/departures_func.h	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/departures_func.h	2013-11-22 05:49:07.000000000 +0100
@@ -0,0 +1,21 @@
+/* $Id: departures_func.h $ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file departures_func.h Functions related to departures. */
+
+#ifndef DEPARTURES_FUNC_H
+#define DEPARTURES_FUNC_H
+
+#include "station_base.h"
+#include "core/smallvec_type.hpp"
+#include "departures_type.h"
+
+DepartureList* MakeDepartureList(StationID station, bool show_vehicle_types[4], DepartureType type = D_DEPARTURE, bool show_vehicles_via = false);
+
+#endif /* DEPARTURES_FUNC_H */
diff -urNad openttd-1.3.2/src/departures_gui.cpp openttd-1.3.2-DC3.0RC3/src/departures_gui.cpp
--- openttd-1.3.2/src/departures_gui.cpp	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/departures_gui.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -0,0 +1,859 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file departures_gui.cpp Scheduled departures from a station. */
+
+#include "stdafx.h"
+#include "debug.h"
+#include "gui.h"
+#include "textbuf_gui.h"
+#include "strings_func.h"
+#include "window_func.h"
+#include "vehicle_func.h"
+#include "string_func.h"
+#include "window_gui.h"
+#include "timetable.h"
+#include "vehiclelist.h"
+#include "company_base.h"
+#include "date_func.h"
+#include "departures_gui.h"
+#include "station_base.h"
+#include "vehicle_gui_base.h"
+#include "vehicle_base.h"
+#include "vehicle_gui.h"
+#include "order_base.h"
+#include "settings_type.h"
+#include "core/smallvec_type.hpp"
+#include "date_type.h"
+#include "company_type.h"
+#include "departures_func.h"
+#include "cargotype.h"
+
+#include "table/sprites.h"
+#include "table/strings.h"
+
+static const NWidgetPart _nested_departures_list[] = {
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
+		NWidget(WWT_CAPTION, COLOUR_GREY, WID_DB_CAPTION), SetDataTip(STR_DEPARTURES_CAPTION, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_SHADEBOX, COLOUR_GREY),
+		NWidget(WWT_STICKYBOX, COLOUR_GREY),
+	EndContainer(),
+
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_MATRIX, COLOUR_GREY, WID_DB_LIST), SetMinimalSize(0, 0), SetFill(1, 0), SetResize(1, 1),
+		NWidget(NWID_VSCROLLBAR, COLOUR_GREY, WID_DB_SCROLLBAR),
+	EndContainer(),
+
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_PANEL, COLOUR_GREY), SetMinimalSize(0, 12), SetResize(1, 0), SetFill(1, 1), EndContainer(),
+		NWidget(WWT_TEXTBTN, COLOUR_GREY, WID_DB_SHOW_DEPS), SetMinimalSize(6, 12), SetFill(0, 1), SetDataTip(STR_DEPARTURES_DEPARTURES, STR_DEPARTURES_DEPARTURES_TOOLTIP),
+		NWidget(WWT_TEXTBTN, COLOUR_GREY, WID_DB_SHOW_ARRS), SetMinimalSize(6, 12), SetFill(0, 1), SetDataTip(STR_DEPARTURES_ARRIVALS, STR_DEPARTURES_ARRIVALS_TOOLTIP),
+		NWidget(WWT_TEXTBTN, COLOUR_GREY, WID_DB_SHOW_VIA), SetMinimalSize(11, 12), SetFill(0, 1), SetDataTip(STR_DEPARTURES_VIA_BUTTON, STR_DEPARTURES_VIA_TOOLTIP),
+		NWidget(WWT_TEXTBTN, COLOUR_GREY, WID_DB_SHOW_TRAINS), SetMinimalSize(14, 12), SetFill(0, 1), SetDataTip(STR_TRAIN, STR_STATION_VIEW_SCHEDULED_TRAINS_TOOLTIP),
+		NWidget(WWT_TEXTBTN, COLOUR_GREY, WID_DB_SHOW_ROADVEHS), SetMinimalSize(14, 12), SetFill(0, 1), SetDataTip(STR_LORRY, STR_STATION_VIEW_SCHEDULED_ROAD_VEHICLES_TOOLTIP),
+		NWidget(WWT_TEXTBTN, COLOUR_GREY, WID_DB_SHOW_SHIPS), SetMinimalSize(14, 12), SetFill(0, 1), SetDataTip(STR_SHIP, STR_STATION_VIEW_SCHEDULED_SHIPS_TOOLTIP),
+		NWidget(WWT_TEXTBTN, COLOUR_GREY, WID_DB_SHOW_PLANES),  SetMinimalSize(14, 12), SetFill(0, 1), SetDataTip(STR_PLANE, STR_STATION_VIEW_SCHEDULED_AIRCRAFT_TOOLTIP),
+		NWidget(WWT_RESIZEBOX, COLOUR_GREY),
+	EndContainer(),
+};
+
+static WindowDesc _departures_desc(
+	WDP_AUTO, 260, 246,
+	WC_DEPARTURES_BOARD, WC_NONE,
+	0,
+	_nested_departures_list, lengthof(_nested_departures_list)
+);
+
+static uint cached_date_width = 0;         ///< The cached maximum width required to display a date.
+static uint cached_status_width = 0;       ///< The cached maximum width required to show the status field.
+static uint cached_date_arrow_width = 0;   ///< The cached width of the red/green arrows that may be displayed alongside times.
+static bool cached_date_display_method;    ///< Whether the above cached values refers to original (d,m,y) dates or the 24h clock.
+static bool cached_arr_dep_display_method; ///< Whether to show departures and arrivals on a single line.
+
+template<bool Twaypoint = false>
+struct DeparturesWindow : public Window {
+protected:
+	StationID station;         ///< The station whose departures we're showing.
+	DepartureList *departures; ///< The current list of departures from this station.
+	DepartureList *arrivals;   ///< The current list of arrivals from this station.
+	uint entry_height;         ///< The height of an entry in the departures list.
+	uint tick_count;           ///< The number of ticks that have elapsed since the window was created. Used for scrolling text.
+	int calc_tick_countdown;   ///< The number of ticks to wait until recomputing the departure list. Signed in case it goes below zero.
+	bool show_types[4];        ///< The vehicle types to show in the departure list.
+	bool departure_types[3];   ///< The types of departure to show in the departure list.
+	uint min_width;            ///< The minimum width of this window.
+	Scrollbar *vscroll;
+
+	virtual uint GetMinWidth() const;
+	static void RecomputeDateWidth();
+	virtual void DrawDeparturesListItems(const Rect &r) const;
+	void DeleteDeparturesList(DepartureList* list);
+public:
+
+	DeparturesWindow(const WindowDesc *desc, WindowNumber window_number) : Window(),
+		station(window_number),
+		departures(new DepartureList()),
+		arrivals(new DepartureList()),
+		entry_height(1 + FONT_HEIGHT_NORMAL + 1 + (_settings_client.gui.departure_larger_font ? FONT_HEIGHT_NORMAL : FONT_HEIGHT_SMALL) + 1 + 1),
+		tick_count(0),
+		calc_tick_countdown(0),
+		min_width(400)
+	{
+		this->CreateNestedTree(desc);
+		this->vscroll = this->GetScrollbar(WID_DB_SCROLLBAR);
+		this->FinishInitNested(desc, window_number);
+
+		/* By default, only show departures. */
+		departure_types[0] = true;
+		departure_types[1] = false;
+		departure_types[2] = false;
+		this->LowerWidget(WID_DB_SHOW_DEPS);
+		this->RaiseWidget(WID_DB_SHOW_ARRS);
+		this->RaiseWidget(WID_DB_SHOW_VIA);
+
+		for (uint i = 0; i < 4; ++i) {
+			show_types[i] = true;
+			this->LowerWidget(WID_DB_SHOW_TRAINS + i);
+		}
+
+		if (Twaypoint) {
+			this->GetWidget<NWidgetCore>(WID_DB_CAPTION)->SetDataTip(STR_DEPARTURES_CAPTION_WAYPOINT, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS);
+
+			for (uint i = 0; i < 4; ++i) {
+				this->DisableWidget(WID_DB_SHOW_TRAINS + i);
+			}
+
+			this->DisableWidget(WID_DB_SHOW_ARRS);
+			this->DisableWidget(WID_DB_SHOW_DEPS);
+			this->DisableWidget(WID_DB_SHOW_VIA);
+
+			departure_types[2] = true;
+
+			this->LowerWidget(WID_DB_SHOW_VIA);
+		}
+	}
+
+	virtual ~DeparturesWindow()
+	{
+		this->DeleteDeparturesList(departures);
+		this->DeleteDeparturesList(this->arrivals);
+	}
+
+	virtual void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize)
+	{
+		switch (widget) {
+			case WID_DB_LIST:
+				resize->height = DeparturesWindow::entry_height;
+				size->height = 2 * resize->height;
+				break;
+		}
+	}
+
+	virtual void SetStringParameters(int widget) const
+	{
+		if (widget == WID_DB_CAPTION) {
+			const Station *st = Station::Get(this->station);
+			SetDParam(0, st->index);
+		}
+	}
+
+	virtual void OnClick(Point pt, int widget, int click_count)
+	{
+		switch (widget) {
+			case WID_DB_SHOW_TRAINS:   // Show trains to this station
+			case WID_DB_SHOW_ROADVEHS: // Show road vehicles to this station
+			case WID_DB_SHOW_SHIPS:    // Show ships to this station
+			case WID_DB_SHOW_PLANES:   // Show aircraft to this station
+				this->show_types[widget - WID_DB_SHOW_TRAINS] = !this->show_types[widget - WID_DB_SHOW_TRAINS];
+				if (this->show_types[widget - WID_DB_SHOW_TRAINS]) {
+					this->LowerWidget(widget);
+				} else {
+					this->RaiseWidget(widget);
+				}
+				/* We need to recompute the departures list. */
+				this->calc_tick_countdown = 0;
+				/* We need to redraw the button that was pressed. */
+				this->SetWidgetDirty(widget);
+				break;
+
+			case WID_DB_SHOW_DEPS:
+			case WID_DB_SHOW_ARRS:
+				if (_settings_client.gui.departure_show_both) break;
+				/* FALL THROUGH */
+
+			case WID_DB_SHOW_VIA:
+
+				this->departure_types[widget - WID_DB_SHOW_DEPS] = !this->departure_types[widget - WID_DB_SHOW_DEPS];
+				if (this->departure_types[widget - WID_DB_SHOW_DEPS]) {
+					this->LowerWidget(widget);
+				} else {
+					this->RaiseWidget(widget);
+				}
+
+				if (!this->departure_types[0]) {
+					this->RaiseWidget(WID_DB_SHOW_VIA);
+					this->DisableWidget(WID_DB_SHOW_VIA);
+				} else {
+					this->EnableWidget(WID_DB_SHOW_VIA);
+
+					if (this->departure_types[2]) {
+						this->LowerWidget(WID_DB_SHOW_VIA);
+					}
+				}
+				/* We need to recompute the departures list. */
+				this->calc_tick_countdown = 0;
+				/* We need to redraw the button that was pressed. */
+				this->SetWidgetDirty(widget);
+				break;
+
+			case WID_DB_LIST:   // Matrix to show departures
+				/* We need to find the departure corresponding to where the user clicked. */
+				uint32 id_v = (pt.y - this->GetWidget<NWidgetBase>(WID_DB_LIST)->pos_y) / this->entry_height;
+
+				if (id_v >= this->vscroll->GetCapacity()) return; // click out of bounds
+
+				id_v += this->vscroll->GetPosition();
+
+				if (id_v >= (this->departures->Length() + this->arrivals->Length())) return; // click out of list bound
+
+				uint departure = 0;
+				uint arrival = 0;
+
+				/* Draw each departure. */
+				for (uint i = 0; i <= id_v; ++i) {
+					const Departure *d;
+
+					if (arrival == this->arrivals->Length()) {
+						d = (*(this->departures))[departure++];
+					} else if (departure == this->departures->Length()) {
+						d = (*(this->arrivals))[arrival++];
+					} else {
+						d = (*(this->departures))[departure];
+						const Departure *a = (*(this->arrivals))[arrival];
+
+						if (a->scheduled_date < d->scheduled_date) {
+							d = a;
+							arrival++;
+						} else {
+							departure++;
+						}
+					}
+
+					if (i == id_v) {
+						ShowVehicleViewWindow(d->vehicle);
+						break;
+					}
+				}
+
+				break;
+		}
+	}
+
+	virtual void OnTick()
+	{
+		if (_pause_mode == PM_UNPAUSED) {
+			this->tick_count += 1;
+			this->calc_tick_countdown -= 1;
+		}
+
+		/* Recompute the minimum date display width if the cached one is no longer valid. */
+		if (cached_date_width == 0 ||
+				_settings_client.gui.time_in_minutes != cached_date_display_method ||
+				_settings_client.gui.departure_show_both != cached_arr_dep_display_method) {
+			this->RecomputeDateWidth();
+		}
+
+		/* We need to redraw the scrolling text in its new position. */
+		this->SetWidgetDirty(WID_DB_LIST);
+
+		/* Recompute the list of departures if we're due to. */
+		if (this->calc_tick_countdown <= 0) {
+			this->calc_tick_countdown = _settings_client.gui.departure_calc_frequency;
+			this->DeleteDeparturesList(this->departures);
+			this->DeleteDeparturesList(this->arrivals);
+//arr/dep csere
+//			this->departures = (this->departure_types[0] ? MakeDepartureList(this->station, this->show_types, D_DEPARTURE, Twaypoint || this->departure_types[2]) : new DepartureList());
+//			this->arrivals   = (this->departure_types[1] && !_settings_client.gui.departure_show_both ? MakeDepartureList(this->station, this->show_types, D_ARRIVAL  ) : new DepartureList());
+			this->departures = (this->departure_types[0] ? MakeDepartureList(this->station, this->show_types, D_ARRIVAL, Twaypoint || this->departure_types[2]) : new DepartureList());
+			this->arrivals   = (this->departure_types[1] && !_settings_client.gui.departure_show_both ? MakeDepartureList(this->station, this->show_types, D_DEPARTURE  ) : new DepartureList());
+			this->SetWidgetDirty(WID_DB_LIST);
+		}
+
+		uint new_width = this->GetMinWidth();
+
+		if (new_width != this->min_width) {
+			NWidgetCore *n = this->GetWidget<NWidgetCore>(WID_DB_LIST);
+			n->SetMinimalSize(new_width, 0);
+			this->ReInit();
+			this->min_width = new_width;
+		}
+
+		uint new_height = 1 + FONT_HEIGHT_NORMAL + 1 + (_settings_client.gui.departure_larger_font ? FONT_HEIGHT_NORMAL : FONT_HEIGHT_SMALL) + 1 + 1;
+
+		if (new_height != this->entry_height) {
+			this->entry_height = new_height;
+			this->SetWidgetDirty(WID_DB_LIST);
+			this->ReInit();
+		}
+	}
+
+	virtual void OnPaint()
+	{
+		if (Twaypoint || _settings_client.gui.departure_show_both) {
+			this->DisableWidget(WID_DB_SHOW_ARRS);
+			this->DisableWidget(WID_DB_SHOW_DEPS);
+		} else {
+			this->EnableWidget(WID_DB_SHOW_ARRS);
+			this->EnableWidget(WID_DB_SHOW_DEPS);
+		}
+
+		this->vscroll->SetCount(min(_settings_client.gui.max_departures, this->departures->Length() + this->arrivals->Length()));
+		this->DrawWidgets();
+	}
+
+	virtual void DrawWidget(const Rect &r, int widget) const
+	{
+		switch (widget) {
+			case WID_DB_LIST:
+				this->DrawDeparturesListItems(r);
+				break;
+		}
+	}
+
+	virtual void OnResize()
+	{
+		this->vscroll->SetCapacityFromWidget(this, WID_DB_LIST);
+		this->GetWidget<NWidgetCore>(WID_DB_LIST)->widget_data = (this->vscroll->GetCapacity() << MAT_ROW_START) + (1 << MAT_COL_START);
+	}
+};
+
+/**
+ * Shows a window of scheduled departures for a station.
+ * @param station the station to show a departures window for
+ */
+void ShowStationDepartures(StationID station)
+{
+	AllocateWindowDescFront<DeparturesWindow<> >(&_departures_desc, station);
+}
+
+/**
+ * Shows a window of scheduled departures for a station.
+ * @param station the station to show a departures window for
+ */
+void ShowWaypointDepartures(StationID waypoint)
+{
+	AllocateWindowDescFront<DeparturesWindow<true> >(&_departures_desc, waypoint);
+}
+
+template<bool Twaypoint>
+void DeparturesWindow<Twaypoint>::RecomputeDateWidth()
+{
+	cached_date_width = 0;
+	cached_status_width = 0;
+	cached_date_display_method = _settings_client.gui.time_in_minutes;
+	cached_arr_dep_display_method = _settings_client.gui.departure_show_both;
+
+	cached_status_width = max((GetStringBoundingBox(STR_DEPARTURES_ON_TIME)).width, cached_status_width);
+	cached_status_width = max((GetStringBoundingBox(STR_DEPARTURES_DELAYED)).width, cached_status_width);
+	cached_status_width = max((GetStringBoundingBox(STR_DEPARTURES_CANCELLED)).width, cached_status_width);
+
+	uint interval = cached_date_display_method ? _settings_client.gui.ticks_per_minute : DAY_TICKS;
+	uint count = cached_date_display_method ? 24*60 : 365;
+
+	for (uint i = 0; i < count; ++i) {
+		SetDParam(0, INT_MAX - (i*interval));
+		SetDParam(1, INT_MAX - (i*interval));
+		cached_date_width = max(GetStringBoundingBox(cached_arr_dep_display_method ? STR_DEPARTURES_TIME_BOTH : STR_DEPARTURES_TIME_DEP).width, cached_date_width);
+		cached_status_width = max((GetStringBoundingBox(STR_DEPARTURES_EXPECTED)).width, cached_status_width);
+	}
+
+	SetDParam(0, 0);
+	cached_date_arrow_width = GetStringBoundingBox(STR_DEPARTURES_TIME_DEP).width - GetStringBoundingBox(STR_DEPARTURES_TIME).width;
+
+	if (!_settings_client.gui.departure_show_both) {
+		cached_date_width -= cached_date_arrow_width;
+	}
+}
+
+template<bool Twaypoint>
+uint DeparturesWindow<Twaypoint>::GetMinWidth() const
+{
+	uint result = 0;
+
+	/* Time */
+	result = cached_date_width;
+
+	/* Vehicle type icon */
+	result += _settings_client.gui.departure_show_vehicle_type ? (GetStringBoundingBox(STR_DEPARTURES_TYPE_PLANE)).width : 0;
+
+	/* Status */
+	result += cached_status_width;
+
+	/* Find the maximum company name width. */
+	int toc_width = 0;
+
+	/* Find the maximum company name width. */
+	int group_width = 0;
+
+	/* Find the maximum vehicle name width. */
+	int veh_width = 0;
+
+	if (_settings_client.gui.departure_show_vehicle || _settings_client.gui.departure_show_company || _settings_client.gui.departure_show_group) {
+		for (uint i = 0; i < 4; ++i) {
+			VehicleList vehicles;
+
+			/* MAX_COMPANIES is probably the wrong thing to put here, but it works. GenerateVehicleSortList doesn't check the company when the type of list is VL_STATION_LIST (r20801). */
+			if (!GenerateVehicleSortList(&vehicles, VehicleListIdentifier(VL_STATION_LIST, (VehicleType)(VEH_TRAIN + i), MAX_COMPANIES, station).Pack())) {
+				/* Something went wrong: panic! */
+				continue;
+			}
+
+			for (const Vehicle **v = vehicles.Begin(); v != vehicles.End(); v++) {
+				SetDParam(0, (uint64)((*v)->index));
+				int width = (GetStringBoundingBox(STR_DEPARTURES_VEH)).width;
+				if (_settings_client.gui.departure_show_vehicle && width > veh_width) veh_width = width;
+
+				if ((*v)->group_id != INVALID_GROUP && (*v)->group_id != DEFAULT_GROUP) {
+					SetDParam(0, (uint64)((*v)->group_id));
+					width = (GetStringBoundingBox(STR_DEPARTURES_GROUP)).width;
+					if (_settings_client.gui.departure_show_group && width > group_width) group_width = width;
+				}
+
+				SetDParam(0, (uint64)((*v)->owner));
+				width = (GetStringBoundingBox(STR_DEPARTURES_TOC)).width;
+				if (_settings_client.gui.departure_show_company && width > toc_width) toc_width = width;
+			}
+		}
+	}
+
+	result += toc_width + veh_width + group_width;
+
+	return result + 140;
+}
+
+/**
+ * Deletes this window's departure list.
+ */
+template<bool Twaypoint>
+void DeparturesWindow<Twaypoint>::DeleteDeparturesList(DepartureList *list)
+{
+	/* SmallVector uses free rather than delete on its contents (which doesn't invoke the destructor), so we need to delete each departure manually. */
+	for (uint i = 0; i < list->Length(); ++i) {
+		Departure **d = list->Get(i);
+		delete *d;
+		/* Make sure a double free doesn't happen. */
+		*d = NULL;
+	}
+	list->Reset();
+	delete list;
+	list = NULL;
+}
+
+/**
+ * Draws a list of departures.
+ */
+template<bool Twaypoint>
+void DeparturesWindow<Twaypoint>::DrawDeparturesListItems(const Rect &r) const
+{
+	int left = r.left + WD_MATRIX_LEFT;
+	int right = r.right - WD_MATRIX_RIGHT;
+
+	bool rtl = _current_text_dir == TD_RTL;
+	bool ltr = !rtl;
+
+	int text_offset = WD_FRAMERECT_RIGHT;
+	int text_left  = left  + (rtl ?           0 : text_offset);
+	int text_right = right - (rtl ? text_offset :           0);
+
+	int y = r.top + 1;
+	uint max_departures = min(this->vscroll->GetPosition() + this->vscroll->GetCapacity(), this->departures->Length() + this->arrivals->Length());
+
+	if (max_departures > _settings_client.gui.max_departures) {
+		max_departures = _settings_client.gui.max_departures;
+	}
+
+	byte small_font_size = _settings_client.gui.departure_larger_font ? FONT_HEIGHT_NORMAL : FONT_HEIGHT_SMALL;
+
+	/* Draw the black background. */
+	GfxFillRect(r.left + 1, r.top, r.right - 1, r.bottom, PC_BLACK);
+
+	/* Nothing selected? Then display the information text. */
+	bool none_selected[2] = {true, true};
+	for (uint i = 0; i < 4; ++i)
+	{
+		if (this->show_types[i]) {
+			none_selected[0] = false;
+			break;
+		}
+	}
+
+	for (uint i = 0; i < 2; ++i)
+	{
+		if (this->departure_types[i]) {
+			none_selected[1] = false;
+			break;
+		}
+	}
+
+	if (none_selected[0] || none_selected[1]) {
+		DrawString(text_left, text_right, y + 1, STR_DEPARTURES_NONE_SELECTED);
+		return;
+	}
+
+	/* No scheduled departures? Then display the information text. */
+	if (max_departures == 0) {
+		DrawString(text_left, text_right, y + 1, STR_DEPARTURES_EMPTY);
+		return;
+	}
+
+	/* Find the maximum possible width of the departure time and "Expt <time>" fields. */
+	int time_width = cached_date_width;
+
+	if (!_settings_client.gui.departure_show_both) {
+		time_width += (departure_types[0] && departure_types[1] ? cached_date_arrow_width : 0);
+	}
+
+	/* Vehicle type icon */
+	int type_width = _settings_client.gui.departure_show_vehicle_type ? (GetStringBoundingBox(STR_DEPARTURES_TYPE_PLANE)).width : 0;
+
+	/* Find the maximum width of the status field */
+	int status_width = cached_status_width;
+
+	/* Find the width of the "Calling at:" field. */
+	int calling_at_width = (GetStringBoundingBox(_settings_client.gui.departure_larger_font ? STR_DEPARTURES_CALLING_AT_LARGE : STR_DEPARTURES_CALLING_AT)).width;
+
+	/* Find the maximum company name width. */
+	int toc_width = 0;
+
+	/* Find the maximum group name width. */
+	int group_width = 0;
+
+	/* Find the maximum vehicle name width. */
+	int veh_width = 0;
+
+	if (_settings_client.gui.departure_show_vehicle || _settings_client.gui.departure_show_company || _settings_client.gui.departure_show_group) {
+		for (uint i = 0; i < 4; ++i) {
+			VehicleList vehicles;
+
+			/* MAX_COMPANIES is probably the wrong thing to put here, but it works. GenerateVehicleSortList doesn't check the company when the type of list is VL_STATION_LIST (r20801). */
+			if (!GenerateVehicleSortList(&vehicles, VehicleListIdentifier(VL_STATION_LIST, (VehicleType)(VEH_TRAIN + i), MAX_COMPANIES, station).Pack())) {
+				/* Something went wrong: panic! */
+				continue;
+			}
+
+			for (const Vehicle **v = vehicles.Begin(); v != vehicles.End(); v++) {
+				SetDParam(0, (uint64)((*v)->index));
+				int width = (GetStringBoundingBox(STR_DEPARTURES_VEH)).width;
+				if (_settings_client.gui.departure_show_vehicle && width > veh_width) veh_width = width;
+
+				if ((*v)->group_id != INVALID_GROUP && (*v)->group_id != DEFAULT_GROUP) {
+					SetDParam(0, (uint64)((*v)->group_id));
+					width = (GetStringBoundingBox(STR_DEPARTURES_GROUP)).width;
+					if (_settings_client.gui.departure_show_group && width > group_width) group_width = width;
+				}
+
+				SetDParam(0, (uint64)((*v)->owner));
+				width = (GetStringBoundingBox(STR_DEPARTURES_TOC)).width;
+				if (_settings_client.gui.departure_show_company && width > toc_width) toc_width = width;
+			}
+		}
+	}
+
+	uint departure = 0;
+	uint arrival = 0;
+
+	/* Draw each departure. */
+	for (uint i = 0; i < max_departures; ++i) {
+		const Departure *d;
+
+		if (arrival == this->arrivals->Length()) {
+			d = (*(this->departures))[departure++];
+		} else if (departure == this->departures->Length()) {
+			d = (*(this->arrivals))[arrival++];
+		} else {
+			d = (*(this->departures))[departure];
+			const Departure *a = (*(this->arrivals))[arrival];
+
+			if (a->scheduled_date < d->scheduled_date) {
+				d = a;
+				arrival++;
+			} else {
+				departure++;
+			}
+		}
+
+		if (i < this->vscroll->GetPosition()) {
+			continue;
+		}
+
+		/* If for some reason the departure is too far in the future or is at a negative time, skip it. */
+		if ((d->scheduled_date / DAY_TICKS) > (_date + _settings_client.gui.max_departure_time) ||
+			d->scheduled_date < 0) {
+			continue;
+		}
+
+		if (d->terminus == INVALID_STATION) continue;
+
+		StringID time_str = (departure_types[0] && departure_types[1]) ? (d->type == D_DEPARTURE ? STR_DEPARTURES_TIME_DEP : STR_DEPARTURES_TIME_ARR) : STR_DEPARTURES_TIME;
+
+		if (_settings_client.gui.departure_show_both) time_str = STR_DEPARTURES_TIME_BOTH;
+
+		/* Time */
+		SetDParam(0, d->scheduled_date);
+		SetDParam(1, d->scheduled_date - d->order->wait_time);
+		ltr ? DrawString(              text_left, text_left + time_width, y + 1, time_str)
+			: DrawString(text_right - time_width,             text_right, y + 1, time_str);
+
+		/* Vehicle type icon, with thanks to sph */
+		if (_settings_client.gui.departure_show_vehicle_type) {
+			StringID type = STR_DEPARTURES_TYPE_TRAIN;
+			int offset = (_settings_client.gui.departure_show_vehicle_color ? 1 : 0);
+
+			switch (d->vehicle->type) {
+				case VEH_TRAIN:
+					type = STR_DEPARTURES_TYPE_TRAIN;
+					break;
+				case VEH_ROAD:
+					type = IsCargoInClass(d->vehicle->cargo_type, CC_PASSENGERS) ? STR_DEPARTURES_TYPE_BUS : STR_DEPARTURES_TYPE_LORRY;
+					break;
+				case VEH_SHIP:
+					type = STR_DEPARTURES_TYPE_SHIP;
+					break;
+				case VEH_AIRCRAFT:
+					type = STR_DEPARTURES_TYPE_PLANE;
+					break;
+				default:
+					break;
+			}
+
+			type += offset;
+
+			DrawString(text_left + time_width + 3, text_left + time_width + type_width + 3, y, type);
+		}
+
+		/* The icons to show with the destination and via stations. */
+		StringID icon = STR_DEPARTURES_STATION_NONE;
+		StringID icon_via = STR_DEPARTURES_STATION_NONE;
+
+		if (_settings_client.gui.departure_destination_type) {
+			Station *t = Station::Get(d->terminus.station);
+
+			if (t->facilities & FACIL_DOCK &&
+					t->facilities & FACIL_AIRPORT &&
+					d->vehicle->type != VEH_SHIP &&
+					d->vehicle->type != VEH_AIRCRAFT) {
+				icon = STR_DEPARTURES_STATION_PORTAIRPORT;
+			} else if (t->facilities & FACIL_DOCK &&
+					d->vehicle->type != VEH_SHIP) {
+				icon = STR_DEPARTURES_STATION_PORT;
+			} else if (t->facilities & FACIL_AIRPORT &&
+					d->vehicle->type != VEH_AIRCRAFT) {
+				icon = STR_DEPARTURES_STATION_AIRPORT;
+			}
+		}
+
+		if (_settings_client.gui.departure_destination_type && d->via != INVALID_STATION) {
+			Station *t = Station::Get(d->via);
+
+			if (t->facilities & FACIL_DOCK &&
+					t->facilities & FACIL_AIRPORT &&
+					d->vehicle->type != VEH_SHIP &&
+					d->vehicle->type != VEH_AIRCRAFT) {
+				icon_via = STR_DEPARTURES_STATION_PORTAIRPORT;
+			} else if (t->facilities & FACIL_DOCK &&
+					d->vehicle->type != VEH_SHIP) {
+				icon_via = STR_DEPARTURES_STATION_PORT;
+			} else if (t->facilities & FACIL_AIRPORT &&
+					d->vehicle->type != VEH_AIRCRAFT) {
+				icon_via = STR_DEPARTURES_STATION_AIRPORT;
+			}
+		}
+
+		/* Destination */
+		if (d->via == INVALID_STATION) {
+			/* Only show the terminus. */
+			SetDParam(0, d->terminus.station);
+			SetDParam(1, icon);
+			ltr ? DrawString(              text_left + time_width + type_width + 6,   text_right - status_width - (toc_width + veh_width + group_width + 2) - 2, y + 1, STR_DEPARTURES_TERMINUS)
+				: DrawString(text_left + status_width + (toc_width + veh_width + group_width + 2) + 2,                 text_right - time_width - type_width - 6, y + 1, STR_DEPARTURES_TERMINUS);
+		} else {
+			/* Show the terminus and the via station. */
+			SetDParam(0, d->terminus.station);
+			SetDParam(1, icon);
+			SetDParam(2, d->via);
+			SetDParam(3, icon_via);
+			int text_width = (GetStringBoundingBox(STR_DEPARTURES_TERMINUS_VIA_STATION)).width;
+
+			if (text_width < text_right - status_width - (toc_width + veh_width + group_width + 2) - 2 - (text_left + time_width + type_width + 6)) {
+				/* They will both fit, so show them both. */
+				SetDParam(0, d->terminus.station);
+				SetDParam(1, icon);
+				SetDParam(2, d->via);
+				SetDParam(3, icon_via);
+				ltr ? DrawString(              text_left + time_width + type_width + 6, text_right - status_width - (toc_width + veh_width + group_width + 2) - 2, y + 1, STR_DEPARTURES_TERMINUS_VIA_STATION)
+					: DrawString(text_left + status_width + (toc_width + veh_width + group_width + 2) + 2,               text_right - time_width - type_width - 6, y + 1, STR_DEPARTURES_TERMINUS_VIA_STATION);
+			} else {
+				/* They won't both fit, so switch between showing the terminus and the via station approximately every 4 seconds. */
+				if (this->tick_count & (1 << 7)) {
+					SetDParam(0, d->via);
+					SetDParam(1, icon_via);
+					ltr ? DrawString(              text_left + time_width + type_width + 6, text_right - status_width - (toc_width + veh_width + group_width + 2) - 2, y + 1, STR_DEPARTURES_VIA)
+						: DrawString(text_left + status_width + (toc_width + veh_width + group_width + 2) + 2,               text_right - time_width - type_width - 6, y + 1, STR_DEPARTURES_VIA);
+				} else {
+					SetDParam(0, d->terminus.station);
+					SetDParam(1, icon);
+					ltr ? DrawString(              text_left + time_width + type_width + 6, text_right - status_width - (toc_width + veh_width + group_width + 2) - 2, y + 1, STR_DEPARTURES_TERMINUS_VIA)
+						: DrawString(text_left + status_width + (toc_width + veh_width + group_width + 2) + 2,               text_right - time_width - type_width - 6, y + 1, STR_DEPARTURES_TERMINUS_VIA);
+				}
+			}
+		}
+
+		/* Status */
+		{
+			int status_left = ltr ? text_right - status_width - 2 - (toc_width + veh_width + group_width + 2) : text_left + (toc_width + veh_width + group_width + 2) + 7;
+			int status_right = ltr ? text_right - (toc_width + veh_width + group_width + 2) + 2 : text_left + status_width + 2 + (toc_width + veh_width + group_width + 7);
+
+			if (d->status == D_ARRIVED) {
+				/* The vehicle has arrived. */
+				DrawString(status_left, status_right, y + 1, STR_DEPARTURES_ARRIVED);
+			} else if(d->status == D_CANCELLED) {
+				/* The vehicle has been cancelled. */
+				DrawString(status_left, status_right, y + 1, STR_DEPARTURES_CANCELLED);
+			} else{
+				if (d->lateness <= DAY_TICKS && d->scheduled_date > ((_date * DAY_TICKS) + _date_fract)) {
+					/* We have no evidence that the vehicle is late, so assume it is on time. */
+					DrawString(status_left, status_right, y + 1, STR_DEPARTURES_ON_TIME);
+				} else {
+					if ((d->scheduled_date + d->lateness) < ((_date * DAY_TICKS) + _date_fract)) {
+						/* The vehicle was expected to have arrived by now, even if we knew it was going to be late. */
+						/* We assume that the train stays at least a day at a station so it won't accidentally be marked as delayed for a fraction of a day. */
+						DrawString(status_left, status_right, y + 1, STR_DEPARTURES_DELAYED);
+					} else {
+						/* The vehicle is expected to be late and is not yet due to arrive. */
+						SetDParam(0, d->scheduled_date + d->lateness);
+						DrawString(status_left, status_right, y + 1, STR_DEPARTURES_EXPECTED);
+					}
+				}
+			}
+		}
+
+		/* Vehicle name */
+
+		if (_settings_client.gui.departure_show_vehicle) {
+			SetDParam(0, (uint64)(d->vehicle->index));
+			ltr ? DrawString(text_right - (toc_width + veh_width + group_width + 2),              text_right - toc_width - group_width - 2, y + 1, STR_DEPARTURES_VEH)
+				: DrawString(               text_left + toc_width + group_width + 2, text_left + (toc_width + veh_width + group_width + 2), y + 1, STR_DEPARTURES_VEH);
+		}
+
+		/* Group name */
+
+		if (_settings_client.gui.departure_show_group && d->vehicle->group_id != INVALID_GROUP && d->vehicle->group_id != DEFAULT_GROUP) {
+			SetDParam(0, (uint64)(d->vehicle->group_id));
+			ltr ? DrawString(text_right - (toc_width + group_width + 2),              text_right - toc_width - 2, y + 1, STR_DEPARTURES_GROUP)
+				: DrawString(               text_left + toc_width + 2, text_left + (toc_width + group_width + 2), y + 1, STR_DEPARTURES_GROUP);
+		}
+
+		/* Operating company */
+		if (_settings_client.gui.departure_show_company) {
+			SetDParam(0, (uint64)(d->vehicle->owner));
+			ltr ? DrawString(text_right - toc_width,            text_right, y + 1, STR_DEPARTURES_TOC, TC_FROMSTRING, SA_RIGHT)
+				: DrawString(             text_left, text_left + toc_width, y + 1, STR_DEPARTURES_TOC, TC_FROMSTRING, SA_LEFT);
+		}
+
+		int bottom_y = y + this->entry_height - small_font_size - (_settings_client.gui.departure_larger_font ? 1 : 3);
+
+		/* Calling at */
+		ltr ? DrawString(                    text_left,  text_left + calling_at_width, bottom_y, _settings_client.gui.departure_larger_font ? STR_DEPARTURES_CALLING_AT_LARGE : STR_DEPARTURES_CALLING_AT)
+			: DrawString(text_right - calling_at_width,                    text_right, bottom_y, _settings_client.gui.departure_larger_font ? STR_DEPARTURES_CALLING_AT_LARGE : STR_DEPARTURES_CALLING_AT);
+
+		/* List of stations */
+		/* RTL languages can be handled in the language file, e.g. by having the following: */
+		/* STR_DEPARTURES_CALLING_AT_STATION      :{STATION}, {RAW_STRING} */
+		/* STR_DEPARTURES_CALLING_AT_LAST_STATION :{STATION} & {RAW_STRING}*/
+		char buffer[512], scratch[512];
+
+		if (d->calling_at.Length() != 0) {
+			SetDParam(0, (uint64)(*d->calling_at.Get(0)).station);
+			GetString(scratch, STR_DEPARTURES_CALLING_AT_FIRST_STATION, lastof(scratch));
+
+			StationID continuesTo = INVALID_STATION;
+
+			if (d->calling_at.Get(0)->station == d->terminus.station && d->calling_at.Length() > 1) {
+				continuesTo = d->calling_at.Get(d->calling_at.Length() - 1)->station;
+			} else if (d->calling_at.Length() > 1) {
+				/* There's more than one stop. */
+
+				uint i;
+				/* For all but the last station, write out ", <station>". */
+				for (i = 1; i < d->calling_at.Length() - 1; ++i) {
+					StationID s = d->calling_at.Get(i)->station;
+					if (s == d->terminus.station) {
+						continuesTo = d->calling_at.Get(d->calling_at.Length() - 1)->station;
+						break;
+					}
+					SetDParam(0, (uint64)scratch);
+					SetDParam(1, (uint64)s);
+					GetString(buffer, STR_DEPARTURES_CALLING_AT_STATION, lastof(buffer));
+					strncpy(scratch, buffer, sizeof(scratch));
+				}
+
+				/* Finally, finish off with " and <station>". */
+				SetDParam(0, (uint64)scratch);
+				SetDParam(1, (uint64)d->calling_at.Get(i)->station);
+				GetString(buffer, STR_DEPARTURES_CALLING_AT_LAST_STATION, lastof(buffer));
+				strncpy(scratch, buffer, sizeof(scratch));
+			}
+
+			SetDParam(0, (uint64)scratch);
+			StringID string;
+			if (continuesTo == INVALID_STATION) {
+				string = _settings_client.gui.departure_larger_font ? STR_DEPARTURES_CALLING_AT_LIST_LARGE : STR_DEPARTURES_CALLING_AT_LIST;
+			} else {
+				SetDParam(1, continuesTo);
+				string = _settings_client.gui.departure_larger_font ? STR_DEPARTURES_CALLING_AT_LIST_SMART_TERMINUS_LARGE : STR_DEPARTURES_CALLING_AT_LIST_SMART_TERMINUS;
+			}
+			GetString(buffer, string, lastof(buffer));
+		} else {
+			buffer[0] = 0;
+			//SetDParam(0, d->terminus);
+			//GetString(scratch, STR_DEPARTURES_CALLING_AT_FIRST_STATION, lastof(scratch));
+		}
+
+		int list_width = (GetStringBoundingBox(buffer, _settings_client.gui.departure_larger_font ? FS_NORMAL : FS_SMALL)).width;
+
+		/* Draw the whole list if it will fit. Otherwise scroll it. */
+		if (list_width < text_right - (text_left + calling_at_width + 2)) {
+			ltr ? DrawString(text_left + calling_at_width + 2,                        text_right, bottom_y, buffer)
+				: DrawString(                       text_left, text_right - calling_at_width - 2, bottom_y, buffer);
+		} else {
+			DrawPixelInfo tmp_dpi;
+			if (ltr
+				? !FillDrawPixelInfo(&tmp_dpi, text_left + calling_at_width + 2, bottom_y, text_right - (text_left + calling_at_width + 2), small_font_size + 3)
+				: !FillDrawPixelInfo(&tmp_dpi, text_left                       , bottom_y, text_right - (text_left + calling_at_width + 2), small_font_size + 3)) {
+				y += this->entry_height;
+				continue;
+			}
+			DrawPixelInfo *old_dpi = _cur_dpi;
+			_cur_dpi = &tmp_dpi;
+
+			/* The scrolling text starts out of view at the right of the screen and finishes when it is out of view at the left of the screen. */
+			int pos = ltr
+				? text_right - (this->tick_count % (list_width + text_right - text_left))
+				:  text_left + (this->tick_count % (list_width + text_right - text_left));
+
+			ltr ? DrawString(       pos, INT16_MAX, 0, buffer, TC_FROMSTRING,  SA_LEFT | SA_FORCE)
+				: DrawString(-INT16_MAX,       pos, 0, buffer, TC_FROMSTRING, SA_RIGHT | SA_FORCE);
+
+			_cur_dpi = old_dpi;
+		}
+
+		y += this->entry_height;
+	}
+}
diff -urNad openttd-1.3.2/src/departures_gui.h openttd-1.3.2-DC3.0RC3/src/departures_gui.h
--- openttd-1.3.2/src/departures_gui.h	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/departures_gui.h	2013-11-22 05:49:07.000000000 +0100
@@ -0,0 +1,22 @@
+/* $Id: departures_gui.h $ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file departures_gui.h */
+
+#ifndef DEPARTURES_GUI_H
+#define DEPARTURES_GUI_H
+
+#include "departures_type.h"
+#include "station_base.h"
+#include "widgets/departures_widget.h"
+
+void ShowStationDepartures(StationID station);
+void ShowWaypointDepartures(StationID waypoint);
+
+#endif /* DEPARTURES_GUI_H */
diff -urNad openttd-1.3.2/src/departures_type.h openttd-1.3.2-DC3.0RC3/src/departures_type.h
--- openttd-1.3.2/src/departures_type.h	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/departures_type.h	2013-11-22 05:49:07.000000000 +0100
@@ -0,0 +1,101 @@
+/* $Id: departures_type.h $ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file departures_type.h Types related to departures. */
+
+#ifndef DEPARTURES_TYPE_H
+#define DEPARTURES_TYPE_H
+
+#include "station_base.h"
+#include "order_base.h"
+#include "vehicle_base.h"
+
+/** Whether or not a vehicle has arrived for a departure. */
+typedef enum {
+	D_TRAVELLING = 0,
+	D_ARRIVED = 1,
+	D_CANCELLED = 2,
+} DepartureStatus;
+
+/** The type of departures. */
+typedef enum {
+	D_DEPARTURE = 0,
+	D_ARRIVAL = 1,
+} DepartureType;
+
+typedef struct CallAt {
+	StationID station;
+	DateTicks scheduled_date;
+
+	CallAt(const StationID& s) : station(s), scheduled_date(0) { }
+	CallAt(const StationID& s, const DateTicks& t) : station(s), scheduled_date(t) { }
+	CallAt(const CallAt& c) : station(c.station), scheduled_date(c.scheduled_date) { }
+
+	inline bool operator==(const CallAt& c) const {
+		return this->station == c.station;
+	}
+
+	inline bool operator!=(const CallAt& c) const {
+		return this->station != c.station;
+	}
+
+	inline bool operator>=(const CallAt& c) const {
+		return this->station == c.station &&
+				this->scheduled_date != 0 &&
+				c.scheduled_date != 0 &&
+				this->scheduled_date >= c.scheduled_date;
+	}
+
+	CallAt& operator=(const CallAt& c) {
+		this->station = c.station;
+		this->scheduled_date = c.scheduled_date;
+		return *this;
+	}
+
+	inline bool operator==(StationID s) const {
+		return this->station == s;
+	}
+} CallAt;
+
+/** A scheduled departure. */
+typedef struct Departure {
+	DateTicks scheduled_date;              ///< The date this departure is scheduled to finish on (i.e. when the vehicle leaves the station)
+	DateTicks lateness;                    ///< How delayed the departure is expected to be
+	CallAt terminus;                    ///< The station at which the vehicle will terminate following this departure
+	StationID via;                         ///< The station the departure should list as going via
+	SmallVector<CallAt, 32> calling_at; ///< The stations both called at and unloaded at by the vehicle after this departure before it terminates
+	DepartureStatus status;                ///< Whether the vehicle has arrived yet for this departure
+	DepartureType type;                    ///< The type of the departure (departure or arrival)
+	const Vehicle *vehicle;                ///< The vehicle performing this departure
+	const Order *order;                    ///< The order corresponding to this departure
+	Departure() : terminus(INVALID_STATION), via(INVALID_STATION), calling_at(), vehicle(NULL) { }
+	~Departure()
+	{
+		calling_at.Reset();
+	}
+
+    inline bool operator==(const Departure& d) const {
+        if (this->calling_at.Length() != d.calling_at.Length()) return false;
+
+        for (uint i = 0; i < this->calling_at.Length(); ++i) {
+            if (*(this->calling_at.Get(i)) != *(d.calling_at.Get(i))) return false;
+        }
+
+        return
+            (this->scheduled_date / DATE_UNIT_SIZE) == (d.scheduled_date / DATE_UNIT_SIZE) &&
+            this->vehicle->type == d.vehicle->type &&
+            this->via == d.via &&
+            this->type == d.type
+            ;
+    }
+} Departure;
+
+typedef SmallVector<Departure*, 32> DepartureList;
+
+#endif /* DEPARTURES_TYPE_H */
diff -urNad openttd-1.3.2/src/depot_gui.cpp openttd-1.3.2-DC3.0RC3/src/depot_gui.cpp
--- openttd-1.3.2/src/depot_gui.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/depot_gui.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -26,6 +26,8 @@
 #include "tilehighlight_func.h"
 #include "window_gui.h"
 #include "vehiclelist.h"
+#include "company_base.h"
+#include "infrastructure_func.h"
 #include "order_backup.h"
 #include "zoom_func.h"
 
@@ -677,7 +679,7 @@
 
 		/* Setup disabled buttons. */
 		TileIndex tile = this->window_number;
-		this->SetWidgetsDisabledState(!IsTileOwner(tile, _local_company),
+		this->SetWidgetsDisabledState(!Company::IsValidID(_local_company) || !IsInfraTileUsageAllowed(this->type, _local_company, tile),
 			WID_D_STOP_ALL,
 			WID_D_START_ALL,
 			WID_D_SELL,
@@ -862,6 +864,7 @@
 
 	virtual void OnMouseDrag(Point pt, int widget)
 	{
+
 		if (this->type != VEH_TRAIN || this->sel == INVALID_VEHICLE) return;
 
 		/* A rail vehicle is dragged.. */
@@ -916,6 +919,7 @@
 
 					if (this->GetVehicleFromDepotWndPt(pt.x - nwi->pos_x, pt.y - nwi->pos_y, &v, &gdvp) == MODE_DRAG_VEHICLE && sel != INVALID_VEHICLE) {
 						if (gdvp.wagon != NULL && gdvp.wagon->index == sel && _ctrl_pressed) {
+
 							DoCommandP(Vehicle::Get(sel)->tile, Vehicle::Get(sel)->index, true,
 									CMD_REVERSE_TRAIN_DIRECTION | CMD_MSG(STR_ERROR_CAN_T_REVERSE_DIRECTION_RAIL_VEHICLE));
 						} else if (gdvp.wagon == NULL || gdvp.wagon->index != sel) {
diff -urNad openttd-1.3.2/src/depot_map.h openttd-1.3.2-DC3.0RC3/src/depot_map.h
--- openttd-1.3.2/src/depot_map.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/depot_map.h	2013-11-22 05:49:07.000000000 +0100
@@ -52,7 +52,7 @@
 {
 	/* Hangars don't have a Depot class, thus store no DepotID. */
 	assert(IsRailDepotTile(t) || IsRoadDepotTile(t) || IsShipDepotTile(t));
-	return _m[t].m2;
+	return GetTile(t)->m2;
 }
 
 #endif /* DEPOT_MAP_H */
diff -urNad openttd-1.3.2/src/direction_func.h openttd-1.3.2-DC3.0RC3/src/direction_func.h
--- openttd-1.3.2/src/direction_func.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/direction_func.h	2013-11-22 05:49:07.000000000 +0100
@@ -250,4 +250,118 @@
 	return (dir & 1) != 0;
 }
 
+/**
+ * Checks if an integer value is a valid DirTransformation.
+ *
+ * @param transformation The value to check.
+ * @return True if the value belongs to a DirTransformation, false otherwise.
+ */
+static inline bool IsValidDirTransform(DirTransformation transformation)
+{
+	return IsInsideMM(transformation, DTR_BEGIN, DTR_END);
+}
+
+/**
+ * Combine two direction transformations into one.
+ * @param a First transformation.
+ * @param b Second transformation.
+ * @return Transformation that works like firstly applying the 'a' transformation and then the 'b' transformation.
+ */
+static inline DirTransformation CombineDirTransform(DirTransformation a, DirTransformation b)
+{
+	/* DirTransformation bit lauout:
+	 *     0000irrr
+	 * where:
+	 *     i - DTR_REFLECTION_BIT
+	 *     rrr - DTR_ROTATION_MASK
+	 *
+	 * DirTransformation transformation can be expressed as a function of an angle:
+	 *   f(x) = I * x + R
+	 * where
+	 *   x - direction expressed in angle units (e.g. DiagDir)
+	 *   I - reflection, -1 to reflect before rotating (DTR_REFLECTION_BIT set), +1 otherwise
+	 *   R - rotation, number of angle units to add (bits of mask DTR_ROTATION_MASK)
+	 *
+	 * 1 angle unit is 90 degree. As we work on angles we must use modular arithmetic for
+	 * calculations. Modulus is 4 because 360 degree is 4 our angle units. To apply
+	 * modulus we can simply bitmask result with DTR_ROTATION_MASK.
+	 *
+	 * To combine two transformations
+	 *   a(x) = IA * x + RA
+	 *   b(x) = IB * x + RB
+	 * into one
+	 *   c(x) = IC * x + RC
+	 * we must compose functions
+	 *   c(x) = b(a(x)) = IB * (IA * x + RA) + RB = IA * IB * x + IB * RA + RB
+	 * From above
+	 *   IC = IA * IB         - so we can XOR reflection bits together to get resulting reflection bit
+	 *   RC = IB * RA + RB    - so we evaluate RB+RA or RB-RA based on reflection bit of transformation B to get resulting rotation bits */
+	return (DirTransformation)(((a ^ b) & DTR_REFLECTION_BIT) | // calculate reflection bit
+		(((b & DTR_REFLECTION_BIT) ? (b - a) : (b + a)) & DTR_ROTATION_MASK)); // calculate rotation bits
+}
+
+/**
+ * Invert given transformation.
+ * @param transformation Tranformation to invert.
+ * @return Inverted transformation transformation.
+ */
+static inline DirTransformation InvertDirTransform(DirTransformation transformation)
+{
+	/* to revert a reflection reflect again, transformation is the same (involution) */
+	if (transformation & DTR_REFLECTION_BIT) return transformation;
+
+	/* to revert a rotation rotate in opposite direction */
+	return (DirTransformation)((-transformation) & DTR_ROTATION_MASK);
+}
+
+static inline DirTransformation DirRotation(DiagDirDiff angle)
+{
+	return (DirTransformation)angle;
+}
+
+static inline DirTransformation DirReflection(Direction axis)
+{
+	return (DirTransformation)(((axis - DiagDirToDir(DIAGDIR_BEGIN)) & DTR_ROTATION_MASK) | DTR_REFLECTION_BIT);
+}
+
+static inline DirTransformation DirReflection(Axis axis)
+{
+	return (DirTransformation)((2 * axis) | DTR_REFLECTION_BIT);
+}
+
+/**
+ * Transform Axis by a given transformation.
+ * @param axis Axis to transform.
+ * @param transformation Transformation to use.
+ * @return Transformed Axis.
+ */
+static inline Axis TransformAxis(Axis axis, DirTransformation transformation)
+{
+	return (Axis)(axis ^ (transformation & 1));
+}
+
+/**
+ * Transform Direction by given transformation.
+ * @param direction Direction to transform.
+ * @param transformation Transformation to use.
+ * @return Transformed Direction.
+ */
+static inline Direction TransformDir(Direction direction, DirTransformation transformation)
+{
+	if (transformation & DTR_REFLECTION_BIT) direction = (Direction)(2 * DIR_NE - direction); // reflect against X-axis
+	return ChangeDir(direction, (DirDiff)(2 * transformation)); // rotate and cut off overflowing bits
+}
+
+/**
+ * Transform DiagDirection by a given transformation.
+ * @param diag_dir DiagDirection to transform.
+ * @param transformation Transformation to use.
+ * @return Transformed DiagDirection.
+ */
+static inline DiagDirection TransformDiagDir(DiagDirection diag_dir, DirTransformation transformation)
+{
+	if (transformation & DTR_REFLECTION_BIT) diag_dir = (DiagDirection)(2 * DIAGDIR_NE - diag_dir); // reflect against X-axis
+	return ChangeDiagDir(diag_dir, (DiagDirDiff)transformation); // rotate and cut off overflowing bits
+}
+
 #endif /* DIRECTION_FUNC_H */
diff -urNad openttd-1.3.2/src/direction_type.h openttd-1.3.2-DC3.0RC3/src/direction_type.h
--- openttd-1.3.2/src/direction_type.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/direction_type.h	2013-11-22 05:49:07.000000000 +0100
@@ -115,6 +115,25 @@
 /** Allow incrementing of DiagDirDiff variables */
 DECLARE_POSTFIX_INCREMENT(DiagDirDiff)
 
+/** Represents transformations to rotate/reflect directions. */
+enum DirTransformation {
+	DTR_BEGIN           = 0, ///< Used for iterations.
+
+	DTR_IDENTITY        = 0, ///< Identity transformation (no tranformation at all).
+	DTR_ROTATE_90_R     = 1, ///< Rotate by 90 degree clockwise.
+	DTR_ROTATE_180      = 2, ///< Rotate by 180 degree.
+	DTR_ROTATE_90_L     = 3, ///< Rotate by 90 degree counterclockwise.
+
+	DTR_REFLECT_NE_SW   = 4, ///< Reflect in respect to a Northeast-Southwest axis.
+	DTR_REFLECT_W_E     = 5, ///< Reflect in respect to a West-East axis.
+	DTR_REFLECT_NW_SE   = 6, ///< Reflect in respect to a Northwest-Southeast axis.
+	DTR_REFLECT_N_S     = 7, ///< Reflect in respect to a North-South axis.
+
+	DTR_END             = 8, ///< Used for iterations.
+
+	DTR_ROTATION_MASK  = 0x03, ///< Rotation mask. The number formed by thiese bits tells how much to rotate object clockwise (in 90 degree units).
+	DTR_REFLECTION_BIT = 0x04, ///< Reflection bit. Indicates if to reflect object in respect to X-axis before rotating it.
+};
 
 /**
  * Enumeration for the two axis X and Y
diff -urNad openttd-1.3.2/src/disaster_cmd.cpp openttd-1.3.2-DC3.0RC3/src/disaster_cmd.cpp
--- openttd-1.3.2/src/disaster_cmd.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/disaster_cmd.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -44,6 +44,7 @@
 #include "company_base.h"
 #include "core/random_func.hpp"
 #include "core/backup_type.hpp"
+#include "aircraft.h"
 
 #include "table/strings.h"
 
@@ -123,6 +124,24 @@
 	_disaster_images_4, _disaster_images_5,                     ///< small and big submarine sprites
 };
 
+static inline void AdjustFlyingDisasterVehicleHeight(DisasterVehicle *v)
+{
+	int min_altitude = GetAircraftMinAltitude(v->x_pos, v->y_pos, 0);
+	int max_altitude = GetAircraftMaxAltitude(v->x_pos, v->y_pos, 0);
+	int middle_altitude = min_altitude + (max_altitude - min_altitude) / 2;
+	if (v->z_pos < min_altitude || (v->in_min_height_correction && v->z_pos < middle_altitude)) {
+		v->in_min_height_correction = true;
+		v->z_pos += 2;
+	} else if (v->z_pos > max_altitude || (v->in_max_height_correction && v->z_pos > middle_altitude)) {
+		v->in_max_height_correction = true;
+		v->z_pos -= 2;
+	} else if (v->in_min_height_correction && v->z_pos >= middle_altitude) {
+		v->in_min_height_correction = false;
+	} else if (v->in_max_height_correction && v->z_pos <= middle_altitude) {
+		v->in_max_height_correction = false;
+	}
+}
+
 static void DisasterVehicleUpdateImage(DisasterVehicle *v)
 {
 	SpriteID img = v->image_override;
@@ -147,6 +166,8 @@
 	v->vehstatus = VS_UNCLICKABLE;
 	v->image_override = 0;
 	v->current_order.Free();
+	v->in_min_height_correction = false;
+	v->in_max_height_correction = false;
 
 	DisasterVehicleUpdateImage(v);
 	VehicleUpdatePositionAndViewport(v);
@@ -202,6 +223,7 @@
 
 		GetNewVehiclePosResult gp = GetNewVehiclePos(v);
 
+		AdjustFlyingDisasterVehicleHeight(v);
 		SetDisasterVehiclePos(v, gp.x, gp.y, v->z_pos);
 
 		if (v->current_order.GetDestination() == 1) {
@@ -296,6 +318,7 @@
 		if (Delta(x, v->x_pos) + Delta(y, v->y_pos) >= (int)TILE_SIZE) {
 			v->direction = GetDirectionTowards(v, x, y);
 			GetNewVehiclePosResult gp = GetNewVehiclePos(v);
+			AdjustFlyingDisasterVehicleHeight(v);
 			SetDisasterVehiclePos(v, gp.x, gp.y, v->z_pos);
 			return true;
 		}
@@ -399,6 +422,7 @@
 	v->image_override = (v->current_order.GetDestination() == 1 && HasBit(v->tick_counter, 2)) ? image_override : 0;
 
 	GetNewVehiclePosResult gp = GetNewVehiclePos(v);
+	AdjustFlyingDisasterVehicleHeight(v);
 	SetDisasterVehiclePos(v, gp.x, gp.y, v->z_pos);
 
 	if ((leave_at_top && gp.x < (-10 * (int)TILE_SIZE)) || (!leave_at_top && gp.x > (int)(MapSizeX() * TILE_SIZE + 9 * TILE_SIZE) - 1)) {
@@ -496,6 +520,7 @@
 			v->direction = GetDirectionTowards(v, x, y);
 
 			GetNewVehiclePosResult gp = GetNewVehiclePos(v);
+			AdjustFlyingDisasterVehicleHeight(v);
 			SetDisasterVehiclePos(v, gp.x, gp.y, v->z_pos);
 			return true;
 		}
@@ -548,6 +573,7 @@
 		if (Delta(x, v->x_pos) + Delta(y, v->y_pos) >= (int)TILE_SIZE) {
 			v->direction = GetDirectionTowards(v, x, y);
 			GetNewVehiclePosResult gp = GetNewVehiclePos(v);
+			AdjustFlyingDisasterVehicleHeight(v);
 			SetDisasterVehiclePos(v, gp.x, gp.y, v->z_pos);
 			return true;
 		}
@@ -583,6 +609,7 @@
 	v->tick_counter++;
 
 	GetNewVehiclePosResult gp = GetNewVehiclePos(v);
+	AdjustFlyingDisasterVehicleHeight(v);
 	SetDisasterVehiclePos(v, gp.x, gp.y, v->z_pos);
 
 	if (gp.x > (int)(MapSizeX() * TILE_SIZE + 9 * TILE_SIZE) - 1) {
@@ -698,7 +725,8 @@
 	}
 
 	DisasterVehicle *v = new DisasterVehicle();
-	InitializeDisasterVehicle(v, x, 0, INITIAL_DISASTER_VEHICLE_ZPOS, DIR_SE, ST_ZEPPELINER);
+	int z = GetAircraftMinAltitude(x, 0, 0);
+	InitializeDisasterVehicle(v, x, 0, z, DIR_SE, ST_ZEPPELINER);
 
 	/* Allocate shadow */
 	DisasterVehicle *u = new DisasterVehicle();
@@ -719,7 +747,8 @@
 	DisasterVehicle *v = new DisasterVehicle();
 	int x = TileX(Random()) * TILE_SIZE + TILE_SIZE / 2;
 
-	InitializeDisasterVehicle(v, x, 0, INITIAL_DISASTER_VEHICLE_ZPOS, DIR_SE, ST_SMALL_UFO);
+	int z = GetAircraftMinAltitude(x, 0, 0);
+	InitializeDisasterVehicle(v, x, 0, z, DIR_SE, ST_SMALL_UFO);
 	v->dest_tile = TileXY(MapSizeX() / 2, MapSizeY() / 2);
 	v->age = 0;
 
@@ -753,7 +782,8 @@
 	int x = (MapSizeX() + 9) * TILE_SIZE - 1;
 	int y = TileY(found->location.tile) * TILE_SIZE + 37;
 
-	InitializeDisasterVehicle(v, x, y, INITIAL_DISASTER_VEHICLE_ZPOS, DIR_NE, ST_AIRPLANE);
+	int z = GetAircraftMinAltitude(x, y, 0);
+	InitializeDisasterVehicle(v, x, y, z, DIR_NE, ST_AIRPLANE);
 
 	DisasterVehicle *u = new DisasterVehicle();
 	v->SetNext(u);
@@ -783,7 +813,8 @@
 	int x = -16 * (int)TILE_SIZE;
 	int y = TileY(found->location.tile) * TILE_SIZE + 37;
 
-	InitializeDisasterVehicle(v, x, y, INITIAL_DISASTER_VEHICLE_ZPOS, DIR_SW, ST_HELICOPTER);
+	int z = GetAircraftMinAltitude(x, y, 0);
+	InitializeDisasterVehicle(v, x, y, z, DIR_SW, ST_HELICOPTER);
 
 	DisasterVehicle *u = new DisasterVehicle();
 	v->SetNext(u);
@@ -792,7 +823,7 @@
 
 	DisasterVehicle *w = new DisasterVehicle();
 	u->SetNext(w);
-	InitializeDisasterVehicle(w, x, y, 140, DIR_SW, ST_HELICOPTER_ROTORS);
+	InitializeDisasterVehicle(w, x, y, z + 5, DIR_SW, ST_HELICOPTER_ROTORS);
 }
 
 
@@ -806,7 +837,8 @@
 	int x = TileX(Random()) * TILE_SIZE + TILE_SIZE / 2;
 	int y = MapMaxX() * TILE_SIZE - 1;
 
-	InitializeDisasterVehicle(v, x, y, INITIAL_DISASTER_VEHICLE_ZPOS, DIR_NW, ST_BIG_UFO);
+	int z = GetAircraftMinAltitude(x, y, 0);
+	InitializeDisasterVehicle(v, x, y, z, DIR_NW, ST_BIG_UFO);
 	v->dest_tile = TileXY(MapSizeX() / 2, MapSizeY() / 2);
 	v->age = 0;
 
diff -urNad openttd-1.3.2/src/economy_base.h openttd-1.3.2-DC3.0RC3/src/economy_base.h
--- openttd-1.3.2/src/economy_base.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/economy_base.h	2013-11-22 05:49:07.000000000 +0100
@@ -24,9 +24,10 @@
  * Helper class to perform the cargo payment.
  */
 struct CargoPayment : CargoPaymentPool::PoolItem<&_cargo_payment_pool> {
-	Vehicle *front;      ///< The front vehicle to do the payment of
-	Money route_profit;  ///< The amount of money to add/remove from the bank account
-	Money visual_profit; ///< The visual profit to show
+	Vehicle *front;        ///< The front vehicle to do the payment of
+	Money route_profit;    ///< The amount of money to add/remove from the bank account
+	Money visual_profit;   ///< The visual (non-transfer) profit to show
+	Money transfer_profit; ///< The transfer profit to show
 
 	/* Unsaved variables */
 	Company *owner;            ///< The owner of the vehicle
diff -urNad openttd-1.3.2/src/economy.cpp openttd-1.3.2-DC3.0RC3/src/economy.cpp
--- openttd-1.3.2/src/economy.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/economy.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -39,13 +39,16 @@
 #include "subsidy_func.h"
 #include "station_base.h"
 #include "waypoint_base.h"
+#include "triphistory.h"
 #include "economy_base.h"
 #include "core/pool_func.hpp"
 #include "core/backup_type.hpp"
+#include "infrastructure_func.h"
 #include "water.h"
 #include "game/game.hpp"
 #include "cargomonitor.h"
 #include "goal_base.h"
+#include "cargodest_func.h"
 
 #include "table/strings.h"
 #include "table/pricebase.h"
@@ -76,7 +79,8 @@
 /**
  * Score info, values used for computing the detailed performance rating.
  */
-const ScoreInfo _score_info[] = {
+//const ScoreInfo _score_info[] = {
+ScoreInfo _score_info[] = {
 	{     120, 100}, // SCORE_VEHICLES
 	{      80, 100}, // SCORE_STATIONS
 	{   10000, 100}, // SCORE_MIN_PROFIT
@@ -419,7 +423,8 @@
 		}
 	}
 
-	{
+	/* Change ownership of vehicles */
+	if (new_owner != INVALID_OWNER) {
 		FreeUnitIDGenerator unitidgen[] = {
 			FreeUnitIDGenerator(VEH_TRAIN, new_owner), FreeUnitIDGenerator(VEH_ROAD,     new_owner),
 			FreeUnitIDGenerator(VEH_SHIP,  new_owner), FreeUnitIDGenerator(VEH_AIRCRAFT, new_owner)
@@ -450,8 +455,12 @@
 		}
 
 		if (new_owner != INVALID_OWNER) GroupStatistics::UpdateAutoreplace(new_owner);
+	} else {
+	/* Depending on sharing settings, other companies could be affected too.
+	 * Let the infrastructure sharing code handle this. */
+	HandleSharingCompanyDeletion(old_owner);
 	}
-
+	
 	/*  Change ownership of tiles */
 	{
 		TileIndex tile = 0;
@@ -464,22 +473,14 @@
 			 * and signals were not propagated
 			 * Similar with crossings - it is needed to bar crossings that weren't before
 			 * because of different owner of crossing and approaching train */
-			tile = 0;
 
-			do {
-				if (IsTileType(tile, MP_RAILWAY) && IsTileOwner(tile, new_owner) && HasSignals(tile)) {
-					TrackBits tracks = GetTrackBits(tile);
-					do { // there may be two tracks with signals for TRACK_BIT_HORZ and TRACK_BIT_VERT
-						Track track = RemoveFirstTrack(&tracks);
-						if (HasSignalOnTrack(tile, track)) AddTrackToSignalBuffer(tile, track, new_owner);
-					} while (tracks != TRACK_BIT_NONE);
-				} else if (IsLevelCrossingTile(tile) && IsTileOwner(tile, new_owner)) {
-					UpdateLevelCrossing(tile);
+			UpdateAllBlockSignals(new_owner);
+		} else if (_settings_game.economy.infrastructure_sharing[VEH_TRAIN]) {
+			/* tracks are being removed while sharing is enabled.
+			 * Thus, update all signals and crossings. */
+			UpdateAllBlockSignals();
 				}
-			} while (++tile != MapSize());
-		}
-
-		/* update signals in buffer */
+		/* Update any signals in the buffer */
 		UpdateSignalsInBuffer();
 	}
 
@@ -493,6 +494,13 @@
 			/* if a company goes bankrupt, set owner to OWNER_NONE so the sign doesn't disappear immediately
 			 * also, drawing station window would cause reading invalid company's colour */
 			st->owner = new_owner == INVALID_OWNER ? OWNER_NONE : new_owner;
+
+			/* Move route links to the new company. */
+			for (CargoID cid = 0; cid < NUM_CARGO; cid++) {
+				for (RouteLinkList::iterator itr = st->goods[cid].routes.begin(); itr != st->goods[cid].routes.end(); ++itr) {
+					if ((*itr)->owner == old_owner) (*itr)->owner = new_owner;
+				}
+			}
 		}
 	}
 
@@ -610,6 +618,30 @@
 	}
 }
 
+/* Change some needed values to reflect day length. */
+bool InitializeGraphPerformance(int32 p1)
+{
+       _score_info[SCORE_MIN_PROFIT].needed = SCORE_MIN_PROFIT_NEEDED;
+       _score_info[SCORE_MIN_INCOME].needed = SCORE_MIN_INCOME_NEEDED;
+       _score_info[SCORE_MAX_INCOME].needed = SCORE_MAX_INCOME_NEEDED;
+       _score_info[SCORE_MONEY].needed = SCORE_MONEY_NEEDED;
+
+       if (_settings_game.economy.day_length_balance_type != DBT_PAYMENTS) {
+               _score_info[SCORE_MIN_PROFIT].needed *= _settings_game.economy.day_length_factor;
+               _score_info[SCORE_MIN_INCOME].needed *= _settings_game.economy.day_length_factor;
+               _score_info[SCORE_MAX_INCOME].needed *= _settings_game.economy.day_length_factor;
+               _score_info[SCORE_MONEY].needed *= _settings_game.economy.day_length_factor;
+       }
+
+       _score_info[SCORE_DELIVERED].needed = SCORE_DELIVERED_NEEDED * _settings_game.economy.day_length_factor;
+
+       SetWindowDirty(WC_PERFORMANCE_DETAIL, 0);
+       SetWindowDirty(WC_PERFORMANCE_HISTORY, 0);
+
+       return true;
+}
+
+
 /**
  * Update the finances of all companies.
  * Pay for the stations, update the history graph, update ratings and company values, and deal with bankruptcy.
@@ -655,6 +687,25 @@
 		CompanyCheckBankrupt(c);
 	}
 
+       FOR_ALL_COMPANIES(c) {
+               _current_company = c->index;
+
+               if (c->inaugurated_year + 2 > _cur_year) continue;
+
+               CommandCost cost(EXPENSES_OTHER, 0);
+
+               if (c->old_economy[0].company_value > 1500000) {
+                       cost.AddCost(c->old_economy[0].company_value >> 6); //~20% company value tax per year
+               }else if (c->old_economy[0].company_value > 200000 ) {
+                       cost.AddCost(c->old_economy[0].company_value >> 7); //~10% company value tax per year
+               }
+
+               if ( (cost.GetCost() > 0) && ( _settings_game.economy.yearly_tax )) {
+                       _economy.industry_helper += cost.GetCost();
+                       SubtractMoneyFromCompany(cost);
+               }
+       }
+
 	/* Only run the economic statics and update company stats every 3rd month (1st of quarter). */
 	if (!HasBit(1 << 0 | 1 << 3 | 1 << 6 | 1 << 9, _cur_month)) return;
 
@@ -791,6 +842,7 @@
 static void CompaniesPayInterest()
 {
 	const Company *c;
+	CommandCost cost;
 
 	Backup<CompanyByte> cur_company(_current_company, FILE_LINE);
 	FOR_ALL_COMPANIES(c) {
@@ -816,7 +868,15 @@
 
 		SubtractMoneyFromCompany(CommandCost(EXPENSES_LOAN_INT, up_to_this_month - up_to_previous_month));
 
-		SubtractMoneyFromCompany(CommandCost(EXPENSES_OTHER, _price[PR_STATION_VALUE] >> 2));
+		cost = CommandCost(EXPENSES_OTHER, _price[PR_STATION_VALUE] >> 2);
+		/* Multiply property according to day length balance type. */
+		if (_settings_game.economy.day_length_balance_type == DBT_ALL_COSTS ||
+			(_settings_game.economy.day_length_balance_type == DBT_RUN_COST &&
+			_settings_game.economy.include_prop_main_to_run))
+		{
+			cost.AffectCost( _settings_game.economy.day_length_balance_factor );
+		}
+		SubtractMoneyFromCompany(cost);
 	}
 	cur_company.Restore();
 }
@@ -985,6 +1045,33 @@
 /** The industries we've currently brought cargo to. */
 static SmallIndustryList _cargo_delivery_destinations;
 
+ /**
+ * Deliver goods to an industry. Cargo acceptance by the industry is checked.
+ * @param ind The industry to deliver to.
+ * @param cargo_type Type of cargo delivered.
+ * @param num_pieces Amount of cargo delivered.
+ * @return Accepted pieces of cargo.
+ */
+static uint DeliverGoodsToIndustry(Industry *ind, CargoID cargo_type, uint num_pieces)
+{
+	uint cargo_index;
+	for (cargo_index = 0; cargo_index < lengthof(ind->accepts_cargo); cargo_index++) {
+		if (cargo_type == ind->accepts_cargo[cargo_index]) break;
+	}
+	/* Check if matching cargo has been found */
+	if (cargo_index >= lengthof(ind->accepts_cargo)) return 0;
+
+	/* Check if industry temporarily refuses acceptance */
+	if (IndustryTemporarilyRefusesCargo(ind, cargo_type)) return 0;
+
+	/* Insert the industry into _cargo_delivery_destinations, if not yet contained */
+	_cargo_delivery_destinations.Include(ind);
+
+	uint amount = min(num_pieces, 0xFFFFU - ind->incoming_cargo_waiting[cargo_index]);
+	ind->incoming_cargo_waiting[cargo_index] += amount;
+	return amount;
+}
+
 /**
  * Transfer goods from station to industry.
  * All cargo is delivered to the nearest (Manhattan) industry to the station sign, which is inside the acceptance rectangle and actually accepts the cargo.
@@ -1009,21 +1096,7 @@
 		Industry *ind = st->industries_near[i];
 		if (ind->index == source) continue;
 
-		uint cargo_index;
-		for (cargo_index = 0; cargo_index < lengthof(ind->accepts_cargo); cargo_index++) {
-			if (cargo_type == ind->accepts_cargo[cargo_index]) break;
-		}
-		/* Check if matching cargo has been found */
-		if (cargo_index >= lengthof(ind->accepts_cargo)) continue;
-
-		/* Check if industry temporarily refuses acceptance */
-		if (IndustryTemporarilyRefusesCargo(ind, cargo_type)) continue;
-
-		/* Insert the industry into _cargo_delivery_destinations, if not yet contained */
-		_cargo_delivery_destinations.Include(ind);
-
-		uint amount = min(num_pieces, 0xFFFFU - ind->incoming_cargo_waiting[cargo_index]);
-		ind->incoming_cargo_waiting[cargo_index] += amount;
+		uint amount = DeliverGoodsToIndustry(ind, cargo_type, num_pieces);
 		num_pieces -= amount;
 		accepted += amount;
 	}
@@ -1041,17 +1114,25 @@
  * @param company The company delivering the cargo
  * @param src_type Type of source of cargo (industry, town, headquarters)
  * @param src Index of source of cargo
+ * @param cp_dest_type Type of destination of cargo
+ * @param cp_dest Index of the destination of cargo
  * @return Revenue for delivering cargo
  * @note The cargo is just added to the stockpile of the industry. It is due to the caller to trigger the industry's production machinery
  */
-static Money DeliverGoods(int num_pieces, CargoID cargo_type, StationID dest, TileIndex source_tile, byte days_in_transit, Company *company, SourceType src_type, SourceID src)
+static Money DeliverGoods(int num_pieces, CargoID cargo_type, StationID dest, TileIndex source_tile, byte days_in_transit, Company *company, SourceType src_type, SourceID src, SourceType cp_dest_type, SourceID cp_dest)
 {
 	assert(num_pieces > 0);
 
 	Station *st = Station::Get(dest);
 
-	/* Give the goods to the industry. */
-	uint accepted = DeliverGoodsToIndustry(st, cargo_type, num_pieces, src_type == ST_INDUSTRY ? src : INVALID_INDUSTRY);
+	uint accepted = 0;
+	if (cp_dest != INVALID_SOURCE) {
+		/* If this cargo has an industry as destination, deliver the cargo to it. */
+		if (cp_dest_type == ST_INDUSTRY) accepted = DeliverGoodsToIndustry(Industry::Get(cp_dest), cargo_type, num_pieces);
+	} else {
+		/* Give the goods to any accepting industry. */
+		accepted = DeliverGoodsToIndustry(st, cargo_type, num_pieces, src_type == ST_INDUSTRY ? src : INVALID_INDUSTRY);
+	}
 
 	/* If this cargo type is always accepted, accept all */
 	if (HasBit(st->always_accepted, cargo_type)) accepted = num_pieces;
@@ -1140,23 +1221,39 @@
 
 	this->front->cargo_payment = NULL;
 
-	if (this->visual_profit == 0) return;
+	if (this->visual_profit == 0 && this->transfer_profit == 0) return;
 
 	Backup<CompanyByte> cur_company(_current_company, this->front->owner, FILE_LINE);
 
+	/* Divide income according to day length balance type. */
+	if (_settings_game.economy.day_length_balance_type == DBT_PAYMENTS) {
+		this->route_profit /= _settings_game.economy.day_length_balance_factor;
+		this->visual_profit /= _settings_game.economy.day_length_balance_factor;
+	}
+
 	SubtractMoneyFromCompany(CommandCost(this->front->GetExpenseType(true), -this->route_profit));
-	this->front->profit_this_year += this->visual_profit << 8;
+	this->front->profit_this_year += (this->visual_profit + this->transfer_profit) << 8;
+
+	int z = this->front->z_pos;
 
 	if (this->route_profit != 0) {
-		if (IsLocalCompany() && !PlayVehicleSound(this->front, VSE_LOAD_UNLOAD)) {
-			SndPlayVehicleFx(SND_14_CASHTILL, this->front);
-		}
+		/* Show profit/loss from final delivery. */
+		ShowCostOrIncomeAnimation(this->front->x_pos, this->front->y_pos, z, -this->visual_profit);
+		z += VPSM_TOP + FONT_HEIGHT_NORMAL + VPSM_BOTTOM;
+	}
 
-		ShowCostOrIncomeAnimation(this->front->x_pos, this->front->y_pos, this->front->z_pos, -this->visual_profit);
-	} else {
-		ShowFeederIncomeAnimation(this->front->x_pos, this->front->y_pos, this->front->z_pos, this->visual_profit);
+	if (this->transfer_profit != 0) {
+		/* Show transfer credits. */
+		ShowFeederIncomeAnimation(this->front->x_pos, this->front->y_pos, z, this->transfer_profit);
+	}
+
+	/* Play cash sound. */
+	if ( (IsLocalCompany() && !PlayVehicleSound(this->front, VSE_LOAD_UNLOAD)) && ( _settings_client.sound.cashtill ) ) {
+		SndPlayVehicleFx(SND_14_CASHTILL, this->front);
 	}
 
+	this->front->trip_history.AddValue(this->route_profit, _date);
+	InvalidateWindowData(WC_VEHICLE_TRIP_HISTORY, this->front->index);
 	cur_company.Restore();
 }
 
@@ -1172,7 +1269,7 @@
 	}
 
 	/* Handle end of route payment */
-	Money profit = DeliverGoods(count, this->ct, this->current_station, cp->SourceStationXY(), cp->DaysInTransit(), this->owner, cp->SourceSubsidyType(), cp->SourceSubsidyID());
+	Money profit = DeliverGoods(count, this->ct, this->current_station, cp->SourceStationXY(), cp->DaysInTransit(), this->owner, cp->SourceSubsidyType(), cp->SourceSubsidyID(), cp->DestinationType(), cp->DestinationID());
 	this->route_profit += profit;
 
 	/* The vehicle's profit is whatever route profit there is minus feeder shares. */
@@ -1196,7 +1293,7 @@
 
 	profit = profit * _settings_game.economy.feeder_payment_share / 100;
 
-	this->visual_profit += profit; // accumulate transfer profits for whole vehicle
+	this->transfer_profit += profit; // accumulate transfer profits for whole vehicle
 	return profit; // account for the (virtual) profit already made for the cargo packet
 }
 
@@ -1245,6 +1342,30 @@
 }
 
 /**
+ * Tests, whether vehicle's next order leads to current order.
+ * @param v Vehicle
+ * @return True, if true ...
+ */
+static bool VehicleStayConditional(const Vehicle * v)
+{
+	if (v->GetNumOrders() > 1) {
+		const Order * order = v->GetOrder(v->cur_real_order_index);
+		const Order * next_order = order->next;
+
+		/* Next order must be conditional. */
+		if (next_order != NULL && next_order->IsType(OT_CONDITIONAL)) {
+			const VehicleOrderID ord_id = ProcessConditionalOrder(next_order, v);
+			/* We jump on conditional order to the same station we are currently at. */
+			if (ord_id != INVALID_VEH_ORDER_ID && v->GetOrder(ord_id)->index == order->index) {
+				return true;
+			}
+		}
+	}
+
+	return false;
+}
+
+/**
  * Loads/unload the vehicle if possible.
  * @param front the vehicle to be (un)loaded
  * @param cargo_left the amount of each cargo type that is
@@ -1252,10 +1373,12 @@
  *                   picked up by another vehicle when all
  *                   previous vehicles have loaded.
  */
-static void LoadUnloadVehicle(Vehicle *front, int *cargo_left)
+static void LoadUnloadVehicle(Vehicle *front, StationCargoList::OrderMap (&cargo_left)[NUM_CARGO])
 {
 	assert(front->current_order.IsType(OT_LOADING));
 
+	OrderID last_order = front->last_order_id;
+
 	/* We have not waited enough time till the next round of loading/unloading */
 	if (front->load_unload_ticks != 0) {
 		if (_settings_game.order.improved_load && (front->current_order.GetLoadType() & OLFB_FULL_LOAD)) {
@@ -1263,7 +1386,15 @@
 			for (Vehicle *v = front; v != NULL; v = v->Next()) {
 				int cap_left = v->cargo_cap;
 				if (!HasBit(v->vehicle_flags, VF_CARGO_UNLOADING)) cap_left -= v->cargo.Count();
-				if (cap_left > 0) cargo_left[v->cargo_type] -= cap_left;
+				if (cap_left > 0) {
+					/* Try the bucket for our next destination first. */
+					int loaded = min(cap_left, cargo_left[v->cargo_type][last_order]);
+					cargo_left[v->cargo_type][last_order] -= loaded;
+
+					/* Reserve from the common bucket if still space left. */
+					loaded = min(cap_left - loaded, cargo_left[v->cargo_type][INVALID_ORDER]);
+					cargo_left[v->cargo_type][INVALID_ORDER] -= loaded;
+				}
 			}
 		}
 		return;
@@ -1348,15 +1479,44 @@
 			uint amount_unloaded = _settings_game.order.gradual_loading ? min(cargo_count, load_amount) : cargo_count;
 			bool remaining = false; // Are there cargo entities in this vehicle that can still be unloaded here?
 			bool accepted  = false; // Is the cargo accepted by the station?
+			bool did_transfer = false;
 
 			payment->SetCargo(v->cargo_type);
 
-			if (HasBit(ge->acceptance_pickup, GoodsEntry::GES_ACCEPTANCE) && !(front->current_order.GetUnloadType() & OUFB_TRANSFER)) {
-				/* The cargo has reached its final destination, the packets may now be destroyed */
-				remaining = v->cargo.MoveTo<StationCargoList>(NULL, amount_unloaded, VehicleCargoList::MTA_FINAL_DELIVERY, payment, last_visited);
+			if (CargoHasDestinations(v->cargo_type)) {
+				/* This cargo type has destinations enabled, this means explicit transfer
+				 * orders are overridden for cargo packets with destination.
+				 * Default action for destination-less cargo packets is final delivery when
+				 * accepted, otherwise no action. If the current order is forced unload,
+				 * always unload all cargo. */
+				VehicleCargoList::MoveToAction mta = HasBit(ge->acceptance_pickup, GoodsEntry::GES_ACCEPTANCE) ? VehicleCargoList::MTA_FINAL_DELIVERY : VehicleCargoList::MTA_NO_ACTION;
+				if (front->current_order.GetUnloadType() & OUFB_UNLOAD) mta = VehicleCargoList::MTA_UNLOAD; //front was u
+				remaining = v->cargo.MoveTo(&ge->cargo, amount_unloaded, mta, payment, last_visited, last_order, v->cargo_type, &did_transfer);
 
 				dirty_vehicle = true;
 				accepted = true;
+			} else {
+				/* Cargo destinations are not enabled, handle transfer orders. */
+				if (HasBit(ge->acceptance_pickup, GoodsEntry::GES_ACCEPTANCE) && !(front->current_order.GetUnloadType() & OUFB_TRANSFER)) { //front was u
+					/* The cargo has reached its final destination, the packets may now be destroyed */
+					remaining = v->cargo.MoveTo<StationCargoList>(NULL, amount_unloaded, VehicleCargoList::MTA_FINAL_DELIVERY, payment, last_visited, v->cargo_type);
+
+					dirty_vehicle = true;
+					accepted = true;
+				}
+
+				/* The !accepted || v->cargo.Count == cargo_count clause is there
+				 * to make it possible to force unload vehicles at the station where
+				 * they were loaded, but to not force unload the vehicle when the
+				 * station is still accepting the cargo in the vehicle. It doesn't
+				 * accept cargo that was loaded at the same station. */
+				if ((front->current_order.GetUnloadType() & (OUFB_UNLOAD | OUFB_TRANSFER)) && (!accepted || v->cargo.Count() == cargo_count)) { //front was u
+					remaining = v->cargo.MoveTo(&ge->cargo, amount_unloaded, front->current_order.GetUnloadType() & OUFB_TRANSFER ? VehicleCargoList::MTA_TRANSFER : VehicleCargoList::MTA_UNLOAD, payment, last_visited, v->cargo_type); //front was u
+
+					did_transfer = true;
+					dirty_vehicle = true;
+					accepted = true;
+				}
 			}
 
 			/* The !accepted || v->cargo.Count == cargo_count clause is there
@@ -1364,15 +1524,15 @@
 			 * they were loaded, but to not force unload the vehicle when the
 			 * station is still accepting the cargo in the vehicle. It doesn't
 			 * accept cargo that was loaded at the same station. */
-			if ((front->current_order.GetUnloadType() & (OUFB_UNLOAD | OUFB_TRANSFER)) && (!accepted || v->cargo.Count() == cargo_count)) {
-				remaining = v->cargo.MoveTo(&ge->cargo, amount_unloaded, front->current_order.GetUnloadType() & OUFB_TRANSFER ? VehicleCargoList::MTA_TRANSFER : VehicleCargoList::MTA_UNLOAD, payment);
+			if (did_transfer) {
+				/* Update station information. */
 				if (!HasBit(ge->acceptance_pickup, GoodsEntry::GES_PICKUP)) {
 					SetBit(ge->acceptance_pickup, GoodsEntry::GES_PICKUP);
 					InvalidateWindowData(WC_STATION_LIST, last_visited);
 				}
-
-				dirty_vehicle = dirty_station = true;
-			} else if (!accepted) {
+				dirty_station = true;
+			}
+			if (!accepted) {
 				/* The order changed while unloading (unset unload/transfer) or the
 				 * station does not accept our goods. */
 				ClrBit(v->vehicle_flags, VF_CARGO_UNLOADING);
@@ -1436,13 +1596,13 @@
 				FOR_EACH_SET_CARGO_ID(cid, refit_mask) {
 					/* Consider refitting to this cargo, if other vehicles of the consist cannot
 					 * already take the cargo without refitting */
-					if (cargo_left[cid] > (int)consist_capleft[cid] + amount) {
+					if (cargo_left[cid][last_order] + cargo_left[cid][INVALID_ORDER] > (int)consist_capleft[cid] + amount) {
 						/* Try to find out if auto-refitting would succeed. In case the refit is allowed,
 						 * the returned refit capacity will be greater than zero. */
 						new_subtype = GetBestFittingSubType(v, v, cid);
 						DoCommand(v_start->tile, v_start->index, cid | 1U << 6 | new_subtype << 8 | 1U << 16, DC_QUERY_COST, GetCmdRefitVeh(v_start)); // Auto-refit and only this vehicle including artic parts.
 						if (_returned_refit_capacity > 0) {
-							amount = cargo_left[cid] - consist_capleft[cid];
+							amount = cargo_left[cid][last_order] + cargo_left[cid][INVALID_ORDER] - consist_capleft[cid];
 							new_cid = cid;
 						}
 					}
@@ -1495,11 +1655,12 @@
 		int cap_left = v->cargo_cap - v->cargo.Count();
 		if (!ge->cargo.Empty() && cap_left > 0) {
 			uint cap = cap_left;
-			uint count = ge->cargo.Count();
+			uint count = ge->cargo.CountForNextHop(last_order) + ge->cargo.CountForNextHop(INVALID_ORDER);
 
 			/* Skip loading this vehicle if another train/vehicle is already handling
-			 * the same cargo type at this station */
-			if (_settings_game.order.improved_load && cargo_left[v->cargo_type] <= 0) {
+			 * the same cargo type at this station. Check the buckets for our next
+			 * destination and the general bucket. */
+			if (_settings_game.order.improved_load && cargo_left[v->cargo_type][last_order] <= 0 && cargo_left[v->cargo_type][INVALID_ORDER] <= 0) {
 				SetBit(cargo_not_full, v->cargo_type);
 				continue;
 			}
@@ -1511,14 +1672,23 @@
 			}
 			if (_settings_game.order.improved_load) {
 				/* Don't load stuff that is already 'reserved' for other vehicles */
-				cap = min((uint)cargo_left[v->cargo_type], cap);
-				count = cargo_left[v->cargo_type];
+				count = cargo_left[v->cargo_type][last_order] + cargo_left[v->cargo_type][INVALID_ORDER];
+
+				/* Try the bucket for our next destination first. */
+				int load_next = min<uint>(cap, cargo_left[v->cargo_type][last_order]);
+
+				/* Reserve from the common bucket if still space left. */
+				int load_common = min<uint>(cap - load_next, cargo_left[v->cargo_type][INVALID_ORDER]);
+
+				cap = load_next + load_common;
+				cargo_left[v->cargo_type][last_order] -= load_next;
+
 				if (use_autorefit) {
 					/* When using autorefit, reserve all cargo for this wagon to prevent other wagons
 					 * from feeling the need to refit. */
-					uint total_cap_left = v->cargo_cap - v->cargo.Count();
-					cargo_left[v->cargo_type] -= total_cap_left;
+					uint total_cap_left = v->cargo_cap - v->cargo.Count() - load_common;
 					consist_capleft[v->cargo_type] -= total_cap_left;
+					cargo_left[v->cargo_type][INVALID_ORDER] -= total_cap_left;
 					if (total_cap_left > cap && count > cap) {
 						/* Remember if there are reservations left so that we don't stop
 						 * loading before they're loaded. */
@@ -1527,7 +1697,7 @@
 				} else {
 					/* Update cargo left; but don't reserve everything yet, so other wagons
 					 * of the same consist load in parallel. */
-					cargo_left[v->cargo_type] -= cap;
+					cargo_left[v->cargo_type][INVALID_ORDER] -= load_common;
 				}
 			}
 
@@ -1550,7 +1720,7 @@
 			completely_emptied = false;
 			anything_loaded = true;
 
-			ge->cargo.MoveTo(&v->cargo, cap, StationCargoList::MTA_CARGO_LOAD, NULL, st->xy);
+			ge->cargo.MoveTo(&v->cargo, cap, StationCargoList::MTA_CARGO_LOAD, NULL, last_visited, last_order, v->cargo_type);
 
 			st->time_since_load = 0;
 			st->last_vehicle_type = v->type;
@@ -1594,20 +1764,29 @@
 		for (Vehicle *v = front; v != NULL; v = v->Next()) {
 			int cap_left = v->cargo_cap;
 			if (!HasBit(v->vehicle_flags, VF_CARGO_UNLOADING)) {
-				if (use_autorefit) {
+				if ( use_autorefit || VehicleStayConditional(front) )  {
 					continue;
 				} else {
 					cap_left -= v->cargo.Count();
 				}
 			}
-			if (cap_left > 0) cargo_left[v->cargo_type] -= cap_left;
+			if (cap_left > 0) {
+				/* Try the bucket for our next destination first. */
+				int loaded = min(cap_left, cargo_left[v->cargo_type][last_order]);
+				cargo_left[v->cargo_type][last_order] -= loaded;
+
+				/* Reserve from the common bucket if still space left. */
+				loaded = min(cap_left - loaded, cargo_left[v->cargo_type][INVALID_ORDER]);
+				cargo_left[v->cargo_type][INVALID_ORDER] -= loaded;
+			}
 		}
 	}
 
 	if (!anything_unloaded) delete payment;
 
 	ClrBit(front->vehicle_flags, VF_STOP_LOADING);
-	if (anything_loaded || anything_unloaded) {
+	const bool condition_stay = VehicleStayConditional(front);
+	if (!condition_stay && (anything_loaded || anything_unloaded)) {
 		if (_settings_game.order.gradual_loading) {
 			/* The time it takes to load one 'slice' of cargo or passengers depends
 			 * on the vehicle type - the values here are those found in TTDPatch */
@@ -1621,7 +1800,7 @@
 				front->current_order_time >= (uint)max(front->current_order.wait_time - front->lateness_counter, 0)) {
 			SetBit(front->vehicle_flags, VF_STOP_LOADING);
 		}
-	} else {
+	} else if (!condition_stay) {
 		bool finished_loading = true;
 		if (front->current_order.GetLoadType() & OLFB_FULL_LOAD) {
 			if (front->current_order.GetLoadType() == OLF_FULL_LOAD_ANY) {
@@ -1637,7 +1816,7 @@
 		}
 		unloading_time = 20;
 
-		SB(front->vehicle_flags, VF_LOADING_FINISHED, 1, finished_loading);
+		if (finished_loading) SetBit(front->vehicle_flags, VF_LOADING_FINISHED);
 	}
 
 	if (front->type == VEH_TRAIN) {
@@ -1718,9 +1897,10 @@
 	 */
 	if (last_loading == NULL) return;
 
-	int cargo_left[NUM_CARGO];
-
-	for (uint i = 0; i < NUM_CARGO; i++) cargo_left[i] = st->goods[i].cargo.Count();
+	StationCargoList::OrderMap cargo_left[NUM_CARGO];
+	for (CargoID i = 0; i < NUM_CARGO; i++) {
+		cargo_left[i] = st->goods[i].cargo.CountForNextHop();
+	}
 
 	for (iter = st->loading_vehicles.begin(); iter != st->loading_vehicles.end(); ++iter) {
 		Vehicle *v = *iter;
diff -urNad openttd-1.3.2/src/economy_func.h openttd-1.3.2-DC3.0RC3/src/economy_func.h
--- openttd-1.3.2/src/economy_func.h	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/economy_func.h	2013-11-22 05:49:07.000000000 +0100
@@ -21,17 +21,18 @@
 void ResetPriceBaseMultipliers();
 void SetPriceBaseMultiplier(Price price, int factor);
 
-extern const ScoreInfo _score_info[];
+extern ScoreInfo _score_info[];
 extern int _score_part[MAX_COMPANIES][SCORE_END];
 extern Economy _economy;
 /* Prices and also the fractional part. */
 extern Prices _price;
 
 int UpdateCompanyRatingAndValue(Company *c, bool update);
+bool InitializeGraphPerformance(int32 p1 = 0);
 void StartupIndustryDailyChanges(bool init_counter);
 
 Money GetTransportedGoodsIncome(uint num_pieces, uint dist, byte transit_days, CargoID cargo_type);
-uint MoveGoodsToStation(CargoID type, uint amount, SourceType source_type, SourceID source_id, const StationList *all_stations);
+uint MoveGoodsToStation(CargoID type, uint amount, SourceType source_type, SourceID source_id, const StationList *all_stations, TileIndex src_tile);
 
 void PrepareUnload(Vehicle *front_v);
 void LoadUnloadStation(Station *st);
diff -urNad openttd-1.3.2/src/economy_type.h openttd-1.3.2-DC3.0RC3/src/economy_type.h
--- openttd-1.3.2/src/economy_type.h	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/economy_type.h	2013-11-22 05:49:07.000000000 +0100
@@ -28,6 +28,7 @@
 	uint32 industry_daily_increment;      ///< The value which will increment industry_daily_change_counter. Computed value. NOSAVE
 	uint64 inflation_prices;              ///< Cumulated inflation of prices since game start; 16 bit fractional part
 	uint64 inflation_payment;             ///< Cumulated inflation of cargo paypent since game start; 16 bit fractional part
+	Money industry_helper;
 
 	/* Old stuff for savegame conversion only */
 	Money old_max_loan_unround;           ///< Old: Unrounded max loan
@@ -154,6 +155,7 @@
 	EXPENSES_ROADVEH_RUN,         ///< Running costs road vehicles.
 	EXPENSES_AIRCRAFT_RUN,        ///< Running costs aircrafts.
 	EXPENSES_SHIP_RUN,            ///< Running costs ships.
+	EXPENSES_LOST_RUN,            ///< Lost passengers costs.
 	EXPENSES_PROPERTY,            ///< Property costs.
 	EXPENSES_TRAIN_INC,           ///< Income from trains.
 	EXPENSES_ROADVEH_INC,         ///< Income from road vehicles.
@@ -161,6 +163,8 @@
 	EXPENSES_SHIP_INC,            ///< Income from ships.
 	EXPENSES_LOAN_INT,            ///< Interest payments over the loan.
 	EXPENSES_OTHER,               ///< Other expenses.
+	EXPENSES_SHARING_COST,        ///< Infrastructure sharing costs
+	EXPENSES_SHARING_INC,         ///< Infrastructure sharing income
 	EXPENSES_END,                 ///< Number of expense types.
 	INVALID_EXPENSES      = 0xFF, ///< Invalid expense type.
 };
@@ -184,6 +188,22 @@
 	Price fallback_price;   ///< Fallback price multiplier for new prices but old grfs.
 };
 
+/* Default needed values for score */
+#define SCORE_MIN_PROFIT_NEEDED    10000
+#define SCORE_MIN_INCOME_NEEDED    50000
+#define SCORE_MAX_INCOME_NEEDED    100000
+#define SCORE_DELIVERED_NEEDED     40000
+#define SCORE_MONEY_NEEDED         10000000
+
+enum DayLengthBalanceType {
+	DBT_NONE = 0,   ///< no balancing for day length
+	DBT_RUN_COST,   ///< balancing running cost
+	DBT_ALL_COSTS,  ///< balancing all costs
+	DBT_PAYMENTS,   ///< balancing payments
+
+	DBT_NUM,
+};
+
 /** The "steps" in loan size, in British Pounds! */
 static const int LOAN_INTERVAL = 10000;
 
diff -urNad openttd-1.3.2/src/engine.cpp openttd-1.3.2-DC3.0RC3/src/engine.cpp
--- openttd-1.3.2/src/engine.cpp	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/engine.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -312,6 +312,12 @@
 
 		default: NOT_REACHED();
 	}
+       /* Multiply showed running cost according to day length balance type. */
+       if (_settings_game.economy.day_length_balance_type == DBT_ALL_COSTS ||
+               _settings_game.economy.day_length_balance_type == DBT_RUN_COST)
+       {
+               return GetPrice(base_price, cost_factor, this->GetGRF(), -8) * _settings_game.economy.day_length_balance_factor;
+       }
 
 	return GetPrice(base_price, cost_factor, this->GetGRF(), -8);
 }
@@ -352,6 +358,10 @@
 
 		default: NOT_REACHED();
 	}
+       /* Multiply showed cost according to day length balance type. */
+       if (_settings_game.economy.day_length_balance_type == DBT_ALL_COSTS) {
+               return GetPrice(base_price, cost_factor, this->GetGRF(), -8) * _settings_game.economy.day_length_balance_factor;
+       }
 
 	return GetPrice(base_price, cost_factor, this->GetGRF(), -8);
 }
diff -urNad openttd-1.3.2/src/fios.h openttd-1.3.2-DC3.0RC3/src/fios.h
--- openttd-1.3.2/src/fios.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/fios.h	2013-11-22 05:49:07.000000000 +0100
@@ -91,9 +91,11 @@
 	/** First slot usable for (New)GRFs used during the game. */
 	FIRST_GRF_SLOT =  2,
 	/** Last slot usable for (New)GRFs used during the game. */
-	LAST_GRF_SLOT  = 63,
+	LAST_GRF_SLOT  = 255,
 	/** Maximum number of slots. */
-	MAX_FILE_SLOTS = 64
+	MAX_FILE_SLOTS = 256,
+       /** Maximum number of slots for network game */
+       MAX_FILE_SLOTS_IN_NETWORK = 63
 };
 
 /** Mode of the file dialogue window. */
diff -urNad openttd-1.3.2/src/genworld.cpp openttd-1.3.2-DC3.0RC3/src/genworld.cpp
--- openttd-1.3.2/src/genworld.cpp	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/genworld.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -29,6 +29,7 @@
 #include "newgrf.h"
 #include "core/random_func.hpp"
 #include "core/backup_type.hpp"
+#include "cargodest_func.h"
 #include "progress.h"
 #include "error.h"
 #include "game/game.hpp"
@@ -138,6 +139,7 @@
 				GenerateIndustries();
 				GenerateObjects();
 				GenerateTrees();
+				UpdateCargoLinks();
 			}
 		}
 
diff -urNad openttd-1.3.2/src/genworld_gui.cpp openttd-1.3.2-DC3.0RC3/src/genworld_gui.cpp
--- openttd-1.3.2/src/genworld_gui.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/genworld_gui.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -20,6 +20,7 @@
 #include "sound_func.h"
 #include "fios.h"
 #include "string_func.h"
+#include "gui.h"
 #include "widgets/dropdown_type.h"
 #include "widgets/dropdown_func.h"
 #include "querystring_gui.h"
@@ -29,6 +30,7 @@
 #include "core/random_func.hpp"
 #include "progress.h"
 #include "error.h"
+#include "tile_map.h"
 
 #include "widgets/genworld_widget.h"
 
@@ -82,10 +84,10 @@
 					NWidget(WWT_TEXT, COLOUR_ORANGE), SetDataTip(STR_MAPGEN_LAND_GENERATOR, STR_NULL), SetFill(1, 1),
 					NWidget(WWT_TEXT, COLOUR_ORANGE), SetDataTip(STR_MAPGEN_NUMBER_OF_TOWNS, STR_NULL), SetFill(1, 1),
 					NWidget(WWT_TEXT, COLOUR_ORANGE), SetDataTip(STR_MAPGEN_TERRAIN_TYPE, STR_NULL), SetFill(1, 1),
+					NWidget(WWT_TEXT, COLOUR_ORANGE), SetDataTip(STR_MAPGEN_VARIETY, STR_NULL), SetFill(1, 1),
 					NWidget(WWT_TEXT, COLOUR_ORANGE), SetDataTip(STR_MAPGEN_RANDOM_SEED, STR_NULL), SetFill(1, 1),
 					NWidget(WWT_TEXT, COLOUR_ORANGE), SetDataTip(STR_MAPGEN_QUANTITY_OF_SEA_LAKES, STR_NULL), SetFill(1, 1),
 					NWidget(WWT_TEXT, COLOUR_ORANGE), SetDataTip(STR_MAPGEN_TREE_PLACER, STR_NULL), SetFill(1, 1),
-					NWidget(WWT_TEXT, COLOUR_ORANGE), SetDataTip(STR_MAPGEN_VARIETY, STR_NULL), SetFill(1, 1),
 					NWidget(WWT_TEXT, COLOUR_ORANGE), SetDataTip(STR_MAPGEN_BORDER_TYPE, STR_NULL), SetFill(1, 1),
 				EndContainer(),
 				/* Widgets at the right of the labels. */
@@ -99,34 +101,41 @@
 					NWidget(WWT_DROPDOWN, COLOUR_ORANGE, WID_GL_LANDSCAPE_PULLDOWN), SetDataTip(STR_JUST_STRING, STR_NULL), SetFill(1, 0),
 					NWidget(WWT_DROPDOWN, COLOUR_ORANGE, WID_GL_TOWN_PULLDOWN), SetDataTip(STR_JUST_STRING, STR_NULL), SetFill(1, 0),
 					NWidget(WWT_DROPDOWN, COLOUR_ORANGE, WID_GL_TERRAIN_PULLDOWN), SetDataTip(STR_JUST_STRING, STR_NULL), SetFill(1, 0),
+					NWidget(WWT_DROPDOWN, COLOUR_ORANGE, WID_GL_VARIETY_PULLDOWN), SetDataTip(STR_JUST_STRING, STR_NULL), SetFill(1, 0),
 					NWidget(WWT_EDITBOX, COLOUR_ORANGE, WID_GL_RANDOM_EDITBOX), SetDataTip(STR_MAPGEN_RANDOM_SEED_OSKTITLE, STR_MAPGEN_RANDOM_SEED_HELP), SetFill(1, 1),
 					NWidget(WWT_DROPDOWN, COLOUR_ORANGE, WID_GL_WATER_PULLDOWN), SetDataTip(STR_JUST_STRING, STR_NULL), SetFill(1, 0),
 					NWidget(WWT_DROPDOWN, COLOUR_ORANGE, WID_GL_TREE_PULLDOWN), SetDataTip(STR_JUST_STRING, STR_NULL), SetFill(1, 0),
-					NWidget(WWT_DROPDOWN, COLOUR_ORANGE, WID_GL_VARIETY_PULLDOWN), SetDataTip(STR_JUST_STRING, STR_NULL), SetFill(1, 0),
 					NWidget(WWT_TEXTBTN, COLOUR_ORANGE, WID_GL_BORDERS_RANDOM), SetDataTip(STR_JUST_STRING, STR_NULL), SetFill(1, 0),
 				EndContainer(),
 			EndContainer(),
 			NWidget(NWID_VERTICAL), SetPIP(0, 4, 0),
 				NWidget(NWID_HORIZONTAL), SetPIP(0, 3, 0),
 					NWidget(NWID_VERTICAL, NC_EQUALSIZE), SetPIP(0, 4, 0),
-						NWidget(WWT_TEXT, COLOUR_ORANGE), SetDataTip(STR_MAPGEN_DATE, STR_NULL), SetFill(1, 1),
+						NWidget(WWT_TEXT, COLOUR_ORANGE), SetDataTip(STR_MAPGEN_MAX_HEIGHTLEVEL, STR_NULL), SetFill(1, 1),
 						NWidget(WWT_TEXT, COLOUR_ORANGE), SetDataTip(STR_MAPGEN_SNOW_LINE_HEIGHT, STR_NULL), SetFill(1, 1),
+						NWidget(WWT_TEXT, COLOUR_ORANGE), SetDataTip(STR_MAPGEN_DATE, STR_NULL), SetFill(1, 1),
 						NWidget(WWT_TEXT, COLOUR_ORANGE), SetDataTip(STR_MAPGEN_NUMBER_OF_INDUSTRIES, STR_NULL), SetFill(1, 1),
 						NWidget(WWT_TEXT, COLOUR_ORANGE), SetDataTip(STR_MAPGEN_SMOOTHNESS, STR_NULL), SetFill(1, 1),
 					EndContainer(),
 					NWidget(NWID_VERTICAL, NC_EQUALSIZE), SetPIP(0, 4, 0),
-						/* Starting date. */
+						/* Max. heightlevel. */
 						NWidget(NWID_HORIZONTAL),
-							NWidget(WWT_IMGBTN, COLOUR_ORANGE, WID_GL_START_DATE_DOWN), SetDataTip(SPR_ARROW_DOWN, STR_SCENEDIT_TOOLBAR_TOOLTIP_MOVE_THE_STARTING_DATE_BACKWARD), SetFill(0, 1),
-							NWidget(WWT_PUSHTXTBTN, COLOUR_ORANGE, WID_GL_START_DATE_TEXT), SetDataTip(STR_BLACK_DATE_LONG, STR_NULL), SetFill(1, 0),
-							NWidget(WWT_IMGBTN, COLOUR_ORANGE, WID_GL_START_DATE_UP), SetDataTip(SPR_ARROW_UP, STR_SCENEDIT_TOOLBAR_TOOLTIP_MOVE_THE_STARTING_DATE_FORWARD), SetFill(0, 1),
+							NWidget(WWT_IMGBTN, COLOUR_ORANGE, WID_GL_MAX_HEIGHTLEVEL_DOWN), SetDataTip(SPR_ARROW_DOWN, STR_MAPGEN_MAX_HEIGHTLEVEL_DOWN), SetFill(0, 1),
+							NWidget(WWT_TEXTBTN, COLOUR_ORANGE, WID_GL_MAX_HEIGHTLEVEL_TEXT), SetDataTip(STR_BLACK_INT, STR_NULL), SetFill(1, 0),
+							NWidget(WWT_IMGBTN, COLOUR_ORANGE, WID_GL_MAX_HEIGHTLEVEL_UP), SetDataTip(SPR_ARROW_UP, STR_MAPGEN_MAX_HEIGHTLEVEL_UP), SetFill(0, 1),
 						EndContainer(),
 						/* Snow line. */
 						NWidget(NWID_HORIZONTAL),
 							NWidget(WWT_IMGBTN, COLOUR_ORANGE, WID_GL_SNOW_LEVEL_DOWN), SetDataTip(SPR_ARROW_DOWN, STR_MAPGEN_SNOW_LINE_DOWN), SetFill(0, 1),
-							NWidget(WWT_PUSHTXTBTN, COLOUR_ORANGE, WID_GL_SNOW_LEVEL_TEXT), SetDataTip(STR_BLACK_INT, STR_NULL), SetFill(1, 0),
+							NWidget(WWT_TEXTBTN, COLOUR_ORANGE, WID_GL_SNOW_LEVEL_TEXT), SetDataTip(STR_BLACK_INT, STR_NULL), SetFill(1, 0),
 							NWidget(WWT_IMGBTN, COLOUR_ORANGE, WID_GL_SNOW_LEVEL_UP), SetDataTip(SPR_ARROW_UP, STR_MAPGEN_SNOW_LINE_UP), SetFill(0, 1),
 						EndContainer(),
+						/* Starting date. */
+						NWidget(NWID_HORIZONTAL),
+							NWidget(WWT_IMGBTN, COLOUR_ORANGE, WID_GL_START_DATE_DOWN), SetDataTip(SPR_ARROW_DOWN, STR_SCENEDIT_TOOLBAR_TOOLTIP_MOVE_THE_STARTING_DATE_BACKWARD), SetFill(0, 1),
+							NWidget(WWT_PUSHTXTBTN, COLOUR_ORANGE, WID_GL_START_DATE_TEXT), SetDataTip(STR_BLACK_DATE_LONG, STR_NULL), SetFill(1, 0),
+							NWidget(WWT_IMGBTN, COLOUR_ORANGE, WID_GL_START_DATE_UP), SetDataTip(SPR_ARROW_UP, STR_SCENEDIT_TOOLBAR_TOOLTIP_MOVE_THE_STARTING_DATE_FORWARD), SetFill(0, 1),
+						EndContainer(),
 						NWidget(WWT_DROPDOWN, COLOUR_ORANGE, WID_GL_INDUSTRY_PULLDOWN), SetDataTip(STR_JUST_STRING, STR_NULL), SetFill(1, 0),
 						NWidget(WWT_DROPDOWN, COLOUR_ORANGE, WID_GL_SMOOTHNESS_PULLDOWN), SetDataTip(STR_JUST_STRING, STR_NULL), SetFill(1, 0),
 					EndContainer(),
@@ -197,12 +206,12 @@
 			NWidget(NWID_VERTICAL, NC_EQUALSIZE), SetPIP(0, 4, 0),
 				NWidget(WWT_TEXT, COLOUR_ORANGE), SetDataTip(STR_MAPGEN_HEIGHTMAP_NAME, STR_NULL), SetFill(1, 1),
 				NWidget(WWT_TEXT, COLOUR_ORANGE), SetDataTip(STR_MAPGEN_MAPSIZE, STR_NULL), SetFill(1, 1),
+				NWidget(WWT_TEXT, COLOUR_ORANGE), SetDataTip(STR_MAPGEN_HEIGHTMAP_ROTATION, STR_NULL), SetFill(1, 1),
 				NWidget(WWT_TEXT, COLOUR_ORANGE), SetDataTip(STR_MAPGEN_NUMBER_OF_TOWNS, STR_NULL), SetFill(1, 1),
 				NWidget(WWT_TEXT, COLOUR_ORANGE), SetDataTip(STR_MAPGEN_NUMBER_OF_INDUSTRIES, STR_NULL), SetFill(1, 1),
 				NWidget(WWT_TEXT, COLOUR_ORANGE), SetDataTip(STR_MAPGEN_RANDOM_SEED, STR_NULL), SetFill(1, 1),
 				NWidget(WWT_TEXT, COLOUR_ORANGE), SetDataTip(STR_MAPGEN_QUANTITY_OF_RIVERS, STR_NULL), SetFill(1, 1),
 				NWidget(WWT_TEXT, COLOUR_ORANGE), SetDataTip(STR_MAPGEN_TREE_PLACER, STR_NULL), SetFill(1, 1),
-				NWidget(WWT_TEXT, COLOUR_ORANGE), SetDataTip(STR_MAPGEN_HEIGHTMAP_ROTATION, STR_NULL), SetFill(1, 1),
 			EndContainer(),
 			/* Widgets at the right of the labels. */
 			NWidget(NWID_VERTICAL), SetPIP(0, 4, 0),
@@ -215,32 +224,38 @@
 							NWidget(WWT_TEXT, COLOUR_ORANGE), SetDataTip(STR_MAPGEN_BY, STR_NULL), SetPadding(1, 0, 0, 0), SetFill(1, 1),
 							NWidget(WWT_DROPDOWN, COLOUR_ORANGE, WID_GL_MAPSIZE_Y_PULLDOWN), SetDataTip(STR_JUST_INT, STR_NULL), SetFill(1, 0),
 						EndContainer(),
+						NWidget(WWT_DROPDOWN, COLOUR_ORANGE, WID_GL_HEIGHTMAP_ROTATION_PULLDOWN), SetDataTip(STR_JUST_STRING, STR_NULL), SetFill(1, 0),
 						NWidget(WWT_DROPDOWN, COLOUR_ORANGE, WID_GL_TOWN_PULLDOWN), SetDataTip(STR_JUST_STRING, STR_NULL), SetFill(1, 0),
 						NWidget(WWT_DROPDOWN, COLOUR_ORANGE, WID_GL_INDUSTRY_PULLDOWN), SetDataTip(STR_JUST_STRING, STR_NULL), SetFill(1, 0),
 						NWidget(WWT_EDITBOX, COLOUR_ORANGE, WID_GL_RANDOM_EDITBOX), SetDataTip(STR_MAPGEN_RANDOM_SEED_OSKTITLE, STR_MAPGEN_RANDOM_SEED_HELP), SetFill(1, 1),
 						NWidget(WWT_DROPDOWN, COLOUR_ORANGE, WID_GL_RIVER_PULLDOWN), SetDataTip(STR_JUST_STRING, STR_NULL), SetFill(1, 0),
 						NWidget(WWT_DROPDOWN, COLOUR_ORANGE, WID_GL_TREE_PULLDOWN), SetDataTip(STR_JUST_STRING, STR_NULL), SetFill(1, 0),
-						NWidget(WWT_DROPDOWN, COLOUR_ORANGE, WID_GL_HEIGHTMAP_ROTATION_PULLDOWN), SetDataTip(STR_JUST_STRING, STR_NULL), SetFill(1, 0),
 					EndContainer(),
 					NWidget(NWID_VERTICAL), SetPIP(0, 4, 0),
 						NWidget(NWID_HORIZONTAL), SetPIP(0, 3, 0),
 							NWidget(NWID_VERTICAL, NC_EQUALSIZE), SetPIP(0, 4, 0),
 								NWidget(WWT_TEXT, COLOUR_ORANGE), SetDataTip(STR_MAPGEN_HEIGHTMAP_SIZE_LABEL, STR_NULL), SetFill(1, 1),
-								NWidget(WWT_TEXT, COLOUR_ORANGE), SetDataTip(STR_MAPGEN_DATE, STR_NULL), SetFill(1, 1),
 								NWidget(WWT_TEXT, COLOUR_ORANGE), SetDataTip(STR_MAPGEN_SNOW_LINE_HEIGHT, STR_NULL), SetFill(1, 1),
+								NWidget(WWT_TEXT, COLOUR_ORANGE), SetDataTip(STR_MAPGEN_MAX_HEIGHTLEVEL, STR_NULL), SetFill(1, 1),
+								NWidget(WWT_TEXT, COLOUR_ORANGE), SetDataTip(STR_MAPGEN_DATE, STR_NULL), SetFill(1, 1),
 							EndContainer(),
 							NWidget(NWID_VERTICAL, NC_EQUALSIZE), SetPIP(0, 4, 0),
 								NWidget(WWT_TEXT, COLOUR_ORANGE, WID_GL_HEIGHTMAP_SIZE_TEXT), SetDataTip(STR_MAPGEN_HEIGHTMAP_SIZE, STR_NULL), SetFill(1, 0),
 								NWidget(NWID_HORIZONTAL),
+									NWidget(WWT_IMGBTN, COLOUR_ORANGE, WID_GL_SNOW_LEVEL_DOWN), SetDataTip(SPR_ARROW_DOWN, STR_MAPGEN_SNOW_LINE_DOWN), SetFill(0, 1),
+									NWidget(WWT_TEXTBTN, COLOUR_ORANGE, WID_GL_SNOW_LEVEL_TEXT), SetDataTip(STR_BLACK_INT, STR_NULL), SetFill(1, 0),
+									NWidget(WWT_IMGBTN, COLOUR_ORANGE, WID_GL_SNOW_LEVEL_UP), SetDataTip(SPR_ARROW_UP, STR_MAPGEN_SNOW_LINE_UP), SetFill(0, 1),
+								EndContainer(),
+								NWidget(NWID_HORIZONTAL),
+									NWidget(WWT_IMGBTN, COLOUR_ORANGE, WID_GL_MAX_HEIGHTLEVEL_DOWN), SetDataTip(SPR_ARROW_DOWN, STR_MAPGEN_MAX_HEIGHTLEVEL_DOWN), SetFill(0, 1),
+									NWidget(WWT_TEXTBTN, COLOUR_ORANGE, WID_GL_MAX_HEIGHTLEVEL_TEXT), SetDataTip(STR_BLACK_INT, STR_NULL), SetFill(1, 0),
+									NWidget(WWT_IMGBTN, COLOUR_ORANGE, WID_GL_MAX_HEIGHTLEVEL_UP), SetDataTip(SPR_ARROW_UP, STR_MAPGEN_MAX_HEIGHTLEVEL_UP), SetFill(0, 1),
+								EndContainer(),
+								NWidget(NWID_HORIZONTAL),
 									NWidget(WWT_IMGBTN, COLOUR_ORANGE, WID_GL_START_DATE_DOWN), SetDataTip(SPR_ARROW_DOWN, STR_SCENEDIT_TOOLBAR_TOOLTIP_MOVE_THE_STARTING_DATE_BACKWARD), SetFill(0, 1),
 									NWidget(WWT_PUSHTXTBTN, COLOUR_ORANGE, WID_GL_START_DATE_TEXT), SetDataTip(STR_BLACK_DATE_LONG, STR_NULL), SetFill(1, 0),
 									NWidget(WWT_IMGBTN, COLOUR_ORANGE, WID_GL_START_DATE_UP), SetDataTip(SPR_ARROW_UP, STR_SCENEDIT_TOOLBAR_TOOLTIP_MOVE_THE_STARTING_DATE_FORWARD), SetFill(0, 1),
 								EndContainer(),
-								NWidget(NWID_HORIZONTAL),
-									NWidget(WWT_IMGBTN, COLOUR_ORANGE, WID_GL_SNOW_LEVEL_DOWN), SetDataTip(SPR_ARROW_DOWN, STR_MAPGEN_SNOW_LINE_DOWN), SetFill(0, 1),
-									NWidget(WWT_PUSHTXTBTN, COLOUR_ORANGE, WID_GL_SNOW_LEVEL_TEXT), SetDataTip(STR_BLACK_INT, STR_NULL), SetFill(1, 0),
-									NWidget(WWT_IMGBTN, COLOUR_ORANGE, WID_GL_SNOW_LEVEL_UP), SetDataTip(SPR_ARROW_UP, STR_MAPGEN_SNOW_LINE_UP), SetFill(0, 1),
-								EndContainer(),
 							EndContainer(),
 						EndContainer(),
 						NWidget(WWT_PUSHTXTBTN, COLOUR_ORANGE, WID_GL_RANDOM_BUTTON), SetDataTip(STR_MAPGEN_RANDOM, STR_MAPGEN_RANDOM_HELP), SetFill(1, 0),
@@ -277,12 +292,37 @@
 	if (confirmed) StartGeneratingLandscape((GenenerateLandscapeWindowMode)w->window_number);
 }
 
-static DropDownList *BuildMapsizeDropDown()
+/**
+ * Check if map size set lies in allowed boundaries.
+ * @param print_warning If set to true, messagebox with warning is printed out if size is outside limits.
+ * @return true if size is ok, false otherwise.
+ */
+static bool CheckMapSize(bool print_warning = true)
+{
+	uint64 tiles = 1ULL << (_settings_newgame.game_creation.map_x + _settings_newgame.game_creation.map_y);
+
+	if (_settings_newgame.game_creation.map_x + _settings_newgame.game_creation.map_y > MAX_MAP_TILES_BITS) {
+		if (print_warning) {
+			SetDParam(0, MAX_MAP_TILES);
+			SetDParam(1, tiles);
+			ShowErrorMessage(STR_MAPGEN_TOO_MANY_TILES_MESSAGE, INVALID_STRING_ID, WL_ERROR, 0, 0);
+		}
+		return false;
+	}
+	return true;
+}
+
+/**
+ * Build dropdown list with map sizes
+ * Dimension selected in the other dropdown is used to suggest which choices are 'valid'
+ * @param other_dimension Dimension specified by the second dropdown.
+ */
+static DropDownList *BuildMapsizeDropDown(int other_dimension)
 {
 	DropDownList *list = new DropDownList();
 
 	for (uint i = MIN_MAP_SIZE_BITS; i <= MAX_MAP_SIZE_BITS; i++) {
-		DropDownListParamStringItem *item = new DropDownListParamStringItem(STR_JUST_INT, i, false);
+		DropDownListParamStringItem *item = new DropDownListParamStringItem((i + other_dimension > MAX_MAP_TILES_BITS) ? STR_RED_INT : STR_JUST_INT, i, false);
 		item->SetParam(0, 1 << i);
 		list->push_back(item);
 	}
@@ -290,10 +330,10 @@
 	return list;
 }
 
-static const StringID _elevations[]  = {STR_TERRAIN_TYPE_VERY_FLAT, STR_TERRAIN_TYPE_FLAT, STR_TERRAIN_TYPE_HILLY, STR_TERRAIN_TYPE_MOUNTAINOUS, INVALID_STRING_ID};
+static const StringID _elevations[]  = {STR_TERRAIN_TYPE_EXTREMELY_FLAT, STR_TERRAIN_TYPE_VERY_FLAT, STR_TERRAIN_TYPE_FLAT, STR_TERRAIN_TYPE_BUMPY, STR_TERRAIN_TYPE_HILLY, STR_TERRAIN_TYPE_MOUNTAINOUS, STR_TERRAIN_TYPE_ALPINIST, INVALID_STRING_ID};
 static const StringID _sea_lakes[]   = {STR_SEA_LEVEL_VERY_LOW, STR_SEA_LEVEL_LOW, STR_SEA_LEVEL_MEDIUM, STR_SEA_LEVEL_HIGH, STR_SEA_LEVEL_CUSTOM, INVALID_STRING_ID};
 static const StringID _rivers[]      = {STR_RIVERS_NONE, STR_RIVERS_FEW, STR_RIVERS_MODERATE, STR_RIVERS_LOT, INVALID_STRING_ID};
-static const StringID _smoothness[]  = {STR_CONFIG_SETTING_ROUGHNESS_OF_TERRAIN_VERY_SMOOTH, STR_CONFIG_SETTING_ROUGHNESS_OF_TERRAIN_SMOOTH, STR_CONFIG_SETTING_ROUGHNESS_OF_TERRAIN_ROUGH, STR_CONFIG_SETTING_ROUGHNESS_OF_TERRAIN_VERY_ROUGH, INVALID_STRING_ID};
+static const StringID _smoothness[]  = {STR_CONFIG_SETTING_ROUGHNESS_OF_TERRAIN_VERY_SMOOTH, STR_CONFIG_SETTING_ROUGHNESS_OF_TERRAIN_SMOOTH, STR_CONFIG_SETTING_ROUGHNESS_OF_TERRAIN_ROUGH, STR_CONFIG_SETTING_ROUGHNESS_OF_TERRAIN_VERY_ROUGH, STR_CONFIG_SETTING_ROUGHNESS_OF_TERRAIN_CEREALLY_ROUGH, STR_CONFIG_SETTING_ROUGHNESS_OF_TERRAIN_COMMUTORZ, STR_CONFIG_SETTING_ROUGHNESS_OF_TERRAIN_FLOWING, INVALID_STRING_ID};
 static const StringID _tree_placer[] = {STR_CONFIG_SETTING_TREE_PLACER_NONE, STR_CONFIG_SETTING_TREE_PLACER_ORIGINAL, STR_CONFIG_SETTING_TREE_PLACER_IMPROVED, INVALID_STRING_ID};
 static const StringID _rotation[]    = {STR_CONFIG_SETTING_HEIGHTMAP_ROTATION_COUNTER_CLOCKWISE, STR_CONFIG_SETTING_HEIGHTMAP_ROTATION_CLOCKWISE, INVALID_STRING_ID};
 static const StringID _landscape[]   = {STR_CONFIG_SETTING_LAND_GENERATOR_ORIGINAL, STR_CONFIG_SETTING_LAND_GENERATOR_TERRA_GENESIS, INVALID_STRING_ID};
@@ -310,7 +350,13 @@
 	char name[64];
 	GenenerateLandscapeWindowMode mode;
 	QueryString seed_editbox;
-
+       void SetDropDownColor()
+       {
+               /* Draw sizes in mapsize selection dropdowns in red if too large size is selected */
+               bool mapsize_valid = CheckMapSize(false);
+               this->GetWidget<NWidgetCore>(WID_GL_MAPSIZE_X_PULLDOWN)->widget_data = mapsize_valid ? STR_JUST_INT : STR_RED_INT;
+               this->GetWidget<NWidgetCore>(WID_GL_MAPSIZE_Y_PULLDOWN)->widget_data = mapsize_valid ? STR_JUST_INT : STR_RED_INT;
+       }
 	GenerateLandscapeWindow(const WindowDesc *desc, WindowNumber number = 0) : seed_editbox(11)
 	{
 		this->InitNested(desc, number);
@@ -324,6 +370,8 @@
 
 		this->mode = (GenenerateLandscapeWindowMode)this->window_number;
 
+		SetDropDownColor();
+
 		/* Disable town, industry and trees in SE */
 		this->SetWidgetDisabledState(WID_GL_TOWN_PULLDOWN,     _game_mode == GM_EDITOR);
 		this->SetWidgetDisabledState(WID_GL_INDUSTRY_PULLDOWN, _game_mode == GM_EDITOR);
@@ -336,10 +384,11 @@
 	virtual void SetStringParameters(int widget) const
 	{
 		switch (widget) {
-			case WID_GL_START_DATE_TEXT:     SetDParam(0, ConvertYMDToDate(_settings_newgame.game_creation.starting_year, 0, 1)); break;
-			case WID_GL_MAPSIZE_X_PULLDOWN:  SetDParam(0, 1 << _settings_newgame.game_creation.map_x); break;
-			case WID_GL_MAPSIZE_Y_PULLDOWN:  SetDParam(0, 1 << _settings_newgame.game_creation.map_y); break;
-			case WID_GL_SNOW_LEVEL_TEXT:     SetDParam(0, _settings_newgame.game_creation.snow_line_height); break;
+			case WID_GL_START_DATE_TEXT:      SetDParam(0, ConvertYMDToDate(_settings_newgame.game_creation.starting_year, 0, 1)); break;
+			case WID_GL_MAPSIZE_X_PULLDOWN:   SetDParam(0, 1 << _settings_newgame.game_creation.map_x); break;
+			case WID_GL_MAPSIZE_Y_PULLDOWN:   SetDParam(0, 1 << _settings_newgame.game_creation.map_y); break;
+			case WID_GL_MAX_HEIGHTLEVEL_TEXT: SetDParam(0, _settings_newgame.construction.max_heightlevel); break;
+			case WID_GL_SNOW_LEVEL_TEXT:      SetDParam(0, _settings_newgame.game_creation.snow_line_height); break;
 
 			case WID_GL_TOWN_PULLDOWN:
 				if (_game_mode == GM_EDITOR) {
@@ -421,14 +470,17 @@
 					WID_GL_TERRAIN_PULLDOWN, WID_GL_WATER_PULLDOWN, WIDGET_LIST_END);
 		}
 
-		/* Disable snowline if not arctic */
-		this->SetWidgetDisabledState(WID_GL_SNOW_LEVEL_TEXT, _settings_newgame.game_creation.landscape != LT_ARCTIC);
+//		/* Disable snowline if not arctic */
+               /* Disable snowline if not arctic and not temperate with snow enabled */
+               this->SetWidgetDisabledState(WID_GL_SNOW_LEVEL_TEXT, _settings_newgame.game_creation.landscape != LT_ARCTIC && !(_settings_newgame.game_creation.landscape == LT_TEMPERATE && _settings_newgame.construction.snow_in_temperate));
 
 		/* Update availability of decreasing / increasing start date and snow level */
+		this->SetWidgetDisabledState(WID_GL_MAX_HEIGHTLEVEL_DOWN, _settings_newgame.construction.max_heightlevel <= MIN_MAX_HEIGHTLEVEL);
+		this->SetWidgetDisabledState(WID_GL_MAX_HEIGHTLEVEL_UP, _settings_newgame.construction.max_heightlevel >= MAX_MAX_HEIGHTLEVEL);
 		this->SetWidgetDisabledState(WID_GL_START_DATE_DOWN, _settings_newgame.game_creation.starting_year <= MIN_YEAR);
 		this->SetWidgetDisabledState(WID_GL_START_DATE_UP,   _settings_newgame.game_creation.starting_year >= MAX_YEAR);
-		this->SetWidgetDisabledState(WID_GL_SNOW_LEVEL_DOWN, _settings_newgame.game_creation.snow_line_height <= MIN_SNOWLINE_HEIGHT || _settings_newgame.game_creation.landscape != LT_ARCTIC);
-		this->SetWidgetDisabledState(WID_GL_SNOW_LEVEL_UP,   _settings_newgame.game_creation.snow_line_height >= MAX_SNOWLINE_HEIGHT || _settings_newgame.game_creation.landscape != LT_ARCTIC);
+               this->SetWidgetDisabledState(WID_GL_SNOW_LEVEL_DOWN, _settings_newgame.game_creation.snow_line_height <= MIN_SNOWLINE_HEIGHT || (_settings_newgame.game_creation.landscape != LT_ARCTIC && !(_settings_newgame.game_creation.landscape == LT_TEMPERATE && _settings_newgame.construction.snow_in_temperate)));
+               this->SetWidgetDisabledState(WID_GL_SNOW_LEVEL_UP,   _settings_newgame.game_creation.snow_line_height >= MAX_SNOWLINE_HEIGHT || (_settings_newgame.game_creation.landscape != LT_ARCTIC && !(_settings_newgame.game_creation.landscape == LT_TEMPERATE && _settings_newgame.construction.snow_in_temperate)));
 
 		/* Do not allow a custom sea level with the original land generator. */
 		if (_settings_newgame.game_creation.land_generator == 0 &&
@@ -442,6 +494,11 @@
 	{
 		const StringID *strs = NULL;
 		switch (widget) {
+			case WID_GL_MAX_HEIGHTLEVEL_TEXT:
+				SetDParam(0, MAX_TILE_HEIGHT);
+				*size = GetStringBoundingBox(STR_JUST_INT);
+				break;
+
 			case WID_GL_START_DATE_TEXT:
 				SetDParam(0, ConvertYMDToDate(MAX_YEAR, 0, 1));
 				*size = GetStringBoundingBox(STR_BLACK_DATE_LONG);
@@ -532,11 +589,11 @@
 				break;
 
 			case WID_GL_MAPSIZE_X_PULLDOWN: // Mapsize X
-				ShowDropDownList(this, BuildMapsizeDropDown(), _settings_newgame.game_creation.map_x, WID_GL_MAPSIZE_X_PULLDOWN);
+				ShowDropDownList(this, BuildMapsizeDropDown(_settings_newgame.game_creation.map_y), _settings_newgame.game_creation.map_x, WID_GL_MAPSIZE_X_PULLDOWN);
 				break;
 
 			case WID_GL_MAPSIZE_Y_PULLDOWN: // Mapsize Y
-				ShowDropDownList(this, BuildMapsizeDropDown(), _settings_newgame.game_creation.map_y, WID_GL_MAPSIZE_Y_PULLDOWN);
+				ShowDropDownList(this, BuildMapsizeDropDown(_settings_newgame.game_creation.map_x), _settings_newgame.game_creation.map_y, WID_GL_MAPSIZE_Y_PULLDOWN);
 				break;
 
 			case WID_GL_TOWN_PULLDOWN: // Number of towns
@@ -554,6 +611,7 @@
 				break;
 
 			case WID_GL_GENERATE_BUTTON: { // Generate
+				if (!CheckMapSize()) break;
 				/* Get rotated map size. */
 				uint map_x;
 				uint map_y;
@@ -580,6 +638,25 @@
 				break;
 			}
 
+			case WID_GL_MAX_HEIGHTLEVEL_DOWN:
+			case WID_GL_MAX_HEIGHTLEVEL_UP: // Snow line buttons
+				/* Don't allow too fast scrolling */
+				if (!(this->flags & WF_TIMEOUT) || this->timeout_timer <= 1) {
+					this->HandleButtonClick(widget);
+
+					_settings_newgame.construction.max_heightlevel = Clamp(_settings_newgame.construction.max_heightlevel + widget - WID_GL_MAX_HEIGHTLEVEL_TEXT, MIN_MAX_HEIGHTLEVEL, MAX_MAX_HEIGHTLEVEL);
+					this->InvalidateData();
+				}
+				_left_button_clicked = false;
+				break;
+
+			case WID_GL_MAX_HEIGHTLEVEL_TEXT: // Snow line text
+				this->widget_id = WID_GL_MAX_HEIGHTLEVEL_TEXT;
+				SetDParam(0, _settings_newgame.construction.max_heightlevel);
+				ShowQueryString(STR_JUST_INT, STR_MAPGEN_MAX_HEIGHTLEVEL_QUERY_CAPT, 4, this, CS_NUMERAL, QSF_ENABLE_DEFAULT);
+				break;
+
+
 			case WID_GL_START_DATE_DOWN:
 			case WID_GL_START_DATE_UP: // Year buttons
 				/* Don't allow too fast scrolling */
@@ -613,7 +690,7 @@
 			case WID_GL_SNOW_LEVEL_TEXT: // Snow line text
 				this->widget_id = WID_GL_SNOW_LEVEL_TEXT;
 				SetDParam(0, _settings_newgame.game_creation.snow_line_height);
-				ShowQueryString(STR_JUST_INT, STR_MAPGEN_SNOW_LINE_QUERY_CAPT, 3, this, CS_NUMERAL, QSF_ENABLE_DEFAULT);
+				ShowQueryString(STR_JUST_INT, STR_MAPGEN_SNOW_LINE_QUERY_CAPT, 4, this, CS_NUMERAL, QSF_ENABLE_DEFAULT);
 				break;
 
 			case WID_GL_TREE_PULLDOWN: // Tree placer
@@ -684,7 +761,7 @@
 
 	virtual void OnTimeout()
 	{
-		static const int raise_widgets[] = {WID_GL_START_DATE_DOWN, WID_GL_START_DATE_UP, WID_GL_SNOW_LEVEL_UP, WID_GL_SNOW_LEVEL_DOWN, WIDGET_LIST_END};
+		static const int raise_widgets[] = {WID_GL_MAX_HEIGHTLEVEL_DOWN, WID_GL_MAX_HEIGHTLEVEL_UP, WID_GL_START_DATE_DOWN, WID_GL_START_DATE_UP, WID_GL_SNOW_LEVEL_UP, WID_GL_SNOW_LEVEL_DOWN, WIDGET_LIST_END};
 		for (const int *widget = raise_widgets; *widget != WIDGET_LIST_END; widget++) {
 			if (this->IsWidgetLowered(*widget)) {
 				this->RaiseWidget(*widget);
@@ -707,13 +784,27 @@
 	virtual void OnDropdownSelect(int widget, int index)
 	{
 		switch (widget) {
-			case WID_GL_MAPSIZE_X_PULLDOWN:     _settings_newgame.game_creation.map_x = index; break;
-			case WID_GL_MAPSIZE_Y_PULLDOWN:     _settings_newgame.game_creation.map_y = index; break;
+			case WID_GL_MAPSIZE_X_PULLDOWN:
+				_settings_newgame.game_creation.map_x = index;
+				SetDropDownColor();
+				break;
+			case WID_GL_MAPSIZE_Y_PULLDOWN:
+				_settings_newgame.game_creation.map_y = index;
+				SetDropDownColor();
+				break;
 			case WID_GL_TREE_PULLDOWN:          _settings_newgame.game_creation.tree_placer = index; break;
 			case WID_GL_RIVER_PULLDOWN:         _settings_newgame.game_creation.amount_of_rivers = index; break;
 			case WID_GL_SMOOTHNESS_PULLDOWN:    _settings_newgame.game_creation.tgen_smoothness = index;  break;
 			case WID_GL_VARIETY_PULLDOWN:       _settings_newgame.game_creation.variety = index; break;
-			case WID_GL_LANDSCAPE_PULLDOWN:     _settings_newgame.game_creation.land_generator = index; break;
+
+			case WID_GL_LANDSCAPE_PULLDOWN:     _settings_newgame.game_creation.land_generator = index;
+				/* If original landgenerator is selected and mountainous or alpinist terrain_type was selected, revert to hilly. */
+				if ((_settings_newgame.game_creation.land_generator == 0) &&
+						(_settings_newgame.difficulty.terrain_type == 5 || _settings_newgame.difficulty.terrain_type == 6)) {
+					_settings_newgame.difficulty.terrain_type = 4;
+				}
+				break;
+
 			case WID_GL_HEIGHTMAP_ROTATION_PULLDOWN: _settings_newgame.game_creation.heightmap_rotation = index; break;
 
 			case WID_GL_TOWN_PULLDOWN:
@@ -733,6 +824,12 @@
 				GameMode old_gm = _game_mode;
 				_game_mode = GM_MENU;
 				IConsoleSetSetting("difficulty.terrain_type", index);
+				/* If landgenerator is original and mountainous or alpinist terrain_type is selected, revert to hilly. */
+				/* TODO: instead of reverting on selection, grey out selections, but where? */
+				if ((_settings_newgame.game_creation.land_generator == 0) &&
+						(_settings_newgame.difficulty.terrain_type == 5 || _settings_newgame.difficulty.terrain_type == 6)) {
+					_settings_newgame.difficulty.terrain_type = 4;
+				}
 				_game_mode = old_gm;
 				break;
 			}
@@ -764,6 +861,7 @@
 		} else {
 			/* An empty string means revert to the default */
 			switch (this->widget_id) {
+				case WID_GL_MAX_HEIGHTLEVEL_TEXT: value = DEF_MAX_HEIGHTLEVEL; break;
 				case WID_GL_START_DATE_TEXT: value = DEF_START_YEAR; break;
 				case WID_GL_SNOW_LEVEL_TEXT: value = DEF_SNOWLINE_HEIGHT; break;
 				case WID_GL_TOWN_PULLDOWN:   value = 1; break;
@@ -773,6 +871,11 @@
 		}
 
 		switch (this->widget_id) {
+			case WID_GL_MAX_HEIGHTLEVEL_TEXT:
+				this->SetWidgetDirty(WID_GL_MAX_HEIGHTLEVEL_TEXT);
+				_settings_newgame.construction.max_heightlevel = Clamp(value, MIN_MAX_HEIGHTLEVEL, MAX_MAX_HEIGHTLEVEL);
+				break;
+
 			case WID_GL_START_DATE_TEXT:
 				this->SetWidgetDirty(WID_GL_START_DATE_TEXT);
 				_settings_newgame.game_creation.starting_year = Clamp(value, MIN_YEAR, MAX_YEAR);
@@ -870,10 +973,19 @@
 {
 	uint widget_id;
 
+	void SetDropDownColor()
+	{
+		/* Draw sizes in mapsize selection dropdowns in red if too large size is selected */
+		bool mapsize_valid = CheckMapSize(false);
+		this->GetWidget<NWidgetCore>(WID_CS_MAPSIZE_X_PULLDOWN)->widget_data = mapsize_valid ? STR_JUST_INT : STR_RED_INT;
+		this->GetWidget<NWidgetCore>(WID_CS_MAPSIZE_Y_PULLDOWN)->widget_data = mapsize_valid ? STR_JUST_INT : STR_RED_INT;
+	}
+
 	CreateScenarioWindow(const WindowDesc *desc, WindowNumber window_number) : Window()
 	{
 		this->InitNested(desc, window_number);
 		this->LowerWidget(_settings_newgame.game_creation.landscape + WID_CS_TEMPERATE);
+		SetDropDownColor();
 	}
 
 	virtual void SetStringParameters(int widget) const
@@ -897,6 +1009,8 @@
 		}
 	}
 
+
+
 	virtual void OnPaint()
 	{
 		this->SetWidgetDisabledState(WID_CS_START_DATE_DOWN,       _settings_newgame.game_creation.starting_year <= MIN_YEAR);
@@ -950,18 +1064,20 @@
 				break;
 
 			case WID_CS_MAPSIZE_X_PULLDOWN: // Mapsize X
-				ShowDropDownList(this, BuildMapsizeDropDown(), _settings_newgame.game_creation.map_x, WID_CS_MAPSIZE_X_PULLDOWN);
+				ShowDropDownList(this, BuildMapsizeDropDown(_settings_newgame.game_creation.map_y), _settings_newgame.game_creation.map_x, WID_CS_MAPSIZE_X_PULLDOWN);
 				break;
 
 			case WID_CS_MAPSIZE_Y_PULLDOWN: // Mapsize Y
-				ShowDropDownList(this, BuildMapsizeDropDown(), _settings_newgame.game_creation.map_y, WID_CS_MAPSIZE_Y_PULLDOWN);
+				ShowDropDownList(this, BuildMapsizeDropDown(_settings_newgame.game_creation.map_x), _settings_newgame.game_creation.map_y, WID_CS_MAPSIZE_Y_PULLDOWN);
 				break;
 
 			case WID_CS_EMPTY_WORLD: // Empty world / flat world
+				if (!CheckMapSize()) break;
 				StartGeneratingLandscape(GLWM_SCENARIO);
 				break;
 
 			case WID_CS_RANDOM_WORLD: // Generate
+				if (!CheckMapSize()) break;
 				ShowGenerateLandscape();
 				break;
 
@@ -998,7 +1114,7 @@
 			case WID_CS_FLAT_LAND_HEIGHT_TEXT: // Height level text
 				this->widget_id = WID_CS_FLAT_LAND_HEIGHT_TEXT;
 				SetDParam(0, _settings_newgame.game_creation.se_flat_world_height);
-				ShowQueryString(STR_JUST_INT, STR_SE_MAPGEN_FLAT_WORLD_HEIGHT_QUERY_CAPT, 3, this, CS_NUMERAL, QSF_NONE);
+				ShowQueryString(STR_JUST_INT, STR_SE_MAPGEN_FLAT_WORLD_HEIGHT_QUERY_CAPT, 4, this, CS_NUMERAL, QSF_NONE);
 				break;
 		}
 	}
@@ -1020,6 +1136,8 @@
 			case WID_CS_MAPSIZE_X_PULLDOWN: _settings_newgame.game_creation.map_x = index; break;
 			case WID_CS_MAPSIZE_Y_PULLDOWN: _settings_newgame.game_creation.map_y = index; break;
 		}
+		SetDropDownColor();
+
 		this->SetDirty();
 	}
 
diff -urNad openttd-1.3.2/src/gfxinit.cpp openttd-1.3.2-DC3.0RC3/src/gfxinit.cpp
--- openttd-1.3.2/src/gfxinit.cpp	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/gfxinit.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -175,6 +175,9 @@
 	_palette_remap_grf[i] = (PAL_DOS != used_set->palette);
 	LoadGrfFile(used_set->files[GFT_LOGOS].filename, 4793, i++);
 
+	/* Blacktileset comlete all slopes. */
+	LoadGrfFile("flat_blacktiles.grf", SPR_FLAT_BLACKTILES, i++);
+
 	/*
 	 * Load additional sprites for climates other than temperate.
 	 * This overwrites some of the temperate sprites, such as foundations
@@ -189,9 +192,15 @@
 		);
 	}
 
+	/* Load clipboard graphics */
+	LoadGrfFile("clipboard.grf", SPR_CLIPBOARD_BASE, i++);
+
 	/* Initialize the unicode to sprite mapping table */
 	InitializeUnicodeGlyphMap();
 
+	/* Load traffic lights graphics. */
+	LoadGrfFile("trafficlights.grf", SPR_TRAFFICLIGHTS_BASE, i++);
+
 	/*
 	 * Load the base NewGRF with OTTD required graphics as first NewGRF.
 	 * However, we do not want it to show up in the list of used NewGRFs,
diff -urNad openttd-1.3.2/src/ground_vehicle.hpp openttd-1.3.2-DC3.0RC3/src/ground_vehicle.hpp
--- openttd-1.3.2/src/ground_vehicle.hpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/ground_vehicle.hpp	2013-11-22 05:49:07.000000000 +0100
@@ -231,9 +231,9 @@
 	 * @param update_delta Indicates to also update the delta.
 	 * @return Old height of the vehicle.
 	 */
-	inline byte UpdateInclination(bool new_tile, bool update_delta)
+	inline int UpdateInclination(bool new_tile, bool update_delta)
 	{
-		byte old_z = this->z_pos;
+		int old_z = this->z_pos;
 
 		if (new_tile) {
 			this->UpdateZPositionAndInclination();
diff -urNad openttd-1.3.2/src/group_cmd.cpp openttd-1.3.2-DC3.0RC3/src/group_cmd.cpp
--- openttd-1.3.2/src/group_cmd.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/group_cmd.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -15,12 +15,16 @@
 #include "train.h"
 #include "vehiclelist.h"
 #include "vehicle_func.h"
+#include "station_base.h"
+#include "town.h"
 #include "autoreplace_base.h"
 #include "autoreplace_func.h"
 #include "string_func.h"
+#include "strings_func.h"
 #include "company_func.h"
 #include "core/pool_func.hpp"
 #include "order_backup.h"
+#include "aaa_template_vehicle.h"
 
 #include "table/strings.h"
 
@@ -135,6 +139,9 @@
  */
 /* static */ void GroupStatistics::CountVehicle(const Vehicle *v, int delta)
 {
+	/* make virtual trains group-neutral */
+	if ( HasBit(v->subtype, GVSF_VIRTUAL) ) return;
+
 	assert(delta == 1 || delta == -1);
 
 	GroupStatistics &stats_all = GroupStatistics::GetAllGroup(v);
@@ -330,6 +337,9 @@
 
 		VehicleType vt = g->vehicle_type;
 
+		/* Delete all template replacements using the just deleted group */
+		deleteIllegalTemplateReplacements(g->index);
+
 		/* Delete the Replace Vehicle Windows */
 		DeleteWindowById(WC_REPLACE_VEHICLE, g->vehicle_type);
 		delete g;
@@ -454,6 +464,143 @@
 			/* Add vehicles in the shared order list as well. */
 			for (Vehicle *v2 = v->FirstShared(); v2 != NULL; v2 = v2->NextShared()) {
 				if (v2->group_id != new_g) AddVehicleToGroup(v2, new_g);
+			}
+		}
+
+		GroupStatistics::UpdateAutoreplace(v->owner);
+
+		/* Update the Replace Vehicle Windows */
+		SetWindowDirty(WC_REPLACE_VEHICLE, v->type);
+		InvalidateWindowData(GetWindowClassForVehicleType(v->type), VehicleListIdentifier(VL_GROUP_LIST, v->type, _current_company).Pack());
+	}
+
+	return CommandCost();
+}
+
+/**
+ * Create a new group, rename it with specific name and add vehicle to this group
+ * @param tile unused
+ * @param flags type of operation
+ * @param p1   vehicle to add to a group
+ *   - p1 bit 0-19 : VehicleID
+ *   - p1 bit   31 : Add shared vehicles as well.
+ * @param p2   unused
+ * @param text unused
+ * @return the cost of this operation or an error
+ */
+CommandCost CmdCreateGroupSpecificName(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
+{
+	Vehicle *v = Vehicle::GetIfValid(GB(p1, 0, 20));
+
+	if (v == NULL) return CMD_ERROR;
+
+	if (v->owner != _current_company || !v->IsPrimaryVehicle()) return CMD_ERROR;
+
+	/* Get the essential orders */
+	VehicleOrderID start = 0;
+
+	Order *first = NULL;
+	Order *last = NULL;
+	Order *order = v->GetOrder(start);
+
+	if (order == NULL) return_cmd_error(STR_ERROR_GROUP_CAN_T_CREATE_NAME);
+
+	VehicleOrderID oid = start;
+
+	do {
+		if (order->IsType(OT_GOTO_STATION)) {
+			if(first == NULL) first = order;
+			last = order;
+		}
+
+		oid++;
+		order = order->next;
+		if (order == NULL) {
+			order = v->orders.list->GetFirstOrder();
+			oid = 0;
+		}
+	} while (oid != start);
+
+	if(last == NULL || first == NULL) return_cmd_error(STR_ERROR_GROUP_CAN_T_CREATE_NAME);
+
+	/* Create the name */
+
+	static char str[130] = { "" };  // 63 + 3 + 63 + 1
+
+	if(_settings_client.gui.specific_group_name == 1) { // Use station names
+
+		static char stationname_first[64] = { "" };
+		static char stationname_last[64] = { "" };
+
+		SetDParam(0, first->GetDestination());
+		GetString(stationname_first, STR_STATION_NAME, lastof(stationname_first));
+
+		SetDParam(0, last->GetDestination());
+		GetString(stationname_last, STR_STATION_NAME, lastof(stationname_last));
+
+		if(strnatcmp(stationname_first, stationname_last) > 0) {  // Sort by name
+			Order *temp = first;
+			first = last;
+			last = temp;
+		}
+		SetDParam(0, first->GetDestination());
+		SetDParam(1, last->GetDestination());
+		GetString(str, STR_GROUP_SPECIFIC_NAME_STATION, lastof(str));
+
+	}
+	else { //Use town names
+		
+		Station *station_first = Station::GetIfValid(first->GetDestination());
+		Station *station_last = Station::GetIfValid(last->GetDestination());
+				
+		if(station_last->IsValidID == false || station_first->IsValidID == false) return_cmd_error(STR_ERROR_GROUP_CAN_T_CREATE_NAME);
+
+		Town *town_first = station_first->town;
+		Town *town_last = station_last->town;
+
+		if(town_first->index == town_last->index) { // First and last station belong to the same town
+			SetDParam(0, town_first->index); 
+			GetString(str, STR_GROUP_SPECIFIC_NAME_TOWN_LOCAL, lastof(str));
+		}
+		else {
+			static char townname_first[64] = { "" };
+			static char townname_last[64] = { "" };
+
+			SetDParam(0, town_first->index);
+			GetString(townname_first, STR_TOWN_NAME, lastof(townname_first));
+
+			SetDParam(0, town_last->index);
+			GetString(townname_last, STR_TOWN_NAME, lastof(townname_last));
+
+			if(strnatcmp(townname_first, townname_last) > 0) { // Sort by name
+				Town *town_temp = town_first;
+				town_first = town_last;
+				town_last = town_temp;
+			}
+
+			SetDParam(0, town_first->index); 
+			SetDParam(1, town_last->index );
+			GetString(str, STR_GROUP_SPECIFIC_NAME_TOWN, lastof(str));
+		}
+	}
+	
+	if (!IsUniqueGroupNameForVehicleType(str, v->type)) return_cmd_error(STR_ERROR_NAME_MUST_BE_UNIQUE);
+
+	if (Utf8StringLength(str) >= MAX_LENGTH_GROUP_NAME_CHARS) return CMD_ERROR;
+
+	CommandCost ret = CmdCreateGroup(0, flags, v->type, 0, NULL);
+	if (ret.Failed()) return ret;
+
+	GroupID new_g = _new_group_id;
+	CommandCost ret2 = CmdRenameGroup(0, flags, new_g, 0, str);
+
+	if (flags & DC_EXEC) {
+		AddVehicleToGroup(v, new_g);
+
+		if (HasBit(p1, 31)) {
+			/* Add vehicles in the shared order list as well. */
+			for (Vehicle *v2 = v->FirstShared(); v2 != NULL; v2 = v2->NextShared()) {
+				if (v2->group_id != new_g) AddVehicleToGroup(v2, new_g);
 			}
 		}
 
diff -urNad openttd-1.3.2/src/group_gui.cpp openttd-1.3.2-DC3.0RC3/src/group_gui.cpp
--- openttd-1.3.2/src/group_gui.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/group_gui.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -30,6 +30,9 @@
 
 #include "table/sprites.h"
 
+// MYGUI_NOEND
+#include "aaa_template_gui_main.h"
+
 typedef GUIList<const Group*> GUIGroupList;
 
 static const NWidgetPart _nested_group_widgets[] = {
@@ -50,6 +53,7 @@
 						SetFill(1, 0), SetResize(0, 1), SetScrollbar(WID_GL_LIST_GROUP_SCROLLBAR),
 				NWidget(NWID_VSCROLLBAR, COLOUR_GREY, WID_GL_LIST_GROUP_SCROLLBAR),
 			EndContainer(),
+			NWidget(WWT_PANEL, COLOUR_GREY, WID_GL_INFO), SetMinimalSize(200, 25), SetFill(1, 0), EndContainer(),
 			NWidget(NWID_HORIZONTAL),
 				NWidget(WWT_PUSHIMGBTN, COLOUR_GREY, WID_GL_CREATE_GROUP), SetFill(0, 1),
 						SetDataTip(SPR_GROUP_CREATE_TRAIN, STR_GROUP_CREATE_TOOLTIP),
@@ -342,6 +346,9 @@
 				max_icon_height = max(max_icon_height, GetSpriteSize(this->GetWidget<NWidgetCore>(WID_GL_DELETE_GROUP)->widget_data).height);
 				max_icon_height = max(max_icon_height, GetSpriteSize(this->GetWidget<NWidgetCore>(WID_GL_REPLACE_PROTECTION)->widget_data).height);
 
+				/* ... minus the height of the group info ... */
+				max_icon_height += 25;
+				
 				/* Get a multiple of tiny_step_height of that amount */
 				size->height = Ceil(size->height - max_icon_height, tiny_step_height);
 				break;
@@ -499,6 +506,29 @@
 				DrawGroupInfo(r.top + WD_FRAMERECT_TOP, r.left, r.right, DEFAULT_GROUP);
 				break;
 
+			case WID_GL_INFO: {
+				Money this_year = 0;
+				Money last_year = 0;
+
+				for (uint i = 0, vehicle_count = this->vehicles.Length(); i < vehicle_count; i++) {
+					const Vehicle *v = this->vehicles[i];
+
+					assert(v->owner == this->owner);
+
+					if (this->vli.index == ALL_GROUP || v->group_id == this->vli.index) {
+						this_year += v->GetDisplayProfitThisYear();
+						last_year += v->GetDisplayProfitLastYear();
+					}
+				}
+
+				SetDParam(0, this_year);
+				DrawString(r.left + WD_FRAMERECT_LEFT + 8, r.right - WD_FRAMERECT_RIGHT - 8, r.top + WD_FRAMERECT_TOP + 1, STR_GROUP_PROFIT_THIS_YEAR);
+				SetDParam(0, last_year);
+				DrawString(r.left + WD_FRAMERECT_LEFT + 8, r.right - WD_FRAMERECT_RIGHT - 8, r.top + WD_FRAMERECT_TOP + FONT_HEIGHT_NORMAL + 2, STR_GROUP_PROFIT_LAST_YEAR, TC_BLACK);
+
+				break;
+			}
+
 			case WID_GL_LIST_GROUP: {
 				int y1 = r.top + WD_FRAMERECT_TOP;
 				int max = min(this->group_sb->GetPosition() + this->group_sb->GetCapacity(), this->groups.Length());
@@ -593,6 +623,7 @@
 				this->vli.index = ALL_GROUP;
 
 				DoCommandP(0, group, 0, CMD_DELETE_GROUP | CMD_MSG(STR_ERROR_GROUP_CAN_T_DELETE));
+				InvalidateWindowData(WC_TEMPLATEGUI_MAIN, 0, 0, 0);
 				break;
 			}
 
@@ -666,6 +697,16 @@
 				}
 				break;
 			}
+			case WID_GL_CREATE_GROUP: { // make new group with vehicle specific name and add vehicle
+				const VehicleID vindex = this->vehicle_sel;
+				this->vehicle_sel = INVALID_VEHICLE;
+				this->group_over = INVALID_GROUP;
+				this->SetDirty();
+
+				DoCommandP(0, vindex | (_ctrl_pressed ? 1 << 31 : 0),0 , CMD_CREATE_GROUP_SPECIFIC_NAME | CMD_MSG(STR_ERROR_GROUP_CAN_T_CREATE_SPECIFIC_NAME),  NULL);
+				
+				break;
+			}
 		}
 		_cursor.vehchain = false;
 	}
@@ -673,6 +714,7 @@
 	virtual void OnQueryTextFinished(char *str)
 	{
 		if (str != NULL) DoCommandP(0, this->group_rename, 0, CMD_RENAME_GROUP | CMD_MSG(STR_ERROR_GROUP_CAN_T_RENAME), NULL, str);
+		InvalidateWindowData(WC_TEMPLATEGUI_MAIN, 0, 0, 0);
 		this->group_rename = INVALID_GROUP;
 	}
 
@@ -698,6 +740,11 @@
 				assert(this->vehicles.Length() != 0);
 
 				switch (index) {
+					case ADI_TEMPLATE_REPLACE: // TemplateReplace Window
+						if ( vli.vtype == VEH_TRAIN )
+							// TODO before we used vli.company in the main gui, maybe retrieve it here and pass it as param to the gui ?
+							ShowTemplateReplaceWindow(this->unitnumber_digits, this->resize.step_height);
+						break;
 					case ADI_REPLACE: // Replace window
 						ShowReplaceGroupVehicleWindow(this->vli.index, this->vli.vtype);
 						break;
@@ -797,7 +844,6 @@
 	}
 };
 
-
 static WindowDesc _other_group_desc(
 	WDP_AUTO, 460, 246,
 	WC_INVALID, WC_NONE,
diff -urNad openttd-1.3.2/src/group_type.h openttd-1.3.2-DC3.0RC3/src/group_type.h
--- openttd-1.3.2/src/group_type.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/group_type.h	2013-11-22 05:49:07.000000000 +0100
@@ -19,7 +19,7 @@
 static const GroupID DEFAULT_GROUP = 0xFFFE; ///< Ungrouped vehicles are in this group.
 static const GroupID INVALID_GROUP = 0xFFFF; ///< Sentinel for invalid groups.
 
-static const uint MAX_LENGTH_GROUP_NAME_CHARS = 32; ///< The maximum length of a group name in characters including '\0'
+static const uint MAX_LENGTH_GROUP_NAME_CHARS = 168; ///< The maximum length of a group name in characters including '\0'
 
 struct Group;
 
diff -urNad openttd-1.3.2/src/gui.h openttd-1.3.2-DC3.0RC3/src/gui.h
--- openttd-1.3.2/src/gui.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/gui.h	2013-11-22 05:49:07.000000000 +0100
@@ -37,6 +37,9 @@
 /* airport_gui.cpp */
 Window *ShowBuildAirToolbar();
 
+/* clipboard_gui.cpp */
+Window *ShowClipboardToolbar();
+
 /* tgp_gui.cpp */
 void ShowGenerateLandscape();
 void ShowHeightmapLoad();
diff -urNad openttd-1.3.2/src/heightmap.cpp openttd-1.3.2-DC3.0RC3/src/heightmap.cpp
--- openttd-1.3.2/src/heightmap.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/heightmap.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -360,8 +360,17 @@
 				assert(img_row < img_height);
 				assert(img_col < img_width);
 
-				/* Colour scales from 0 to 255, OpenTTD height scales from 0 to 15 */
-				SetTileHeight(tile, map[img_row * img_width + img_col] / 16);
+				uint heightmap_height = (uint)map[img_row * img_width + img_col];
+				// the numerator of the fraction (heightmap_height * max_heightlevel) / MAX_MAX_HEIGHTLEVEL
+				uint numerator = heightmap_height * (uint)_settings_game.construction.max_heightlevel;
+				if (numerator != 0 && numerator <= MAX_MAX_HEIGHTLEVEL) {
+					// Scaling should not alter the coastline, thus values in the interval ]0..1] result in a heightlevel of 1
+					SetTileHeight(tile, 1);
+				} else {
+					// Generate a scaled heightlevel; if numerator == zero, the calculated heightlevel will be zero
+					uint heightlevel = numerator / MAX_MAX_HEIGHTLEVEL;
+					SetTileHeight(tile, heightlevel);
+				}
 			}
 			/* Only clear the tiles within the map area. */
 			if (TileX(tile) != MapMaxX() && TileY(tile) != MapMaxY() &&
diff -urNad openttd-1.3.2/src/industry_cmd.cpp openttd-1.3.2-DC3.0RC3/src/industry_cmd.cpp
--- openttd-1.3.2/src/industry_cmd.cpp	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/industry_cmd.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -193,17 +193,36 @@
 
 
 /**
- * Return a random valid industry.
- * @return random industry, NULL if there are no industries
+ * Return a random industry that statisfies some criteria
+ * specified with a callback function.
+ *
+ * @param enum_proc Callback function. Return true for a matching industry and false to continue iterating.
+ * @param skip Skip over this industry id when searching.
+ * @param data Optional data passed to the callback function.
+ * @return An industry satisfying the search criteria or NULL if no such industry exists.
  */
-/* static */ Industry *Industry::GetRandom()
+/* static */ Industry *Industry::GetRandom(EnumIndustryProc enum_proc, IndustryID skip, void *data)
 {
-	if (Industry::GetNumItems() == 0) return NULL;
-	int num = RandomRange((uint16)Industry::GetNumItems());
-	size_t index = MAX_UVALUE(size_t);
+	assert(skip == INVALID_INDUSTRY || Industry::IsValidID(skip));
 
-	while (num >= 0) {
-		num--;
+	uint16 max_num = 0;
+	if (enum_proc != NULL) {
+		/* A callback was given, count all matching industries. */
+		Industry *ind;
+		FOR_ALL_INDUSTRIES(ind) {
+			if (ind->index != skip && enum_proc(ind, data)) max_num++;
+		}
+	} else {
+		max_num = (uint16)Industry::GetNumItems();
+		/* Subtract one if an industry to skip was given. max_num is at least
+		* one here as otherwise skip could not be valid. */
+		if (skip != INVALID_INDUSTRY) max_num--;
+	}
+	if (max_num == 0) return NULL;
+
+	uint num = RandomRange(max_num) + 1;
+	size_t index = MAX_UVALUE(size_t);
+	do {
 		index++;
 
 		/* Make sure we have a valid industry */
@@ -211,7 +230,9 @@
 			index++;
 			assert(index < Industry::GetPoolSize());
 		}
-	}
+
+		if (index != skip && (enum_proc == NULL || enum_proc(Industry::Get(index), data))) num--;
+	} while (num > 0);
 
 	return Industry::Get(index);
 }
@@ -340,6 +361,8 @@
 		DrawGroundSprite(image, GroundSpritePaletteTransform(image, dits->ground.pal, GENERAL_SPRITE_COLOUR(ind->random_colour)));
 	}
 
+	DrawOverlay(ti, MP_INDUSTRY);
+
 	/* If industries are transparent and invisible, do not draw the upper part */
 	if (IsInvisibilitySet(TO_INDUSTRIES)) return;
 
@@ -506,7 +529,7 @@
 
 			i->this_month_production[j] += cw;
 
-			uint am = MoveGoodsToStation(i->produced_cargo[j], cw, ST_INDUSTRY, i->index, stations.GetStations());
+			uint am = MoveGoodsToStation(i->produced_cargo[j], cw, ST_INDUSTRY, i->index, stations.GetStations(), tile);
 			i->this_month_transported[j] += am;
 
 			moved_cargo |= (am != 0);
@@ -1583,6 +1606,28 @@
 	return CommandCost();
 }
 
+/** Update the mask of always accepted cargoes that are also produced. */
+void UpdateIndustryAcceptance(Industry *ind)
+{
+	CargoArray accepted;
+	uint32 always_accepted = 0;
+
+	/* Gather always accepted cargoes for all tiles of this industry. */
+	TILE_AREA_LOOP(tile, ind->location) {
+		if (IsTileType(tile, MP_INDUSTRY) && GetIndustryIndex(tile) == ind->index) {
+			AddAcceptedCargo_Industry(tile, accepted, &always_accepted);
+		}
+	}
+
+	/* Create mask of produced cargoes. */
+	uint32 produced = 0;
+	for (uint i = 0; i < lengthof(ind->produced_cargo); i++) {
+		if (ind->produced_cargo[i] != CT_INVALID) SetBit(produced, ind->produced_cargo[i]);
+	}
+
+	ind->produced_accepted_mask = always_accepted & produced;
+}
+
 /**
  * Advertise about a new industry opening.
  * @param ind Industry being opened.
@@ -1756,6 +1801,7 @@
 	}
 	InvalidateWindowData(WC_INDUSTRY_DIRECTORY, 0, 0);
 
+	UpdateIndustryAcceptance(i);
 	Station::RecomputeIndustriesNearForAll();
 }
 
@@ -1908,7 +1954,13 @@
 		AdvertiseIndustryOpening(ind);
 	}
 
-	return CommandCost(EXPENSES_OTHER, indspec->GetConstructionCost());
+	CommandCost cost(EXPENSES_OTHER, indspec->GetConstructionCost());
+
+	if (_settings_game.economy.day_length_balance_type == DBT_ALL_COSTS) {
+		cost.AffectCost(_settings_game.economy.day_length_balance_factor);
+	}
+
+	return cost;
 }
 
 
@@ -2153,6 +2205,9 @@
 
 			i->last_month_transported[j] = i->this_month_transported[j];
 			i->this_month_transported[j] = 0;
+
+			/* Average production over the last eight months. */
+			i->average_production[j] = (i->average_production[j] * 7 + i->last_month_production[j]) / 8;
 		}
 	}
 }
@@ -2671,7 +2726,12 @@
 		perc = min(9u, perc + (_industry_builder.wanted_inds >> 16) - GetCurrentTotalNumberOfIndustries());
 	}
 	for (uint16 j = 0; j < change_loop; j++) {
-		if (Chance16(perc, 100)) {
+               /* industry for taxes */
+               if (_economy.industry_helper > _price[PR_BUILD_INDUSTRY] << 3) {
+                       _economy.industry_helper -= _price[PR_BUILD_INDUSTRY] << 3;
+                       _industry_builder.TryBuildNewIndustry();
+//		if (Chance16(perc, 100)) {
+		} else if (Chance16(perc, 100)) {
 			_industry_builder.TryBuildNewIndustry();
 		} else {
 			Industry *i = Industry::GetRandom();
@@ -2697,6 +2757,7 @@
 	Industry *i;
 	FOR_ALL_INDUSTRIES(i) {
 		UpdateIndustryStatistics(i);
+		UpdateIndustryAcceptance(i);
 		if (i->prod_level == PRODLEVEL_CLOSURE) {
 			delete i;
 		} else {
@@ -2817,4 +2878,5 @@
 	NULL,                        // vehicle_enter_tile_proc
 	GetFoundation_Industry,      // get_foundation_proc
 	TerraformTile_Industry,      // terraform_tile_proc
+	NULL,                        // copypaste_tile_proc
 };
diff -urNad openttd-1.3.2/src/industry_gui.cpp openttd-1.3.2-DC3.0RC3/src/industry_gui.cpp
--- openttd-1.3.2/src/industry_gui.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/industry_gui.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -38,6 +38,7 @@
 #include "smallmap_gui.h"
 #include "widgets/dropdown_type.h"
 #include "widgets/industry_widget.h"
+#include "cargodest_gui.h"
 
 #include "table/strings.h"
 
@@ -109,7 +110,9 @@
 	}
 }
 
-IndustryType _sorted_industry_types[NUM_INDUSTRYTYPES]; ///< Industry types sorted by name.
+IndustryType _sorted_industry_types[NUM_INDUSTRYTYPES];             ///< Industry types sorted by name.
+static SmallVector<IndustryType, 8> _sorted_enabled_industry_types; ///< Subgroup of enabled (and sorted) industry types.
+static uint64 _industry_filter_enabled;                             ///< Bit mask of the enabled industry types.
 
 /** Sort industry types by their name. */
 static int CDECL IndustryTypeNameSorter(const IndustryType *a, const IndustryType *b)
@@ -142,6 +145,17 @@
 
 	/* Sort industry types by name. */
 	QSortT(_sorted_industry_types, NUM_INDUSTRYTYPES, &IndustryTypeNameSorter);
+
+	/* Build the bitmask/collection of all the enabled industry types */
+	_industry_filter_enabled = 0;
+	_sorted_enabled_industry_types.Clear();
+	for (IndustryType i = 0; i < NUM_INDUSTRYTYPES; i++) {
+		IndustryType ind = _sorted_industry_types[i];
+		if (GetIndustrySpec(ind)->enabled) {
+			SetBit(_industry_filter_enabled, ind);
+			*_sorted_enabled_industry_types.Append() = ind;
+		}
+	}
 }
 
 /**
@@ -653,8 +667,11 @@
 	int production_offset_y;  ///< The offset of the production texts/buttons
 	int info_height;          ///< Height needed for the #WID_IV_INFO panel
 
+	CargoDestinationList dest_list; ///< Sorted list of demand destinations.
+	int dest_list_top;        ///< Top coordinate of the destination list.
+
 public:
-	IndustryViewWindow(const WindowDesc *desc, WindowNumber window_number) : Window()
+	IndustryViewWindow(const WindowDesc *desc, WindowNumber window_number) : Window(), dest_list(Industry::Get(window_number))
 	{
 		this->flags |= WF_DISABLE_VP_SCROLL;
 		this->editbox_line = IL_NONE;
@@ -747,6 +764,14 @@
 
 			SetDParam(0, i->produced_cargo[j]);
 			SetDParam(1, i->last_month_production[j]);
+
+			/* Show values corresponding to show_orig_productions settings. */
+//			if (_settings_game.economy.show_orig_productions) {
+//				SetDParam(1, 8 * i->production_rate[j]);
+//			} else {
+//				SetDParam(1, 8 * i->production_rate[j] * _settings_game.economy.day_length_factor);
+//			}
+
 			SetDParamStr(2, cargo_suffix[j]);
 			SetDParam(3, ToPercent8(i->last_month_pct_transported[j]));
 			uint x = left + WD_FRAMETEXT_LEFT + (this->editable == EA_RATE ? SETTING_BUTTON_WIDTH + 10 : 0);
@@ -792,6 +817,10 @@
 				}
 			}
 		}
+
+		this->dest_list_top = y;
+		y = this->dest_list.DrawList(left, right, y);
+
 		return y + WD_FRAMERECT_BOTTOM;
 	}
 
@@ -811,6 +840,13 @@
 			case WID_IV_INFO: {
 				Industry *i = Industry::Get(this->window_number);
 				InfoLine line = IL_NONE;
+				NWidgetBase *nwi = this->GetWidget<NWidgetBase>(widget);
+
+				/* Test for click on destination list. */
+				if (pt.y > this->dest_list_top) {
+					this->dest_list.OnClick(pt.y - this->dest_list_top);
+					return;
+				}
 
 				switch (this->editable) {
 					case EA_NONE: break;
@@ -835,7 +871,6 @@
 				}
 				if (line == IL_NONE) return;
 
-				NWidgetBase *nwi = this->GetWidget<NWidgetBase>(widget);
 				int left = nwi->pos_x + WD_FRAMETEXT_LEFT;
 				int right = nwi->pos_x + nwi->current_x - 1 - WD_FRAMERECT_RIGHT;
 				if (IsInsideMM(pt.x, left, left + SETTING_BUTTON_WIDTH)) {
@@ -963,6 +998,13 @@
 		} else {
 			this->editable = EA_NONE;
 		}
+
+		/* Rebuild destination list if data is not zero, otherwise just resort. */
+		if (data != 0) {
+			this->dest_list.InvalidateData();
+		} else {
+			this->dest_list.Resort();
+		}
 	}
 
 	virtual bool IsNewGRFInspectable() const
@@ -1024,6 +1066,32 @@
 	AllocateWindowDescFront<IndustryViewWindow>(&_industry_view_desc, industry);
 }
 
+/**
+ * Make a horizontal row of industry type buttons, starting at widget #WID_ID_TYPE_START.
+ * @param biggest_index Pointer to store biggest used widget number of the buttons.
+ * @return Horizontal row.
+ */
+static NWidgetBase *IndustryTypeWidgets(int *biggest_index)
+{
+	NWidgetHorizontal *container = new NWidgetHorizontal();
+
+	for (size_t i = 0; i < _sorted_enabled_industry_types.Length(); i++) {
+		IndustryType ind = _sorted_enabled_industry_types[i];
+		const IndustrySpec *indsp = GetIndustrySpec(ind);
+		assert(indsp->enabled);
+
+		NWidgetBackground *panel = new NWidgetBackground(WWT_PANEL, COLOUR_BROWN, WID_ID_TYPE_START + i);
+		panel->SetMinimalSize(16, 11);
+		panel->SetResize(0, 0);
+		panel->SetFill(0, 1);
+		panel->SetDataTip(0, STR_INDUSTRY_DIRECTORY_USE_CTRL_TO_SELECT_MORE);
+		container->Add(panel);
+	}
+
+	*biggest_index = WID_ID_TYPE_START + _sorted_enabled_industry_types.Length();
+	return container;
+}
+
 /** Widget definition of the industry directory gui */
 static const NWidgetPart _nested_industry_directory_widgets[] = {
 	NWidget(NWID_HORIZONTAL),
@@ -1037,7 +1105,9 @@
 			NWidget(NWID_HORIZONTAL),
 				NWidget(WWT_TEXTBTN, COLOUR_BROWN, WID_ID_DROPDOWN_ORDER), SetDataTip(STR_BUTTON_SORT_BY, STR_TOOLTIP_SORT_ORDER),
 				NWidget(WWT_DROPDOWN, COLOUR_BROWN, WID_ID_DROPDOWN_CRITERIA), SetDataTip(STR_JUST_STRING, STR_TOOLTIP_SORT_CRITERIA),
-				NWidget(WWT_PANEL, COLOUR_BROWN), SetResize(1, 0), EndContainer(),
+				NWidget(WWT_PANEL, COLOUR_BROWN), SetMinimalSize(25, 11), SetResize(1, 0), EndContainer(),
+				NWidget(WWT_PUSHBTN, COLOUR_BROWN, WID_ID_TYPESALL), SetMinimalSize(16, 11), SetDataTip(0x0, STR_INDUSTRY_DIRECTORY_SELECT_ALL_TYPES), SetFill(0, 1),
+				NWidgetFunction(IndustryTypeWidgets),
 			EndContainer(),
 			NWidget(WWT_PANEL, COLOUR_BROWN, WID_ID_INDUSTRY_LIST), SetDataTip(0x0, STR_INDUSTRY_DIRECTORY_LIST_CAPTION), SetResize(1, 1), SetScrollbar(WID_ID_SCROLLBAR), EndContainer(),
 		EndContainer(),
@@ -1059,6 +1129,7 @@
 	/* Runtime saved values */
 	static Listing last_sorting;
 	static const Industry *last_industry;
+	static uint64 industry_filter;
 
 	/* Constants for sorting stations */
 	static const StringID sorter_names[];
@@ -1075,7 +1146,9 @@
 
 			const Industry *i;
 			FOR_ALL_INDUSTRIES(i) {
-				*this->industries.Append() = i;
+				if (HasBit(this->industry_filter, i->type)) {
+					*this->industries.Append() = i;
+				}
 			}
 
 			this->industries.Compact();
@@ -1207,12 +1280,39 @@
 		}
 	}
 
+	/**
+	 * Enable/disable all industry type filters.
+	 * @param enable True to lower and enable all industry type filters, false to raise/disable.
+	 */
+	void ToggleIndustryFilters(bool enable)
+	{
+		for (size_t i = 0; i < _sorted_enabled_industry_types.Length(); i++) {
+			NWidgetBackground* panel = this->GetWidget<NWidgetBackground>(WID_ID_TYPE_START + i);
+			panel->SetLowered(enable);
+		}
+
+		this->industry_filter = enable ? _industry_filter_enabled : 0;
+	}
+
 public:
 	IndustryDirectoryWindow(const WindowDesc *desc, WindowNumber number) : Window()
 	{
 		this->CreateNestedTree(desc);
 		this->vscroll = this->GetScrollbar(WID_ID_SCROLLBAR);
 
+		// if the industry filter has disabled industries selected
+		// it means the industry set has changed, so we need to re-initialize
+		if (this->industry_filter & ~_industry_filter_enabled) {
+			this->industry_filter = _industry_filter_enabled;
+		}
+
+		for (size_t i = 0; i < _sorted_enabled_industry_types.Length(); i++) {
+			IndustryType ind = _sorted_enabled_industry_types[i];
+			if (HasBit(this->industry_filter, ind)) {
+				this->LowerWidget(WID_ID_TYPE_START + i);
+			}
+		}
+
 		this->industries.SetListing(this->last_sorting);
 		this->industries.SetSortFuncs(IndustryDirectoryWindow::sorter_funcs);
 		this->industries.ForceRebuild();
@@ -1253,6 +1353,24 @@
 				}
 				break;
 			}
+
+			case WID_ID_TYPESALL: {
+				int it_ofst = this->IsWidgetLowered(widget) ? 2 : 1;
+				DrawString(r.left + it_ofst, r.right + it_ofst, r.top + it_ofst, STR_ABBREV_ALL, TC_BLACK, SA_HOR_CENTER);
+				break;
+			}
+
+			default:
+				if (widget >= WID_ID_TYPE_START)
+				{
+					IndustryType ind = _sorted_enabled_industry_types[widget - WID_ID_TYPE_START];
+					const IndustrySpec *indsp = GetIndustrySpec(ind);
+					int it_ofst = HasBit(this->industry_filter, ind) ? 2 : 1;;
+					GfxFillRect(r.left + it_ofst, r.top + it_ofst, r.right - 2 + it_ofst, r.bottom - 2 + it_ofst, indsp->map_colour);
+					TextColour tc = GetContrastColour(indsp->map_colour);
+					DrawString(r.left + it_ofst, r.right + it_ofst, r.top + it_ofst, indsp->abbrev, tc, SA_HOR_CENTER);
+				}
+				break;
 		}
 	}
 
@@ -1290,6 +1408,25 @@
 				*size = maxdim(*size, d);
 				break;
 			}
+
+			case WID_ID_TYPESALL: {
+				Dimension d = GetStringBoundingBox(STR_ABBREV_ALL);
+				d.width  += padding.width + 2;
+				d.height += padding.height;
+				*size = maxdim(*size, d);
+				break;
+			}
+
+			default:
+				if (widget >= WID_ID_TYPE_START) {
+					IndustryType ind = _sorted_enabled_industry_types[widget - WID_ID_TYPE_START];
+					const IndustrySpec* indsp = GetIndustrySpec(ind);
+					Dimension d = GetStringBoundingBox(indsp->abbrev);
+					d.width  += padding.width + 2;
+					d.height += padding.height;
+					*size = maxdim(*size, d);
+				}
+				break;
 		}
 	}
 
@@ -1317,6 +1454,34 @@
 				}
 				break;
 			}
+
+			case WID_ID_TYPESALL: {
+				ToggleIndustryFilters(true);
+
+				this->industries.ForceRebuild();
+				this->BuildSortIndustriesList();
+				this->SetDirty();
+				break;
+			}
+
+			default:
+				if (widget >= WID_ID_TYPE_START)
+				{
+					IndustryType ind = _sorted_enabled_industry_types[widget - WID_ID_TYPE_START];
+					if (_ctrl_pressed) {
+						ToggleBit(this->industry_filter, ind);
+						this->ToggleWidgetLoweredState(widget);
+					} else {
+						ToggleIndustryFilters(false);
+						SetBit(this->industry_filter, ind);
+						this->LowerWidget(widget);
+					}
+
+					this->industries.ForceRebuild();
+					this->BuildSortIndustriesList();
+					this->SetDirty();
+				}
+				break;
 		}
 	}
 
@@ -1363,6 +1528,7 @@
 
 Listing IndustryDirectoryWindow::last_sorting = {false, 0};
 const Industry *IndustryDirectoryWindow::last_industry = NULL;
+uint64 IndustryDirectoryWindow::industry_filter = UINT64_MAX;
 
 /* Available station sorting functions. */
 GUIIndustryList::SortFunction * const IndustryDirectoryWindow::sorter_funcs[] = {
diff -urNad openttd-1.3.2/src/industry.h openttd-1.3.2-DC3.0RC3/src/industry.h
--- openttd-1.3.2/src/industry.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/industry.h	2013-11-22 05:49:07.000000000 +0100
@@ -16,6 +16,7 @@
 #include "subsidy_type.h"
 #include "industry_map.h"
 #include "tilearea_type.h"
+#include "cargodest_base.h"
 
 
 typedef Pool<Industry, IndustryID, 64, 64000> IndustryPool;
@@ -36,7 +37,7 @@
 /**
  * Defines the internal data of a functional industry.
  */
-struct Industry : IndustryPool::PoolItem<&_industry_pool> {
+struct Industry : IndustryPool::PoolItem<&_industry_pool>, CargoSourceSink {
 	TileArea location;                  ///< Location of the industry
 	Town *town;                         ///< Nearest town
 	CargoID produced_cargo[2];          ///< 2 production cargo slots
@@ -45,11 +46,13 @@
 	byte production_rate[2];            ///< production rate for each cargo
 	byte prod_level;                    ///< general production level
 	CargoID accepts_cargo[3];           ///< 3 input cargo slots
+	uint32 produced_accepted_mask;      ///< Bit mask of all cargoes that are always accepted and also produced
 	uint16 this_month_production[2];    ///< stats of this month's production per cargo
 	uint16 this_month_transported[2];   ///< stats of this month's transport per cargo
 	byte last_month_pct_transported[2]; ///< percentage transported per cargo in the last full month
 	uint16 last_month_production[2];    ///< total units produced per cargo in the last full month
 	uint16 last_month_transported[2];   ///< total units transported per cargo in the last full month
+	uint16 average_production[2];       ///< average production during the last months
 	uint16 counter;                     ///< used for animation and/or production (if available cargo)
 
 	IndustryType type;                  ///< type of industry.
@@ -76,6 +79,41 @@
 
 	void RecomputeProductionMultipliers();
 
+	/* virtual */ SourceType GetType() const
+	{
+		return ST_INDUSTRY;
+	}
+
+	/* virtual */ SourceID GetID() const
+	{
+		return this->index;
+	}
+
+	/* virtual */ bool AcceptsCargo(CargoID cid) const
+	{
+		if (HasBit(this->produced_accepted_mask, cid)) return true;
+
+		for (uint i = 0; i < lengthof(this->accepts_cargo); i++) {
+			if (this->accepts_cargo[i] == cid) return true;
+		}
+		return false;
+	}
+
+	/* virtual */ bool SuppliesCargo(CargoID cid) const
+	{
+		for (uint i = 0; i < lengthof(this->produced_cargo); i++) {
+			if (this->produced_cargo[i] == cid) return true;
+		}
+		return false;
+	}
+
+	/* virtual */ uint GetDestinationWeight(CargoID cid, byte weight_mod) const;
+
+	/* virtual */ TileArea GetTileForDestination(CargoID cid)
+	{
+		return this->location;
+	}
+
 	/**
 	 * Check if a given tile belongs to this industry.
 	 * @param tile The tile to check.
@@ -97,7 +135,10 @@
 		return Industry::Get(GetIndustryIndex(tile));
 	}
 
-	static Industry *GetRandom();
+	/** Callback function for #Industry::GetRandom. */
+	typedef bool (*EnumIndustryProc)(const Industry *ind, void *data);
+
+	static Industry *GetRandom(EnumIndustryProc enum_proc = NULL, IndustryID skip = INVALID_INDUSTRY, void *data = NULL);
 	static void PostDestructor(size_t index);
 
 	/**
@@ -147,6 +188,8 @@
 
 void ReleaseDisastersTargetingIndustry(IndustryID);
 
+void UpdateIndustryAcceptance(Industry *ind);
+
 bool IsTileForestIndustry(TileIndex tile);
 
 #define FOR_ALL_INDUSTRIES_FROM(var, start) FOR_ALL_ITEMS_FROM(Industry, industry_index, var, start)
diff -urNad openttd-1.3.2/src/industry_map.h openttd-1.3.2-DC3.0RC3/src/industry_map.h
--- openttd-1.3.2/src/industry_map.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/industry_map.h	2013-11-22 05:49:07.000000000 +0100
@@ -65,7 +65,7 @@
 static inline IndustryID GetIndustryIndex(TileIndex t)
 {
 	assert(IsTileType(t, MP_INDUSTRY));
-	return _m[t].m2;
+	return GetTile(t)->m2;
 }
 
 /**
@@ -77,7 +77,7 @@
 static inline bool IsIndustryCompleted(TileIndex t)
 {
 	assert(IsTileType(t, MP_INDUSTRY));
-	return HasBit(_m[t].m1, 7);
+	return HasBit(GetTile(t)->m1, 7);
 }
 
 IndustryType GetIndustryType(TileIndex tile);
@@ -91,7 +91,7 @@
 static inline void SetIndustryCompleted(TileIndex tile, bool isCompleted)
 {
 	assert(IsTileType(tile, MP_INDUSTRY));
-	SB(_m[tile].m1, 7, 1, isCompleted ? 1 :0);
+	SB(GetTile(tile)->m1, 7, 1, isCompleted ? 1 :0);
 }
 
 /**
@@ -103,7 +103,7 @@
 static inline byte GetIndustryConstructionStage(TileIndex tile)
 {
 	assert(IsTileType(tile, MP_INDUSTRY));
-	return IsIndustryCompleted(tile) ? (byte)INDUSTRY_COMPLETED : GB(_m[tile].m1, 0, 2);
+	return IsIndustryCompleted(tile) ? (byte)INDUSTRY_COMPLETED : GB(GetTile(tile)->m1, 0, 2);
 }
 
 /**
@@ -115,7 +115,7 @@
 static inline void SetIndustryConstructionStage(TileIndex tile, byte value)
 {
 	assert(IsTileType(tile, MP_INDUSTRY));
-	SB(_m[tile].m1, 0, 2, value);
+	SB(GetTile(tile)->m1, 0, 2, value);
 }
 
 /**
@@ -128,7 +128,7 @@
 static inline IndustryGfx GetCleanIndustryGfx(TileIndex t)
 {
 	assert(IsTileType(t, MP_INDUSTRY));
-	return _m[t].m5 | (GB(_m[t].m6, 2, 1) << 8);
+	return GetTile(t)->m5 | (GB(GetTileEx(t)->m6, 2, 1) << 8);
 }
 
 /**
@@ -152,8 +152,8 @@
 static inline void SetIndustryGfx(TileIndex t, IndustryGfx gfx)
 {
 	assert(IsTileType(t, MP_INDUSTRY));
-	_m[t].m5 = GB(gfx, 0, 8);
-	SB(_m[t].m6, 2, 1, GB(gfx, 8, 1));
+	GetTile(t)->m5 = GB(gfx, 0, 8);
+	SB(GetTileEx(t)->m6, 2, 1, GB(gfx, 8, 1));
 }
 
 /**
@@ -165,7 +165,7 @@
 static inline byte GetIndustryConstructionCounter(TileIndex tile)
 {
 	assert(IsTileType(tile, MP_INDUSTRY));
-	return GB(_m[tile].m1, 2, 2);
+	return GB(GetTile(tile)->m1, 2, 2);
 }
 
 /**
@@ -177,7 +177,7 @@
 static inline void SetIndustryConstructionCounter(TileIndex tile, byte value)
 {
 	assert(IsTileType(tile, MP_INDUSTRY));
-	SB(_m[tile].m1, 2, 2, value);
+	SB(GetTile(tile)->m1, 2, 2, value);
 }
 
 /**
@@ -190,8 +190,8 @@
 static inline void ResetIndustryConstructionStage(TileIndex tile)
 {
 	assert(IsTileType(tile, MP_INDUSTRY));
-	SB(_m[tile].m1, 0, 4, 0);
-	SB(_m[tile].m1, 7, 1, 0);
+	SB(GetTile(tile)->m1, 0, 4, 0);
+	SB(GetTile(tile)->m1, 7, 1, 0);
 }
 
 /**
@@ -202,7 +202,7 @@
 static inline byte GetIndustryAnimationLoop(TileIndex tile)
 {
 	assert(IsTileType(tile, MP_INDUSTRY));
-	return _m[tile].m4;
+	return GetTile(tile)->m4;
 }
 
 /**
@@ -214,7 +214,7 @@
 static inline void SetIndustryAnimationLoop(TileIndex tile, byte count)
 {
 	assert(IsTileType(tile, MP_INDUSTRY));
-	_m[tile].m4 = count;
+	GetTile(tile)->m4 = count;
 }
 
 /**
@@ -227,7 +227,7 @@
 static inline byte GetIndustryRandomBits(TileIndex tile)
 {
 	assert(IsTileType(tile, MP_INDUSTRY));
-	return _m[tile].m3;
+	return GetTile(tile)->m3;
 }
 
 /**
@@ -240,7 +240,7 @@
 static inline void SetIndustryRandomBits(TileIndex tile, byte bits)
 {
 	assert(IsTileType(tile, MP_INDUSTRY));
-	_m[tile].m3 = bits;
+	GetTile(tile)->m3 = bits;
 }
 
 /**
@@ -253,7 +253,7 @@
 static inline byte GetIndustryTriggers(TileIndex tile)
 {
 	assert(IsTileType(tile, MP_INDUSTRY));
-	return GB(_m[tile].m6, 3, 3);
+	return GB(GetTileEx(tile)->m6, 3, 3);
 }
 
 
@@ -267,7 +267,7 @@
 static inline void SetIndustryTriggers(TileIndex tile, byte triggers)
 {
 	assert(IsTileType(tile, MP_INDUSTRY));
-	SB(_m[tile].m6, 3, 3, triggers);
+	SB(GetTileEx(tile)->m6, 3, 3, triggers);
 }
 
 /**
@@ -281,14 +281,14 @@
 static inline void MakeIndustry(TileIndex t, IndustryID index, IndustryGfx gfx, uint8 random, WaterClass wc)
 {
 	SetTileType(t, MP_INDUSTRY);
-	_m[t].m1 = 0;
-	_m[t].m2 = index;
+	GetTile(t)->m1 = 0;
+	GetTile(t)->m2 = index;
 	SetIndustryRandomBits(t, random); // m3
-	_m[t].m4 = 0;
+	GetTile(t)->m4 = 0;
 	SetIndustryGfx(t, gfx); // m5, part of m6
 	SetIndustryTriggers(t, 0); // rest of m6
 	SetWaterClass(t, wc);
-	_me[t].m7 = 0;
+	GetTileEx(t)->m7 = 0;
 }
 
 #endif /* INDUSTRY_MAP_H */
diff -urNad openttd-1.3.2/src/industrytype.h openttd-1.3.2-DC3.0RC3/src/industrytype.h
--- openttd-1.3.2/src/industrytype.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/industrytype.h	2013-11-22 05:49:07.000000000 +0100
@@ -120,6 +120,7 @@
 	IndustryBehaviour behaviour;          ///< How this industry will behave, and how others entities can use it
 	byte map_colour;                      ///< colour used for the small map
 	StringID name;                        ///< Displayed name of the industry
+	StringID abbrev;                      ///< Abbreviation of the industry name
 	StringID new_industry_text;           ///< Message appearing when the industry is built
 	StringID closure_text;                ///< Message appearing when the industry closes
 	StringID production_up_text;          ///< Message appearing when the industry's production is increasing
diff -urNad openttd-1.3.2/src/infrastructure.cpp openttd-1.3.2-DC3.0RC3/src/infrastructure.cpp
--- openttd-1.3.2/src/infrastructure.cpp	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/infrastructure.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -0,0 +1,345 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file infrastructure.cpp Implementation of infrastructure sharing */
+
+#include "stdafx.h"
+#include "infrastructure_func.h"
+#include "train.h"
+#include "aircraft.h"
+#include "vehicle_func.h"
+#include "station_base.h"
+#include "depot_base.h"
+#include "pbs.h"
+#include "signal_func.h"
+#include "window_func.h"
+#include "gui.h"
+#include "pathfinder/yapf/yapf_cache.h"
+#include "company_base.h"
+#include "error.h"
+
+#include "table/strings.h"
+
+/**
+ * Helper function for transferring sharing fees
+ * @param v The vehicle involved
+ * @param infra_owner The owner of the infrastructure
+ * @param cost Amount to transfer as money fraction (shifted 8 bits to the left)
+ */
+static void PaySharingFee(Vehicle *v, Owner infra_owner, Money cost)
+{
+	Company *c = Company::Get(v->owner);
+	if (!_settings_game.economy.sharing_payment_in_debt) {
+		/* Do not allow fee payment to drop (money - loan) below 0. */
+		cost = min(cost, (c->money - c->current_loan) << 8);
+		if (cost <= 0) return;
+	}
+	v->profit_this_year -= cost;
+	SubtractMoneyFromCompanyFract(v->owner, CommandCost(EXPENSES_SHARING_COST, cost));
+	SubtractMoneyFromCompanyFract(infra_owner, CommandCost(EXPENSES_SHARING_INC, -cost));
+}
+
+/**
+ * Pay the fee for spending a single tick inside a station.
+ * @param v The vehicle that is using the station.
+ * @param st The station that it uses.
+ */
+void PayStationSharingFee(Vehicle *v, const Station *st)
+{
+	if (v->owner == st->owner || st->owner == OWNER_NONE || v->type == VEH_TRAIN) return;
+	Money cost = _settings_game.economy.sharing_fee[v->type];
+	PaySharingFee(v, st->owner, (cost << 8) / DAY_TICKS);
+}
+
+uint16 is2_GetWeight(Train *v)
+{
+	uint16 weight = (CargoSpec::Get(v->cargo_type)->weight * v->cargo.Count() * FreightWagonMult(v->cargo_type)) / 16;
+		/* Vehicle weight is not added for articulated parts. */
+	if (!v->IsArticulatedPart()) {
+		weight += GetVehicleProperty(v, PROP_TRAIN_WEIGHT, RailVehInfo(v->engine_type)->weight);
+	}
+		/* Powered wagons have extra weight added. */
+	if (HasBit(v->flags, VRF_POWEREDWAGON)) {
+		weight += RailVehInfo(v->gcache.first_engine)->pow_wag_weight;
+	}
+		return weight;
+}
+
+
+/**
+ * Pay the daily fee for trains on foreign tracks.
+ * @param v The vehicle to pay the fee for.
+ */
+void PayDailyTrackSharingFee(Train *v)
+{
+	Owner owner = GetTileOwner(v->tile);
+	if (owner == v->owner) return;
+	Money cost = _settings_game.economy.sharing_fee[VEH_TRAIN] << 8;
+	/* Cost is calculated per 1000 tonnes */
+	cost = cost * is2_GetWeight(v) / 1000;
+	/* Only pay the required fraction */
+	cost = cost * v->running_ticks / DAY_TICKS;
+	if (cost != 0) PaySharingFee(v, owner, cost);
+}
+
+/**
+ * Check whether a vehicle is in an allowed position.
+ * @param v     The vehicle to check.
+ * @param owner Owner whose infrastructure is not allowed, because the company will be removed. Ignored if INVALID_OWNER.
+ * @return      True if the vehicle is compeletely in an allowed position.
+ */
+static bool VehiclePositionIsAllowed(const Vehicle *v, Owner owner = INVALID_OWNER)
+{
+	switch (v->type) {
+		case VEH_TRAIN:
+			for (const Vehicle *u = v; u != NULL; u = u->Next()) {
+				if (!IsInfraTileUsageAllowed(VEH_TRAIN, v->owner, u->tile) || GetTileOwner(u->tile) == owner) return false;
+			}
+			return true;
+		case VEH_ROAD:
+			for (const Vehicle *u = v; u != NULL; u = u->Next()) {
+				if (IsRoadDepotTile(u->tile) || IsStandardRoadStopTile(u->tile)) {
+					if (!IsInfraTileUsageAllowed(VEH_ROAD, v->owner, u->tile) || GetTileOwner(u->tile) == owner) return false;
+				}
+			}
+			return true;
+		case VEH_SHIP:
+			if (IsShipDepotTile(v->tile) && v->IsStoppedInDepot()) {
+				if (!IsInfraTileUsageAllowed(VEH_SHIP, v->owner, v->tile) || GetTileOwner(v->tile) == owner) return false;
+			}
+			return true;
+		case VEH_AIRCRAFT: {
+			const Aircraft *a = Aircraft::From(v);
+			if (a->state != FLYING && Station::IsValidID(a->targetairport)) {
+				Owner station_owner = Station::Get(a->targetairport)->owner;
+				if (!IsInfraUsageAllowed(VEH_AIRCRAFT, a->owner, station_owner) || station_owner == owner) return false;
+			}
+			return true;
+		}
+		default: return true;
+	}
+}
+
+/**
+ * Check whether an order has a destination that is allowed.
+ * I.e. it refers to a station/depot/waypoint the vehicle is allowed to visit.
+ * @param order The order to check
+ * @param v     The vehicle this order belongs to.
+ * @param owner Owner whose infrastructure is not allowed, because the company will be removed. Ignored if INVALID_OWNER.
+ * @return      True if the order has an allowed destination.
+ */
+static bool OrderDestinationIsAllowed(const Order *order, const Vehicle *v, Owner owner = INVALID_OWNER)
+{
+	Owner dest_owner;
+	switch (order->GetType()) {
+		case OT_GOTO_STATION:
+		case OT_GOTO_WAYPOINT: dest_owner = BaseStation::Get(order->GetDestination())->owner; break;
+		case OT_GOTO_DEPOT:    dest_owner = (v->type == VEH_AIRCRAFT) ? Station::Get(order->GetDestination())->owner : GetTileOwner(Depot::Get(order->GetDestination())->xy); break;
+		case OT_LOADING:       dest_owner = Station::Get(v->last_station_visited)->owner; break;
+		default: return true;
+	}
+	return dest_owner != owner && IsInfraUsageAllowed(v->type, v->owner, dest_owner);
+}
+
+/**
+ * Sell a vehicle, no matter where it may be.
+ * @param v The vehicle to sell
+ * @param give_money Do we actually need to give money to the vehicle owner?
+ */
+static void RemoveAndSellVehicle(Vehicle *v, bool give_money)
+{
+	assert(v->Previous() == NULL);
+
+	if (give_money) {
+		/* compute total value and give that to the owner */
+		Money value = 0;
+		for (Vehicle *u = v->First(); u != NULL; u = u->Next()) {
+			value += v->value;
+		}
+		CompanyID old = _current_company;
+		_current_company = v->owner;
+		SubtractMoneyFromCompany(CommandCost(EXPENSES_NEW_VEHICLES, -value));
+		_current_company = old;
+	}
+
+	/* take special measures for trains, but not when sharing is disabled or when the train is a free wagon chain */
+	if (_settings_game.economy.infrastructure_sharing[VEH_TRAIN] && v->type == VEH_TRAIN && Train::From(v)->IsFrontEngine()) {
+ 		DeleteVisibleTrain(Train::From(v));
+	} else {
+		delete v;
+	}
+}
+
+/**
+ * Check all path reservations, and reserve a new path if the current path is invalid.
+ */
+static void FixAllReservations()
+{
+	/* if this function is called, we can safely assume that sharing of rails is being switched off */
+	assert(!_settings_game.economy.infrastructure_sharing[VEH_TRAIN]);
+	Train *v;
+	FOR_ALL_TRAINS(v) {
+		if (!v->IsPrimaryVehicle() || (v->vehstatus & VS_CRASHED) != 0) continue;
+		/* It might happen that the train reserved additional tracks,
+		 * but FollowTrainReservation can't detect those because they are no longer reachable.
+		 * detect this by first finding the end of the reservation,
+		 * then switch sharing on and try again. If these two ends differ,
+		 * unreserve the path, switch sharing off and try to reserve a new path */
+		PBSTileInfo end_tile_info = FollowTrainReservation(v);
+
+		/* first do a quick test to determine whether the next tile has any reservation at all */
+		TileIndex next_tile = end_tile_info.tile + TileOffsByDiagDir(TrackdirToExitdir(end_tile_info.trackdir));
+		/* If the next tile doesn't have a reservation at all, the reservation surely ends here. Thus all is well */
+		if (GetReservedTrackbits(next_tile) == TRACK_BIT_NONE) continue;
+
+		/* change sharing setting temporarily */
+		_settings_game.economy.infrastructure_sharing[VEH_TRAIN] = true;
+		PBSTileInfo end_tile_info2 = FollowTrainReservation(v);
+		/* if these two reservation ends differ, unreserve the path and try to reserve a new path */
+		if (end_tile_info.tile != end_tile_info2.tile || end_tile_info.trackdir != end_tile_info2.trackdir) {
+			FreeTrainTrackReservation(v);
+			_settings_game.economy.infrastructure_sharing[VEH_TRAIN] = false;
+			TryPathReserve(v, true);
+		} else {
+			_settings_game.economy.infrastructure_sharing[VEH_TRAIN] = false;
+		}
+	}
+}
+
+/**
+ * Check if a sharing change is possible.
+ * If vehicles are still on others' infrastructure or using others' stations,
+ * The change is not possible and false is returned.
+ * @param type The type of vehicle whose setting will be changed.
+ * @return True if the change can take place, false otherwise.
+ */
+bool CheckSharingChangePossible(VehicleType type)
+{
+	if (type != VEH_AIRCRAFT) YapfNotifyTrackLayoutChange(INVALID_TILE, INVALID_TRACK);
+	/* Only do something when sharing is being disabled */
+	if (_settings_game.economy.infrastructure_sharing[type]) return true;
+
+	StringID error_message = STR_NULL;
+	Vehicle *v;
+	FOR_ALL_VEHICLES(v) {
+		if (type != v->type) continue;
+		if (v->Previous() != NULL) continue;
+
+		/* Check vehicle positiion */
+		if (!VehiclePositionIsAllowed(v)) {
+			error_message = STR_CONFIG_SETTING_SHARING_USED_BY_VEHICLES;
+			/* Break immediately, this error message takes precedence over the others. */
+			break;
+		}
+
+		/* Check current order */
+		if (!OrderDestinationIsAllowed(&v->current_order, v)) {
+			error_message = STR_CONFIG_SETTING_SHARING_ORDERS_TO_OTHERS;
+		}
+
+		/* Check order list */
+		if (v->FirstShared() != v) continue;
+		Order *o;
+		FOR_VEHICLE_ORDERS(v, o) {
+			if (!OrderDestinationIsAllowed(o, v)) {
+				error_message = STR_CONFIG_SETTING_SHARING_ORDERS_TO_OTHERS;
+			}
+		}
+	}
+
+	if (error_message != STR_NULL) {
+		ShowErrorMessage(error_message, INVALID_STRING_ID, WL_ERROR);
+		return false;
+	}
+
+	if (type == VEH_TRAIN) FixAllReservations();
+
+	return true;
+}
+
+/**
+ * Handle the removal (through reset_company or bankruptcy) of a company.
+ * i.e. remove all vehicles owned by that company or on its infrastructure,
+ * and delete all now-invalid orders.
+ * @param Owner the company to be removed.
+ */
+void HandleSharingCompanyDeletion(Owner owner)
+{
+	YapfNotifyTrackLayoutChange(INVALID_TILE, INVALID_TRACK);
+
+	Vehicle *v;
+	FOR_ALL_VEHICLES(v) {
+		if (!IsCompanyBuildableVehicleType(v) || v->Previous() != NULL) continue;
+		/* vehicle position */
+		if (v->owner == owner || !VehiclePositionIsAllowed(v, owner)) {
+			RemoveAndSellVehicle(v, v->owner != owner);
+			continue;
+		}
+		/* current order */
+		if (!OrderDestinationIsAllowed(&v->current_order, v, owner)) {
+			if (v->current_order.IsType(OT_LOADING)) {
+				v->LeaveStation();
+			} else {
+				v->current_order.MakeDummy();
+			}
+			SetWindowDirty(WC_VEHICLE_VIEW, v->index);
+		}
+
+		/* order list */
+		if (v->FirstShared() != v) continue;
+
+		Order *o;
+		int id = -1;
+		FOR_VEHICLE_ORDERS(v, o) {
+			id++;
+			if (OrderDestinationIsAllowed(o, v, owner)) continue;
+
+			o->MakeDummy();
+			for (const Vehicle *w = v; w != NULL; w = w->NextShared()) {
+				/* In GUI, simulate by removing the order and adding it back */
+				InvalidateVehicleOrder(w, id | (INVALID_VEH_ORDER_ID << 8));
+				InvalidateVehicleOrder(w, (id << 8) | INVALID_VEH_ORDER_ID);
+			}
+		}
+	}
+}
+
+/**
+ * Update all block signals on the map.
+ * To be called after the setting for sharing of rails changes.
+ * @param owner Owner whose signals to update. If INVALID_OWNER, update everything.
+ */
+void UpdateAllBlockSignals(Owner owner)
+{
+	Owner last_owner = INVALID_OWNER;
+	TileIndex tile = 0;
+	do {
+		if (IsTileType(tile, MP_RAILWAY) && HasSignals(tile)) {
+			Owner track_owner = GetTileOwner(tile);
+			if (owner != INVALID_OWNER && track_owner != owner) continue;
+
+			if (!IsOneSignalBlock(track_owner, last_owner)) {
+				/* Cannot update signals of two different companies in one run,
+				 * if these signal blocks are not joined */
+				UpdateSignalsInBuffer();
+				last_owner = track_owner;
+			}
+			TrackBits bits = GetTrackBits(tile);
+			do {
+				Track track = RemoveFirstTrack(&bits);
+				if (HasSignalOnTrack(tile, track)) {
+					AddTrackToSignalBuffer(tile, track, track_owner);
+				}
+			} while (bits != TRACK_BIT_NONE);
+		} else if (IsLevelCrossingTile(tile) && (owner == INVALID_OWNER || GetTileOwner(tile) == owner)) {
+			UpdateLevelCrossing(tile);
+		}
+	} while (++tile != MapSize());
+
+	UpdateSignalsInBuffer();}
diff -urNad openttd-1.3.2/src/infrastructure_func.h openttd-1.3.2-DC3.0RC3/src/infrastructure_func.h
--- openttd-1.3.2/src/infrastructure_func.h	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/infrastructure_func.h	2013-11-22 05:49:07.000000000 +0100
@@ -0,0 +1,106 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file infrastructure_func.h Functions for access to (shared) infrastructure */
+
+#ifndef INFRASTRUCTURE_FUNC_H
+#define INFRASTRUCTURE_FUNC_H
+
+#include "vehicle_base.h"
+#include "settings_type.h"
+#include "command_type.h"
+#include "company_func.h"
+#include "tile_map.h"
+
+void PayStationSharingFee(Vehicle *v, const Station *st);
+void PayDailyTrackSharingFee(Train *v);
+
+bool CheckSharingChangePossible(VehicleType type);
+void HandleSharingCompanyDeletion(Owner owner);
+void UpdateAllBlockSignals(Owner owner = INVALID_OWNER);
+
+/**
+ * Check whether a vehicle of a given owner and type can use the infrastrucutre of a given company.
+ * @param type        Type of vehicle we are talking about.
+ * @param veh_owner   Owner of the vehicle in question.
+ * @param infra_owner The owner of the infrastructure.
+ * @return            True if infrastructure usage is allowed, false otherwise.
+ */
+static inline bool IsInfraUsageAllowed(VehicleType type, Owner veh_owner, Owner infra_owner)
+{
+	return infra_owner == veh_owner || infra_owner == OWNER_NONE || _settings_game.economy.infrastructure_sharing[type];
+}
+
+/**
+ * Check whether a vehicle of a given owner and type can use the infrastrucutre on a given tile.
+ * @param type        Type of vehicle we are talking about.
+ * @param veh_owner   Owner of the vehicle in question.
+ * @param tile        The tile that may or may not be used.
+ * @return            True if infrastructure usage is allowed, false otherwise.
+ */
+static inline bool IsInfraTileUsageAllowed(VehicleType type, Owner veh_owner, TileIndex tile)
+{
+	return IsInfraUsageAllowed(type, veh_owner, GetTileOwner(tile));
+}
+
+/**
+ * Is a vehicle owned by _current_company allowed to use the infrastructure of infra_owner?
+ * If this is not allowed, this function provides the appropriate error message.
+ * @see IsInfraUsageAllowed
+ * @see CheckOwnership
+ * @param type        Type of vehicle.
+ * @param infra_owner Owner of the infrastructure.
+ * @param tile        Tile of the infrastructure.
+ * @return            CommandCost indicating success or failure.
+ */
+static inline CommandCost CheckInfraUsageAllowed(VehicleType type, Owner infra_owner, TileIndex tile = 0)
+{
+	if (infra_owner == OWNER_NONE || _settings_game.economy.infrastructure_sharing[type]) return CommandCost();
+	return CheckOwnership(infra_owner, tile);
+}
+
+/**
+ * Check whether a given company can control this vehicle.
+ * Controlling a vehicle means permission to start, stop or reverse it or to make it ignore signals.
+ * @param v The vehicle which may or may not be controlled.
+ * @param o The company which may or may not control this vehicle.
+ * @return  True if the given company is allowed to control this vehicle.
+ */
+static inline bool IsVehicleControlAllowed(const Vehicle *v, Owner o)
+{
+	return v->owner == o || (v->type == VEH_TRAIN && IsTileOwner(v->tile, o));
+}
+
+/**
+ * Check whether _current_company can control this vehicle.
+ * If this is not allowed, this function provides the appropriate error message.
+ * @see IsVehicleControlAllowed
+ * @param v The vehicle which may or may not be controlled.
+ * @return  CommandCost indicating success or failure.
+ */
+static inline CommandCost CheckVehicleControlAllowed(const Vehicle *v)
+{
+	if (v->type == VEH_TRAIN && IsTileOwner(v->tile, _current_company)) return CommandCost();
+	return CheckOwnership(v->owner);
+}
+
+/**
+ * Do signal states propagate from the tracks of one owner to the other?
+ * @note This function should be consistent, so if it returns true for (a, b) and (b, c),
+ * it should also return true for (a, c).
+ * @param o1 First track owner.
+ * @param o2 Second track owner.
+ * @return   True if tracks of the two owners are part of the same signal block.
+ */
+static inline bool IsOneSignalBlock(Owner o1, Owner o2)
+{
+	return o1 == o2 || _settings_game.economy.infrastructure_sharing[VEH_TRAIN];
+}
+
+#endif /* INFRASTRUCTURE_FUNC_H */
diff -urNad openttd-1.3.2/src/landscape.cpp openttd-1.3.2-DC3.0RC3/src/landscape.cpp
--- openttd-1.3.2/src/landscape.cpp	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/landscape.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -21,6 +21,7 @@
 #include "void_map.h"
 #include "tgp.h"
 #include "genworld.h"
+#include "town.h"
 #include "fios.h"
 #include "date_func.h"
 #include "water.h"
@@ -559,6 +560,8 @@
  */
 byte GetSnowLine()
 {
+       if (_settings_game.game_creation.landscape == LT_TEMPERATE && !_settings_game.construction.snow_in_temperate) return 0xFF;
+
 	if (_snow_line == NULL) return _settings_game.game_creation.snow_line_height;
 
 	YearMonthDay ymd;
@@ -635,7 +638,43 @@
 			return_cmd_error(STR_ERROR_CAN_T_BUILD_ON_WATER);
 		}
 	} else {
-		cost.AddCost(_tile_type_procs[GetTileType(tile)]->clear_tile_proc(tile, flags));
+
+   		TileType type = GetTileType(tile);
+		cost.AddCost(_tile_type_procs[type]->clear_tile_proc(tile, flags));
+
+		/* construction near towns is more expensive with the town construction cost patch enabled */
+		if (_settings_game.economy.town_construction_cost) {
+			const Town *t = ClosestTownFromTile(tile, (uint)-1);
+			if (t != NULL) { ///< this if is required or scenario editor will crash with no towns on certain actions
+				uint distance = DistanceSquare(tile, t->xy);
+				switch(type) {
+
+					case MP_HOUSE: ///< demolishing a house is expensive especially in large cities
+						if (t->cache.population < 600) break;
+						cost.MultiplyCost(((t->cache.population / 408) * (1024 / (distance + 1)) / 2) + 1);
+						break;
+
+					case MP_WATER: ///< make levelling and demolishing on water a little less expensive
+						if (t->cache.population < 600) break;
+						cost.MultiplyCost(((t->cache.population / 408) * (1024 / (distance + 1)) / 48) + 1);
+						break;
+
+					case MP_ROAD: ///< building and demolishing road should be a little easier
+						cost.MultiplyCost((((t->cache.population + 1) / 640) * (1536 / (distance + 1)) / 8) + 1);
+						break;
+
+					case MP_RAILWAY: case MP_OBJECT: ///< don't give you more money on selling than you paid
+						if (t->cache.population < 999999) break; ///< to fix exploits until a better solution is found
+						cost.MultiplyCost(((t->cache.population / 512) * (1536 / (distance + 1)) / 12) + 1);
+						break;
+
+					default:
+						if (t->cache.population < 800) break;
+						cost.MultiplyCost((t->cache.population / 408) * (1536 / (distance + 1)) + 1);
+						break;
+	}
+			}
+		}
 	}
 
 	if (flags & DC_EXEC) {
@@ -899,7 +938,7 @@
 		for (data = _make_desert_or_rainforest_data;
 				data != endof(_make_desert_or_rainforest_data); ++data) {
 			TileIndex t = AddTileIndexDiffCWrap(tile, *data);
-			if (t != INVALID_TILE && (TileHeight(t) >= 4 || IsTileType(t, MP_WATER))) break;
+			if (t != INVALID_TILE && (TileHeight(t) >= _settings_game.construction.max_heightlevel / 4 || IsTileType(t, MP_WATER))) break;
 		}
 		if (data == endof(_make_desert_or_rainforest_data)) {
 			SetTropicZone(tile, TROPICZONE_DESERT);
@@ -1044,15 +1083,40 @@
 	}
 }
 
+/** Callback to widen a river tile. */
+static bool RiverMakeWider(TileIndex tile, void *data)
+{
+	if (IsValidTile(tile) && !IsWaterTile(tile) && GetTileSlope(tile) == GetTileSlope(*(TileIndex *)data)) {
+		MakeRiver(tile, Random());
+		/* Remove desert directly around the river tile. */
+		TileIndex cur_tile = tile;
+		CircularTileSearch(&cur_tile, 5, RiverModifyDesertZone, NULL);
+	}
+	return false;
+}
+
 /* AyStar callback when an route has been found. */
 static void River_FoundEndNode(AyStar *aystar, OpenListNode *current)
 {
+	/* Count river length. */
+	uint length = 0;
 	for (PathNode *path = &current->path; path != NULL; path = path->parent) {
+		length++;
+	}
+
+	uint cur_pos = 0;
+	for (PathNode *path = &current->path; path != NULL; path = path->parent, cur_pos++) {
 		TileIndex tile = path->node.tile;
 		if (!IsWaterTile(tile)) {
 			MakeRiver(tile, Random());
-			/* Remove desert directly around the river tile. */
-			CircularTileSearch(&tile, 5, RiverModifyDesertZone, NULL);
+			/* Widen river depending on how far we are away from the source. */
+			uint radius = min((length - cur_pos) / 15u, 3u);
+			if (radius > 1) {
+				CircularTileSearch(&tile, radius + RandomRange(1), RiverMakeWider, (void *)&path->node.tile);
+			} else {
+				/* Remove desert directly around the river tile. */
+				CircularTileSearch(&tile, 5, RiverModifyDesertZone, NULL);
+			}
 		}
 	}
 }
diff -urNad openttd-1.3.2/src/lang/afrikaans.txt openttd-1.3.2-DC3.0RC3/src/lang/afrikaans.txt
--- openttd-1.3.2/src/lang/afrikaans.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/afrikaans.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1912,7 +1912,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Skop
 STR_NETWORK_CLIENTLIST_BAN                                      :Verbod
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Gee geld
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Praat met almal
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Praat met maatskappy
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Privaate boodskap
@@ -1921,7 +1920,6 @@
 STR_NETWORK_CLIENT                                              :Klient
 STR_NETWORK_SPECTATORS                                          :Aanskouers
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Sleutel die bedrag geld in wat u wil gee
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Moenie die ingesleutelde wagwoord bewaar nie
@@ -3006,6 +3004,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Bou hoofkwartier elders teen 'n koste gelykstaande aan 1% van maatskappy se waarde. Shift+Kliek vir kwotasie
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Besonderhede
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}Sien gedetaileerde infrastruktuur telling
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Gee geld
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}Nuwe Gesig
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Kies nuwe gesig vir bestuurder
@@ -3023,6 +3022,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Maatskappy Naam
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Bestuurder se Naam
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Sleutel die bedrag geld in wat u wil gee
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Ons is opsoek na 'n vervoer maatskappy wat ons se maatskappy sal oorvat.{}{}Wil jy {COMPANY} koop vir {CURRENCY_LONG}?
 
diff -urNad openttd-1.3.2/src/lang/arabic_egypt.txt openttd-1.3.2-DC3.0RC3/src/lang/arabic_egypt.txt
--- openttd-1.3.2/src/lang/arabic_egypt.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/arabic_egypt.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1700,7 +1700,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :اطرد
 STR_NETWORK_CLIENTLIST_BAN                                      :بان
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :اعط اموال
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :تحدث مع الكل
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :تحدث لشركة
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :رسالة خاصة
@@ -1709,7 +1708,6 @@
 STR_NETWORK_CLIENT                                              :عميل
 STR_NETWORK_SPECTATORS                                          :المشاهدين
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}ادخل قدر المال الذي تود اعطائه
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}لا تحفظ كلمة المرور المدخلة
@@ -2743,6 +2741,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :اسم الشركة
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :اسم صاحب الشركة
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :ادخل قدر المال الذي تود اعطائه
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}نحن نبحث عن شركة لتشتري شركتنا. {}{} عل ترغب في شراء {COMPANY} بـ {CURRENCY_LONG}؟
 
diff -urNad openttd-1.3.2/src/lang/basque.txt openttd-1.3.2-DC3.0RC3/src/lang/basque.txt
--- openttd-1.3.2/src/lang/basque.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/basque.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1912,7 +1912,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Kanporatu
 STR_NETWORK_CLIENTLIST_BAN                                      :Debekatu
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Dirua eman
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Guztiei hitz egin
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Konpainiari hitz egin
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Mezu pribatua
@@ -1921,7 +1920,6 @@
 STR_NETWORK_CLIENT                                              :Bezeroa
 STR_NETWORK_SPECTATORS                                          :Ikusleak
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Eman nahi duzun diru kantitatea ezarri
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Ez gorde sartutako pasahitza
@@ -3003,6 +3001,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Konpainiaren egoitza birkokatu, konpainiaren balioaren %1 gatik. Shift+klik gutxi gora beherako kostea erakutsi
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Xehetasunak
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}Azpiegitura kantitateak xehetasunez ikusi
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Dirua eman
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}Aurpegi berria
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Lehendakariaren aurpegi berria aukeratu
@@ -3020,6 +3019,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Konpainiaren izena
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Lehendakariaren izena
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Eman nahi duzun diru kantitatea ezarri
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Gure konpainia erostea nahiko genuke{}{}{COMPANY} {CURRENCY_LONG}rengatik erosi nahi duzu?
 
diff -urNad openttd-1.3.2/src/lang/belarusian.txt openttd-1.3.2-DC3.0RC3/src/lang/belarusian.txt
--- openttd-1.3.2/src/lang/belarusian.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/belarusian.txt	2013-11-22 05:49:07.000000000 +0100
@@ -2267,7 +2267,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Выкінуць гульца
 STR_NETWORK_CLIENTLIST_BAN                                      :Бан
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Передаць грошай
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Пагутарыць з усімі
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Пагутарыць з кампаніяй
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Прыватнае паведамленьне
@@ -2276,7 +2275,6 @@
 STR_NETWORK_CLIENT                                              :Кліент
 STR_NETWORK_SPECTATORS                                          :Назіральнікі
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Увядзіце суму грошай, якую вы хочаце перадаць
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Не захоўваць уведзены пароль
@@ -3384,6 +3382,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Перамясьціць штаб-кватэру кампаніі ў іншае месца за 1% ацэнкавага кошту капіталу кампаніі. Shift+пстрычка — ацэнка кошту пераносу.
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Дэталi
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}Паказаць дэталёвыя iнфраструктурныя падлiкi
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Передаць грошай
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}Зьнешнасьць
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Зьмяніць зьнешнасьць дырэктара
@@ -3401,6 +3400,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Кампанія
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Імя дырэктара
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Увядзіце суму грошай, якую вы хочаце перадаць
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Мы шукаем транспартную кампанію для далучэньня да яе.{}{}Вы хочаце купіць {COMPANY} за {CURRENCY_LONG}?
 
diff -urNad openttd-1.3.2/src/lang/brazilian_portuguese.txt openttd-1.3.2-DC3.0RC3/src/lang/brazilian_portuguese.txt
--- openttd-1.3.2/src/lang/brazilian_portuguese.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/brazilian_portuguese.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1955,7 +1955,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Banir
 STR_NETWORK_CLIENTLIST_BAN                                      :Banir
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Dar dinheiro
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Falar com todos
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Falar com a empresa
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Mensagem privada
@@ -1964,7 +1963,6 @@
 STR_NETWORK_CLIENT                                              :Cliente
 STR_NETWORK_SPECTATORS                                          :Espectadores
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Entre a quantia a ser dada
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Não salvar a senha digitada
@@ -3052,6 +3050,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Reconstruir sede da empresa em outro local por 1% do valor da empresa. Shift+Clique mostra o preço estimado sem reconstruir a sede
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Detalhes
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}Ver informações detalhadas de infraestrutura
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Dar dinheiro
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}Novo Rosto
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Selecionar novo rosto para o presidente
@@ -3069,6 +3068,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Nome da Empresa
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Nome do Presidente
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Entre a quantia a ser dada
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Estamos à procura de uma empresa de transportes para comprar a nossa empresa{}{}Deseja comprar {COMPANY} por {CURRENCY_LONG}?
 
diff -urNad openttd-1.3.2/src/lang/bulgarian.txt openttd-1.3.2-DC3.0RC3/src/lang/bulgarian.txt
--- openttd-1.3.2/src/lang/bulgarian.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/bulgarian.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1962,7 +1962,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Изгони
 STR_NETWORK_CLIENTLIST_BAN                                      :Бан
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Дай пари
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Кажи на всички
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Кажи на компания
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Лично съобщение
@@ -1971,7 +1970,6 @@
 STR_NETWORK_CLIENT                                              :Клиент
 STR_NETWORK_SPECTATORS                                          :Наблюдатели
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Въведете количеството пари, което искате да дадете
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Незапазвай паролата
@@ -3075,6 +3073,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Име на компанията
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Име на управителя
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Въведете количеството пари, което искате да дадете
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Ние търсим транспортна компания, която да поеме нашата компания.{}{}Do you want to purchase {COMPANY} for {CURRENCY_LONG}?
 
diff -urNad openttd-1.3.2/src/lang/catalan.txt openttd-1.3.2-DC3.0RC3/src/lang/catalan.txt
--- openttd-1.3.2/src/lang/catalan.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/catalan.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1955,7 +1955,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Breu
 STR_NETWORK_CLIENTLIST_BAN                                      :Prohibit
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Entrega diners
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Parla a tothom
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Parla a l'Empresa
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Missatge Privat
@@ -1964,7 +1963,6 @@
 STR_NETWORK_CLIENT                                              :Client
 STR_NETWORK_SPECTATORS                                          :Espectadors
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Introdueix la quantitat de diners que vols donar
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}No desis la contrasenya introduïda
@@ -3052,6 +3050,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Trasllada la seu de la companyia a un altre lloc amb el cost d'un 1% del seu valor. Shift+Clic mostra el cost estimat sense traslladar la seu
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Detalls
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}Veure detalls del càlculs de l'infrastructura
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Entrega diners
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}Nova Cara
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Selecciona una nova cara pel president
@@ -3069,6 +3068,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Nom Empresa
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Nom President
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Introdueix la quantitat de diners que vols donar
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Busquem empresa de transports per absorbir la nostra companyia{}{}Vols comprar a {COMPANY} per {CURRENCY_LONG}?
 
diff -urNad openttd-1.3.2/src/lang/croatian.txt openttd-1.3.2-DC3.0RC3/src/lang/croatian.txt
--- openttd-1.3.2/src/lang/croatian.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/croatian.txt	2013-11-22 05:49:07.000000000 +0100
@@ -2050,7 +2050,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Izbaci
 STR_NETWORK_CLIENTLIST_BAN                                      :Zabrana
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Daj novac
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Razgovaraj sa svima
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Razgovaraj s tvrtkom
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Privatna poruka
@@ -2059,7 +2058,6 @@
 STR_NETWORK_CLIENT                                              :Klijent
 STR_NETWORK_SPECTATORS                                          :Promatrači
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Unesite iznos novca koji želite dati
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Nemoj spremiti upisanu zaporku
@@ -3147,6 +3145,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Izgradi sjedište tvrtke negdje drugdje za 1% troška od cjelokupne vrijednosti tvrtke. Shift+Klik prikazuje trošak bez premještanja sjedišta tvrtke.
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Detalji
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}Pogledaj detaljne podatke infrastrukture
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Daj novac
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}Novo lice
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Odaberi novo lice direktora
@@ -3164,6 +3163,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Ime tvrtke
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Ime direktora
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Unesite iznos novca koji želite dati
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Tražimo prijevoznu tvrtku koja bi preuzela našu tvrtku.{}{}Želiš li kupiti tvrtku {COMPANY} za {CURRENCY_LONG}?
 
diff -urNad openttd-1.3.2/src/lang/czech.txt openttd-1.3.2-DC3.0RC3/src/lang/czech.txt
--- openttd-1.3.2/src/lang/czech.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/czech.txt	2013-11-22 05:49:07.000000000 +0100
@@ -2036,7 +2036,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Vyhodit
 STR_NETWORK_CLIENTLIST_BAN                                      :Ban
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Darovat peníze
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Napsat všem
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Napsat společnosti
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Soukromá zpráva
@@ -2045,7 +2044,6 @@
 STR_NETWORK_CLIENT                                              :Klient
 STR_NETWORK_SPECTATORS                                          :Pozorovatelé
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Napiš částku, kterou chceš poskytnout
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Neukládat zadané heslo
@@ -3139,6 +3137,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Sídlo společnosti můžeš vystavit jinde za 1{NBSP}% její hodnoty. Stisknutý Shift pro zobrazení odhadu ceny
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Detaily
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}Zobrazit detaily a souhrny o infrastruktuře
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Darovat peníze
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}Nový obličej
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Zvol nový obličej prezidenta
@@ -3156,6 +3155,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Jméno společnosti
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Jméno prezidenta
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Napiš částku, kterou chceš poskytnout
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Hledáme společnost, která převezme naši společnost.{}{}Chcete zakoupit {COMPANY} za {CURRENCY_LONG}?
 
diff -urNad openttd-1.3.2/src/lang/danish.txt openttd-1.3.2-DC3.0RC3/src/lang/danish.txt
--- openttd-1.3.2/src/lang/danish.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/danish.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1954,7 +1954,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Smid ud
 STR_NETWORK_CLIENTLIST_BAN                                      :Ban (Forvis spiller)
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Giv penge
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Tal til alle
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Tal til selskab
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Privat besked
@@ -1963,7 +1962,6 @@
 STR_NETWORK_CLIENT                                              :Klient
 STR_NETWORK_SPECTATORS                                          :Tilskuere
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Skriv beløbet du vil give
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Gem ikke den indtastede adgangskode
@@ -3051,6 +3049,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Flyt selskabets hovedkvarter for 1% af selskabsværdien. Shift skifter mellem at flytte og vise prisoverslag.
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Detaljer
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}Se detaljerede infrastruktur-tal
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Giv penge
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}Nyt ansigt
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Vælg nyt ansigt til direktøren
@@ -3068,6 +3067,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Selskabsnavn
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Direktørens navn
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Skriv beløbet du vil give
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Vi leder efter et selskab til at overtage vores{}{}Vil du købe {COMPANY} for {CURRENCY_LONG}?
 
diff -urNad openttd-1.3.2/src/lang/dutch.txt openttd-1.3.2-DC3.0RC3/src/lang/dutch.txt
--- openttd-1.3.2/src/lang/dutch.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/dutch.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1954,7 +1954,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Gooi uit het spel
 STR_NETWORK_CLIENTLIST_BAN                                      :Verban uit het spel
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Geef geld
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Praat met iedereen
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Praat met het bedrijf
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Praat met deze persoon
@@ -1963,7 +1962,6 @@
 STR_NETWORK_CLIENT                                              :Speler
 STR_NETWORK_SPECTATORS                                          :Toeschouwers
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Voer de hoeveelheid geld die je wilt geven in
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Sla het ingegeven wachtwoord niet op
@@ -3051,6 +3049,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Herbouw bedrijfshoofdkwartier ergens anders voor 1% van de bedrijfswaarde. Shift+klik toont verwachte kosten zonder HQ te verplaatsen
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Details
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}Bekijken gedetailleerde aantallen infrastructuur
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Geef geld
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}Nieuw gezicht
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Kies nieuw gezicht voor directeur
@@ -3068,6 +3067,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Bedrijfsnaam
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Naam van directeur
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Voer de hoeveelheid geld die je wilt geven in
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}We zoeken een transportbedrijf dat ons bedrijf over kan nemen.{}{}Wil je {COMPANY} kopen voor {CURRENCY_LONG}?
 
diff -urNad openttd-1.3.2/src/lang/english_AU.txt openttd-1.3.2-DC3.0RC3/src/lang/english_AU.txt
--- openttd-1.3.2/src/lang/english_AU.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/english_AU.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1954,7 +1954,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Kick
 STR_NETWORK_CLIENTLIST_BAN                                      :Ban
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Give money
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Speak to all
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Speak to company
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Private message
@@ -1963,7 +1962,6 @@
 STR_NETWORK_CLIENT                                              :Client
 STR_NETWORK_SPECTATORS                                          :Spectators
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Enter the amount of money you want to give
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Do not save the entered password
@@ -3051,6 +3049,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Rebuild company headquarters elsewhere for 1% cost of company value. Shift+Click shows estimated cost without relocating HQ
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Details
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}View detailed infrastructure counts
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Give money
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}New Face
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Select new face for manager
@@ -3068,6 +3067,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Company Name
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Manager's Name
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Enter the amount of money you want to give
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}We are looking for a transport company to take-over our company.{}{}Do you want to purchase {COMPANY} for {CURRENCY_LONG}?
 
diff -urNad openttd-1.3.2/src/lang/english.txt openttd-1.3.2-DC3.0RC3/src/lang/english.txt
--- openttd-1.3.2/src/lang/english.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/english.txt	2013-11-22 06:03:25.000000000 +0100
@@ -224,6 +224,7 @@
 STR_TOOLTIP_SORT_ORDER                                          :{BLACK}Select sorting order (descending/ascending)
 STR_TOOLTIP_SORT_CRITERIA                                       :{BLACK}Select sorting criteria
 STR_TOOLTIP_FILTER_CRITERIA                                     :{BLACK}Select filtering criteria
+STR_BUTTON_COVERAGE                                             :{BLACK}Coverage
 STR_BUTTON_SORT_BY                                              :{BLACK}Sort by
 STR_BUTTON_LOCATION                                             :{BLACK}Location
 STR_BUTTON_RENAME                                               :{BLACK}Rename
@@ -358,6 +359,7 @@
 STR_SETTINGS_MENU_SIGNS_DISPLAYED                               :Signs displayed
 STR_SETTINGS_MENU_SHOW_COMPETITOR_SIGNS                         :Competitor signs and names displayed
 STR_SETTINGS_MENU_FULL_ANIMATION                                :Full animation
+STR_SETTINGS_MENU_RAIL_FENCES                                   :Rail fences
 STR_SETTINGS_MENU_FULL_DETAIL                                   :Full detail
 STR_SETTINGS_MENU_TRANSPARENT_BUILDINGS                         :Transparent buildings
 STR_SETTINGS_MENU_TRANSPARENT_SIGNS                             :Transparent signs
@@ -375,6 +377,7 @@
 STR_MAP_MENU_MAP_OF_WORLD                                       :Map of world
 STR_MAP_MENU_EXTRA_VIEW_PORT                                    :Extra viewport
 STR_MAP_MENU_SIGN_LIST                                          :Sign list
+STR_MAP_MENU_WATCH_COMPANY                                      :Watch Company
 
 ############ range for town menu starts
 STR_TOWN_MENU_TOWN_DIRECTORY                                    :Town directory
@@ -429,6 +432,7 @@
 
 ############ range for landscaping menu starts
 STR_LANDSCAPING_MENU_LANDSCAPING                                :Landscaping
+STR_LANDSCAPING_MENU_CLIPBOARD                                  :Clipboard
 STR_LANDSCAPING_MENU_PLANT_TREES                                :Plant trees
 STR_LANDSCAPING_MENU_PLACE_SIGN                                 :Place sign
 ############ range ends here
@@ -661,17 +665,20 @@
 STR_SMALLMAP_TYPE_CONTOURS                                      :Contours
 STR_SMALLMAP_TYPE_VEHICLES                                      :Vehicles
 STR_SMALLMAP_TYPE_INDUSTRIES                                    :Industries
+STR_SMALLMAP_TYPE_ROUTELINKS                                    :Route links
 STR_SMALLMAP_TYPE_ROUTES                                        :Routes
 STR_SMALLMAP_TYPE_VEGETATION                                    :Vegetation
 STR_SMALLMAP_TYPE_OWNERS                                        :Owners
 STR_SMALLMAP_TOOLTIP_SHOW_LAND_CONTOURS_ON_MAP                  :{BLACK}Show land contours on map
 STR_SMALLMAP_TOOLTIP_SHOW_VEHICLES_ON_MAP                       :{BLACK}Show vehicles on map
 STR_SMALLMAP_TOOLTIP_SHOW_INDUSTRIES_ON_MAP                     :{BLACK}Show industries on map
+STR_SMALLMAP_TOOLTIP_SHOW_ROUTE_LINKS_ON_MAP                    :{BLACK}Show route links on map
 STR_SMALLMAP_TOOLTIP_SHOW_TRANSPORT_ROUTES_ON                   :{BLACK}Show transport routes on map
 STR_SMALLMAP_TOOLTIP_SHOW_VEGETATION_ON_MAP                     :{BLACK}Show vegetation on map
 STR_SMALLMAP_TOOLTIP_SHOW_LAND_OWNERS_ON_MAP                    :{BLACK}Show land owners on map
 STR_SMALLMAP_TOOLTIP_INDUSTRY_SELECTION                         :{BLACK}Click on an industry type to toggle displaying it. Ctrl+Click disables all types except the selected one. Ctrl+Click on it again to enable all industry types
 STR_SMALLMAP_TOOLTIP_COMPANY_SELECTION                          :{BLACK}Click on a company to toggle displaying its property. Ctrl+Click disables all companies except the selected one. Ctrl+Click on it again to enable all companies
+STR_SMALLMAP_TOOLTIP_ROUTELINK_SELECTION                        :{BLACK}Click on a cargo to toggle displaying the route links. Ctrl+Click disables all route links except the selected one. Ctrl+Click on it again to enable all route links
 
 STR_SMALLMAP_LEGENDA_ROADS                                      :{TINY_FONT}{BLACK}Roads
 STR_SMALLMAP_LEGENDA_RAILROADS                                  :{TINY_FONT}{BLACK}Railways
@@ -707,6 +714,7 @@
 STR_SMALLMAP_INDUSTRY                                           :{TINY_FONT}{STRING} ({NUM})
 STR_SMALLMAP_COMPANY                                            :{TINY_FONT}{COMPANY}
 STR_SMALLMAP_TOWN                                               :{TINY_FONT}{WHITE}{TOWN}
+STR_SMALLMAP_CARGO                                              :{TINY_FONT}{STRING}
 STR_SMALLMAP_DISABLE_ALL                                        :{BLACK}Disable all
 STR_SMALLMAP_ENABLE_ALL                                         :{BLACK}Enable all
 STR_SMALLMAP_SHOW_HEIGHT                                        :{BLACK}Show height
@@ -715,6 +723,8 @@
 STR_SMALLMAP_TOOLTIP_SHOW_HEIGHT                                :{BLACK}Toggle display of heightmap
 STR_SMALLMAP_TOOLTIP_DISABLE_ALL_COMPANIES                      :{BLACK}Display no company property on the map
 STR_SMALLMAP_TOOLTIP_ENABLE_ALL_COMPANIES                       :{BLACK}Display all company property on the map
+STR_SMALLMAP_TOOLTIP_DISABLE_ALL_ROUTELINKS                     :{BLACK}Display no route links on the map
+STR_SMALLMAP_TOOLTIP_ENABLE_ALL_ROUTELINKS                      :{BLACK}Display route links for all cargoes on the map
 
 # Status bar messages
 STR_STATUSBAR_TOOLTIP_SHOW_LAST_NEWS                            :{BLACK}Show last message or news report
@@ -1029,10 +1039,13 @@
 STR_SUBSIDY_X3                                                  :x3
 STR_SUBSIDY_X4                                                  :x4
 
+STR_TERRAIN_TYPE_EXTREMELY_FLAT                                 :Extremely flat
 STR_TERRAIN_TYPE_VERY_FLAT                                      :Very Flat
 STR_TERRAIN_TYPE_FLAT                                           :Flat
+STR_TERRAIN_TYPE_BUMPY                                          :Bumpy
 STR_TERRAIN_TYPE_HILLY                                          :Hilly
 STR_TERRAIN_TYPE_MOUNTAINOUS                                    :Mountainous
+STR_TERRAIN_TYPE_ALPINIST                                       :Alpinist
 
 STR_CITY_APPROVAL_PERMISSIVE                                    :Permissive
 STR_CITY_APPROVAL_TOLERANT                                      :Tolerant
@@ -1100,8 +1113,12 @@
 STR_CONFIG_SETTING_SUBSIDY_MULTIPLIER_HELPTEXT                  :Set how much is paid for subsidised connections
 STR_CONFIG_SETTING_CONSTRUCTION_COSTS                           :Construction costs: {STRING2}
 STR_CONFIG_SETTING_CONSTRUCTION_COSTS_HELPTEXT                  :Set level of construction and purchase costs
+STR_CONFIG_SETTING_TAXES                                   	:Yearly taxes: {STRING2}
+STR_CONFIG_SETTING_TAXES_HELPTEXT                          	:Enable yearly taxes. 10% for 200.000 income, and 20% for 1.500.000 income.
 STR_CONFIG_SETTING_RECESSIONS                                   :Recessions: {STRING2}
 STR_CONFIG_SETTING_RECESSIONS_HELPTEXT                          :If enabled, recessions may occur every few years. During a recession all production is significantly lower (it returns to previous level when the recession is over)
+STR_CONFIG_SETTING_LOST_CARGO                                    :Lost cargo generates lost money: {STRING2}
+STR_CONFIG_SETTING_LOST_CARGO_HELPTEXT                           :If a rating at a station is below than 50%, then the lost cargo will cost money.
 STR_CONFIG_SETTING_TRAIN_REVERSING                              :Disallow train reversing in stations: {STRING2}
 STR_CONFIG_SETTING_TRAIN_REVERSING_HELPTEXT                     :If enabled, trains will not reverse in non-terminus stations, even if there is a shorter path to their next destination when reversing
 STR_CONFIG_SETTING_DISASTERS                                    :Disasters: {STRING2}
@@ -1109,14 +1126,20 @@
 STR_CONFIG_SETTING_CITY_APPROVAL                                :City council's attitude towards area restructuring: {STRING2}
 STR_CONFIG_SETTING_CITY_APPROVAL_HELPTEXT                       :Choose how much noise and environmental damage by companies affect their town rating and further construction actions in their area
 
+STR_CONFIG_SETTING_MAX_HEIGHTLEVEL                              :Maximal allowed heightlevel: {STRING2}
+STR_CONFIG_SETTING_TOO_HIGH_MOUNTAIN                            :You can´t set the maximal allowed heightlevel to this value. At least one mountain on the map is higher.
 STR_CONFIG_SETTING_BUILDONSLOPES                                :Allow building on slopes and coasts: {STRING2}
 STR_CONFIG_SETTING_BUILDONSLOPES_HELPTEXT                       :If enabled, tracks and stations can be build on most slopes. If disabled, they are only allowed on slopes which match the direction of the track and thus require no foundations
 STR_CONFIG_SETTING_AUTOSLOPE                                    :Allow landscaping under buildings, tracks, etc. (autoslope): {STRING2}
 STR_CONFIG_SETTING_AUTOSLOPE_HELPTEXT                           :Allow landscaping under buildings and tracks without removing them
+STR_CONFIG_SETTING_ENABLE_LAND_BUYING                           :Allow buying land: {STRING2}
+STR_CONFIG_SETTING_ENABLE_RESTRICTIVE_LAND_BUYING               :Enable restriction on drag and drop land buying: {STRING2}
+STR_CONFIG_SETTING_DRAG_DROP_LAND_BUYING_LIMIT                  :Max amount of spaces allowed to buy land at one time: {STRING2}
 STR_CONFIG_SETTING_CATCHMENT                                    :Allow more realistically sized catchment areas: {STRING2}
 STR_CONFIG_SETTING_CATCHMENT_HELPTEXT                           :Have differently sized catchment areas for different types of stations and airports
 STR_CONFIG_SETTING_EXTRADYNAMITE                                :Allow removal of more town-owned roads, bridges and tunnels: {STRING2}
 STR_CONFIG_SETTING_EXTRADYNAMITE_HELPTEXT                       :Make it easier to remove town-owned infrastructure and buildings
+STR_CONFIG_SETTING_SNOW_IN_TEMPERATE                            :Allow snow in temperate: {STRING2}
 STR_CONFIG_SETTING_TRAIN_LENGTH                                 :Maximum length of trains: {STRING2}
 STR_CONFIG_SETTING_TRAIN_LENGTH_HELPTEXT                        :Set the maximum length of trains
 STR_CONFIG_SETTING_TILE_LENGTH                                  :{COMMA} tile{P 0 "" s}
@@ -1163,6 +1186,10 @@
 STR_CONFIG_SETTING_SIGNALSIDE_RIGHT                             :On the right
 STR_CONFIG_SETTING_SHOWFINANCES                                 :Show finances window at the end of the year: {STRING2}
 STR_CONFIG_SETTING_SHOWFINANCES_HELPTEXT                        :If enabled, the finances window pops up at the end of each year to allow easy inspection of the financial status of the company
+STR_CONFIG_SETTING_SPECIFIC_GROUP_NAME                          :Use {STRING2} names for specific group name
+STR_CONFIG_SETTING_SPECIFIC_GROUP_NAME_HELPTEXT                 :Uses the selected name from the first and last order of a vehicle to create a specific group name
+STR_CONFIG_SETTING_SPECIFIC_GROUP_NAME_TOWN                     :town
+STR_CONFIG_SETTING_SPECIFIC_GROUP_NAME_STATION                  :station
 STR_CONFIG_SETTING_NONSTOP_BY_DEFAULT                           :New orders are 'non-stop' by default: {STRING2}
 STR_CONFIG_SETTING_NONSTOP_BY_DEFAULT_HELPTEXT                  :Normally, a vehicle will stop at every station it passes. By enabling this setting, it will drive through all station on the way to its final destination without stopping. Note, that this setting only defines a default value for new orders. Individual orders can be set explicitly to either behaviour nevertheless
 STR_CONFIG_SETTING_STOP_LOCATION                                :New train orders stop by default at the {STRING2} of the platform
@@ -1204,15 +1231,19 @@
 STR_CONFIG_SETTING_STOP_ON_COMPETITOR_ROAD_HELPTEXT             :Allow construction of drive-through road stops on roads owned by other companies
 STR_CONFIG_SETTING_ADJACENT_STATIONS                            :Allow building adjacent stations: {STRING2}
 STR_CONFIG_SETTING_ADJACENT_STATIONS_HELPTEXT                   :Allow different stations to touch each other
+ 
 STR_CONFIG_SETTING_DYNAMIC_ENGINES                              :Enable multiple NewGRF engine sets: {STRING2}
 STR_CONFIG_SETTING_DYNAMIC_ENGINES_HELPTEXT                     :Compatibility option for old NewGRFs. Do not disable this, unless you know exactly what you are doing!
 STR_CONFIG_SETTING_DYNAMIC_ENGINES_EXISTING_VEHICLES            :{WHITE}Changing this setting is not possible when there are vehicles
-STR_CONFIG_SETTING_INFRASTRUCTURE_MAINTENANCE                   :Infrastructure maintenance: {STRING2}
+STR_CONFIG_SETTING_INFRASTRUCTURE_MAINTENANCE                   :{LTBLUE}Infrastructure maintenance: {ORANGE}{STRING1}
 STR_CONFIG_SETTING_INFRASTRUCTURE_MAINTENANCE_HELPTEXT          :When enabled, infrastructure causes maintenance costs. The cost grows over-proportional with the network size, thus affecting bigger companies more than smaller ones
-
+STR_CONFIG_SETTING_CLIPBOARD_CAPACITY                           :Clipboard capacity: {STRING2}
+STR_CONFIG_SETTING_CLIPBOARD_CAPACITY_VALUE                     :{0:NUM}{CROSS}{0:NUM} tiles
+STR_CONFIG_SETTING_CLIPBOARD_CAPACITY_HELPTEXT                  :Maximum allowed width/height of area that can be copied into clipboard
 STR_CONFIG_SETTING_NEVER_EXPIRE_AIRPORTS                        :Airports never expire: {STRING2}
 STR_CONFIG_SETTING_NEVER_EXPIRE_AIRPORTS_HELPTEXT               :Enabling this setting makes each airport type stay available forever after its introduction
 
+
 STR_CONFIG_SETTING_WARN_LOST_VEHICLE                            :Warn if vehicle is lost: {STRING2}
 STR_CONFIG_SETTING_WARN_LOST_VEHICLE_HELPTEXT                   :Trigger messages about vehicles unable to find a path to their ordered destination
 STR_CONFIG_SETTING_ORDER_REVIEW                                 :Review vehicles' orders: {STRING2}
@@ -1224,6 +1255,8 @@
 STR_CONFIG_SETTING_WARN_INCOME_LESS_HELPTEXT                    :When enabled, a news message gets sent when a vehicle has not made any profit within a calendar year
 STR_CONFIG_SETTING_NEVER_EXPIRE_VEHICLES                        :Vehicles never expire: {STRING2}
 STR_CONFIG_SETTING_NEVER_EXPIRE_VEHICLES_HELPTEXT               :When enabled, all vehicle models remain available forever after their introduction
+STR_CONFIG_SETTING_REPAIR_COST                                  :Repair cost: {STRING2}
+STR_CONFIG_SETTING_REPAIR_COST_HELPTEXT                         :When enables, cost of repair for each breakdown is 1/1024 vehicle value.
 STR_CONFIG_SETTING_AUTORENEW_VEHICLE                            :Autorenew vehicle when it gets old: {STRING2}
 STR_CONFIG_SETTING_AUTORENEW_VEHICLE_HELPTEXT                   :When enabled, a vehicle nearing its end of life gets automatically replaced when the renew conditions are fulfilled
 STR_CONFIG_SETTING_AUTORENEW_MONTHS                             :Autorenew when vehicle is {STRING2} max age
@@ -1243,7 +1276,8 @@
 STR_CONFIG_SETTING_POPULATION_IN_LABEL_HELPTEXT                 :Display the population of towns in their label on the map
 STR_CONFIG_SETTING_GRAPH_LINE_THICKNESS                         :Thickness of lines in graphs: {STRING2}
 STR_CONFIG_SETTING_GRAPH_LINE_THICKNESS_HELPTEXT                :Width of the line in the graphs. A thin line is more precisely readable, a thicker line is easier to see and colours are easier to distinguish
-
+STR_CONFIG_SETTING_FORECAST_DISPLAY                             :Display supply and demand forecasting on station building: {STRING1}
+ 
 STR_CONFIG_SETTING_LAND_GENERATOR                               :Land generator: {STRING2}
 STR_CONFIG_SETTING_LAND_GENERATOR_ORIGINAL                      :Original
 STR_CONFIG_SETTING_LAND_GENERATOR_TERRA_GENESIS                 :TerraGenesis
@@ -1255,6 +1289,9 @@
 STR_CONFIG_SETTING_ROUGHNESS_OF_TERRAIN_SMOOTH                  :Smooth
 STR_CONFIG_SETTING_ROUGHNESS_OF_TERRAIN_ROUGH                   :Rough
 STR_CONFIG_SETTING_ROUGHNESS_OF_TERRAIN_VERY_ROUGH              :Very Rough
+STR_CONFIG_SETTING_ROUGHNESS_OF_TERRAIN_CEREALLY_ROUGH          :Cereally rough
+STR_CONFIG_SETTING_ROUGHNESS_OF_TERRAIN_COMMUTORZ               :CommutorZ
+STR_CONFIG_SETTING_ROUGHNESS_OF_TERRAIN_FLOWING                 :Flowing
 STR_CONFIG_SETTING_TREE_PLACER                                  :Tree placer algorithm: {STRING2}
 STR_CONFIG_SETTING_TREE_PLACER_NONE                             :None
 STR_CONFIG_SETTING_TREE_PLACER_ORIGINAL                         :Original
@@ -1268,6 +1305,8 @@
 STR_CONFIG_SETTING_EDGES_NOT_EMPTY                              :{WHITE}One or more tiles at the northern edge are not empty
 STR_CONFIG_SETTING_EDGES_NOT_WATER                              :{WHITE}One or more tiles at one of the edges is not water
 
+STR_CONFIG_SETTING_STATION_ADVANCED                             :Advanced station control: {STRING2}
+STR_CONFIG_SETTING_STATION_ADVANCED_HELPTEXT                    :Remove cargo from station via Ctrl-Click
 STR_CONFIG_SETTING_STATION_SPREAD                               :Max station spread: {STRING2}
 STR_CONFIG_SETTING_STATION_SPREAD_HELPTEXT                      :Maximum area the parts of a single station may be spread out on. Note that high values will slow the game
 STR_CONFIG_SETTING_SERVICEATHELIPAD                             :Service helicopters at helipads automatically: {STRING2}
@@ -1305,6 +1344,10 @@
 STR_CONFIG_SETTING_OSK_ACTIVATION_DOUBLE_CLICK                  :Double click
 STR_CONFIG_SETTING_OSK_ACTIVATION_SINGLE_CLICK_FOCUS            :Single click (when focussed)
 STR_CONFIG_SETTING_OSK_ACTIVATION_SINGLE_CLICK                  :Single click (immediately)
+STR_CONFIG_SETTING_VIEWPORT_MAP_SHOW_VEHICLE_ROUTE_STOPOVERS    :Show the vehicle's stopovers: {STRING2}
+STR_CONFIG_SETTING_VIEWPORT_MAP_SHOW_VEHICLE_ROUTE_PATH         :Show the vehicle's path: {STRING2}
+STR_CONFIG_SETTING_VIEWPORT_MAP_SHOW_VEHICLE_ROUTE_PATH_NO      :No
+STR_CONFIG_SETTING_VIEWPORT_MAP_SHOW_VEHICLE_ROUTE_PATH_SIMPLE  :Simple
 
 STR_CONFIG_SETTING_RIGHT_MOUSE_BTN_EMU                          :Right-click emulation: {STRING2}
 STR_CONFIG_SETTING_RIGHT_MOUSE_BTN_EMU_HELPTEXT                 :Select the method to emulate right mouse-button clicks
@@ -1340,8 +1383,24 @@
 STR_CONFIG_SETTING_LOADING_INDICATORS_HELPTEXT                  :Select whether loading indicators are displayed above loading or unloading vehicles
 STR_CONFIG_SETTING_TIMETABLE_IN_TICKS                           :Show timetable in ticks rather than days: {STRING2}
 STR_CONFIG_SETTING_TIMETABLE_IN_TICKS_HELPTEXT                  :Show travel times in time tables in game ticks instead of days
+STR_CONFIG_SETTING_TIME_IN_MINUTES                              :Show time in minutes rather than days: {STRING2}
+STR_CONFIG_SETTING_TIME_IN_MINUTES_HELPTEXT                     :Select whether to use hours and minutes instead of days
+STR_CONFIG_SETTING_TICKS_PER_MINUTE                             :Ticks per minute: {STRING2}
+STR_CONFIG_SETTING_TICKS_PER_MINUTE_HELPTEXT                    :The number of game ticks per minute
+STR_CONFIG_SETTING_DATE_WITH_TIME                               :Show date with time in status bar: {STRING2}
+STR_CONFIG_SETTING_DATE_WITH_TIME_HELPTEXT                      :Show the real game date in the status bar as well as the time
+STR_CONFIG_SETTING_CLOCK_OFFSET                                 :Clock offset in minutes: {STRING2}
+STR_CONFIG_SETTING_CLOCK_OFFSET_HELPTEXT                        :The number of minutes the game clock is offset by
+STR_CONFIG_SETTING_DATE_WITH_TIME_NONE                          :None
+STR_CONFIG_SETTING_DATE_WITH_TIME_Y                             :Year
+STR_CONFIG_SETTING_DATE_WITH_TIME_YM                            :Month and year
+STR_CONFIG_SETTING_DATE_WITH_TIME_YMD                           :Full date
+STR_CONFIG_SETTING_TIMETABLE_START_TEXT_ENTRY                   :Enter timetable start times as text (requires time to be in minutes): {STRING2}
+STR_CONFIG_SETTING_TIMETABLE_START_TEXT_ENTRY_HELPTEXT          :Select whether timetable start times may be entered as text if time is being shown in minutes
 STR_CONFIG_SETTING_TIMETABLE_SHOW_ARRIVAL_DEPARTURE             :Show arrival and departure in timetables: {STRING2}
 STR_CONFIG_SETTING_TIMETABLE_SHOW_ARRIVAL_DEPARTURE_HELPTEXT    :Display anticipated arrival and departure times in timetables
+STR_CONFIG_SETTING_TIMETABLE_ENABLE_SEPARATION                  :Enable automatic timetable separation: {STRING2}
+STR_CONFIG_SETTING_TIMETABLE_ENABLE_SEPARATION_HELPTEXT         :Automatic timetable separation on shared orders
 STR_CONFIG_SETTING_QUICKGOTO                                    :Quick creation of vehicle orders: {STRING2}
 STR_CONFIG_SETTING_QUICKGOTO_HELPTEXT                           :Pre-select the 'goto cursor' when opening the orders window
 STR_CONFIG_SETTING_DEFAULT_RAIL_TYPE                            :Default rail type (after new game/game load): {STRING2}
@@ -1372,6 +1431,8 @@
 STR_CONFIG_SETTING_SOUND_VEHICLE_HELPTEXT                       :Play sound effects of vehicles
 STR_CONFIG_SETTING_SOUND_AMBIENT                                :Ambient: {STRING2}
 STR_CONFIG_SETTING_SOUND_AMBIENT_HELPTEXT                       :Play ambient sounds of landscape, industries and towns
+STR_CONFIG_SETTING_SOUND_CASHTILL                               :Cashtill: {STRING2}
+STR_CONFIG_SETTING_SOUND_CASHTILL_HELPTEXT                      :Play sound when income
 
 STR_CONFIG_SETTING_DISABLE_UNSUITABLE_BUILDING                  :Disable infrastructure building when no suitable vehicles are available: {STRING2}
 STR_CONFIG_SETTING_DISABLE_UNSUITABLE_BUILDING_HELPTEXT         :When enabled, infrastructure is only available if there are also vehicles available, preventing waste of time and money on unusable infrastructure
@@ -1383,7 +1444,7 @@
 STR_CONFIG_SETTING_MAX_AIRCRAFT_HELPTEXT                        :Maximum number of aircraft that a company can have
 STR_CONFIG_SETTING_MAX_SHIPS                                    :Max ships per company: {STRING2}
 STR_CONFIG_SETTING_MAX_SHIPS_HELPTEXT                           :Maximum number of ships that a company can have
-
+ 
 STR_CONFIG_SETTING_AI_BUILDS_TRAINS                             :Disable trains for computer: {STRING2}
 STR_CONFIG_SETTING_AI_BUILDS_TRAINS_HELPTEXT                    :Enabling this setting makes building trains impossible for a computer player
 STR_CONFIG_SETTING_AI_BUILDS_ROAD_VEHICLES                      :Disable road vehicles for computer: {STRING2}
@@ -1393,6 +1454,18 @@
 STR_CONFIG_SETTING_AI_BUILDS_SHIPS                              :Disable ships for computer: {STRING2}
 STR_CONFIG_SETTING_AI_BUILDS_SHIPS_HELPTEXT                     :Enabling this setting makes building ships impossible for a computer player
 
+STR_CONFIG_SETTING_SHARING_RAIL                                 :{LTBLUE}Enable sharing of railways: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_SHARING_ROAD                                 :{LTBLUE}Enable sharing of road stops and depots: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_SHARING_WATER                                :{LTBLUE}Enable sharing of docks and ship depots: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_SHARING_AIR                                  :{LTBLUE}Enable sharing of airports: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_SHARING_FEE_RAIL                             :{LTBLUE}Daily track toll for trains: {ORANGE}{STRING1} per 1000 tonnes
+STR_CONFIG_SETTING_SHARING_FEE_ROAD                             :{LTBLUE}Stopping fee for road vehicles: {ORANGE}{STRING1} per day
+STR_CONFIG_SETTING_SHARING_FEE_WATER                            :{LTBLUE}Docking fee for ships: {ORANGE}{STRING1} per day
+STR_CONFIG_SETTING_SHARING_FEE_AIR                              :{LTBLUE}Terminal fee for aircraft: {ORANGE}{STRING1} per day
+STR_CONFIG_SETTING_SHARING_PAYMENT_IN_DEBT                      :{LTBLUE}Allow companies in debt to pay sharing fees: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_SHARING_USED_BY_VEHICLES                     :{WHITE}Can't change this setting, vehicles are using shared infrastructure.
+STR_CONFIG_SETTING_SHARING_ORDERS_TO_OTHERS                     :{WHITE}Can't change this setting, vehicles have orders to destinations of others.
+
 STR_CONFIG_SETTING_AI_PROFILE                                   :Default settings profile: {STRING2}
 STR_CONFIG_SETTING_AI_PROFILE_HELPTEXT                          :Choose which settings profile to use for random AIs or for initial values when adding a new AI or Game Script
 STR_CONFIG_SETTING_AI_PROFILE_EASY                              :Easy
@@ -1486,6 +1559,8 @@
 STR_CONFIG_SETTING_CYCLE_SIGNAL_NORMAL                          :Block signals only
 STR_CONFIG_SETTING_CYCLE_SIGNAL_PBS                             :Path signals only
 STR_CONFIG_SETTING_CYCLE_SIGNAL_ALL                             :All
+STR_CONFIG_PATCHES_RANDOM_ROAD_CONSTRUCTION                     :Probability of random road construction (0 = off): {STRING2}
+STR_CONFIG_PATCHES_RANDOM_ROAD_CONSTRUCTION_HELP                :Probability of random road construction in towns (required for trafficlights)
 
 STR_CONFIG_SETTING_TOWN_LAYOUT                                  :Road layout for new towns: {STRING2}
 STR_CONFIG_SETTING_TOWN_LAYOUT_HELPTEXT                         :Layout for the road network of towns
@@ -1505,6 +1580,10 @@
 STR_CONFIG_SETTING_TOWN_FOUNDING_FORBIDDEN                      :Forbidden
 STR_CONFIG_SETTING_TOWN_FOUNDING_ALLOWED                        :Allowed
 STR_CONFIG_SETTING_TOWN_FOUNDING_ALLOWED_CUSTOM_LAYOUT          :Allowed, custom town layout
+STR_CONFIG_SETTING_TOWN_CARGO_FACTOR                            :Town cargo generation factor (less < 0 < more): {STRING2}
+STR_CONFIG_SETTING_DAYLENGTH_FACTOR                             :Day length factor: {STRING2}x
+STR_CONFIG_SETTING_DAYLENGTH_FACTOR_HELPTEXT                    :Multiply the length of day.
+STR_CONFIG_SETTING_TOWN_CONSTRUCTION_COST                       :Increase contruction costs near towns: {STRING2}
 
 STR_CONFIG_SETTING_EXTRA_TREE_PLACEMENT                         :In game placement of trees: {STRING2}
 STR_CONFIG_SETTING_EXTRA_TREE_PLACEMENT_HELPTEXT                :Control random appearance of trees during the game. This might affect industries which rely on tree growth, for example lumber mills
@@ -1512,6 +1591,28 @@
 STR_CONFIG_SETTING_EXTRA_TREE_PLACEMENT_RAINFOREST              :Only in rain forests
 STR_CONFIG_SETTING_EXTRA_TREE_PLACEMENT_ALL                     :Everywhere
 
+STR_CONFIG_SETTING_TREE_GROWTH                                  :Trees growth speed: {STRING2}
+STR_CONFIG_SETTING_TREE_GROWTH_HELPTEXT                         :Tree growth factor
+STR_CONFIG_SETTING_TREE_GROWTH_NORMAL                           :Normal
+STR_CONFIG_SETTING_TREE_GROWTH_SLOW                             :Slow
+STR_CONFIG_SETTING_TREE_GROWTH_VERY_SLOW                        :Very slow
+STR_CONFIG_SETTING_TREE_GROWTH_EXTREMLY_SLOW                    :Extremly slow
+
+STR_CONFIG_SETTING_DAY_LENGTH_FACTOR                            :Day length factor: {STRING2}
+STR_CONFIG_SETTING_DAY_LENGTH_BALANCE                           :Balancing of day length: {STRING2}
+STR_CONFIG_SETTING_DAY_LENGTH_BALANCE_NONE                      :None {GREEN}(Very easy)
+STR_CONFIG_SETTING_DAY_LENGTH_BALANCE_RUN_COST                  :Running costs {GREEN}(Easy)
+STR_CONFIG_SETTING_DAY_LENGTH_BALANCE_ALL_COSTS                 :All costs
+STR_CONFIG_SETTING_DAY_LENGTH_BALANCE_DECREASE_PAYMENTS         :Payments
+STR_CONFIG_SETTING_DAY_LENGTH_BAL_FACTOR                        :Balance factor: {STRING2}
+STR_CONFIG_SETTING_INCL_PROP_MAIN_TO_RUN                        :Include property maintemance into running costs: {STRING2}
+STR_CONFIG_SETTING_INCL_LOAN_INT_TO_RUN                         :Include loan interests into running costs: {STRING2}
+STR_CONFIG_SETTING_SLOW_DOWN_VEH_REL_DROP                       :Slow down vehicle reliability drop down: {STRING2}
+STR_CONFIG_SETTING_SLOW_DOWN_TOWN_GROWTH                        :Slow down town growth with day length factor: {STRING2}
+STR_CONFIG_SETTING_SLOW_DOWN_PROD                               :Slow down production factor: {STRING2}
+STR_CONFIG_SETTING_SLOW_DOWN_PROD_HELPTEXT                      :Slow down the cargo production for day length changes
+STR_CONFIG_SETTING_SHOW_ORIG_PRODUCTION                         :Show original production value of industry: {STRING2}
+
 STR_CONFIG_SETTING_TOOLBAR_POS                                  :Position of main toolbar: {STRING2}
 STR_CONFIG_SETTING_TOOLBAR_POS_HELPTEXT                         :Horizontal position of the main toolbar at the top of the screen
 STR_CONFIG_SETTING_STATUSBAR_POS                                :Position of status bar: {STRING2}
@@ -1549,6 +1650,27 @@
 STR_CONFIG_SETTING_CITY_SIZE_MULTIPLIER_HELPTEXT                :Average size of cities relative to normal towns at start of the game
 STR_CONFIG_SETTING_MODIFIED_ROAD_REBUILD                        :Remove absurd road-elements during the road construction: {STRING2}
 STR_CONFIG_SETTING_MODIFIED_ROAD_REBUILD_HELPTEXT               :Remove dead road ends during funded road reconstruction
+STR_CONFIG_SETTING_TRAFFIC_LIGHTS                               :Enable traffic lights:{STRING2}
+STR_CONFIG_SETTING_TRAFFIC_LIGHTS_HELPTEXT                      :Enables/disables building of traffic lights completely
+STR_CONFIG_SETTING_TOWNS_BUILD_TRAFFIC_LIGHTS                   :Towns can build traffic lights: {STRING2}
+STR_CONFIG_SETTING_TOWNS_BUILD_TRAFFIC_LIGHTS_HELPTEXT          :Allows/dissallows towns to build traffic lights during road construction
+STR_CONFIG_SETTING_ALLOW_BUILDING_TLS_ON_TOWN_ROADS             :Build and remove traffic lights on town roads: {STRING2}
+STR_CONFIG_SETTING_ALLOW_BUILDING_TLS_ON_TOWN_ROADS_HELPTEXT    :Allows/disallows the players building and removing traffic lights on town roads
+STR_CONFIG_SETTING_TRAFFIC_LIGHTS_GREEN_PHASE                   :Length of traffic lights' green phase: {STRING2}
+STR_CONFIG_SETTING_TRAFFIC_LIGHTS_GREEN_PHASE_HELPTEXT          :Time in seconds that traffic lights stay green
+STR_CONFIG_SETTING_MAX_TRAFFIC_LIGHT_CONSIST_SIZE               :Maximum TL consist size: {STRING2}
+STR_CONFIG_SETTING_MAX_TRAFFIC_LIGHT_CONSIST_SIZE_HELPTEXT      :Maximum number of trafficlights that can be synchronised. Warning: High setting slow down the game
+STR_CONFIG_SETTING_MAX_TRAFFIC_LIGHT_CONSIST_DISTANCE           :Maximum distance between two trafficlights for synchronising: {STRING2}
+STR_CONFIG_SETTING_MAX_TRAFFIC_LIGHT_CONSIST_DISTANCE_HELPTEXT  :Sets the maximum tile distance between two trafficlights for them to be synchronised
+
+STR_CONFIG_SETTING_CARGODEST_PAX                                :Destination mode for passengers/mail: {STRING2}
+STR_CONFIG_SETTING_CARGODEST_PAX_HELPTEXT                       :Enable passengers and mail choosing destinations on their own
+STR_CONFIG_SETTING_CARGODEST_TOWN                               :Destination mode for town-accepted cargoes: {STRING2}
+STR_CONFIG_SETTING_CARGODEST_TOWN_HELPTEXT                      :Enable town-accepted cargoes choosing destinations on their own
+STR_CONFIG_SETTING_CARGODEST_OTHER                              :Destination mode for other cargoes: {STRING2}
+STR_CONFIG_SETTING_CARGODEST_OTHER_HELPTEXT                     :Enable other cargoes choosing destinations on their own
+STR_CONFIG_SETTING_CARGODEST_MODE_OFF                           :Original
+STR_CONFIG_SETTING_CARGODEST_MODE_DEST                          :Fixed destinations
 
 STR_CONFIG_SETTING_GUI                                          :{ORANGE}Interface
 STR_CONFIG_SETTING_CONSTRUCTION                                 :{ORANGE}Construction
@@ -1561,14 +1683,17 @@
 STR_CONFIG_SETTING_SOUND                                        :{ORANGE}Sound effects
 STR_CONFIG_SETTING_NEWS                                         :{ORANGE}News and messages
 STR_CONFIG_SETTING_CONSTRUCTION_SIGNALS                         :{ORANGE}Signals
+STR_CONFIG_SETTING_CONSTRUCTION_TRAFFIC_LIGHTS                  :{ORANGE}Traffic lights
 STR_CONFIG_SETTING_STATIONS_CARGOHANDLING                       :{ORANGE}Cargo handling
 STR_CONFIG_SETTING_AI_NPC                                       :{ORANGE}Computer players
+STR_CONFIG_SETTING_SHARING                                      :{ORANGE}Infrastructure sharing
 STR_CONFIG_SETTING_VEHICLES_AUTORENEW                           :{ORANGE}Autorenew
 STR_CONFIG_SETTING_VEHICLES_SERVICING                           :{ORANGE}Servicing
 STR_CONFIG_SETTING_VEHICLES_ROUTING                             :{ORANGE}Routing
 STR_CONFIG_SETTING_VEHICLES_TRAINS                              :{ORANGE}Trains
 STR_CONFIG_SETTING_ECONOMY_TOWNS                                :{ORANGE}Towns
 STR_CONFIG_SETTING_ECONOMY_INDUSTRIES                           :{ORANGE}Industries
+STR_CONFIG_SETTING_ECONOMY_DAY_LENGTH                           :{ORANGE}Day length
 
 STR_CONFIG_SETTING_PATHFINDER_OPF                               :Original
 STR_CONFIG_SETTING_PATHFINDER_NPF                               :NPF
@@ -1583,6 +1708,18 @@
 STR_CONFIG_SETTING_REVERSE_AT_SIGNALS                           :Automatic reversing at signals: {STRING2}
 STR_CONFIG_SETTING_REVERSE_AT_SIGNALS_HELPTEXT                  :Allow trains to reverse on a signal, if they waited there a long time
 
+STR_CONFIG_SETTING_VEHICLES_SPEEDLIMIT                          :{ORANGE}Speed limits
+STR_CONFIG_SETTING_LIMITVEHSPEED_IN                             :Limit road vehicle speed in towns: {STRING}
+STR_CONFIG_SETTING_LIMITVEHSPEED_IN_HELPTEXT                    :Set speed limit for all town
+STR_CONFIG_SETTING_SET_LIMITVEHSPEED_IN_TNEW                    :Set max vehicle speed in towns on two-way road: {STRING} km/h
+STR_CONFIG_SETTING_SET_LIMITVEHSPEED_IN_OWOW                    :Set max vehicle speed in towns on one-way road: {STRING} km/h
+STR_CONFIG_SETTING_LIMITVEHSPEED_OUT                            :Limit road vehicle speed outside towns: {STRING}
+STR_CONFIG_SETTING_SET_LIMITVEHSPEED_OUT_TNEW                   :Set max vehicle speed outside towns on two-way road: {STRING} km/h
+STR_CONFIG_SETTING_SET_LIMITVEHSPEED_OUT_OWOW                   :Set max vehicle speed outside towns on one-way road: {STRING} km/h
+STR_CONFIG_SETTING_LIMITVEHSPEED_WORMHOLE                       :Limit road vehicle speed in tunnel and on bridge: {STRING}
+STR_CONFIG_SETTING_SET_LIMITVEHSPEED_WORMHOLE                   :Set max vehicle speed in tunnel and on bridge: {STRING} km/h
+STR_CONFIG_SETTING_LIMITVEHSPEED_CURVE                          :Limit road vehicle speed in curves: {STRING}
+
 STR_CONFIG_SETTING_QUERY_CAPTION                                :{WHITE}Change setting value
 
 # Config errors
@@ -1677,6 +1814,8 @@
 STR_CHEAT_EXTRA_DYNAMITE                                        :{LTBLUE}Magic bulldozer (remove industries, unmovable objects): {ORANGE}{STRING1}
 STR_CHEAT_CROSSINGTUNNELS                                       :{LTBLUE}Tunnels may cross each other: {ORANGE}{STRING1}
 STR_CHEAT_NO_JETCRASH                                           :{LTBLUE}Jetplanes will not crash (frequently) on small airports: {ORANGE}{STRING}
+STR_CHEAT_EDIT_MAX_HL                                           :{LTBLUE}Edit the maximal allowed heightlevel: {ORANGE}{NUM}
+STR_CHEAT_EDIT_MAX_HL_QUERY_CAPT                                :{WHITE}Edit the maximal allowed heightlevel
 STR_CHEAT_SWITCH_CLIMATE_TEMPERATE_LANDSCAPE                    :Temperate landscape
 STR_CHEAT_SWITCH_CLIMATE_SUB_ARCTIC_LANDSCAPE                   :Sub-arctic landscape
 STR_CHEAT_SWITCH_CLIMATE_SUB_TROPICAL_LANDSCAPE                 :Sub-tropical landscape
@@ -1954,7 +2093,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Kick
 STR_NETWORK_CLIENTLIST_BAN                                      :Ban
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Give money
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Speak to all
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Speak to company
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Private message
@@ -1963,7 +2101,6 @@
 STR_NETWORK_CLIENT                                              :Client
 STR_NETWORK_SPECTATORS                                          :Spectators
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Enter the amount of money you want to give
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Do not save the entered password
@@ -2153,6 +2290,7 @@
 STR_TRANSPARENT_STRUCTURES_TOOLTIP                              :{BLACK}Toggle transparency for structures like lighthouses and antennas. Ctrl+Click to lock
 STR_TRANSPARENT_CATENARY_TOOLTIP                                :{BLACK}Toggle transparency for catenary. Ctrl+Click to lock
 STR_TRANSPARENT_LOADING_TOOLTIP                                 :{BLACK}Toggle transparency for loading indicators. Ctrl+Click to lock
+STR_TRANSPARENT_TUNNELS_TOOLTIP                                 :{BLACK}Toggle transparency for vehicles in tunnels. Ctrl+Click to lock.
 STR_TRANSPARENT_INVISIBLE_TOOLTIP                               :{BLACK}Set objects invisible instead of transparent
 
 # Linkgraph legend window
@@ -2256,6 +2394,34 @@
 STR_BRIDGE_NAME_TUBULAR_STEEL                                   :Tubular, Steel
 STR_BRIDGE_TUBULAR_SILICON                                      :Tubular, Silicon
 
+# Clipboard toolbar window
+STR_CLIPBOARD_TOOLBAR_CAPTION                                   :{WHITE}Clipboard
+STR_CLIPBOARD_TOOLTIP_SWITCH_TO_1ST_CLIPBOARD                   :{BLACK}Switch to first clipboard
+STR_CLIPBOARD_TOOLTIP_SWITCH_TO_2ND_CLIPBOARD                   :{BLACK}Switch to second clipboard
+STR_CLIPBOARD_TOOLTIP_SWITCH_TO_3RD_CLIPBOARD                   :{BLACK}Switch to third clipboard
+STR_CLIPBOARD_TOOLTIP_SWITCH_TO_4TH_CLIPBOARD                   :{BLACK}Switch to fourth clipboard
+STR_CLIPBOARD_TOOLTIP_COPY                                      :{BLACK}Select area to copy
+STR_CLIPBOARD_TOOLTIP_PASTE                                     :{BLACK}Paste selected area
+STR_CLIPBOARD_TOOLTIP_SELECT_COPY_AREA                          :{BLACK}Select source area to be copied
+STR_CLIPBOARD_TOOLTIP_INSTANT_COPY_PASTE                        :{BLACK}Copy previously selected area and past it at a given location
+STR_CLIPBOARD_TOOLTIP_COPY_WITH_RAIL_TRANSPORT                  :{BLACK}Paste rail transport infrastructure
+STR_CLIPBOARD_TOOLTIP_COPY_WITH_ROAD_TRANSPORT                  :{BLACK}Paste road transport infrastructure
+STR_CLIPBOARD_TOOLTIP_COPY_WITH_WATER_TRANSPORT                 :{BLACK}Paste water transport infrastructure
+STR_CLIPBOARD_TOOLTIP_COPY_WITH_AIR_TRANSPORT                   :{BLACK}Paste air transport infrastructure
+STR_CLIPBOARD_TOOLTIP_TERRAFORM                                 :{BLACK}Terraform land when pasting{}(red) no terraforming{}(yellow) minimal terraforming{}(green) full terraforming
+STR_CLIPBOARD_TOOLTIP_CONVERT_RAIL                              :{BLACK}Converts rail infrastructure to{}current rail type when pasting
+STR_CLIPBOARD_TOOLTIP_MIRROR_SIGNALS                            :{BLACK}Mirror signals when pasting
+STR_CLIPBOARD_TOOLTIP_UPGRADE_BRIDGES                           :{BLACK}Upgrade bridges when pasting
+STR_CLIPBOARD_TOOLTIP_STOP_ON_FAILURE                           :{BLACK}Stop pasting immidiately if something is failing
+STR_CLIPBOARD_TOOLTIP_TRANSFORMATION                            :{BLACK}Current transformation,{}click to reset
+STR_CLIPBOARD_TOOLTIP_ROTATE_LEFT                               :{BLACK}Rotate by 90 degree anticlockwise
+STR_CLIPBOARD_TOOLTIP_ROTATE_RIGHT                              :{BLACK}Rotate by 90 degree clockwise
+STR_CLIPBOARD_TOOLTIP_REFLECT_NE_SW                             :{BLACK}Reflect against NW-SE axis
+STR_CLIPBOARD_TOOLTIP_REFLECT_NW_SE                             :{BLACK}Reflect against NE-SW axis
+STR_CLIPBOARD_HEIGHT_DIFF                                       :{GOLD}{STRING1}
+STR_CLIPBOARD_HEIGHT_DIFF_NEGATIVE                              :-{NUM}
+STR_CLIPBOARD_HEIGHT_DIFF_NEUTRAL                               : {NUM}
+STR_CLIPBOARD_HEIGHT_DIFF_POSITIVE                              :+{NUM}
 
 # Road construction toolbar
 STR_ROAD_TOOLBAR_ROAD_CONSTRUCTION_CAPTION                      :{WHITE}Road Construction
@@ -2271,6 +2437,7 @@
 STR_ROAD_TOOLBAR_TOOLTIP_BUILD_TRUCK_LOADING_BAY                :{BLACK}Build lorry loading bay. Ctrl enables joining stations. Shift toggles building/showing cost estimate
 STR_ROAD_TOOLBAR_TOOLTIP_BUILD_CARGO_TRAM_STATION               :{BLACK}Build freight tram station. Ctrl enables joining stations. Shift toggles building/showing cost estimate
 STR_ROAD_TOOLBAR_TOOLTIP_TOGGLE_ONE_WAY_ROAD                    :{BLACK}Activate/Deactivate one way roads
+STR_ROAD_TOOLBAR_TOOLTIP_BUILD_TRAFFIC_LIGHT                    :{BLACK}Build traffic light
 STR_ROAD_TOOLBAR_TOOLTIP_BUILD_ROAD_BRIDGE                      :{BLACK}Build road bridge. Shift toggles building/showing cost estimate
 STR_ROAD_TOOLBAR_TOOLTIP_BUILD_TRAMWAY_BRIDGE                   :{BLACK}Build tramway bridge. Shift toggles building/showing cost estimate
 STR_ROAD_TOOLBAR_TOOLTIP_BUILD_ROAD_TUNNEL                      :{BLACK}Build road tunnel. Shift toggles building/showing cost estimate
@@ -2332,10 +2499,13 @@
 STR_AIRPORT_HELIPORT                                            :Heliport
 STR_AIRPORT_HELIDEPOT                                           :Helidepot
 STR_AIRPORT_HELISTATION                                         :Helistation
+STR_AIRPORT_INTERCONTINENTAL2                                   :Intercontinental 2
+STR_AIRPORT_CIRCLE                                              :Circle
 
 STR_AIRPORT_CLASS_SMALL                                         :Small airports
 STR_AIRPORT_CLASS_LARGE                                         :Large airports
 STR_AIRPORT_CLASS_HUB                                           :Hub airports
+STR_AIRPORT_CLASS_HUGE                                          :Huge airports
 STR_AIRPORT_CLASS_HELIPORTS                                     :Helicopter airports
 
 STR_STATION_BUILD_NOISE                                         :{BLACK}Noise generated: {GOLD}{COMMA}
@@ -2345,6 +2515,7 @@
 STR_LANDSCAPING_TOOLTIP_LOWER_A_CORNER_OF_LAND                  :{BLACK}Lower a corner of land. Dragging lowers the first selected corner and levels the selected area to the new corner height. Ctrl selects the area diagonally. Shift toggles building/showing cost estimate
 STR_LANDSCAPING_TOOLTIP_RAISE_A_CORNER_OF_LAND                  :{BLACK}Raise a corner of land. Dragging raises the first selected corner and levels the selected area to the new corner height. Ctrl selects the area diagonally. Shift toggles building/showing cost estimate
 STR_LANDSCAPING_LEVEL_LAND_TOOLTIP                              :{BLACK}Level an area of land to the height of the first selected corner. Ctrl selects the area diagonally. Shift toggles building/showing cost estimate
+STR_LANDSCAPING_TOOLTIP_SHOW_CLIPBOARD_TOOLBAR                  :{BLACK}Show clipboard toolbar
 STR_LANDSCAPING_TOOLTIP_PURCHASE_LAND                           :{BLACK}Purchase land for future use. Shift toggles building/showing cost estimate
 
 # Object construction window
@@ -2500,6 +2671,7 @@
 STR_LAI_ROAD_DESCRIPTION_TREE_LINED_ROAD                        :Tree-lined road
 STR_LAI_ROAD_DESCRIPTION_ROAD_VEHICLE_DEPOT                     :Road vehicle depot
 STR_LAI_ROAD_DESCRIPTION_ROAD_RAIL_LEVEL_CROSSING               :Road/rail level crossing
+STR_LAI_ROAD_DESCRIPTION_ROAD_WITH_TRAFFIC_LIGHTS               :Road with traffic lights
 STR_LAI_ROAD_DESCRIPTION_TRAMWAY                                :Tramway
 
 # Houses come directly from their building names
@@ -2591,6 +2763,9 @@
 STR_MAPGEN_NUMBER_OF_TOWNS                                      :{BLACK}No. of towns:
 STR_MAPGEN_DATE                                                 :{BLACK}Date:
 STR_MAPGEN_NUMBER_OF_INDUSTRIES                                 :{BLACK}No. of industries:
+STR_MAPGEN_MAX_HEIGHTLEVEL                                      :{BLACK}Maximal allowed heightlevel
+STR_MAPGEN_MAX_HEIGHTLEVEL_UP                                   :{BLACK}Increase the maximal allowed heightlevel by one
+STR_MAPGEN_MAX_HEIGHTLEVEL_DOWN                                 :{BLACK}Decrease the maximal allowed heightlevel by one
 STR_MAPGEN_SNOW_LINE_HEIGHT                                     :{BLACK}Snow line height:
 STR_MAPGEN_SNOW_LINE_UP                                         :{BLACK}Move the snow line height one up
 STR_MAPGEN_SNOW_LINE_DOWN                                       :{BLACK}Move the snow line height one down
@@ -2623,8 +2798,10 @@
 STR_MAPGEN_HEIGHTMAP_NAME                                       :{BLACK}Heightmap name:
 STR_MAPGEN_HEIGHTMAP_SIZE_LABEL                                 :{BLACK}Size:
 STR_MAPGEN_HEIGHTMAP_SIZE                                       :{ORANGE}{NUM} x {NUM}
+STR_MAPGEN_TOO_MANY_TILES_MESSAGE                               :{YELLOW}Too many tiles in map. Maximum number of tiles is {NUM}, you have selected {NUM}
 
 STR_MAPGEN_RANDOM_SEED_OSKTITLE                                 :{BLACK}Enter a random seed
+STR_MAPGEN_MAX_HEIGHTLEVEL_QUERY_CAPT                           :{WHITE}Change maximal allowed heightlevel
 STR_MAPGEN_SNOW_LINE_QUERY_CAPT                                 :{WHITE}Change snow line height
 STR_MAPGEN_START_DATE_QUERY_CAPT                                :{WHITE}Change starting year
 
@@ -2822,6 +2999,13 @@
 
 STR_EDIT_SIGN_SIGN_OSKTITLE                                     :{BLACK}Enter a name for the sign
 
+# Cargodest UI strings
+STR_VIEW_CARGO_LAST_MONTH_OUT                                   :{BLACK}Outgoing cargo last month:
+STR_VIEW_CARGO_LAST_MONTH_TOWN                                  :{BLACK}{CARGO_SHORT} out of {CARGO_LONG} to {TOWN}
+STR_VIEW_CARGO_LAST_MONTH_INDUSTRY                              :{BLACK}{CARGO_SHORT} out of {CARGO_LONG} to {INDUSTRY}
+STR_VIEW_CARGO_LAST_MONTH_LOCAL                                 :{BLACK}{CARGO_SHORT} out of {CARGO_LONG} to local destinations
+STR_VIEW_CARGO_LAST_MONTH_OTHER                                 :{BLACK}{CARGO_SHORT} out of {CARGO_LONG} to other destinations
+
 # Town directory window
 STR_TOWN_DIRECTORY_CAPTION                                      :{WHITE}Towns
 STR_TOWN_DIRECTORY_NONE                                         :{ORANGE}- None -
@@ -2942,9 +3126,20 @@
 
 # Station view window
 STR_STATION_VIEW_CAPTION                                        :{WHITE}{STATION} {STATION_FEATURES}
+STR_STATION_VIEW_WAITING_BUTTON                                 :{BLACK}Source
+STR_STATION_VIEW_WAITING_TOOLTIP                                :{BLACK}Show list of waiting cargo with its source
+STR_STATION_VIEW_WAITING_TO_BUTTON                              :{BLACK}Destination
+STR_STATION_VIEW_WAITING_TO_TOOLTIP                             :{BLACK}Show list of waiting cargo with its destination
+STR_STATION_VIEW_WAITING_VIA_BUTTON                             :{BLACK}Next hop
+STR_STATION_VIEW_WAITING_VIA_TOOLTIP                            :{BLACK}Show list of waiting cargo with its next hop
+STR_STATION_VIEW_WAITING_TRANSFER_BUTTON                        :{BLACK}Transfer
+STR_STATION_VIEW_WAITING_TRANSFER_TOOLTIP                       :{BLACK}Show list of waiting cargo with its next transfer station
 STR_STATION_VIEW_WAITING_TITLE                                  :{BLACK}Waiting: {WHITE}{STRING}
 STR_STATION_VIEW_WAITING_CARGO                                  :{WHITE}{CARGO_LONG}
 STR_STATION_VIEW_EN_ROUTE_FROM                                  :{YELLOW}({CARGO_SHORT} from {STATION})
+STR_STATION_VIEW_WAITING_VIA                                    :{YELLOW}{CARGO_SHORT} en-route via {STATION}
+STR_STATION_VIEW_WAITING_TRANSFER                               :{YELLOW}{CARGO_SHORT} transfering at {STATION}
+STR_STATION_VIEW_WAITING_TO                                     :{YELLOW}{CARGO_SHORT} en-route to {STRING1}
 
 STR_STATION_VIEW_ACCEPTS_BUTTON                                 :{BLACK}Accepts
 STR_STATION_VIEW_ACCEPTS_TOOLTIP                                :{BLACK}Show list of accepted cargo
@@ -2958,6 +3153,9 @@
 STR_STATION_VIEW_CARGO_RATINGS_TITLE                            :{BLACK}Local rating of transport service:
 STR_STATION_VIEW_CARGO_RATING                                   :{WHITE}{STRING}: {YELLOW}{STRING} ({COMMA}%)
 
+STR_STATION_VIEW_DEPARTURES_BUTTON                              :{BLACK}Departures
+STR_STATION_VIEW_DEPARTURES_TOOLTIP                             :{BLACK}Show list of scheduled departures
+
 ############ range for rating starts
 STR_CARGO_RATING_APPALLING                                      :Appalling
 STR_CARGO_RATING_VERY_POOR                                      :Very Poor
@@ -2972,16 +3170,110 @@
 STR_STATION_VIEW_CENTER_TOOLTIP                                 :{BLACK}Centre main view on station location. Ctrl+Click opens a new viewport on station location
 STR_STATION_VIEW_RENAME_TOOLTIP                                 :{BLACK}Change name of station
 
+STR_STATION_VIEW_COVERAGE                                       :{BLACK}Coverage
+STR_STATION_VIEW_COVERAGE_TIP                                   :{BLACK}Show station's area coverage
 STR_STATION_VIEW_SCHEDULED_TRAINS_TOOLTIP                       :{BLACK}Show all trains which have this station on their schedule
 STR_STATION_VIEW_SCHEDULED_ROAD_VEHICLES_TOOLTIP                :{BLACK}Show all road vehicles which have this station on their schedule
 STR_STATION_VIEW_SCHEDULED_AIRCRAFT_TOOLTIP                     :{BLACK}Show all aircraft which have this station on their schedule
 STR_STATION_VIEW_SCHEDULED_SHIPS_TOOLTIP                        :{BLACK}Show all ships which have this station on their schedule
 
 STR_STATION_VIEW_RENAME_STATION_CAPTION                         :Rename station/loading area
-
 STR_STATION_VIEW_CLOSE_AIRPORT                                  :{BLACK}Close airport
 STR_STATION_VIEW_CLOSE_AIRPORT_TOOLTIP                          :{BLACK}Prevent aircraft from landing on this airport
 
+# Departures window
+STR_DEPARTURES_CAPTION                                          :{WHITE}{STATION} Live Travel Information
+STR_DEPARTURES_CAPTION_WAYPOINT                                 :{WHITE}{WAYPOINT} Live Travel Information
+STR_DEPARTURES_DEPARTURES                                       :{BLACK}{TINY_FONT}D
+STR_DEPARTURES_ARRIVALS                                         :{BLACK}{TINY_FONT}A
+STR_DEPARTURES_VIA_BUTTON                                       :{BLACK}{TINY_FONT}via
+STR_DEPARTURES_DEPARTURES_TOOLTIP                               :{BLACK}Show timetabled departures
+STR_DEPARTURES_ARRIVALS_TOOLTIP                                 :{BLACK}Show timetabled arrivals
+STR_DEPARTURES_VIA_TOOLTIP                                      :{BLACK}Show timetabled vehicles that do not stop here
+STR_DEPARTURES_EMPTY                                            :{ORANGE}No vehicles are currently timetabled for this station.
+STR_DEPARTURES_NONE_SELECTED                                    :{ORANGE}No timetable information has been requested.
+STR_DEPARTURES_TIME                                             :{ORANGE}{DATE_WALLCLOCK_TINY}
+STR_DEPARTURES_TIME_DEP                                         :{ORANGE}{DATE_WALLCLOCK_TINY} {GREEN}{UP_ARROW}
+STR_DEPARTURES_TIME_ARR                                         :{ORANGE}{DATE_WALLCLOCK_TINY} {RED}{DOWN_ARROW}
+STR_DEPARTURES_TIME_BOTH                                        :{ORANGE}{1:DATE_WALLCLOCK_TINY} {RED}{DOWN_ARROW} {ORANGE}{0:DATE_WALLCLOCK_TINY} {GREEN}{UP_ARROW}
+STR_DEPARTURES_TERMINUS                                         :{ORANGE}{STATION}{STRING}
+STR_DEPARTURES_TERMINUS_VIA_STATION                             :{ORANGE}{STATION}{STRING} via {STATION}{STRING}
+STR_DEPARTURES_TERMINUS_VIA                                     :{ORANGE}{STATION}{STRING} via
+STR_DEPARTURES_VIA                                              :{ORANGE}via {STATION}{STRING}
+STR_DEPARTURES_TOC                                              :{ORANGE}{COMPANY}
+STR_DEPARTURES_GROUP                                            :{ORANGE}{GROUP}
+STR_DEPARTURES_VEH                                              :{ORANGE}{VEHICLE}
+STR_DEPARTURES_CALLING_AT                                       :{TINY_FONT}{ORANGE}Calling at:
+STR_DEPARTURES_CALLING_AT_LARGE                                 :{ORANGE}Calling at:
+STR_DEPARTURES_CALLING_AT_FIRST_STATION                         :{STATION}
+STR_DEPARTURES_CALLING_AT_STATION                               :{RAW_STRING}, {STATION}
+STR_DEPARTURES_CALLING_AT_LAST_STATION                          :{RAW_STRING} and {STATION}
+STR_DEPARTURES_CALLING_AT_LIST                                  :{TINY_FONT}{ORANGE}{RAW_STRING}.
+STR_DEPARTURES_CALLING_AT_LIST_LARGE                            :{ORANGE}{RAW_STRING}.
+STR_DEPARTURES_CALLING_AT_LIST_SMART_TERMINUS                   :{TINY_FONT}{ORANGE}{RAW_STRING}. This service continues to {STATION}.
+STR_DEPARTURES_CALLING_AT_LIST_SMART_TERMINUS_LARGE             :{ORANGE}{RAW_STRING}. This service continues to {STATION}.
+
+STR_DEPARTURES_TYPE_TRAIN                                       :{ORANGE}{TRAIN}
+STR_DEPARTURES_TYPE_TRAIN_SILVER                                :{SILVER}{TRAIN}
+STR_DEPARTURES_TYPE_BUS                                         :{ORANGE}{BUS}
+STR_DEPARTURES_TYPE_BUS_SILVER                                  :{SILVER}{BUS}
+STR_DEPARTURES_TYPE_LORRY                                       :{ORANGE}{LORRY}
+STR_DEPARTURES_TYPE_LORRY_SILVER                                :{SILVER}{LORRY}
+STR_DEPARTURES_TYPE_PLANE                                       :{ORANGE}{PLANE}
+STR_DEPARTURES_TYPE_PLANE_SILVER                                :{SILVER}{PLANE}
+STR_DEPARTURES_TYPE_SHIP                                        :{ORANGE}{SHIP}
+STR_DEPARTURES_TYPE_SHIP_SILVER                                 :{SILVER}{SHIP}
+
+STR_DEPARTURES_STATION_NONE                                     :
+STR_DEPARTURES_STATION_PORT                                     :{ORANGE} {SHIP}
+STR_DEPARTURES_STATION_AIRPORT                                  :{ORANGE} {PLANE}
+STR_DEPARTURES_STATION_PORTAIRPORT                              :{ORANGE} {SHIP} {PLANE}
+
+############ possible statuses start
+STR_DEPARTURES_ON_TIME                                          :{GREEN}On time
+STR_DEPARTURES_ARRIVED                                          :{GREEN}Arrived
+STR_DEPARTURES_DELAYED                                          :{YELLOW}Delayed
+STR_DEPARTURES_EXPECTED                                         :{YELLOW}Expt {DATE_WALLCLOCK_TINY}
+STR_DEPARTURES_CANCELLED                                        :{RED}Cancelled
+
+############ config settings
+STR_CONFIG_SETTING_DEPARTUREBOARDS                              :{ORANGE}Departure boards
+STR_CONFIG_MAX_DEPARTURES                                       :Show at most {STRING2} departures at each station
+STR_CONFIG_MAX_DEPARTURES_HELPTEXT                              :The maximum number of departures to show on a departure board
+STR_CONFIG_MAX_DEPARTURE_TIME                                   :Show departures at most {STRING2} days in advance
+STR_CONFIG_MAX_DEPARTURE_TIME_HELPTEXT                          :How far in advance to show departures, in days
+STR_CONFIG_DEPARTURE_CALC_FREQUENCY                             :Calculate departures every {STRING2} ticks
+STR_CONFIG_DEPARTURE_CALC_FREQUENCY_HELPTEXT                    :How frequently to refresh a list of departures, in ticks
+STR_CONFIG_DEPARTURE_VEHICLE_NAME                               :Show vehicle name with departures: {STRING2}
+STR_CONFIG_DEPARTURE_VEHICLE_NAME_HELPTEXT                      :Whether to show vehicle names next to their departures
+STR_CONFIG_DEPARTURE_GROUP_NAME                                 :Show group name with departures: {STRING2}
+STR_CONFIG_DEPARTURE_GROUP_NAME_HELPTEXT                        :Whether to show names of groups that a vehicle belongs to next to its departures
+STR_CONFIG_DEPARTURE_COMPANY_NAME                               :Show company name with departures: {STRING2}
+STR_CONFIG_DEPARTURE_COMPANY_NAME_HELPTEXT                      :Whether to show a company's name next to its vehicles' departures
+STR_CONFIG_DEPARTURE_VEHICLE_TYPE                               :Show vehicle type icon with departures: {STRING2}
+STR_CONFIG_DEPARTURE_VEHICLE_TYPE_HELPTEXT                      :Whether to show a vehicle's type as an icon next to its departures
+STR_CONFIG_DEPARTURE_VEHICLE_COLOR                              :Show vehicle type icon in silver: {STRING2}
+STR_CONFIG_DEPARTURE_VEHICLE_COLOR_HELPTEXT                     :Whether to show vehicle type icons in silver
+STR_CONFIG_DEPARTURE_LARGER_FONT                                :Use larger font for stations called at on departure boards: {STRING2}
+STR_CONFIG_DEPARTURE_LARGER_FONT_HELPTEXT                       :Whether to use a larger font for lists of stations called at
+STR_CONFIG_DEPARTURE_DESTINATION_TYPE                           :Show icons for destinations that are docks or airports: {STRING2}
+STR_CONFIG_DEPARTURE_DESTINATION_TYPE_HELPTEXT                  :Whether to show icons next to destinations that are docks or airports
+STR_CONFIG_DEPARTURE_SHOW_BOTH                                  :Show arrival and departure times on the same line: {STRING2}
+STR_CONFIG_DEPARTURE_SHOW_BOTH_HELPTEXT                         :Whether to show both arrival and departure times next to departures
+STR_CONFIG_DEPARTURE_ONLY_PASSENGERS                            :Only show departures for vehicles that can carry passengers: {STRING2}
+STR_CONFIG_DEPARTURE_ONLY_PASSENGERS_HELPTEXT                   :Whether to only show departures of vehicles that can carry passengers
+STR_CONFIG_DEPARTURE_SMART_TERMINUS                             :Don't show termini that can be reached sooner on a later vehicle: {STRING2}
+STR_CONFIG_DEPARTURE_SMART_TERMINUS_HELPTEXT                    :Whether to show termini that can be reached sooner on another vehicle that departs later
+STR_CONFIG_DEPARTURE_CONDITIONALS                               :Handle conditional order jumps by: {STRING2}
+STR_CONFIG_DEPARTURE_CONDITIONALS_HELPTEXT                      :How conditional orders should be dealt with when calculating departures
+STR_CONFIG_DEPARTURE_CONDITIONALS_1                             :giving up
+STR_CONFIG_DEPARTURE_CONDITIONALS_2                             :assuming they will be taken
+STR_CONFIG_DEPARTURE_CONDITIONALS_3                             :assuming they will not be taken
+STR_CONFIG_DEPARTURE_SHOW_ALL_STOPS                             :Show all stations called at regardless of loading/unloading: {STRING2}
+STR_CONFIG_DEPARTURE_SHOW_ALL_STOPS_HELPTEXT                    :Whether stations that a vehicle only loads from will be shown in the calling at list
+STR_CONFIG_DEPARTURE_MERGE_IDENTICAL                            :Merge identical departures: {STRING2}
+STR_CONFIG_DEPARTURE_MERGE_IDENTICAL_HELPTEXT                   :Whether identical departures should be merged into a single departure
+
 # Waypoint/buoy view window
 STR_WAYPOINT_VIEW_CAPTION                                       :{WHITE}{WAYPOINT}
 STR_WAYPOINT_VIEW_CENTER_TOOLTIP                                :{BLACK}Centre main view on waypoint location. Ctrl+Click opens a new viewport on waypoint location
@@ -3001,6 +3293,7 @@
 STR_FINANCES_SECTION_ROAD_VEHICLE_RUNNING_COSTS                 :{GOLD}Road Vehicle Running Costs
 STR_FINANCES_SECTION_AIRCRAFT_RUNNING_COSTS                     :{GOLD}Aircraft Running Costs
 STR_FINANCES_SECTION_SHIP_RUNNING_COSTS                         :{GOLD}Ship Running Costs
+STR_FINANCES_SECTION_LOST_RUNNING_COSTS                         :{GOLD}Lost Cargo Costs
 STR_FINANCES_SECTION_PROPERTY_MAINTENANCE                       :{GOLD}Property Maintenance
 STR_FINANCES_SECTION_TRAIN_INCOME                               :{GOLD}Train Income
 STR_FINANCES_SECTION_ROAD_VEHICLE_INCOME                        :{GOLD}Road Vehicle Income
@@ -3008,6 +3301,8 @@
 STR_FINANCES_SECTION_SHIP_INCOME                                :{GOLD}Ship Income
 STR_FINANCES_SECTION_LOAN_INTEREST                              :{GOLD}Loan Interest
 STR_FINANCES_SECTION_OTHER                                      :{GOLD}Other
+STR_FINANCES_SECTION_INFRASTRUCTURE_COSTS                       :{GOLD}Infrastructure Sharing Costs
+STR_FINANCES_SECTION_INFRASTRUCTURE_INCOME                      :{GOLD}Infrastructure Sharing Income
 STR_FINANCES_NEGATIVE_INCOME                                    :{BLACK}-{CURRENCY_LONG}
 STR_FINANCES_POSITIVE_INCOME                                    :{BLACK}+{CURRENCY_LONG}
 STR_FINANCES_TOTAL_CAPTION                                      :{WHITE}Total:
@@ -3051,6 +3346,8 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Rebuild company headquarters elsewhere for 1% cost of company value. Shift+Click shows estimated cost without relocating HQ
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Details
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}View detailed infrastructure counts
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Give money
+STR_COMPANY_VIEW_GIVE_MONEY_TOOLTIP                             :{BLACK}Give money to this company
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}New Face
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Select new face for manager
@@ -3068,6 +3365,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Company Name
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Manager's Name
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Enter the amount of money you want to give
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}We are looking for a transport company to take-over our company.{}{}Do you want to purchase {COMPANY} for {CURRENCY_LONG}?
 
@@ -3093,6 +3391,8 @@
 STR_INDUSTRY_DIRECTORY_ITEM_TWO                                 :{ORANGE}{INDUSTRY}{BLACK} ({CARGO_LONG}{RAW_STRING}/{CARGO_LONG}{RAW_STRING}){YELLOW} ({COMMA}%/{COMMA}% transported)
 STR_INDUSTRY_DIRECTORY_ITEM_NOPROD                              :{ORANGE}{INDUSTRY}
 STR_INDUSTRY_DIRECTORY_LIST_CAPTION                             :{BLACK}Industry names - click on name to centre main view on industry. Ctrl+Click opens a new viewport on industry location
+STR_INDUSTRY_DIRECTORY_SELECT_ALL_TYPES                         :{BLACK}Select all industry types
+STR_INDUSTRY_DIRECTORY_USE_CTRL_TO_SELECT_MORE                  :{BLACK}Hold Ctrl to select more than one item
 
 # Industry view
 STR_INDUSTRY_VIEW_CAPTION                                       :{WHITE}{INDUSTRY}
@@ -3101,6 +3401,14 @@
 STR_INDUSTRY_VIEW_LOCATION_TOOLTIP                              :{BLACK}Centre the main view on industry location. Ctrl+Click opens a new viewport on industry location
 STR_INDUSTRY_VIEW_PRODUCTION_LEVEL                              :{BLACK}Production level: {YELLOW}{COMMA}%
 
+# Industry tooltip
+STR_INDUSTRY_VIEW_TRANSPORTED_TOOLTIP                           :{BLACK}{STRING}
+STR_INDUSTRY_VIEW_TRANSPORTED_TOOLTIP_TOOLTIP                   :{BLACK}{STRING}{}{CARGO_LONG} ({COMMA}%)
+STR_INDUSTRY_VIEW_TRANSPORTED_TOOLTIP_TOOLTIP_TOOLTIP           :{BLACK}{STRING}{}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%)
+
+# Town tooltip
+STR_TOWN_NAME_TOOLTIP                                           :{BLACK}{TOWN}
+
 ############ range for requires starts
 STR_INDUSTRY_VIEW_REQUIRES_CARGO                                :{BLACK}Requires: {YELLOW}{STRING}{RAW_STRING}
 STR_INDUSTRY_VIEW_REQUIRES_CARGO_CARGO                          :{BLACK}Requires: {YELLOW}{STRING}{RAW_STRING}, {STRING}{RAW_STRING}
@@ -3172,6 +3480,13 @@
 STR_GROUP_REMOVE_ALL_VEHICLES                                   :Remove all vehicles
 
 STR_GROUP_RENAME_CAPTION                                        :{BLACK}Rename a group
+STR_GROUP_SPECIFIC_NAME_STATION                                 :{STATION} - {STATION}
+STR_GROUP_SPECIFIC_NAME_TOWN                                    :{TOWN} - {TOWN}
+STR_GROUP_SPECIFIC_NAME_TOWN_LOCAL                              :Local {TOWN}
+
+STR_GROUP_PROFIT_THIS_YEAR                                      :{BLACK}Profit this year: {CURRENCY_LONG}
+STR_GROUP_PROFIT_LAST_YEAR                                      :{BLACK}Profit last year: {CURRENCY_LONG}
+
 
 # Build vehicle window
 STR_BUY_VEHICLE_TRAIN_RAIL_CAPTION                              :New Rail Vehicles
@@ -3210,6 +3525,16 @@
 STR_BUY_VEHICLE_SHIP_LIST_TOOLTIP                               :{BLACK}Ship selection list - click on ship for information
 STR_BUY_VEHICLE_AIRCRAFT_LIST_TOOLTIP                           :{BLACK}Aircraft selection list - click on aircraft for information
 
+STR_BUY_REFIT_VEHICLE_TRAIN_BUY_VEHICLE_BUTTON                  :{BLACK}Buy and Refit Vehicle
+STR_BUY_REFIT_VEHICLE_ROAD_VEHICLE_BUY_VEHICLE_BUTTON           :{BLACK}Buy and Refit Vehicle
+STR_BUY_REFIT_VEHICLE_SHIP_BUY_VEHICLE_BUTTON                   :{BLACK}Buy and Refit Ship
+STR_BUY_REFIT_VEHICLE_AIRCRAFT_BUY_VEHICLE_BUTTON               :{BLACK}Buy and Refit Aircraft
+
+STR_BUY_REFIT_VEHICLE_TRAIN_BUY_VEHICLE_TOOLTIP                 :{BLACK}Buy the highlighted train vehicle and refit it to selected cargo type 
+STR_BUY_REFIT_VEHICLE_ROAD_VEHICLE_BUY_VEHICLE_TOOLTIP          :{BLACK}Buy the highlighted road vehicle and refit it to selected cargo type 
+STR_BUY_REFIT_VEHICLE_SHIP_BUY_VEHICLE_TOOLTIP                  :{BLACK}Buy the highlighted ship and refit it to selected cargo type 
+STR_BUY_REFIT_VEHICLE_AIRCRAFT_BUY_VEHICLE_TOOLTIP              :{BLACK}Buy the highlighted aircraft and refit it to selected cargo type 
+
 STR_BUY_VEHICLE_TRAIN_BUY_VEHICLE_BUTTON                        :{BLACK}Buy Vehicle
 STR_BUY_VEHICLE_ROAD_VEHICLE_BUY_VEHICLE_BUTTON                 :{BLACK}Buy Vehicle
 STR_BUY_VEHICLE_SHIP_BUY_VEHICLE_BUTTON                         :{BLACK}Buy Ship
@@ -3484,6 +3809,7 @@
 STR_VEHICLE_DETAILS_CARGO_EMPTY                                 :{LTBLUE}Empty
 STR_VEHICLE_DETAILS_CARGO_FROM                                  :{LTBLUE}{CARGO_LONG} from {STATION}
 STR_VEHICLE_DETAILS_CARGO_FROM_MULT                             :{LTBLUE}{CARGO_LONG} from {STATION} (x{NUM})
+STR_VEHICLE_DETAILS_CARGO_TO                                    :{LTBLUE}{CARGO_SHORT} to {STRING1}
 
 STR_VEHICLE_DETAIL_TAB_CARGO                                    :{BLACK}Cargo
 STR_VEHICLE_DETAILS_TRAIN_CARGO_TOOLTIP                         :{BLACK}Show details of cargo carried
@@ -3577,6 +3903,18 @@
 STR_ORDER_CONDITIONAL_REQUIRES_SERVICE                          :Requires service
 STR_ORDER_CONDITIONAL_UNCONDITIONALLY                           :Always
 STR_ORDER_CONDITIONAL_REMAINING_LIFETIME                        :Remaining lifetime (years)
+STR_ORDER_CONDITIONAL_CARGO_WAITING                             :Waiting cargo
+STR_ORDER_CONDITIONAL_ACCEPTANCE_DROPDOWN                       :Accepted cargo
+STR_ORDER_CONDITIONAL_FREE_PLATFORMS                            :Free platforms
+STR_ORDER_CONDITIONAL_PERCENT                                   :Percent of times
+
+STR_ORDER_CONDITIONAL_REQUIRES_SERVICE_ORDER                    :Requires service {STRING}
+STR_ORDER_CONDITIONAL_CARGO_WAITING_ORDER                       :Next station {STRING} {STRING} waiting
+STR_ORDER_CONDITIONAL_ACCEPTANCE                                :Next station {STRING} {STRING}
+STR_CONDITIONAL_FREE_PLATFORMS                                  :Jump to order {COMMA} when Next station {STRING} {COMMA} free platform{P "" s}
+STR_CONDITIONAL_PERCENT                                         :Jump to order {COMMA} {COMMA} percent of times
+
+STR_ORDER_CONDITIONAL_NEXT_STATION                              :Next station
 
 STR_ORDER_CONDITIONAL_COMPARATOR_TOOLTIP                        :{BLACK}How to compare the vehicle data to the given value
 STR_ORDER_CONDITIONAL_COMPARATOR_EQUALS                         :is equal to
@@ -3589,8 +3927,18 @@
 STR_ORDER_CONDITIONAL_COMPARATOR_IS_FALSE                       :is false
 
 STR_ORDER_CONDITIONAL_VALUE_TOOLTIP                             :{BLACK}The value to compare the vehicle data against
+STR_ORDER_CONDITIONAL_CARGO_TOOLTIP                             :{BLACK}The cargo to compare the station data against
 STR_ORDER_CONDITIONAL_VALUE_CAPT                                :{WHITE}Enter value to compare against
 
+STR_ORDER_CONDITIONAL_COMPARATOR_ACCEPTS                        :accepts
+STR_ORDER_CONDITIONAL_COMPARATOR_DOES_NOT_ACCEPT                :does not accept
+STR_ORDER_CONDITIONAL_COMPARATOR_HAS                            :has
+STR_ORDER_CONDITIONAL_COMPARATOR_HAS_NO                         :does not have
+STR_ORDER_CONDITIONAL_COMPARATOR_HAS_LESS_THAN                  :has less than
+STR_ORDER_CONDITIONAL_COMPARATOR_HAS_LESS_EQUALS                :has less than or exactly
+STR_ORDER_CONDITIONAL_COMPARATOR_HAS_MORE_THAN                  :has more than
+STR_ORDER_CONDITIONAL_COMPARATOR_HAS_MORE_EQUALS                :has more than or exactly
+
 STR_ORDERS_SKIP_BUTTON                                          :{BLACK}Skip
 STR_ORDERS_SKIP_TOOLTIP                                         :{BLACK}Skip the current order, and start the next. Ctrl+Click skips to the selected order
 
@@ -3671,6 +4019,7 @@
 
 STR_ORDER_CONDITIONAL_UNCONDITIONAL                             :Jump to order {COMMA}
 STR_ORDER_CONDITIONAL_NUM                                       :Jump to order {COMMA} when {STRING} {STRING} {COMMA}
+STR_ORDER_CONDITIONAL_CARGO                                     :Jump to order {COMMA} when {STRING} {STRING} {STRING}
 STR_ORDER_CONDITIONAL_TRUE_FALSE                                :Jump to order {COMMA} when {STRING} {STRING}
 
 STR_INVALID_ORDER                                               :{RED} (Invalid Order)
@@ -3692,6 +4041,7 @@
 STR_TIMETABLE_AND_TRAVEL_FOR                                    :and travel for {STRING1}
 STR_TIMETABLE_DAYS                                              :{COMMA} day{P "" s}
 STR_TIMETABLE_TICKS                                             :{COMMA} tick{P "" s}
+STR_TIMETABLE_MINUTES                                           :{COMMA} minute{P "" s}
 
 STR_TIMETABLE_TOTAL_TIME                                        :{BLACK}This timetable will take {STRING1} to complete
 STR_TIMETABLE_TOTAL_TIME_INCOMPLETE                             :{BLACK}This timetable will take at least {STRING1} to complete (not all timetabled)
@@ -3738,6 +4088,8 @@
 STR_DATE_DAY_TOOLTIP                                            :{BLACK}Select day
 STR_DATE_MONTH_TOOLTIP                                          :{BLACK}Select month
 STR_DATE_YEAR_TOOLTIP                                           :{BLACK}Select year
+STR_DATE_MINUTES_DAY_TOOLTIP                                    :{BLACK}Select minute
+STR_DATE_MINUTES_MONTH_TOOLTIP                                  :{BLACK}Select hour
 
 
 # AI debug window
@@ -3798,6 +4150,32 @@
 STR_AI_LIST_VERSION                                             :{LTBLUE}Version: {ORANGE}{NUM}
 STR_AI_LIST_URL                                                 :{LTBLUE}URL: {ORANGE}{RAW_STRING}
 
+######## Trip History
+STR_TRIP_HISTORY                                                :{BLACK}History
+STR_TRIP_HISTORY_TOOLTIP                                        :{BLACK}Shows the history of the last 10 trips
+STR_TRIP_HISTORY_RECEIVED_LABEL                                 :{BLACK}Received
+STR_TRIP_HISTORY_RECEIVED_LABEL_TIP                             :{BLACK}The date when the cargo was received
+STR_TRIP_HISTORY_PROFIT_LABEL                                   :{BLACK}Profit
+STR_TRIP_HISTORY_PROFIT_LABEL_TIP                               :{BLACK}The profit received from each trip
+STR_TRIP_HISTORY_PERCHANGE_LABEL                                :{BLACK}% Change
+STR_TRIP_HISTORY_PERCHANGE_LABEL_TIP                            :{BLACK}Percentage change between the current and last trips profit
+STR_TRIP_HISTORY_TBT_LABEL                                      :{BLACK}TBT
+STR_TRIP_HISTORY_TBT_LABEL_TIP                                  :{BLACK}Time taken between the current and last trip
+STR_TRIP_HISTORY_DAYCHANGE_LABEL                                :{BLACK}Change
+STR_TRIP_HISTORY_DAYCHANGE_LABEL_TIP                            :{BLACK}Change (in days) between the current and last trips length
+STR_TRIP_HISTORY_TOTALINCOME                                    :{BLACK}Total income for the last {NUM} trip{P "" s}:{LTBLUE} {CURRENCY_SHORT} {BLACK}({LTBLUE}{CURRENCY_SHORT} {BLACK} per day)
+STR_TRIP_HISTORY_DAYAVERAGE                                     :{BLACK}Average trip length:{LTBLUE} {NUM} day{P "" s}
+STR_TRIP_HISTORY_DAYAVERAGE_IMPROVEMENT                         :{BLACK}Improvement over last {NUM} trip{P "" s}:{LTBLUE} {NUM}%
+STR_TRIP_HISTORY_CAPTION                                        :{WHITE}{VEHICLE} Trip History
+STR_TRIP_HISTORY_DATE                                           :{BLACK}{DATE_LONG}
+STR_TRIP_HISTORY_PROFIT                                         :{BLACK}{CURRENCY_SHORT}
+STR_TRIP_HISTORY_VIRTUAL_PROFIT                                 :{YELLOW}{CURRENCY_SHORT}
+STR_TRIP_HISTORY_PROFITCHANGEPOS                                :{GREEN}+{NUM}%
+STR_TRIP_HISTORY_PROFITCHANGENEG                                :{RED}{NUM}%
+STR_TRIP_HISTORY_TBT                                            :{BLACK}{NUM} day{P "" s}
+STR_TRIP_HISTORY_TBTCHANGEPOS                                   :{RED}+{NUM}
+STR_TRIP_HISTORY_TBTCHANGENEG                                   :{GREEN}{NUM}
+
 STR_AI_LIST_ACCEPT                                              :{BLACK}Accept
 STR_AI_LIST_ACCEPT_TOOLTIP                                      :{BLACK}Select highlighted script
 STR_AI_LIST_CANCEL                                              :{BLACK}Cancel
@@ -3842,6 +4220,29 @@
 STR_MESSAGE_ESTIMATED_COST                                      :{WHITE}Estimated Cost: {CURRENCY_LONG}
 STR_MESSAGE_ESTIMATED_INCOME                                    :{WHITE}Estimated Income: {CURRENCY_LONG}
 
+# Timetable separation UI strings
+STR_TTSEPARATION_AUTO                                           :Auto
+STR_TTSEPARATION_MAN_NUM                                        :Manual Number
+STR_TTSEPARATION_MAN_TIME                                       :Manual Time
+STR_TTSEPARATION_BUFFERED_AUTO                                  :Buffered Auto
+STR_TTSEPARATION_OFF                                            :Off
+STR_TTSEPARATION_APPLY                                          :{BLACK}Apply
+STR_TTSEPARATION_RESET                                          :{BLACK}Reset
+STR_TTSEPARATION_MODE_DESC                                      :{BLACK}Separation mode
+STR_TTSEPARATION_SETTINGS_DESC                                  :{BLACK}Separation settings
+STR_TTSEPARATION_SET_XX                                         :{BLACK}Set {STRING}
+STR_TTSEPARATION_SET_NUM                                        :number
+STR_TTSEPARATION_SET_TIME                                       :time
+STR_TTSEPARATION_STATUS_DESC                                    :{BLACK}Status:{}{STRING}
+STR_TTSEPARATION_STATUS_INCOMPLETE                              :{SILVER}Incomplete{}timetable
+STR_TTSEPARATION_STATUS_INIT                                    :{YELLOW}Initializing
+STR_TTSEPARATION_STATUS_RUNNING                                 :{GREEN}Running
+STR_TTSEPARATION_STATUS_OFF                                     :{BLACK}Off
+STR_TTSEPARATION_REQ_TIME_DESC_TICKS                            :{NUM} ticks between
+STR_TTSEPARATION_REQ_TIME_DESC_DAYS                             :{NUM} days between
+STR_TTSEPARATION_REQ_TIME_DESC_MINUTES                          :{NUM} minutes between
+STR_TTSEPARATION_REQ_NUM_DESC                                   :{NUM} vehicles
+
 # Saveload messages
 STR_ERROR_SAVE_STILL_IN_PROGRESS                                :{WHITE}Saving still in progress,{}please wait until it is finished!
 STR_ERROR_AUTOSAVE_FAILED                                       :{WHITE}Autosave failed
@@ -3908,6 +4309,8 @@
 STR_ERROR_NAME_MUST_BE_UNIQUE                                   :{WHITE}Name must be unique
 STR_ERROR_GENERIC_OBJECT_IN_THE_WAY                             :{WHITE}{1:STRING} in the way
 STR_ERROR_NOT_ALLOWED_WHILE_PAUSED                              :{WHITE}Not allowed while paused
+STR_ERROR_NOTHING_TO_DO                                         :{WHITE}... there is nothing to do
+STR_ERROR_INAPPLICABLE_TRANSFORMATION                           :{WHITE}... inapplicable transformation
 
 # Local authority errors
 STR_ERROR_LOCAL_AUTHORITY_REFUSES_TO_ALLOW_THIS                 :{WHITE}{TOWN} local authority refuses to allow this
@@ -3923,6 +4326,7 @@
 STR_ERROR_ALREADY_AT_SEA_LEVEL                                  :{WHITE}... already at sea level
 STR_ERROR_TOO_HIGH                                              :{WHITE}... too high
 STR_ERROR_ALREADY_LEVELLED                                      :{WHITE}... already flat
+STR_ERROR_BRIDGE_TOO_HIGH_AFTER_LOWER_LAND                      :{WHITE}Afterwards the bridge above it would be too high.
 
 # Company related errors
 STR_ERROR_CAN_T_CHANGE_COMPANY_NAME                             :{WHITE}Can't change company name...
@@ -3982,7 +4386,9 @@
 STR_ERROR_CAN_T_BUILD_DOCK_HERE                                 :{WHITE}Can't build dock here...
 STR_ERROR_CAN_T_BUILD_AIRPORT_HERE                              :{WHITE}Can't build airport here...
 
+STR_ERROR_ADJOINS_EXISTING                                      :{WHITE}Adjoins existing station/loading area
 STR_ERROR_ADJOINS_MORE_THAN_ONE_EXISTING                        :{WHITE}Adjoins more than one existing station/loading area
+STR_ERROR_CAN_T_DISTANT_JOIN                                    :{WHITE}Can't distant-join station/loading area
 STR_ERROR_STATION_TOO_SPREAD_OUT                                :{WHITE}... station too spread out
 STR_ERROR_TOO_MANY_STATIONS_LOADING                             :{WHITE}Too many stations/loading areas
 STR_ERROR_TOO_MANY_STATION_SPECS                                :{WHITE}Too many railway station parts
@@ -4083,6 +4489,13 @@
 STR_ERROR_CAN_T_BUILD_TRAMWAY_HERE                              :{WHITE}Can't build tramway here...
 STR_ERROR_CAN_T_REMOVE_ROAD_FROM                                :{WHITE}Can't remove road from here...
 STR_ERROR_CAN_T_REMOVE_TRAMWAY_FROM                             :{WHITE}Can't remove tramway from here...
+STR_ERROR_CAN_T_REMOVE_TRAFFIC_LIGHTS_FROM                      :{WHITE}Can't remove traffic lights from here...
+STR_ERROR_MUST_REMOVE_TRAFFIC_LIGHTS_FIRST                      :{WHITE}... must remove traffic lights first
+STR_ERROR_TRAFFIC_LIGHT_CONSIST_TOO_BIG                         :{WHITE}... traffic light consist too big
+STR_ERROR_CAN_T_PLACE_TRAFFIC_LIGHTS                            :{WHITE}Can't place traffic lights...
+STR_ERROR_CAN_ONLY_BE_PLACED_ON_ROAD_JUNCTIONS                  :{WHITE}... can only be placed on road junctions
+STR_ERROR_BUILDING_TRAFFIC_LIGHTS_DISABLED                      :{WHITE}... building trafficlights is disabled, enable it in Advanced settings -> Construction -> Traffic lights
+STR_ERROR_TRAFFIC_LIGHTS_NOT_ALLOWED_ON_TOWN_ROADS              :{WHITE}... building trafficlights on town roads is disabled, enable it in Advanced settings -> Construction -> Traffic lights
 STR_ERROR_THERE_IS_NO_ROAD                                      :{WHITE}... there is no road
 STR_ERROR_THERE_IS_NO_TRAMWAY                                   :{WHITE}... there is no tramway
 
@@ -4109,6 +4522,7 @@
 STR_ERROR_CAN_T_START_AND_END_ON                                :{WHITE}Can't start and end in the same spot
 STR_ERROR_BRIDGEHEADS_NOT_SAME_HEIGHT                           :{WHITE}Bridge heads not at the same level
 STR_ERROR_BRIDGE_TOO_LOW_FOR_TERRAIN                            :{WHITE}Bridge is too low for the terrain
+STR_ERROR_BRIDGE_TOO_HIGH_FOR_TERRAIN                           :{WHITE}Bridge is too high for this terrain.
 STR_ERROR_START_AND_END_MUST_BE_IN                              :{WHITE}Start and end must be in line
 STR_ERROR_ENDS_OF_BRIDGE_MUST_BOTH                              :{WHITE}... ends of bridge must both be on land
 STR_ERROR_BRIDGE_TOO_LONG                                       :{WHITE}... bridge too long
@@ -4131,6 +4545,10 @@
 STR_ERROR_CAN_T_PURCHASE_THIS_LAND                              :{WHITE}Can't purchase this land area...
 STR_ERROR_YOU_ALREADY_OWN_IT                                    :{WHITE}... you already own it!
 
+# Clipboard related errors
+STR_COPY_PASTE_ERROR_SUMMARY                                    :{WHITE}{8:STRING}
+STR_ERROR_CAN_T_PASTE_HERE                                      :{WHITE}Can't paste here...
+
 # Group related errors
 STR_ERROR_GROUP_CAN_T_CREATE                                    :{WHITE}Can't create group...
 STR_ERROR_GROUP_CAN_T_DELETE                                    :{WHITE}Can't delete this group...
@@ -4138,6 +4556,8 @@
 STR_ERROR_GROUP_CAN_T_REMOVE_ALL_VEHICLES                       :{WHITE}Can't remove all vehicles from this group...
 STR_ERROR_GROUP_CAN_T_ADD_VEHICLE                               :{WHITE}Can't add the vehicle to this group...
 STR_ERROR_GROUP_CAN_T_ADD_SHARED_VEHICLE                        :{WHITE}Can't add shared vehicles to group...
+STR_ERROR_GROUP_CAN_T_CREATE_SPECIFIC_NAME                      :{WHITE}Can't create group with specific name...
+STR_ERROR_GROUP_CAN_T_CREATE_NAME                               :{WHITE}Can't create group name...
 
 # Generic vehicle errors
 STR_ERROR_TRAIN_IN_THE_WAY                                      :{WHITE}Train in the way
@@ -4321,6 +4741,45 @@
 STR_INDUSTRY_NAME_TOFFEE_QUARRY                                 :Toffee Quarry
 STR_INDUSTRY_NAME_SUGAR_MINE                                    :Sugar Mine
 
+# two/three letter industry name abbreviations
+STR_ABBREV_COAL_MINE                                            :{TINY_FONT}CM
+STR_ABBREV_POWER_STATION                                        :{TINY_FONT}POW
+STR_ABBREV_SAWMILL                                              :{TINY_FONT}SAW
+STR_ABBREV_FOREST                                               :{TINY_FONT}FOR
+STR_ABBREV_OIL_REFINERY                                         :{TINY_FONT}REF
+STR_ABBREV_OIL_RIG                                              :{TINY_FONT}RIG
+STR_ABBREV_FACTORY                                              :{TINY_FONT}FAC
+STR_ABBREV_PRINTING_WORKS                                       :{TINY_FONT}PRW
+STR_ABBREV_STEEL_MILL                                           :{TINY_FONT}STL
+STR_ABBREV_FARM                                                 :{TINY_FONT}FAR
+STR_ABBREV_COPPER_ORE_MINE                                      :{TINY_FONT}ORE
+STR_ABBREV_OIL_WELLS                                            :{TINY_FONT}OIL
+STR_ABBREV_BANK                                                 :{TINY_FONT}BNK
+STR_ABBREV_FOOD_PROCESSING_PLANT                                :{TINY_FONT}FDP
+STR_ABBREV_PAPER_MILL                                           :{TINY_FONT}PAP
+STR_ABBREV_GOLD_MINE                                            :{TINY_FONT}GLD
+STR_ABBREV_BANK_TROPIC_ARCTIC                                   :{TINY_FONT}BNK
+STR_ABBREV_DIAMOND_MINE                                         :{TINY_FONT}DIA
+STR_ABBREV_IRON_ORE_MINE                                        :{TINY_FONT}ORE
+STR_ABBREV_FRUIT_PLANTATION                                     :{TINY_FONT}FRT
+STR_ABBREV_RUBBER_PLANTATION                                    :{TINY_FONT}RUB
+STR_ABBREV_WATER_SUPPLY                                         :{TINY_FONT}WSP
+STR_ABBREV_WATER_TOWER                                          :{TINY_FONT}WTW
+STR_ABBREV_FACTORY_2                                            :{TINY_FONT}FAC
+STR_ABBREV_FARM_2                                               :{TINY_FONT}FAR
+STR_ABBREV_LUMBER_MILL                                          :{TINY_FONT}LUM
+STR_ABBREV_COTTON_CANDY_FOREST                                  :{TINY_FONT}CCF
+STR_ABBREV_CANDY_FACTORY                                        :{TINY_FONT}SWT
+STR_ABBREV_BATTERY_FARM                                         :{TINY_FONT}BAT
+STR_ABBREV_COLA_WELLS                                           :{TINY_FONT}CLW
+STR_ABBREV_TOY_SHOP                                             :{TINY_FONT}TSH
+STR_ABBREV_TOY_FACTORY                                          :{TINY_FONT}TFC
+STR_ABBREV_PLASTIC_FOUNTAINS                                    :{TINY_FONT}PLA
+STR_ABBREV_FIZZY_DRINK_FACTORY                                  :{TINY_FONT}FIZ
+STR_ABBREV_BUBBLE_GENERATOR                                     :{TINY_FONT}BUB
+STR_ABBREV_TOFFEE_QUARRY                                        :{TINY_FONT}TOF
+STR_ABBREV_SUGAR_MINE                                           :{TINY_FONT}SUG
+
 ############ WARNING, using range 0x6000 for strings that are stored in the savegame
 ############ These strings may never get a new id, or savegames will break!
 ##id 0x6000
@@ -4627,6 +5086,11 @@
 STR_FORMAT_DATE_LONG                                            :{STRING} {STRING} {NUM}
 STR_FORMAT_DATE_ISO                                             :{2:NUM}-{1:RAW_STRING}-{0:RAW_STRING}
 
+STR_FORMAT_DATE_MINUTES                                         :{0:RAW_STRING}:{1:RAW_STRING}
+STR_FORMAT_DATE_MINUTES_WITH_Y                                  :{0:RAW_STRING}:{1:RAW_STRING} / {2:NUM}
+STR_FORMAT_DATE_MINUTES_WITH_YM                                 :{0:RAW_STRING}:{1:RAW_STRING} / {2:DATE_SHORT}
+STR_FORMAT_DATE_MINUTES_WITH_YMD                                :{0:RAW_STRING}:{1:RAW_STRING} / {2:DATE_LONG}
+
 STR_FORMAT_BUOY_NAME                                            :{TOWN} Buoy
 STR_FORMAT_BUOY_NAME_SERIAL                                     :{TOWN} Buoy #{COMMA}
 STR_FORMAT_COMPANY_NUM                                          :(Company {COMMA})
@@ -4650,11 +5114,26 @@
 STR_SAVEGAME_NAME_DEFAULT                                       :{COMPANY}, {STRING1}
 STR_SAVEGAME_NAME_SPECTATOR                                     :Spectator, {1:STRING1}
 
+ # Viewport strings
+STR_VIEWPORT_MAP_SHOW_VEHICLE_ROUTE_STOPOVER                    :{BROWN}{NUM} {STRING}
+STR_VIEWPORT_MAP_SHOW_VEHICLE_ROUTE_STOPOVER_STATION            :{BLACK}ST
+STR_VIEWPORT_MAP_SHOW_VEHICLE_ROUTE_STOPOVER_WAYPOINT           :{GRAY}WP
+STR_VIEWPORT_MAP_SHOW_VEHICLE_ROUTE_STOPOVER_IMPLICIT           :{GRAY}IM
+STR_VIEWPORT_MAP_SHOW_VEHICLE_ROUTE_STOPOVER_DEPOT              :{RED}DE
+
 # Viewport strings
+STR_VIEWPORT_TOWN_POP_VERY_POOR_RATING                          :{WHITE}{TOWN} {RED}({COMMA})
+STR_VIEWPORT_TOWN_POP_MEDIOCRE_RATING                           :{WHITE}{TOWN} {ORANGE}({COMMA})
+STR_VIEWPORT_TOWN_POP_GOOD_RATING                               :{WHITE}{TOWN} {YELLOW}({COMMA})
 STR_VIEWPORT_TOWN_POP                                           :{WHITE}{TOWN} ({COMMA})
+STR_VIEWPORT_TOWN_POP_EXCELLENT_RATING                          :{WHITE}{TOWN} {GREEN}({COMMA})
 STR_VIEWPORT_TOWN                                               :{WHITE}{TOWN}
 STR_VIEWPORT_TOWN_TINY_BLACK                                    :{TINY_FONT}{BLACK}{TOWN}
+STR_VIEWPORT_TOWN_TINY_VERY_POOR_RATING                         :{TINY_FONT}{RED}{TOWN}
+STR_VIEWPORT_TOWN_TINY_MEDIOCRE_RATING                          :{TINY_FONT}{ORANGE}{TOWN}
+STR_VIEWPORT_TOWN_TINY_GOOD_RATING                              :{TINY_FONT}{YELLOW}{TOWN}
 STR_VIEWPORT_TOWN_TINY_WHITE                                    :{TINY_FONT}{WHITE}{TOWN}
+STR_VIEWPORT_TOWN_TINY_EXCELLENT_RATING                         :{TINY_FONT}{GREEN}{TOWN}
 
 STR_VIEWPORT_SIGN_SMALL_BLACK                                   :{TINY_FONT}{BLACK}{SIGN}
 STR_VIEWPORT_SIGN_SMALL_WHITE                                   :{TINY_FONT}{WHITE}{SIGN}
@@ -4690,6 +5169,10 @@
 STR_JUST_DATE_SHORT                                             :{DATE_SHORT}
 STR_JUST_DATE_LONG                                              :{DATE_LONG}
 STR_JUST_DATE_ISO                                               :{DATE_ISO}
+STR_JUST_DATE_WALLCLOCK_TINY                                    :{DATE_WALLCLOCK_TINY}
+STR_JUST_DATE_WALLCLOCK_SHORT                                   :{DATE_WALLCLOCK_SHORT}
+STR_JUST_DATE_WALLCLOCK_LONG                                    :{DATE_WALLCLOCK_LONG}
+STR_JUST_DATE_WALLCLOCK_ISO                                     :{DATE_WALLCLOCK_ISO}
 STR_JUST_STRING                                                 :{STRING}
 STR_JUST_STRING_STRING                                          :{STRING}{STRING}
 STR_JUST_RAW_STRING                                             :{RAW_STRING}
@@ -4708,11 +5191,14 @@
 STR_BLACK_CROSS                                                 :{BLACK}{CROSS}
 STR_SILVER_CROSS                                                :{SILVER}{CROSS}
 STR_WHITE_DATE_LONG                                             :{WHITE}{DATE_LONG}
+STR_WHITE_DATE_WALLCLOCK_LONG                                   :{WHITE}{DATE_WALLCLOCK_LONG}
+STR_WHITE_DATE_WALLCLOCK_SHORT                                  :{WHITE}{DATE_WALLCLOCK_SHORT}
 STR_SHORT_DATE                                                  :{WHITE}{DATE_TINY}
 STR_DATE_LONG_SMALL                                             :{TINY_FONT}{BLACK}{DATE_LONG}
 STR_TINY_GROUP                                                  :{TINY_FONT}{GROUP}
 STR_BLACK_INT                                                   :{BLACK}{NUM}
 STR_ORANGE_INT                                                  :{ORANGE}{NUM}
+STR_RED_INT                                                     :{RED}{NUM}
 STR_WHITE_SIGN                                                  :{WHITE}{SIGN}
 STR_TINY_BLACK_STATION                                          :{TINY_FONT}{BLACK}{STATION}
 STR_BLACK_STRING                                                :{BLACK}{STRING}
@@ -4741,5 +5227,67 @@
 STR_LORRY                                                       :{BLACK}{LORRY}
 STR_PLANE                                                       :{BLACK}{PLANE}
 STR_SHIP                                                        :{BLACK}{SHIP}
+STR_WATCH_WINDOW_TITLE                                          :{WHITE}Watching {RAW_STRING}.
+STR_WATCH_CLICK_TO_WATCH_COMPANY                                :{BLACK}Click here to watch company building
+STR_WATCH_CLICK_NEW_WINDOW                                      :{BLACK}Click here to open new watching window
 
 STR_TOOLBAR_RAILTYPE_VELOCITY                                   :{STRING} ({VELOCITY})
+
+STR_TMPL_RPL_TITLE						:{WHITE}Template Replacement
+STR_TMPL_TEMPLATE_REPLACEMENT					:Template Replacement
+STR_TMPL_TRAINS_IN_GROUP					:{BLACK}Trains in group
+STR_TMPL_AVAILABLE_TEMPLATES					:{BLACK}Available Templates
+STR_TMPL_DEFINE_TEMPLATE					:{BLACK}New
+STR_TMPL_EDIT_TEMPLATE						:{BLACK}Edit
+STR_TMPL_CREATE_CLONE_VEH					:{BLACK}Clone
+STR_TMPL_DELETE_TEMPLATE					:{BLACK}Delete
+STR_TMPL_RPL_ALL_TMPL						:{BLACK}Replace All Templates
+STR_TMPL_NEW_VEHICLE						:{BLACK}New Vehicle
+STR_TMPL_CONFIRM						:{BLACK}Ok
+STR_TMPL_CANCEL							:{BLACK}Cancel
+STR_TMPL_NEW							:{BLACK}New Template Vehicle
+STR_TMPL_REFIT							:{BLACK}Refit
+STR_TMPL_GROUP_INFO						:{BLACK}Group Info: {ORANGE}
+STR_TMPL_TEMPLATE_INFO						:{BLACK}Template Info: {ORANGE}
+STR_TMPL_RPL_START						:{BLACK}Start replacing
+STR_TMPL_RPL_STOP						:{BLACK}Stop replacing
+STR_TMPL_TRAIN_OVR_VALUE					:{TINY_FONT}{BLACK}Train Value: {CURRENCY_SHORT}
+STR_TMPL_TEMPLATE_OVR_VALUE					:{TINY_FONT}{BLACK}Buying Cost: {GOLD}{CURRENCY_LONG}
+STR_TMPL_TEMPLATE_OVR_VALUE_nogold				:{TINY_FONT}{BLACK}Buying Cost: {CURRENCY_LONG}
+STR_TMPL_TEMPLATE_OVR_VALUE_nogoldandcurrency			:{TINY_FONT}{BLACK}Buying Cost:
+STR_TMPL_TEMPLATE_OVR_VALUE_notinyfont				:{BLACK}Buying Cost: {GOLD}{CURRENCY_LONG}
+STR_TMPL_TEMPLATE_OVR_VALUE_notinyfontandblack			:Buying Cost: {GOLD}{CURRENCY_LONG}
+STR_TMPL_WARNING_FREE_WAGON					:{RED}Free Chain: not runnable!
+STR_TMPL_TEST							:{ORANGE}Test String: {RAW_STRING} {RAW_STRING}
+STR_TMPL_GROUP_USES_TEMPLATE					:{BLACK}Template in use: {NUM}
+STR_TMP_TEMPLATE_IN_USE						:Template is in use
+STR_TMPL_GROUP_NUM_TRAINS					:{BLACK}{NUM}
+STR_TMPL_CREATEGUI_TITLE					:{WHITE}Create/Edit Template Vehicle
+STR_TMPL_MAINGUI_DEFINEDGROUPS					:{BLACK}Defined Groups for Company
+STR_TMPL_TMPLRPL_EX_DIFF_RAILTYPE				:Uses Template of different rail type
+
+STR_TMPL_SET_USEDEPOT						:{BLACK}Use vehicles in depot
+STR_TMPL_SET_USEDEPOT_TIP					:{BLACK}Use vehicles inside the depot that are in a neutral and idle state to compose trains on template replacement in order to reduce buying costs
+STR_TMPL_SET_KEEPREMAINDERS					:{BLACK}Keep remainders
+STR_TMPL_SET_KEEPREMAINDERS_TIP					:{BLACK}After finishing template replacement keep all remaining vehicles from the old train in a neutral and idle state for later use
+STR_TMPL_SET_REFIT						:{BLACK}Use Refit
+STR_TMPL_SET_REFIT_TIP						:{BLACK}If set, the train will use exactly the cargo refit specified by the template. If not every wagon that is to be newly bought or retrieved from the depot, will *attempt* to be refitted as the old one was. Standard refit if this is impossible.
+
+STR_TMPL_CONFIG_USEDEPOT					:use depot
+STR_TMPL_CONFIG_KEEPREMAINDERS					:keep rem
+STR_TMPL_CONFIG_REFIT						:refit
+
+STR_TMPL_NUM_TRAINS_NEED_RPL					:# trains to replace:
+
+STR_TMPL_CARGO_SUMMARY						:{CARGO_LONG}
+STR_TMPL_CARGO_SUMMARY_MULTI					:{CARGO_LONG} (x{NUM})
+
+STR_TMPL_RPLALLGUI_TITLE					:{WHITE}Replace all Templace Vehicles
+STR_TMPL_RPLALLGUI_INSET_TOP					:{BLACK}Choose Vehicle Type and Replacement
+STR_TMPL_RPLALLGUI_INSET_TOP_1					:{BLACK}Template Engines
+STR_TMPL_RPLALLGUI_INSET_TOP_2					:{BLACK}Buyable Engines
+STR_TMPL_RPLALLGUI_INSET_BOTTOM					:{BLACK}Current Template List (updated only after replacement)
+STR_TMPL_RPLALLGUI_BUTTON_RPLALL				:{BLACK}Replace All
+STR_TMPL_RPLALLGUI_BUTTON_APPLY					:{BLACK}Apply
+STR_TMPL_RPLALLGUI_BUTTON_CANCEL				:{BLACK}Cancel
+STR_TMPL_RPLALLGUI_USE_TIP					:{BLACK}Select a vehicle type from each list and press 'Replace All'. If you are happy with the result displayed in the template list, press 'Apply' to actually apply these changes.
diff -urNad openttd-1.3.2/src/lang/english_US.txt openttd-1.3.2-DC3.0RC3/src/lang/english_US.txt
--- openttd-1.3.2/src/lang/english_US.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/english_US.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1954,7 +1954,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Kick
 STR_NETWORK_CLIENTLIST_BAN                                      :Ban
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Give money
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Speak to all
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Speak to company
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Private message
@@ -1963,7 +1962,6 @@
 STR_NETWORK_CLIENT                                              :Client
 STR_NETWORK_SPECTATORS                                          :Spectators
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Enter the amount of money you want to give
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Do not save the entered password
@@ -3051,6 +3049,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Rebuild company headquarters elsewhere for 1% cost of company value. Shift+Click shows estimated cost without relocating HQ
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Details
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}View detailed infrastructure counts
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Give money
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}New Face
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Select new face for president
@@ -3068,6 +3067,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Company Name
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :President's Name
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Enter the amount of money you want to give
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}We are looking for a transport company to take-over our company{}{}Do you want to purchase {COMPANY} for {CURRENCY_LONG}?
 
diff -urNad openttd-1.3.2/src/lang/esperanto.txt openttd-1.3.2-DC3.0RC3/src/lang/esperanto.txt
--- openttd-1.3.2/src/lang/esperanto.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/esperanto.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1694,7 +1694,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Forbatu
 STR_NETWORK_CLIENTLIST_BAN                                      :Bari
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Donu monon
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Parolu al ĉiuj
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Parolu al kompanio
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Privata mesaĝo
@@ -1703,7 +1702,6 @@
 STR_NETWORK_CLIENT                                              :Kliento
 STR_NETWORK_SPECTATORS                                          :Spektantoj
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Tajpu kiom da mono vi volas doni
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Ne konservu la pasvorton.
@@ -2672,6 +2670,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Kompania Nomo
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Nomo de la Manaĝanto
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Tajpu kiom da mono vi volas doni
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Ni serĉas transportkompanion por transpreni nian kompanion.{}{}Ĉu vi volas aĉeti {COMPANY} por {CURRENCY_LONG}?
 
diff -urNad openttd-1.3.2/src/lang/estonian.txt openttd-1.3.2-DC3.0RC3/src/lang/estonian.txt
--- openttd-1.3.2/src/lang/estonian.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/estonian.txt	2013-11-22 05:49:07.000000000 +0100
@@ -2009,7 +2009,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Viska välja
 STR_NETWORK_CLIENTLIST_BAN                                      :Bänn
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Anna raha
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Räägi kõigiga
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Räägi ettevõttega
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Privaatne sõnum
@@ -2018,7 +2017,6 @@
 STR_NETWORK_CLIENT                                              :Klient
 STR_NETWORK_SPECTATORS                                          :Pealtvaatajad
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Sisesta summa mida anda
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Sisestatud salasõna ei salvestata
@@ -3103,6 +3101,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Ehita ettevõtte peakorter mujale 1% firmaväärtuse tasu eest. Shift+klõps näitab toimingu eeldatavat maksumust
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Täpsustused
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}Vaata infrastruktuuri kogust detailselt
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Anna raha
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}Uus nägu
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Vali presidendile uus nägu
@@ -3120,6 +3119,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Ettevõtte nimi
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Presidendi nimi
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Sisesta summa mida anda
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Otsime ettevõtet, kes võtaks meie firma üle.{}{}Kas soovite osta ettevõtte {COMPANY} {CURRENCY_LONG} eest?
 
diff -urNad openttd-1.3.2/src/lang/faroese.txt openttd-1.3.2-DC3.0RC3/src/lang/faroese.txt
--- openttd-1.3.2/src/lang/faroese.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/faroese.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1910,7 +1910,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Sparka
 STR_NETWORK_CLIENTLIST_BAN                                      :Bannað
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Gev pening
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Tosa við øll
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Tosa við fyritøku
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Persónligt boð
@@ -1919,7 +1918,6 @@
 STR_NETWORK_CLIENT                                              :Klient
 STR_NETWORK_SPECTATORS                                          :Eygleiðarar
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Skriva nøgdina av peningi tú vil geva
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Goym ikki skrivaða loyniorðið
diff -urNad openttd-1.3.2/src/lang/finnish.txt openttd-1.3.2-DC3.0RC3/src/lang/finnish.txt
--- openttd-1.3.2/src/lang/finnish.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/finnish.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1954,7 +1954,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Potkaise
 STR_NETWORK_CLIENTLIST_BAN                                      :Kiellä
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Anna rahaa
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Puhu kaikille
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Puhu yhtiölle
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Yksityinen viesti
@@ -1963,7 +1962,6 @@
 STR_NETWORK_CLIENT                                              :Pelaaja
 STR_NETWORK_SPECTATORS                                          :Katsojat
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Syötä rahamäärä, jonka haluat antaa
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Älä tallenna syötettyä salasanaa
@@ -3051,6 +3049,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Rakenna yhtiön päärakennus muualle, kustannus 1{NBSP}% yhtiön arvosta. Shift+Klik näyttää kustannearvion sijoittamatta päärakennusta uudelleen
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Yksityiskohdat
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}Näytä tarkka infrastruktuurin määrä
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Anna rahaa
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}Uudet kasvot
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Valitse uudet kasvot pääjohtajalle.
@@ -3068,6 +3067,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Yhtiön nimi
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Pääjohtajan nimi
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Syötä rahamäärä, jonka haluat antaa
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Etsimme kuljetusyhtiötä, joka ottaisi haltuunsa yhtiömme{}{}Haluatko ostaa yhtiön {COMPANY} hintaan {CURRENCY_LONG}?
 
diff -urNad openttd-1.3.2/src/lang/french.txt openttd-1.3.2-DC3.0RC3/src/lang/french.txt
--- openttd-1.3.2/src/lang/french.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/french.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1955,7 +1955,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Exclure
 STR_NETWORK_CLIENTLIST_BAN                                      :Bannir
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Donner de l'argent
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Parler à tous
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Parler à la compagnie
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Message privé
@@ -1964,7 +1963,6 @@
 STR_NETWORK_CLIENT                                              :Client
 STR_NETWORK_SPECTATORS                                          :Spectateurs
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Entrer le montant que vous voulez donner
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Ne pas sauver le mot de passe entré
@@ -3052,6 +3050,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Reconstruire ailleurs le siège de la compagnie pour le prix de 1{NBSP}% de sa valeur.{}Shift-clic pour afficher seulement le coût estimé.
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Détails
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}Afficher le détail des calculs d'infrastructure
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Donner de l'argent
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}Nouveau visage
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Choix d'un nouveau visage pour le P.D.G.
@@ -3069,6 +3068,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Nom de la société
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Nom du P.D.G.
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Entrer le montant que vous voulez donner
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Nous sommes à la recherche d'un repreneur pour notre compagnie{}{}Voulez-vous acheter {COMPANY} pour {CURRENCY_LONG}{NBSP}?
 
diff -urNad openttd-1.3.2/src/lang/gaelic.txt openttd-1.3.2-DC3.0RC3/src/lang/gaelic.txt
--- openttd-1.3.2/src/lang/gaelic.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/gaelic.txt	2013-11-22 05:49:07.000000000 +0100
@@ -2155,7 +2155,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Thoir a bhròg dha
 STR_NETWORK_CLIENTLIST_BAN                                      :Toirmisg
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Thoir airgead dha
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Bruidhinn ris a h-uile duine
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Bruidhinn ris a' chompanaidh
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Teachdaireachd phrìobhaideach
@@ -2164,7 +2163,6 @@
 STR_NETWORK_CLIENT                                              :Cliant
 STR_NETWORK_SPECTATORS                                          :Amharcaichean
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Cuir a-steach na tha thu airson toirt seachad
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Na sàbhail am facal-faire air a chur a-steach
diff -urNad openttd-1.3.2/src/lang/galician.txt openttd-1.3.2-DC3.0RC3/src/lang/galician.txt
--- openttd-1.3.2/src/lang/galician.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/galician.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1955,7 +1955,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Chimpar
 STR_NETWORK_CLIENTLIST_BAN                                      :Bloquear
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Dar cartos
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Falar a todos
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Falar con compañía
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Mensaxe privada
@@ -1964,7 +1963,6 @@
 STR_NETWORK_CLIENT                                              :Cliente
 STR_NETWORK_SPECTATORS                                          :Espectadores
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Introduce a cantidade de cartos que queres dar
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Non grava-lo contrasinal introducido
@@ -3069,6 +3067,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Nome da compañía
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Nome do presidente
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Introduce a cantidade de diñeiro que queres dar
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Buscamos unha compañía de transportes para adquiri-la nosa compañía{}{}Queres mercar{COMPANY} por {CURRENCY_LONG}?
 
diff -urNad openttd-1.3.2/src/lang/german.txt openttd-1.3.2-DC3.0RC3/src/lang/german.txt
--- openttd-1.3.2/src/lang/german.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/german.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1955,7 +1955,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Hinauswerfen
 STR_NETWORK_CLIENTLIST_BAN                                      :Sperren
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Geld schenken
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Mit allen sprechen
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Mit Firma sprechen
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Private Nachricht
@@ -1964,7 +1963,6 @@
 STR_NETWORK_CLIENT                                              :Teilnehmer
 STR_NETWORK_SPECTATORS                                          :Zuschauer
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Wieviel Geld soll übergeben werden?
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Eingegebenes Passwort nicht speichern
@@ -3052,6 +3050,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Errichte Firmensitz für 1% des Firmenwertes an anderer Stelle neu. Shift+Klick zeigt einen Kostenvoranschlag
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Details
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}Detaillierte Infrastrukturinformationen anzeigen
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Geld schenken
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}Neues Gesicht
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Neues Gesicht für Manager aussuchen
@@ -3069,6 +3068,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Firmenname
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Name des Managers
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Wieviel Geld soll übergeben werden?
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Wir suchen eine Transportfirma, die unsere Firma übernimmt.{}{}Besteht Interesse daran, {COMPANY} für {CURRENCY_LONG} zu übernehmen?
 
diff -urNad openttd-1.3.2/src/lang/greek.txt openttd-1.3.2-DC3.0RC3/src/lang/greek.txt
--- openttd-1.3.2/src/lang/greek.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/greek.txt	2013-11-22 05:49:07.000000000 +0100
@@ -2031,7 +2031,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Εκδίωξη
 STR_NETWORK_CLIENTLIST_BAN                                      :Απαγόρευση
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Δώστε χρήματα
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Μιλήστε σε όλους
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Μιλήστε στην εταιρεία
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Προσωπικό μήνυμα
@@ -2040,7 +2039,6 @@
 STR_NETWORK_CLIENT                                              :Πελάτης
 STR_NETWORK_SPECTATORS                                          :Θεατές
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Εισάγετε το πόσο των χρημάτων που θέλετε να δώσετε
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Να μην αποθηκευτεί ο κωδικός
@@ -3128,6 +3126,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Εποικοδόμηση της έδρας της εταιρίας σε άλλο μέρος, με κόστος το 1% της αξίας της εταιρίας. Με Shift+Κλικ εμφανίζεται το εκτιμώμενο κόστος χωρίς επανατοποθέτηση της έδρας
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Λεπτομέρειες
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}Προβολή λεπτομερούς μέτρησης υποδομών
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Δώστε χρήματα
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}Νέο Πρόσωπο
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Επιλογή νέου προσώπου διευθυντή
@@ -3145,6 +3144,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Όνομα Εταιρίας
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Όνομα Διευθυντή
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Εισάγετε το πόσο των χρημάτων που θέλετε να δώσετε
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Ψάχνουμε μία εταιρία μεταφορών για να εξαγοράσει την εταιρία μας.{}{}Θέλετε να εξαγοράσετε την {COMPANY} για {CURRENCY_LONG};
 
diff -urNad openttd-1.3.2/src/lang/hebrew.txt openttd-1.3.2-DC3.0RC3/src/lang/hebrew.txt
--- openttd-1.3.2/src/lang/hebrew.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/hebrew.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1966,7 +1966,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :בעט
 STR_NETWORK_CLIENTLIST_BAN                                      :חסימה
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :נתן כסף
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :דבר לכולם
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :דבר לחברה
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :הודעה פרטית
@@ -1975,7 +1974,6 @@
 STR_NETWORK_CLIENT                                              :לקוח
 STR_NETWORK_SPECTATORS                                          :צופים
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}הכנס סכום כסף שברצונך לתת
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}בטל שמירת הסיסמה החדשה
@@ -3076,6 +3074,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :שם החברה
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :שם המנהל
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :הכנס סכום כסף שברצונך לתת
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}.אנו מחפשים אחר קונה לחברה{} ? {NBSP}{1:CURRENCY_LONG} תמורת {NBSP}{0:COMPANY} האם אתה מעוניין לקנות את
 
diff -urNad openttd-1.3.2/src/lang/hungarian.txt openttd-1.3.2-DC3.0RC3/src/lang/hungarian.txt
--- openttd-1.3.2/src/lang/hungarian.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/hungarian.txt	2013-11-22 06:03:25.000000000 +0100
@@ -287,6 +287,7 @@
 STR_TOOLTIP_SORT_ORDER                                          :{BLACK}Csökkenő/növekvő sorbarendezés
 STR_TOOLTIP_SORT_CRITERIA                                       :{BLACK}Sorbarendezési feltétel
 STR_TOOLTIP_FILTER_CRITERIA                                     :{BLACK}Szűrési feltétel kiválasztása
+STR_BUTTON_COVERAGE                                             :{BLACK}Lefedettség
 STR_BUTTON_SORT_BY                                              :{BLACK}Rendezés
 STR_BUTTON_LOCATION                                             :{BLACK}Megnéz
 STR_BUTTON_RENAME                                               :{BLACK}Átnevez
@@ -421,6 +422,7 @@
 STR_SETTINGS_MENU_SIGNS_DISPLAYED                               :Feliratok mutatása
 STR_SETTINGS_MENU_SHOW_COMPETITOR_SIGNS                         :Az ellenfelek feliratainak és neveinek mutatása
 STR_SETTINGS_MENU_FULL_ANIMATION                                :Teljes animáció
+STR_SETTINGS_MENU_RAIL_FENCES                                   :Kerítés a sín mellett
 STR_SETTINGS_MENU_FULL_DETAIL                                   :Minden részlet
 STR_SETTINGS_MENU_TRANSPARENT_BUILDINGS                         :Átlátszó épületek
 STR_SETTINGS_MENU_TRANSPARENT_SIGNS                             :Átlátszó feliratok
@@ -438,6 +440,7 @@
 STR_MAP_MENU_MAP_OF_WORLD                                       :Világtérkép
 STR_MAP_MENU_EXTRA_VIEW_PORT                                    :Extra látkép
 STR_MAP_MENU_SIGN_LIST                                          :Feliratok listája
+STR_MAP_MENU_WATCH_COMPANY                                      :Vállalat követése
 
 ############ range for town menu starts
 STR_TOWN_MENU_TOWN_DIRECTORY                                    :Városlista
@@ -492,6 +495,7 @@
 
 ############ range for landscaping menu starts
 STR_LANDSCAPING_MENU_LANDSCAPING                                :Tájrendezés
+STR_LANDSCAPING_MENU_CLIPBOARD                                  :Vágólap
 STR_LANDSCAPING_MENU_PLANT_TREES                                :Faültetés
 STR_LANDSCAPING_MENU_PLACE_SIGN                                 :Felirat lerakása
 ############ range ends here
@@ -724,17 +728,20 @@
 STR_SMALLMAP_TYPE_CONTOURS                                      :Domborzat
 STR_SMALLMAP_TYPE_VEHICLES                                      :Járművek
 STR_SMALLMAP_TYPE_INDUSTRIES                                    :Gazdaság
+STR_SMALLMAP_TYPE_ROUTELINKS                                    :Útvonalak
 STR_SMALLMAP_TYPE_ROUTES                                        :Utak
 STR_SMALLMAP_TYPE_VEGETATION                                    :Növényzet
 STR_SMALLMAP_TYPE_OWNERS                                        :Tulajdonosok
 STR_SMALLMAP_TOOLTIP_SHOW_LAND_CONTOURS_ON_MAP                  :{BLACK}Domborzat mutatása a térképen
 STR_SMALLMAP_TOOLTIP_SHOW_VEHICLES_ON_MAP                       :{BLACK}Járművek mutatása a térképen
 STR_SMALLMAP_TOOLTIP_SHOW_INDUSTRIES_ON_MAP                     :{BLACK}Gazdasági épületek mutatása a térképen
+STR_SMALLMAP_TOOLTIP_SHOW_ROUTE_LINKS_ON_MAP                    :{BLACK}Rakomány útvonalak mutatása a térképen
 STR_SMALLMAP_TOOLTIP_SHOW_TRANSPORT_ROUTES_ON                   :{BLACK}Szállítási útvonalak mutatása a térképen
 STR_SMALLMAP_TOOLTIP_SHOW_VEGETATION_ON_MAP                     :{BLACK}Növényzet mutatása a térképen
 STR_SMALLMAP_TOOLTIP_SHOW_LAND_OWNERS_ON_MAP                    :{BLACK}Tulajdonosok mutatása a térképen
 STR_SMALLMAP_TOOLTIP_INDUSTRY_SELECTION                         :{BLACK}Kattints egy gazdasági épület típusra annak megjelenítésének ki/bekapcsolásához. Ctrl+kattintással kikapcsolja az összeset kivéve a kiválasztott típust. Ctrl+kattintás még egyszer bekapcsolja az összeset
 STR_SMALLMAP_TOOLTIP_COMPANY_SELECTION                          :{BLACK}Kattints egy vállalatra a tulajdonainak megjelenítésének ki/bekapcsolásához. Ctrl+kattintással kikapcsolja az összeset kivéve a kiválasztottat. Ctrl+kattintás még egyszer bekapcsolja az összeset
+STR_SMALLMAP_TOOLTIP_ROUTELINK_SELECTION                        :{BLACK}Kattints egy rakományra az úticéljainak megjelenítésének ki/bekapcsolásához. Ctrl+kattintással kikapcsolja az összeset kivéve a kiválasztottat. Ctrl+kattintás még egyszer bekapcsolja az összeset
 
 STR_SMALLMAP_LEGENDA_ROADS                                      :{TINY_FONT}{BLACK}Út
 STR_SMALLMAP_LEGENDA_RAILROADS                                  :{TINY_FONT}{BLACK}Vasút
@@ -779,6 +786,8 @@
 STR_SMALLMAP_TOOLTIP_SHOW_HEIGHT                                :{BLACK}Magasságtérkép be/kikapcsolása
 STR_SMALLMAP_TOOLTIP_DISABLE_ALL_COMPANIES                      :{BLACK}Semelyik vállalat tulajdonainak megjelenítése a térképen
 STR_SMALLMAP_TOOLTIP_ENABLE_ALL_COMPANIES                       :{BLACK}Összes vállalat tulajdonainak megjelenítése a térképen
+STR_SMALLMAP_TOOLTIP_DISABLE_ALL_ROUTELINKS                     :{BLACK}Semelyik rakomány úticélját se jelenítsd meg
+STR_SMALLMAP_TOOLTIP_ENABLE_ALL_ROUTELINKS                      :{BLACK}Összes rakomány úticéljának megjelenítése a térképen
 
 # Status bar messages
 STR_STATUSBAR_TOOLTIP_SHOW_LAST_NEWS                            :{BLACK}Utolsó üzenet vagy újsághír megmutatása
@@ -1093,10 +1102,13 @@
 STR_SUBSIDY_X3                                                  :3x
 STR_SUBSIDY_X4                                                  :4x
 
+STR_TERRAIN_TYPE_EXTREMELY_FLAT                                 :Extrémen sík
 STR_TERRAIN_TYPE_VERY_FLAT                                      :Nagyon sík
 STR_TERRAIN_TYPE_FLAT                                           :Sík
+STR_TERRAIN_TYPE_BUMPY                                          :Göröngyös
 STR_TERRAIN_TYPE_HILLY                                          :Dombos
 STR_TERRAIN_TYPE_MOUNTAINOUS                                    :Hegyes
+STR_TERRAIN_TYPE_ALPINIST                                       :Alpinista
 
 STR_CITY_APPROVAL_PERMISSIVE                                    :Engedékeny
 STR_CITY_APPROVAL_TOLERANT                                      :Toleráns
@@ -1164,8 +1176,12 @@
 STR_CONFIG_SETTING_SUBSIDY_MULTIPLIER_HELPTEXT                  :Támogatott kapcsolatok kifizetéseinek szorzója
 STR_CONFIG_SETTING_CONSTRUCTION_COSTS                           :Építkezési költségek: {STRING}
 STR_CONFIG_SETTING_CONSTRUCTION_COSTS_HELPTEXT                  :Építkezések és beszerzésk költségeinek szintje
+STR_CONFIG_SETTING_TAXES                                        :Évenkénti adózás: {STRING}
+STR_CONFIG_SETTING_TAXES_HELPTEXT                               :Évenkénti adózás bekapcsolása. 10% adó €200.000 bevételnél, és 20% adó €1.500.000 bevételnél.
 STR_CONFIG_SETTING_RECESSIONS                                   :Gazdasági válságok: {STRING}
 STR_CONFIG_SETTING_RECESSIONS_HELPTEXT                          :Ha bekapcsolod, gazdasági válság fog kitörni néhány évente. A válság alatt az összes ipar jelentősen kevesebbet termel. (A válság végével a termelés vissza áll az eredeti szintre.)
+STR_CONFIG_SETTING_LOST_CARGO                                   :Elveszett rakomány utáni pénzlevonás: {STRING}
+STR_CONFIG_SETTING_LOST_CARGO_HELPTEXT                          :Ha egy állomás értékelése rossz, akkor az így elveszett rakomány pénzkiadást von maga után.
 STR_CONFIG_SETTING_TRAIN_REVERSING                              :Vonatok állomáson történő megfordulásának tiltása: {STRING}
 STR_CONFIG_SETTING_TRAIN_REVERSING_HELPTEXT                     :Ha engedélyezve van, a vonatok nem fordulnak vissza egy (nem vég-) állomáson, még ha lenne egy rövidebb út is visszafordulva
 STR_CONFIG_SETTING_DISASTERS                                    :Katasztrófák: {STRING}
@@ -1173,14 +1189,21 @@
 STR_CONFIG_SETTING_CITY_APPROVAL                                :Városi tanács hozzáállása a területének az átépítéséhez: {STRING}
 STR_CONFIG_SETTING_CITY_APPROVAL_HELPTEXT                       :Válaszd ki, hogy mennyi zaj és környezeti kár okozása befolyásolja a cég megítélését egy városban, mely hatással van a cég további építési lehetőségeire a város területén belül
 
+STR_CONFIG_SETTING_MAX_HEIGHTLEVEL                              :Maximum megengedett magasság: {STRING}
+STR_CONFIG_SETTING_MAX_HEIGHTLEVEL_HELPTEXT                     :Hány egység legyen a hegyek maximális magassága
+STR_CONFIG_SETTING_TOO_HIGH_MOUNTAIN                            :{WHITE}Nem állíthatod be erre az értékre a maximális magasságot. Legalább egy hegy magasabb ennél.
 STR_CONFIG_SETTING_BUILDONSLOPES                                :Lejtőre és partokra építés: {STRING}
 STR_CONFIG_SETTING_BUILDONSLOPES_HELPTEXT                       :Bekapcsolva utak, vasutak és állomások lejtőre is építhetőek. Kikapcsolva csak olyan lejtőre építhetőek, melyek megegyeznek a lejtő irányával és nem igényelnek egyéb létesítményeket
 STR_CONFIG_SETTING_AUTOSLOPE                                    :Épületek, vágányok stb. alatti tereprendezés engedélyezése: {STRING}
 STR_CONFIG_SETTING_AUTOSLOPE_HELPTEXT                           :Tájrendezés engedélyezése épületek és utak alatt azok eltávolítása nélkül
+STR_CONFIG_SETTING_ENABLE_LAND_BUYING                           :Földvásárlás engedélyezése: {STRING}
+STR_CONFIG_SETTING_ENABLE_RESTRICTIVE_LAND_BUYING               :Megvehető földterület limitálása: {STRING}
+STR_CONFIG_SETTING_DRAG_DROP_LAND_BUYING_LIMIT                  :Maximum megvehető földterület egyszerre: {STRING}
 STR_CONFIG_SETTING_CATCHMENT                                    :Élethűbben méretezett állomási vonzáskörzetek bekapcsolása: {STRING}
 STR_CONFIG_SETTING_CATCHMENT_HELPTEXT                           :A különböző állomások és repterek más vonzáskörzettel rendelkeznek
 STR_CONFIG_SETTING_EXTRADYNAMITE                                :Települési tulajdonú utak/hidak/alagutak rombolásának engedélyezése: {STRING}
 STR_CONFIG_SETTING_EXTRADYNAMITE_HELPTEXT                       :Városi tulajdonú infrastruktúra és épületek könnyebb eltávolíthatósága
+STR_CONFIG_SETTING_SNOW_IN_TEMPERATE                            :Havas hegyek mérsékelt éghajlaton is: {STRING}
 STR_CONFIG_SETTING_TRAIN_LENGTH                                 :Vonatok maximális hossza: {STRING}
 STR_CONFIG_SETTING_TRAIN_LENGTH_HELPTEXT                        :Vonatok maximális hosszának beállítása
 STR_CONFIG_SETTING_TILE_LENGTH                                  :{COMMA} mező
@@ -1227,6 +1250,10 @@
 STR_CONFIG_SETTING_SIGNALSIDE_RIGHT                             :Jobb oldalon
 STR_CONFIG_SETTING_SHOWFINANCES                                 :Pénzügyi összesítés minden év végén: {STRING}
 STR_CONFIG_SETTING_SHOWFINANCES_HELPTEXT                        :Bekapcsolva a pénzügyi összesítő ablak minden év végén felbukkan, elősegítve a vállalat anyagi helyzetének könnyű ellenőrzését
+STR_CONFIG_SETTING_SPECIFIC_GROUP_NAME                          :Csoportok automatikus elnevezése {STRING} alapján
+STR_CONFIG_SETTING_SPECIFIC_GROUP_NAME_HELPTEXT                 :A menetrend első és az utolsó állomásából képzi a csoport nevét.
+STR_CONFIG_SETTING_SPECIFIC_GROUP_NAME_TOWN                     :település
+STR_CONFIG_SETTING_SPECIFIC_GROUP_NAME_STATION                  :állomás
 STR_CONFIG_SETTING_NONSTOP_BY_DEFAULT                           :Minden új utasítás alapból 'non-stop': {STRING}
 STR_CONFIG_SETTING_NONSTOP_BY_DEFAULT_HELPTEXT                  :Alapvetően egy jármű megáll minden útjába eső állomáson. Ezzel a beállítással a járművek a következő célpontjukig nem állnak meg egy útjukba eső állomáson sem. Ez a beállítás csak új utasítások esetén működik. Az egyes célpontok viszont beállíthatók másfajta működésmódra is természetesen
 STR_CONFIG_SETTING_STOP_LOCATION                                :A vonatok az állomások {STRING} állnak meg új utasításokban
@@ -1273,6 +1300,9 @@
 STR_CONFIG_SETTING_DYNAMIC_ENGINES_EXISTING_VEHICLES            :{WHITE}A beállítást nem lehet megváltoztatni, ha van használatban jármű
 STR_CONFIG_SETTING_INFRASTRUCTURE_MAINTENANCE                   :Az infrastruktúra fenntartási költségének engedélyezése: {STRING}
 STR_CONFIG_SETTING_INFRASTRUCTURE_MAINTENANCE_HELPTEXT          :Bekapcsolva az infrastruktúrának fenntartási költsége van. A költség hatványozottan nő a hálózatnagysággal, nagyobb hatással a nagyobb vállalatokra mint a kisebbekre
+STR_CONFIG_SETTING_CLIPBOARD_CAPACITY                           :Vágólap mérete: {STRING}
+STR_CONFIG_SETTING_CLIPBOARD_CAPACITY_VALUE                     :{0:NUM}{CROSS}{0:NUM} mező
+STR_CONFIG_SETTING_CLIPBOARD_CAPACITY_HELPTEXT                  :A vágólap Maximumilás mérete
 
 STR_CONFIG_SETTING_NEVER_EXPIRE_AIRPORTS                        :Repülőterek nem avulnak el: {STRING}
 STR_CONFIG_SETTING_NEVER_EXPIRE_AIRPORTS_HELPTEXT               :Bekapcsolva minden repülőtértípus örökké elérhető marad bevezetése után
@@ -1288,6 +1318,8 @@
 STR_CONFIG_SETTING_WARN_INCOME_LESS_HELPTEXT                    :Üzenetek megjelenítése azokról a járművekről, melyek nem termeltek profitot egy naptári év alatt
 STR_CONFIG_SETTING_NEVER_EXPIRE_VEHICLES                        :Járművek sosem avulnak el: {STRING}
 STR_CONFIG_SETTING_NEVER_EXPIRE_VEHICLES_HELPTEXT               :Bekapcsolva minden járműmodell örökké elérhető marad bevezetése után
+STR_CONFIG_SETTING_REPAIR_COST                                  :Javítási költségek: {STRING}
+STR_CONFIG_SETTING_REPAIR_COST_HELPTEXT                         :Bekapcsolva minden lerobbant jármű javítása a jármű árának 1/1024-edébe kerül
 STR_CONFIG_SETTING_AUTORENEW_VEHICLE                            :Automatikusan felújítja a járművet ha elöregedik: {STRING}
 STR_CONFIG_SETTING_AUTORENEW_VEHICLE_HELPTEXT                   :Bekapcsolva a jármű élettartamának végén automatikusan cserére kerül, ha a lecserélési feltételek teljesülnek
 STR_CONFIG_SETTING_AUTORENEW_MONTHS                             :Automatikus járműfelújítás ha a jármű max {STRING} éves
@@ -1307,6 +1339,7 @@
 STR_CONFIG_SETTING_POPULATION_IN_LABEL_HELPTEXT                 :Település lakosságszámának kijelzése a címkéjén
 STR_CONFIG_SETTING_GRAPH_LINE_THICKNESS                         :A vonalak vastagsága a grafikonokon: {STRING}
 STR_CONFIG_SETTING_GRAPH_LINE_THICKNESS_HELPTEXT                :Vonalak szélessége a grafikonokon. A vékony vonal precízebben olvasható, míg a vastagabb jobban látható és a színek jobban megkülönböztethetőek
+STR_CONFIG_SETTING_FORECAST_DISPLAY                             :Állomások építése közben mutatja a várható utas és levélforgalmat: {STRING}
 
 STR_CONFIG_SETTING_LAND_GENERATOR                               :Terep generálás: {STRING}
 STR_CONFIG_SETTING_LAND_GENERATOR_ORIGINAL                      :Eredeti
@@ -1319,6 +1352,9 @@
 STR_CONFIG_SETTING_ROUGHNESS_OF_TERRAIN_SMOOTH                  :Sima
 STR_CONFIG_SETTING_ROUGHNESS_OF_TERRAIN_ROUGH                   :Durva
 STR_CONFIG_SETTING_ROUGHNESS_OF_TERRAIN_VERY_ROUGH              :Nagyon durva
+STR_CONFIG_SETTING_ROUGHNESS_OF_TERRAIN_CEREALLY_ROUGH          :Még durvább
+STR_CONFIG_SETTING_ROUGHNESS_OF_TERRAIN_COMMUTORZ               :CommutorZ
+STR_CONFIG_SETTING_ROUGHNESS_OF_TERRAIN_FLOWING                 :Folyamatos
 STR_CONFIG_SETTING_TREE_PLACER                                  :Fa-elhelyező módszer: {STRING}
 STR_CONFIG_SETTING_TREE_PLACER_NONE                             :Nincs
 STR_CONFIG_SETTING_TREE_PLACER_ORIGINAL                         :Eredeti
@@ -1332,6 +1368,8 @@
 STR_CONFIG_SETTING_EDGES_NOT_EMPTY                              :{WHITE}Az északi határnál egy vagy több mező nem üres
 STR_CONFIG_SETTING_EDGES_NOT_WATER                              :{WHITE}Az egyik határnál egy vagy több mező nem víz
 
+STR_CONFIG_SETTING_STATION_ADVANCED                             :Haladó rakománykezelés: {STRING}
+STR_CONFIG_SETTING_STATION_ADVANCED_HELPTEXT                    :Rakomány nullázása Ctrl-Kattintással
 STR_CONFIG_SETTING_STATION_SPREAD                               :Max állomás kiterjedés: {STRING}
 STR_CONFIG_SETTING_STATION_SPREAD_HELPTEXT                      :A legnagyobb terület mérete, melyen egy adott állomás terjeszkedhet. Nagyobb érték lelassítja a játékot
 STR_CONFIG_SETTING_SERVICEATHELIPAD                             :Helikopterek automatikus javítása a helikopter-leszállókon: {STRING}
@@ -1369,6 +1407,10 @@
 STR_CONFIG_SETTING_OSK_ACTIVATION_DOUBLE_CLICK                  :Dupla kattintás
 STR_CONFIG_SETTING_OSK_ACTIVATION_SINGLE_CLICK_FOCUS            :Egyszeres kattintás (amikor előtérben van)
 STR_CONFIG_SETTING_OSK_ACTIVATION_SINGLE_CLICK                  :Egyszeres kattintás (azonnal)
+STR_CONFIG_SETTING_VIEWPORT_MAP_SHOW_VEHICLE_ROUTE_STOPOVERS    :Mutasd egy jármű megállóit: {STRING}
+STR_CONFIG_SETTING_VIEWPORT_MAP_SHOW_VEHICLE_ROUTE_PATH         :Mutasd egy jármű útvonalát: {STRING}
+STR_CONFIG_SETTING_VIEWPORT_MAP_SHOW_VEHICLE_ROUTE_PATH_NO      :Ne mutasd
+STR_CONFIG_SETTING_VIEWPORT_MAP_SHOW_VEHICLE_ROUTE_PATH_SIMPLE  :Vonalakkal
 
 STR_CONFIG_SETTING_RIGHT_MOUSE_BTN_EMU                          :Jobb egérgomb emuláció: {STRING}
 STR_CONFIG_SETTING_RIGHT_MOUSE_BTN_EMU_HELPTEXT                 :Jobb egérgomb emulálási módszerének kiválasztása
@@ -1404,8 +1446,24 @@
 STR_CONFIG_SETTING_LOADING_INDICATORS_HELPTEXT                  :A rakodásjelző megjelenítésének kiválasztása a be- és kirakodó járművek felett
 STR_CONFIG_SETTING_TIMETABLE_IN_TICKS                           :Menetrendi idő-alapegység tick a nap helyett: {STRING}
 STR_CONFIG_SETTING_TIMETABLE_IN_TICKS_HELPTEXT                  :Az utazási idők megjelenítése napok helyett tickekben
+STR_CONFIG_SETTING_TIME_IN_MINUTES                              :Az idő percben mutatása napok helyett: {STRING}
+STR_CONFIG_SETTING_TIME_IN_MINUTES_HELPTEXT                     :Napokban vagy órákban/percekben teljen az idő
+STR_CONFIG_SETTING_TICKS_PER_MINUTE                             :Percenkénti tick: {STRING}
+STR_CONFIG_SETTING_TICKS_PER_MINUTE_HELPTEXT                    :Mennyi tick teljen el egy perc alatt
+STR_CONFIG_SETTING_DATE_WITH_TIME                               :Dátum és idő mutatása: {STRING}
+STR_CONFIG_SETTING_DATE_WITH_TIME_HELPTEXT                      :Az igazi dátumot mutassa a játékban vagy az időt is
+STR_CONFIG_SETTING_CLOCK_OFFSET                                 :Óraeltolás percekben: {STRING}
+STR_CONFIG_SETTING_CLOCK_OFFSET_HELPTEXT                        :A játék órájának eltolása percekben
+STR_CONFIG_SETTING_DATE_WITH_TIME_NONE                          :Semmi
+STR_CONFIG_SETTING_DATE_WITH_TIME_Y                             :Év
+STR_CONFIG_SETTING_DATE_WITH_TIME_YM                            :Hónap és év
+STR_CONFIG_SETTING_DATE_WITH_TIME_YMD                           :Teljes dátum
+STR_CONFIG_SETTING_TIMETABLE_START_TEXT_ENTRY                   :A menetrendi idő szöveges bevitele (percenkénti időszámolás kell hozzá): {STRING}
+STR_CONFIG_SETTING_TIMETABLE_START_TEXT_ENTRY_HELPTEXT          :Be lehessen szövegként írni óra, perc pontossággal a menetidőt, ha a percenkénti időszámítást használjuk
 STR_CONFIG_SETTING_TIMETABLE_SHOW_ARRIVAL_DEPARTURE             :Indulás és érkezés megjelenítése a menetrendekben: {STRING}
 STR_CONFIG_SETTING_TIMETABLE_SHOW_ARRIVAL_DEPARTURE_HELPTEXT    :Várható érkezés és indulás megjelenítése a menetrendekben
+STR_CONFIG_SETTING_TIMETABLE_ENABLE_SEPARATION                  :Menetrendszerű járatok automatikus követési távolsága: {STRING}
+STR_CONFIG_SETTING_TIMETABLE_ENABLE_SEPARATION_HELPTEXT         :A megosztott menetrendszerű járatok egyforma távolsággal kövessék egymást
 STR_CONFIG_SETTING_QUICKGOTO                                    :Utasításlista gyors elkészítése: {STRING}
 STR_CONFIG_SETTING_QUICKGOTO_HELPTEXT                           :A 'Menj' parancs előzetes kiválasztása az utasításlista megnyitásakor
 STR_CONFIG_SETTING_DEFAULT_RAIL_TYPE                            :Alapértelmezett vasúti pályatípus: {STRING}
@@ -1436,6 +1494,8 @@
 STR_CONFIG_SETTING_SOUND_VEHICLE_HELPTEXT                       :Járműhangok lejátszása
 STR_CONFIG_SETTING_SOUND_AMBIENT                                :Terület: {STRING}
 STR_CONFIG_SETTING_SOUND_AMBIENT_HELPTEXT                       :Az ipar, városok és tájak környezeti hangjainak lejátszása
+STR_CONFIG_SETTING_SOUND_CASHTILL                               :Kassza: {STRING}
+STR_CONFIG_SETTING_SOUND_CASHTILL_HELPTEXT                      :Pénztárgép hangja bevételnél
 
 STR_CONFIG_SETTING_DISABLE_UNSUITABLE_BUILDING                  :Infrastruktúra építésének tiltása amíg nem elérhető megfelelő jármű: {STRING}
 STR_CONFIG_SETTING_DISABLE_UNSUITABLE_BUILDING_HELPTEXT         :Bekapcsolva az infrastruktúra csak akkor elérhető, ha van megfelelő jármű, megakadályozva a felesleges pénzköltést a kihasználhatatlan infrastruktúrára
@@ -1457,6 +1517,18 @@
 STR_CONFIG_SETTING_AI_BUILDS_SHIPS                              :Hajók tiltása a gépi ellenfeleknek: {STRING}
 STR_CONFIG_SETTING_AI_BUILDS_SHIPS_HELPTEXT                     :Bekapcsolva a számítógép által irányított ellenfelek nem építhetnek hajókat
 
+STR_CONFIG_SETTING_SHARING_RAIL                                 :Vasút megosztása: {STRING}
+STR_CONFIG_SETTING_SHARING_ROAD                                 :{LTBLUE}Közúti megállok és garázsok megosztása: {STRING}
+STR_CONFIG_SETTING_SHARING_WATER                                :Kikötők és dokkok megosztása: {STRING}
+STR_CONFIG_SETTING_SHARING_AIR                                  :Repülőterek megosztása: {STRING}
+STR_CONFIG_SETTING_SHARING_FEE_RAIL                             :Napi vasúti állomáshasználati díj: {STRING} 1000 tonnánként
+STR_CONFIG_SETTING_SHARING_FEE_ROAD                             :Közúti megállóhasználati díj: {STRING} per nap
+STR_CONFIG_SETTING_SHARING_FEE_WATER                            :Kikötő használati díj: {STRING} per nap
+STR_CONFIG_SETTING_SHARING_FEE_AIR                              :Repülőtér használati díj: {STRING} per nap
+STR_CONFIG_SETTING_SHARING_PAYMENT_IN_DEBT                      :Anyagilag negatívban levő vállalatok is fizessenek: {STRING}
+STR_CONFIG_SETTING_SHARING_USED_BY_VEHICLES                     :{WHITE}Can't change this setting, vehicles are using shared infrastructure.
+STR_CONFIG_SETTING_SHARING_ORDERS_TO_OTHERS                     :{WHITE}Can't change this setting, vehicles have orders to destinations of others.
+
 STR_CONFIG_SETTING_AI_PROFILE                                   :Alapértelmezett beállítás: {STRING}
 STR_CONFIG_SETTING_AI_PROFILE_HELPTEXT                          :Válaszd ki, hogy melyik beállítási mintát használja a 'véletlen' MI a belső beállításainak, amikor új MI-t vagy szkriptet adsz hozzá
 STR_CONFIG_SETTING_AI_PROFILE_EASY                              :Könnyű
@@ -1550,6 +1622,8 @@
 STR_CONFIG_SETTING_CYCLE_SIGNAL_NORMAL                          :Csak normál jelzők
 STR_CONFIG_SETTING_CYCLE_SIGNAL_PBS                             :Csak irányjelzők
 STR_CONFIG_SETTING_CYCLE_SIGNAL_ALL                             :Mind
+STR_CONFIG_PATCHES_RANDOM_ROAD_CONSTRUCTION                     :Véletlenszerű útfelújítások esélye (0 = kikapcsolva): {STRING}
+STR_CONFIG_PATCHES_RANDOM_ROAD_CONSTRUCTION_HELP                :Véletlenszerű útfelújítások esélye a településeken (jelzőlámpák telepítéséhez)
 
 STR_CONFIG_SETTING_TOWN_LAYOUT                                  :Új települések úthálózati elrendezése: {STRING}
 STR_CONFIG_SETTING_TOWN_LAYOUT_HELPTEXT                         :Települési úthálózat elrendezése
@@ -1569,6 +1643,10 @@
 STR_CONFIG_SETTING_TOWN_FOUNDING_FORBIDDEN                      :tiltott
 STR_CONFIG_SETTING_TOWN_FOUNDING_ALLOWED                        :megengedett
 STR_CONFIG_SETTING_TOWN_FOUNDING_ALLOWED_CUSTOM_LAYOUT          :megengedett, egyéni városelrendezés
+STR_CONFIG_SETTING_TOWN_CARGO_FACTOR                            :Települések utas/levél forgalmának szabályozása (kevesebb < 0 < több): {STRING}
+STR_CONFIG_SETTING_DAYLENGTH_FACTOR                             :Naphossz növelése: {STRING}x
+STR_CONFIG_SETTING_DAYLENGTH_FACTOR_HELPTEXT                    :Ennyiszer lassabban telnek a napok
+STR_CONFIG_SETTING_TOWN_CONSTRUCTION_COST                       :Település melletti építkezés költségesebb: {STRING}
 
 STR_CONFIG_SETTING_EXTRA_TREE_PLACEMENT                         :Játékbeli faelhelyezkedés: {STRING}
 STR_CONFIG_SETTING_EXTRA_TREE_PLACEMENT_HELPTEXT                :Fák véletlenszerű megjelenésének szabályozása a játék során. Ez befolyásolhatja a gazdasági épületeket, melyek a fák növekedésétől függnek, mint a favágók
@@ -1576,6 +1654,28 @@
 STR_CONFIG_SETTING_EXTRA_TREE_PLACEMENT_RAINFOREST              :csak esőerdőkben
 STR_CONFIG_SETTING_EXTRA_TREE_PLACEMENT_ALL                     :mindenhol
 
+STR_CONFIG_SETTING_TREE_GROWTH                                  :Fák telepítésének sebessége: {STRING}
+STR_CONFIG_SETTING_TREE_GROWTH_HELPTEXT                         :Milyen gyakran jelenjenek meg új fák
+STR_CONFIG_SETTING_TREE_GROWTH_NORMAL                           :eredeti
+STR_CONFIG_SETTING_TREE_GROWTH_SLOW                             :lassú
+STR_CONFIG_SETTING_TREE_GROWTH_VERY_SLOW                        :nagyon lassú
+STR_CONFIG_SETTING_TREE_GROWTH_EXTREMLY_SLOW                    :extrém lassú
+
+STR_CONFIG_SETTING_DAY_LENGTH_FACTOR                            :Nap hossza: {STRING}x
+STR_CONFIG_SETTING_DAY_LENGTH_BALANCE                           :Naphosz szerinti kiegyensúlyozás: {STRING}
+STR_CONFIG_SETTING_DAY_LENGTH_BALANCE_NONE                      :Nincs {GREEN}(nagyon könnyű)
+STR_CONFIG_SETTING_DAY_LENGTH_BALANCE_RUN_COST                  :Üzemeltetési költségek {GREEN}(könnyű)
+STR_CONFIG_SETTING_DAY_LENGTH_BALANCE_ALL_COSTS                 :Minden költség
+STR_CONFIG_SETTING_DAY_LENGTH_BALANCE_DECREASE_PAYMENTS         :Kifizetések
+STR_CONFIG_SETTING_DAY_LENGTH_BAL_FACTOR                        :Kiegyensúlyozás mértéke: {STRING}
+STR_CONFIG_SETTING_INCL_PROP_MAIN_TO_RUN                        :Ingatlanok fenntartási költsége az üzemeltetési költségekhez: {STRING}
+STR_CONFIG_SETTING_INCL_LOAN_INT_TO_RUN                         :Kamatok fizetése üzemeltetési költségekhez: {STRING}
+STR_CONFIG_SETTING_SLOW_DOWN_VEH_REL_DROP                       :Jármű lerobbanások ritkítása a naphossz arányában: {STRING}
+STR_CONFIG_SETTING_SLOW_DOWN_TOWN_GROWTH                        :Városok növekedése a naphosszhoz igazodik: {STRING}
+STR_CONFIG_SETTING_SLOW_DOWN_PROD                               :Termelés csökkentése: {STRING}x
+STR_CONFIG_SETTING_SLOW_DOWN_PROD_HELPTEXT                      :Termelés csökkentése, ha a nap hosszát változtatod
+STR_CONFIG_SETTING_SHOW_ORIG_PRODUCTION                         :Show original production value of industry: {STRING}
+
 STR_CONFIG_SETTING_TOOLBAR_POS                                  :A fő eszközsor helye: {STRING}
 STR_CONFIG_SETTING_TOOLBAR_POS_HELPTEXT                         :A fő eszközsor vízszintes elhelyezésének beállítása a képernyő tetején
 STR_CONFIG_SETTING_STATUSBAR_POS                                :Állapotsor elhelyezkedése: {STRING}
@@ -1614,6 +1714,29 @@
 STR_CONFIG_SETTING_MODIFIED_ROAD_REBUILD                        :Abszurd útrészletek automatikus eltávolítása útépítés közben: {STRING}
 STR_CONFIG_SETTING_MODIFIED_ROAD_REBUILD_HELPTEXT               :Zsákutcák eltávolítása támogatott útfelújítások ideje alatt
 
+STR_CONFIG_SETTING_TRAFFIC_LIGHTS                               :Közlekedési lámpák engedélyezése:{STRING}
+STR_CONFIG_SETTING_TRAFFIC_LIGHTS_HELPTEXT                      :Közlekedési lámpák építésének szabályozása
+STR_CONFIG_SETTING_TOWNS_BUILD_TRAFFIC_LIGHTS                   :A települések építhetnek lámpákat: {STRING}
+STR_CONFIG_SETTING_TOWNS_BUILD_TRAFFIC_LIGHTS_HELPTEXT          :A települések útfelújításkor közlekedési lámpát is építhessenek a kereszteződésekbe
+STR_CONFIG_SETTING_ALLOW_BUILDING_TLS_ON_TOWN_ROADS             :Közlekedési lámpák telepítése a települések útjain: {STRING}
+STR_CONFIG_SETTING_ALLOW_BUILDING_TLS_ON_TOWN_ROADS_HELPTEXT    :Rakhat-e a település útjaira a játékos közlekedési lámpákat
+STR_CONFIG_SETTING_TRAFFIC_LIGHTS_GREEN_PHASE                   :A zöld hossza: {STRING}
+STR_CONFIG_SETTING_TRAFFIC_LIGHTS_GREEN_PHASE_HELPTEXT          :Hány másodperces legyen a zöld
+STR_CONFIG_SETTING_MAX_TRAFFIC_LIGHT_CONSIST_SIZE               :Jelzőlámpák szinkronizálása: {STRING}
+STR_CONFIG_SETTING_MAX_TRAFFIC_LIGHT_CONSIST_SIZE_HELPTEXT      :Maximum mennyi jelzőlámpa kerüljön szinkronba egy szakaszon. Vigyázz: a nagyobb érték lassíthatja a játékot!
+STR_CONFIG_SETTING_MAX_TRAFFIC_LIGHT_CONSIST_DISTANCE           :Maximum távolság két szinkronizálandó lámpa között: {STRING}
+STR_CONFIG_SETTING_MAX_TRAFFIC_LIGHT_CONSIST_DISTANCE_HELPTEXT  :Maximum távolság két közlekedési lámpa között, amiket még szinkronizáljon
+
+STR_CONFIG_SETTING_CARGODEST_PAX                                :Utasok és levelek úticélja: {STRING}
+STR_CONFIG_SETTING_CARGODEST_PAX_HELPTEXT                       :Az utasok és a levelek saját úticéllal rendelkezzenek
+STR_CONFIG_SETTING_CARGODEST_TOWN                               :Városba szállított termékek úticélja: {STRING}
+STR_CONFIG_SETTING_CARGODEST_TOWN_HELPTEXT                      :A különböző termékek saját városi úticéllal rendelkezzenek
+STR_CONFIG_SETTING_CARGODEST_OTHER                              :Az összes többi szállítmány úticélja: {STRING}
+STR_CONFIG_SETTING_CARGODEST_OTHER_HELPTEXT                     :A többi szállítmány is rendelkezzen úticéllal
+STR_CONFIG_SETTING_CARGODEST_MODE_OFF                           :Alapbeállítás (nincs)
+STR_CONFIG_SETTING_CARGODEST_MODE_DEST                          :Saját úticélok
+
+
 STR_CONFIG_SETTING_GUI                                          :{ORANGE}Megjelenítés
 STR_CONFIG_SETTING_CONSTRUCTION                                 :{ORANGE}Építkezés
 STR_CONFIG_SETTING_VEHICLES                                     :{ORANGE}Járművek
@@ -1626,13 +1749,16 @@
 STR_CONFIG_SETTING_NEWS                                         :{ORANGE}Hírek és üzenetek
 STR_CONFIG_SETTING_CONSTRUCTION_SIGNALS                         :{ORANGE}Jelzők
 STR_CONFIG_SETTING_STATIONS_CARGOHANDLING                       :{ORANGE}Rakomány kezelés
+STR_CONFIG_SETTING_CONSTRUCTION_TRAFFIC_LIGHTS                  :{ORANGE}Közlekedési lámpák
 STR_CONFIG_SETTING_AI_NPC                                       :{ORANGE}Számítógép által vezérelt ellenfelek
 STR_CONFIG_SETTING_VEHICLES_AUTORENEW                           :{ORANGE}Automata felújítás
+STR_CONFIG_SETTING_SHARING                                      :{ORANGE}Infrastruktúra megosztás
 STR_CONFIG_SETTING_VEHICLES_SERVICING                           :{ORANGE}Javítás
 STR_CONFIG_SETTING_VEHICLES_ROUTING                             :{ORANGE}Útvonalkeresés
 STR_CONFIG_SETTING_VEHICLES_TRAINS                              :{ORANGE}Vonatok
 STR_CONFIG_SETTING_ECONOMY_TOWNS                                :{ORANGE}Települések
 STR_CONFIG_SETTING_ECONOMY_INDUSTRIES                           :{ORANGE}Gazdasági épületek
+STR_CONFIG_SETTING_ECONOMY_DAY_LENGTH                           :{ORANGE}Nap hossza
 
 STR_CONFIG_SETTING_PATHFINDER_OPF                               :Eredeti
 STR_CONFIG_SETTING_PATHFINDER_NPF                               :NPF
@@ -1647,6 +1773,18 @@
 STR_CONFIG_SETTING_REVERSE_AT_SIGNALS                           :Automatikus megfordulás jelzőknél: {STRING}
 STR_CONFIG_SETTING_REVERSE_AT_SIGNALS_HELPTEXT                  :A vonatok automatikus megfordításának engedélyezése, ha azok túl hosszú ideje várakoznak egy jelző előtt
 
+STR_CONFIG_SETTING_VEHICLES_SPEEDLIMIT                          :{ORANGE}Sebességhatárok
+STR_CONFIG_SETTING_LIMITVEHSPEED_IN                             :Sebességhatár a településeken: {STRING}
+STR_CONFIG_SETTING_LIMITVEHSPEED_IN_HELPTEXT                    :A közúti járműveknek lakott területen megendett legnagyobb sebesség.
+STR_CONFIG_SETTING_SET_LIMITVEHSPEED_IN_TNEW                    :Városi sebességhatár kétirányú utcákban: {STRING} km/h
+STR_CONFIG_SETTING_SET_LIMITVEHSPEED_IN_OWOW                    :Városi sebességhatár egyirányú utcákban: {STRING} km/h
+STR_CONFIG_SETTING_LIMITVEHSPEED_OUT                            :Sebességhatár településeken kívül: {STRING}
+STR_CONFIG_SETTING_SET_LIMITVEHSPEED_OUT_TNEW                   :Maximum sebesség utakon: {STRING} km/h
+STR_CONFIG_SETTING_SET_LIMITVEHSPEED_OUT_OWOW                   :Maximum sebesség egyirányú utakon: {STRING} km/h
+STR_CONFIG_SETTING_LIMITVEHSPEED_WORMHOLE                       :Sebességhatár hidakon és alagutakban: {STRING}
+STR_CONFIG_SETTING_SET_LIMITVEHSPEED_WORMHOLE                   :Maximum sebesség hidakon és alagutakban: {STRING} km/h
+STR_CONFIG_SETTING_LIMITVEHSPEED_CURVE                          :Sebességcsökkenés kanyarban: {STRING}
+
 STR_CONFIG_SETTING_QUERY_CAPTION                                :{WHITE}Válassz beállítási értéket
 
 # Config errors
@@ -1741,6 +1879,8 @@
 STR_CHEAT_EXTRA_DYNAMITE                                        :{LTBLUE}Csodabuldózer (lerombol gazdasági épületeket, mozgathatatlan objektumokat): {ORANGE}{STRING}
 STR_CHEAT_CROSSINGTUNNELS                                       :{LTBLUE}Alagutak keresztezhessék egymást: {ORANGE}{STRING}
 STR_CHEAT_NO_JETCRASH                                           :{LTBLUE}Jet-repülők nem fognak (gyakran) lezuhanni a kis repülőtereken: {ORANGE} {STRING}
+STR_CHEAT_EDIT_MAX_HL                                           :{LTBLUE}Maximális magasság szerkesztése: {ORANGE}{NUM}
+STR_CHEAT_EDIT_MAX_HL_QUERY_CAPT                                :{WHITE}Maximális magasság szerkesztése
 STR_CHEAT_SWITCH_CLIMATE_TEMPERATE_LANDSCAPE                    :Mérsékelt táj
 STR_CHEAT_SWITCH_CLIMATE_SUB_ARCTIC_LANDSCAPE                   :Szubarktikus táj
 STR_CHEAT_SWITCH_CLIMATE_SUB_TROPICAL_LANDSCAPE                 :Szubtrópusi táj
@@ -2018,7 +2158,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Kirúgás
 STR_NETWORK_CLIENTLIST_BAN                                      :Kitiltás
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Pénz adományozása
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Üzenet mindenkinek
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Üzenet a vállalatnak
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Privát üzenet
@@ -2027,7 +2166,6 @@
 STR_NETWORK_CLIENT                                              :Kliens
 STR_NETWORK_SPECTATORS                                          :Megfigyelők
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Add meg a küldeni kívánt pénz mennyiségét
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Ne mentsd el a megadott jelszót
@@ -2217,6 +2355,7 @@
 STR_TRANSPARENT_STRUCTURES_TOOLTIP                              :{BLACK}Tereptárgyak (adótornyok, világítótornyok stb.) átlátszóságának bekapcsolása. Ctrl+kattintással zárolható
 STR_TRANSPARENT_CATENARY_TOOLTIP                                :{BLACK}Felsővezetékek átlátszóságának bekapcsolása. Ctrl+kattintással zárolható
 STR_TRANSPARENT_LOADING_TOOLTIP                                 :{BLACK}Átlátszó rakodásjelző bekapcsolása. Ctrl+kattintással zárolható
+STR_TRANSPARENT_TUNNELS_TOOLTIP                                 :{BLACK}Járművek láthatósága alagutakban. Ctrl+kattintással zárolható
 STR_TRANSPARENT_INVISIBLE_TOOLTIP                               :{BLACK}Az objektum ne átlátszó legyen, hanem láthatatlan
 
 # Linkgraph legend window
@@ -2320,6 +2459,30 @@
 STR_BRIDGE_NAME_TUBULAR_STEEL                                   :Cső, acél
 STR_BRIDGE_TUBULAR_SILICON                                      :Cső, Szilikon
 
+# Clipboard toolbar window
+STR_CLIPBOARD_TOOLBAR_CAPTION                                   :{WHITE}Vágólap
+STR_CLIPBOARD_TOOLTIP_SWITCH_TO_1ST_CLIPBOARD                   :{BLACK}Váltás az 1. vágólapra
+STR_CLIPBOARD_TOOLTIP_SWITCH_TO_2ND_CLIPBOARD                   :{BLACK}Váltás az 2. vágólapra
+STR_CLIPBOARD_TOOLTIP_SWITCH_TO_3RD_CLIPBOARD                   :{BLACK}Váltás az 3. vágólapra
+STR_CLIPBOARD_TOOLTIP_SWITCH_TO_4TH_CLIPBOARD                   :{BLACK}Váltás az 4. vágólapra
+STR_CLIPBOARD_TOOLTIP_COPY                                      :{BLACK}Válaszd ki a másolandó területet
+STR_CLIPBOARD_TOOLTIP_PASTE                                     :{BLACK}A kijelölt területet beillesztése
+STR_CLIPBOARD_TOOLTIP_SELECT_COPY_AREA                          :{BLACK}Válaszd ki a másolandó területet
+STR_CLIPBOARD_TOOLTIP_INSTANT_COPY_PASTE                        :{BLACK}Másold az előzőleg kijelölt területet és illeszd be egy megadott helyre
+STR_CLIPBOARD_TOOLTIP_COPY_WITH_RAIL_TRANSPORT                  :{BLACK}Vasút beillesztése
+STR_CLIPBOARD_TOOLTIP_COPY_WITH_ROAD_TRANSPORT                  :{BLACK}Közút beillesztése
+STR_CLIPBOARD_TOOLTIP_COPY_WITH_WATER_TRANSPORT                 :{BLACK}Vízi út beillesztése
+STR_CLIPBOARD_TOOLTIP_COPY_WITH_AIR_TRANSPORT                   :{BLACK}Reptér beillesztése
+STR_CLIPBOARD_TOOLTIP_TERRAFORM                                 :{BLACK}Terület tájrendezése beillesztés közben{}(red) nincs tájrendezés{}(yellow) minimális tájrendezés{}(green) teljes tájrendezés
+STR_CLIPBOARD_TOOLTIP_CONVERT_RAIL                              :{BLACK}A síneket az aktuális típusra{}konvertálja beillesztés közben
+STR_CLIPBOARD_TOOLTIP_MIRROR_SIGNALS                            :{BLACK}Jelzők tükrözése beillesztés közben
+STR_CLIPBOARD_TOOLTIP_UPGRADE_BRIDGES                           :{BLACK}Hidak frissítése
+STR_CLIPBOARD_TOOLTIP_STOP_ON_FAILURE                           :{BLACK}Stop pasting immidiately if something is failing
+STR_CLIPBOARD_TOOLTIP_TRANSFORMATION                            :{BLACK}Jelenlegi forgatás,{}klikk az eredetihez
+STR_CLIPBOARD_TOOLTIP_ROTATE_LEFT                               :{BLACK}Forgatás órairánnyal szemben
+STR_CLIPBOARD_TOOLTIP_ROTATE_RIGHT                              :{BLACK}Forgatás órairányban
+STR_CLIPBOARD_TOOLTIP_REFLECT_NE_SW                             :{BLACK}Forgatás északnyugat-délkelet mentén
+STR_CLIPBOARD_TOOLTIP_REFLECT_NW_SE                             :{BLACK}Forgatás észekkelet-délnyugat mentén
 
 # Road construction toolbar
 STR_ROAD_TOOLBAR_ROAD_CONSTRUCTION_CAPTION                      :{WHITE}Út építése
@@ -2396,10 +2559,13 @@
 STR_AIRPORT_HELIPORT                                            :Helileszálló
 STR_AIRPORT_HELIDEPOT                                           :Helihangár
 STR_AIRPORT_HELISTATION                                         :Heliállomás
+STR_AIRPORT_INTERCONTINENTAL2                                   :Interkontinentális 2
+STR_AIRPORT_CIRCLE                                              :Körkörös
 
 STR_AIRPORT_CLASS_SMALL                                         :Kis repülőterek
 STR_AIRPORT_CLASS_LARGE                                         :Nagy repülőterek
 STR_AIRPORT_CLASS_HUB                                           :Központi repülőterek
+STR_AIRPORT_CLASS_HUGE                                          :Hatalmas repülőterek
 STR_AIRPORT_CLASS_HELIPORTS                                     :Helikopter-állomások
 
 STR_STATION_BUILD_NOISE                                         :{BLACK}Zajtermelés: {GOLD}{COMMA}
@@ -2409,6 +2575,7 @@
 STR_LANDSCAPING_TOOLTIP_LOWER_A_CORNER_OF_LAND                  :{BLACK}Egy pont lesüllyesztése. Húzással az első kiválasztott sarkot lesüllyeszti, majd a kiválasztott területet vele egy szintbe hozza. Ctrl lenyomásával átlós terület jelölhető ki. Shift lenyomásával megmutatja a terepsüllyesztés várható építési költségét
 STR_LANDSCAPING_TOOLTIP_RAISE_A_CORNER_OF_LAND                  :{BLACK}Egy sarokpont megemelése. Húzással az első kiválasztott sarkot megemeli, majd a kiválasztott területet vele egy szintbe hozza. Ctrl lenyomásával átlós terület jelölhető ki. Shift lenyomásával megmutatja a terepemelés várható építési költségét
 STR_LANDSCAPING_LEVEL_LAND_TOOLTIP                              :{BLACK}Talaj a kijelölt sarokpont szintjére hozása. Ctrl lenyomásával átlós terület jelölhető ki. Shift lenyomásával megmutatja az átalakítás várható költségét
+STR_LANDSCAPING_TOOLTIP_SHOW_CLIPBOARD_TOOLBAR                  :{BLACK}Vágólap eszköztár megjelenítése
 STR_LANDSCAPING_TOOLTIP_PURCHASE_LAND                           :{BLACK}Földterület megvétele későbbi használatra. Shift lenyomásával megmutatja a várható költséget
 
 # Object construction window
@@ -2655,6 +2822,9 @@
 STR_MAPGEN_NUMBER_OF_TOWNS                                      :{BLACK}Várossűrűség:
 STR_MAPGEN_DATE                                                 :{BLACK}Dátum:
 STR_MAPGEN_NUMBER_OF_INDUSTRIES                                 :{BLACK}Gazd. épületek száma:
+STR_MAPGEN_MAX_HEIGHTLEVEL                                      :{BLACK}Maximális megengedett magasság
+STR_MAPGEN_MAX_HEIGHTLEVEL_UP                                   :{BLACK}Maximális magasság emelése eggyel
+STR_MAPGEN_MAX_HEIGHTLEVEL_DOWN                                 :{BLACK}Maximális magasság csökkentése eggyel
 STR_MAPGEN_SNOW_LINE_HEIGHT                                     :{BLACK}Hóhatár:
 STR_MAPGEN_SNOW_LINE_UP                                         :{BLACK}A hóhatár megnövelése eggyel
 STR_MAPGEN_SNOW_LINE_DOWN                                       :{BLACK}A hóhatár csökkentése eggyel
@@ -2689,6 +2859,7 @@
 STR_MAPGEN_HEIGHTMAP_SIZE                                       :{ORANGE}{NUM} x {NUM}
 
 STR_MAPGEN_RANDOM_SEED_OSKTITLE                                 :{BLACK}Irj be egy tetszőleges számot
+STR_MAPGEN_MAX_HEIGHTLEVEL_QUERY_CAPT                           :{WHITE}Maximális magasság megváltoztatása
 STR_MAPGEN_SNOW_LINE_QUERY_CAPT                                 :{WHITE}Hóhatár megváltoztatása
 STR_MAPGEN_START_DATE_QUERY_CAPT                                :{WHITE}Kezdő év megváltoztatása
 
@@ -2886,6 +3057,13 @@
 
 STR_EDIT_SIGN_SIGN_OSKTITLE                                     :{BLACK}Felirat szövegének szerkesztése
 
+# Cargodest UI strings
+STR_VIEW_CARGO_LAST_MONTH_OUT                                   :{BLACK}Az elmúlt hónapban elszállítva:
+STR_VIEW_CARGO_LAST_MONTH_TOWN                                  :{BLACK}{CARGO_SHORT} out of {CARGO_LONG} to {TOWN}
+STR_VIEW_CARGO_LAST_MONTH_INDUSTRY                              :{BLACK}{CARGO_SHORT} out of {CARGO_LONG} to {INDUSTRY}
+STR_VIEW_CARGO_LAST_MONTH_LOCAL                                 :{BLACK}{CARGO_SHORT} out of {CARGO_LONG} településen belül
+STR_VIEW_CARGO_LAST_MONTH_OTHER                                 :{BLACK}{CARGO_SHORT} out of {CARGO_LONG} egyéb állomásokra
+
 # Town directory window
 STR_TOWN_DIRECTORY_CAPTION                                      :{WHITE}Városok
 STR_TOWN_DIRECTORY_NONE                                         :{ORANGE}- Nincs -
@@ -3010,6 +3188,20 @@
 STR_STATION_VIEW_WAITING_CARGO                                  :{WHITE}{CARGO_LONG}
 STR_STATION_VIEW_EN_ROUTE_FROM                                  :{YELLOW}({CARGO_SHORT} ideszállítva {STATION} állomásról)
 
+# YACD
+STR_STATION_VIEW_WAITING_BUTTON                                 :{BLACK}Honnan
+STR_STATION_VIEW_WAITING_TOOLTIP                                :{BLACK}Mutasd, hogy honnan érkeztek ide
+STR_STATION_VIEW_WAITING_TO_BUTTON                              :{BLACK}Úticélok
+STR_STATION_VIEW_WAITING_TO_TOOLTIP                             :{BLACK}Mik a céljai a szállítmányoknak
+STR_STATION_VIEW_WAITING_VIA_BUTTON                             :{BLACK}Köv. állomás
+STR_STATION_VIEW_WAITING_VIA_TOOLTIP                            :{BLACK}Merre mennek innen a szállítmányok
+STR_STATION_VIEW_WAITING_TRANSFER_BUTTON                        :{BLACK}Köv. átszállás
+STR_STATION_VIEW_WAITING_TRANSFER_TOOLTIP                       :{BLACK}A szállítmányok következő transzfer állomásai
+STR_STATION_VIEW_WAITING_VIA                                    :{YELLOW}{CARGO_SHORT} {STATION} irányába indul
+STR_STATION_VIEW_WAITING_TRANSFER                               :{YELLOW}{CARGO_SHORT} átszáll {STATION} állomáson
+STR_STATION_VIEW_WAITING_TO                                     :{YELLOW}{CARGO_SHORT} várakozik {STRING} fele
+
+
 STR_STATION_VIEW_ACCEPTS_BUTTON                                 :{BLACK}Elfogadás
 STR_STATION_VIEW_ACCEPTS_TOOLTIP                                :{BLACK}Az elfogadott áruk listájának mutatása
 STR_STATION_VIEW_ACCEPTS_CARGO                                  :{BLACK}Elfogad:{WHITE}{CARGO_LIST}
@@ -3022,6 +3214,72 @@
 STR_STATION_VIEW_CARGO_RATINGS_TITLE                            :{BLACK}A szállítás helyi megítélése:
 STR_STATION_VIEW_CARGO_RATING                                   :{WHITE}{STRING}: {YELLOW}{STRING} ({COMMA}%)
 
+STR_STATION_VIEW_DEPARTURES_BUTTON                              :{BLACK}Menetrend
+STR_STATION_VIEW_DEPARTURES_TOOLTIP                             :{BLACK}Mutasd az állomás menetrendjét
+
+# Departures window
+STR_DEPARTURES_CAPTION                                          :{WHITE}{STATION} Aktuális menetrend
+STR_DEPARTURES_CAPTION_WAYPOINT                                 :{WHITE}{WAYPOINT} Aktuális menetrend
+STR_DEPARTURES_DEPARTURES                                       :{BLACK}{TINY_FONT}Ind
+STR_DEPARTURES_ARRIVALS                                         :{BLACK}{TINY_FONT}Érk
+STR_DEPARTURES_VIA_BUTTON                                       :{BLACK}{TINY_FONT}Áth
+STR_DEPARTURES_DEPARTURES_TOOLTIP                               :{BLACK}Mutasd az indulási időpontokat
+STR_DEPARTURES_ARRIVALS_TOOLTIP                                 :{BLACK}Mutasd az érkezési időpontokat
+STR_DEPARTURES_VIA_TOOLTIP                                      :{BLACK}Mutasd a keresztülhaladó forgalmat
+STR_DEPARTURES_EMPTY                                            :{ORANGE}Ez az állomás még nincs benne egy jármű menetrendjében sem.
+STR_DEPARTURES_NONE_SELECTED                                    :{ORANGE}Nincs megjeleníthető menetrend
+
+############ possible statuses start
+STR_DEPARTURES_ON_TIME                                          :{GREEN}Időben
+STR_DEPARTURES_ARRIVED                                          :{GREEN}Várakozik
+STR_DEPARTURES_DELAYED                                          :{RED}Késik
+STR_DEPARTURES_EXPECTED                                         :{YELLOW}Várható {DATE_WALLCLOCK_TINY}
+STR_DEPARTURES_CANCELLED                                        :{RED}Törölve
+
+############ config settings
+STR_CONFIG_SETTING_DEPARTUREBOARDS                              :{ORANGE}Menetrendek
+STR_CONFIG_MAX_DEPARTURES                                       :Maximum {STRING} indulási időpontot megjelenítése
+STR_CONFIG_MAX_DEPARTURES_HELPTEXT                              :Mennyyi indulási időpontot mutasson előre az állomásokon
+STR_CONFIG_MAX_DEPARTURE_TIME                                   :Maximum {STRING} napra előre legyen menetrend
+STR_CONFIG_MAX_DEPARTURE_TIME_HELPTEXT                          :Mennyi napra előre számolja ki a menetrendet (vagy percben)
+STR_CONFIG_DEPARTURE_CALC_FREQUENCY                             :Menetrend számítása {STRING} tick-enként
+STR_CONFIG_DEPARTURE_CALC_FREQUENCY_HELPTEXT                    :Milyen gyakran frissítse a menetrendet tick-ben megadva
+STR_CONFIG_DEPARTURE_VEHICLE_NAME                               :Jármű nevének mutatása: {STRING}
+STR_CONFIG_DEPARTURE_VEHICLE_NAME_HELPTEXT                      :Mutassa a jármű nevét a menetrendben
+STR_CONFIG_DEPARTURE_GROUP_NAME                                 :Jármű csoportjának mutatása: {STRING}
+STR_CONFIG_DEPARTURE_GROUP_NAME_HELPTEXT                        :Mutassa a jármű csoportját is, amihez tartozik
+STR_CONFIG_DEPARTURE_COMPANY_NAME                               :Vállalat nevének mutatása: {STRING}
+STR_CONFIG_DEPARTURE_COMPANY_NAME_HELPTEXT                      :Mutassa a vállalat nevét a menetrendekben
+STR_CONFIG_DEPARTURE_VEHICLE_TYPE                               :Jármű típusának megjelenítése: {STRING}
+STR_CONFIG_DEPARTURE_VEHICLE_TYPE_HELPTEXT                      :Mutassa a jármű típusának ikonját a menetrendben
+STR_CONFIG_DEPARTURE_VEHICLE_COLOR                              :A jármű típusát ezüst színnel mutassa: {STRING}
+STR_CONFIG_DEPARTURE_VEHICLE_COLOR_HELPTEXT                     :A járműtípusát ezüst színnel mutassa
+STR_CONFIG_DEPARTURE_LARGER_FONT                                :Nagyobb betűk az érintett állomásoknak: {STRING}
+STR_CONFIG_DEPARTURE_LARGER_FONT_HELPTEXT                       :Nagyobb betűkkel írja az érintett állomásokat is
+STR_CONFIG_DEPARTURE_DESTINATION_TYPE                           :Repülőtereket és kikötők ikonnal: {STRING}
+STR_CONFIG_DEPARTURE_DESTINATION_TYPE_HELPTEXT                  :A repülőtereket és kikötőket jelölje külön ikonnal
+STR_CONFIG_DEPARTURE_SHOW_BOTH                                  :Indulás és érkezés ugyanabban a sorban: {STRING}
+STR_CONFIG_DEPARTURE_SHOW_BOTH_HELPTEXT                         :Mind az indulási- és az érkezési időpontot 1 sorban mutassa
+STR_CONFIG_DEPARTURE_ONLY_PASSENGERS                            :Kizárólag az utasszállító járművek megjelenítése: {STRING}
+STR_CONFIG_DEPARTURE_ONLY_PASSENGERS_HELPTEXT                   :Csak az utasokat szállító járművek szerepeljenek a menetrendben.
+STR_CONFIG_DEPARTURE_SMART_TERMINUS                             :Ne mutasd a végállomást, ha egy késésben levő jármű hamarabb ér oda: {STRING}
+STR_CONFIG_DEPARTURE_SMART_TERMINUS_HELPTEXT                    :Mutassa-e a végállomást a menetrendben, ha egy késésben levő jármű hamarabb érne oda
+STR_CONFIG_DEPARTURE_CONDITIONALS                               :Feltételes utasítások kezelése: {STRING}
+STR_CONFIG_DEPARTURE_CONDITIONALS_HELPTEXT                      :Hogyan számolja a menetrendet a feltételes utasítással rendelkező járműveknél
+STR_CONFIG_DEPARTURE_CONDITIONALS_1                             :figyelmen kívül hagy
+STR_CONFIG_DEPARTURE_CONDITIONALS_2                             :beérkezőnek számítsa
+STR_CONFIG_DEPARTURE_CONDITIONALS_3                             :ne számítsa beérkezőnek
+STR_CONFIG_DEPARTURE_SHOW_ALL_STOPS                             :Minden állomás mutatása rakodástól függetlenül: {STRING}
+STR_CONFIG_DEPARTURE_SHOW_ALL_STOPS_HELPTEXT                    :Csak azokat az állomásokat mutatja egy járműnél, ahol történik ki- és berakodás
+STR_CONFIG_DEPARTURE_MERGE_IDENTICAL                            :Azonos járművek egyesítése: {STRING}
+STR_CONFIG_DEPARTURE_MERGE_IDENTICAL_HELPTEXT                   :Azonos menetrendű járműveket csak egy sorban jeleníti meg
+
+
+STR_TIMETABLE_MINUTES                                           :{COMMA} perc
+STR_DATE_MINUTES_DAY_TOOLTIP                                    :{BLACK}Válassz percet
+STR_DATE_MINUTES_MONTH_TOOLTIP                                  :{BLACK}Válassz órát
+
+
 ############ range for rating starts
 STR_CARGO_RATING_APPALLING                                      :szörnyű
 STR_CARGO_RATING_VERY_POOR                                      :nagyon rossz
@@ -3036,6 +3294,8 @@
 STR_STATION_VIEW_CENTER_TOOLTIP                                 :{BLACK}A fő nézetet az állomásra állítja. Ctrl+kattintás esetén új látképet nyit az állomás pozíciójára
 STR_STATION_VIEW_RENAME_TOOLTIP                                 :{BLACK}Az állomás nevének megváltoztatása
 
+STR_STATION_VIEW_COVERAGE                                       :{BLACK}Lefedettség
+STR_STATION_VIEW_COVERAGE_TIP                                   :{BLACK}Melyik területeket fedi le az állomás
 STR_STATION_VIEW_SCHEDULED_TRAINS_TOOLTIP                       :{BLACK}Kilistázza az összes vonatot, aminek a menetrendjében szerepel ez az állomás
 STR_STATION_VIEW_SCHEDULED_ROAD_VEHICLES_TOOLTIP                :{BLACK}Kilistázza az összes közúti járművet, aminek a menetrendjében szerepel ez az állomás
 STR_STATION_VIEW_SCHEDULED_AIRCRAFT_TOOLTIP                     :{BLACK}Kilistázza az összes repülőt, aminek a menetrendjében szerepel ez az állomás
@@ -3065,6 +3325,7 @@
 STR_FINANCES_SECTION_ROAD_VEHICLE_RUNNING_COSTS                 :{GOLD}Közúti jármű műk. költség
 STR_FINANCES_SECTION_AIRCRAFT_RUNNING_COSTS                     :{GOLD}Repülőgép műk. költség
 STR_FINANCES_SECTION_SHIP_RUNNING_COSTS                         :{GOLD}Hajó működtetési költség
+STR_FINANCES_SECTION_LOST_RUNNING_COSTS                         :{GOLD}Elveszett rakomány
 STR_FINANCES_SECTION_PROPERTY_MAINTENANCE                       :{GOLD}Ingatlanok karbantartása
 STR_FINANCES_SECTION_TRAIN_INCOME                               :{GOLD}Vonatok bevétele
 STR_FINANCES_SECTION_ROAD_VEHICLE_INCOME                        :{GOLD}Közúti járművek bevétele
@@ -3072,6 +3333,8 @@
 STR_FINANCES_SECTION_SHIP_INCOME                                :{GOLD}Hajók bevétele
 STR_FINANCES_SECTION_LOAN_INTEREST                              :{GOLD}Kölcsön kamata
 STR_FINANCES_SECTION_OTHER                                      :{GOLD}Egyéb
+STR_FINANCES_SECTION_INFRASTRUCTURE_COSTS                       :{GOLD}Infrastruktúra használat kiadás
+STR_FINANCES_SECTION_INFRASTRUCTURE_INCOME                      :{GOLD}Infrastruktúra használat bevétel
 STR_FINANCES_NEGATIVE_INCOME                                    :{BLACK}-{CURRENCY_LONG}
 STR_FINANCES_POSITIVE_INCOME                                    :{BLACK}+{CURRENCY_LONG}
 STR_FINANCES_TOTAL_CAPTION                                      :{WHITE}Összesen:
@@ -3115,6 +3378,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}A vállalat székházának újraépítése máshol a vállalat értékének 1%-áért. Shift+kattintással megmutatja a becsült költséget a székhely áthelyezése nélkül
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Részletek
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}Részletes információk megtekintése az infrastruktúráról
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Pénz adományozása
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}Új arc
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Új arc választása az elnöknek
@@ -3132,6 +3396,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :A vállalat neve
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Elnök neve
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Add meg a küldeni kívánt pénz mennyiségét
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Vállalatunk vagyontárgyait eladásra kínáljuk: járművek, terület és hálózat tulajdonok, bankszámla{}{}Megveszed {COMPANY} vállalatot {CURRENCY_LONG}-ért?
 
@@ -3157,6 +3422,8 @@
 STR_INDUSTRY_DIRECTORY_ITEM_TWO                                 :{ORANGE}{INDUSTRY}{BLACK} ({CARGO_LONG}{STRING}/{CARGO_LONG}{STRING}){YELLOW} ({COMMA}%/{COMMA}% elszállítva)
 STR_INDUSTRY_DIRECTORY_ITEM_NOPROD                              :{ORANGE}{INDUSTRY}
 STR_INDUSTRY_DIRECTORY_LIST_CAPTION                             :{BLACK}Gazdasági épületek neve - a névre kattintva a fő nézetet a választott objektumra irányíthatod. Ctrl+kattintással új látképet nyit a gazdasági épület pozíciójára
+STR_INDUSTRY_DIRECTORY_SELECT_ALL_TYPES                         :{BLACK}Az összes típus kiválasztása
+STR_INDUSTRY_DIRECTORY_USE_CTRL_TO_SELECT_MORE                  :{BLACK}Több elem kiválasztásához tartsd lenyomva a Ctrl gombot
 
 # Industry view
 STR_INDUSTRY_VIEW_CAPTION                                       :{WHITE}{INDUSTRY}
@@ -3192,6 +3459,16 @@
 STR_VEHICLE_LIST_SHIP_TOOLTIP                                   :{BLACK}Hajók - kattints egy hajóra az adataihoz
 STR_VEHICLE_LIST_AIRCRAFT_TOOLTIP                               :{BLACK}Repülőgépek - kattints egy repülőgépre az adataihoz
 
+STR_BUY_REFIT_VEHICLE_TRAIN_BUY_VEHICLE_BUTTON                  :{BLACK}Megvesz és átalakít
+STR_BUY_REFIT_VEHICLE_ROAD_VEHICLE_BUY_VEHICLE_BUTTON           :{BLACK}Megvesz és átalakít
+STR_BUY_REFIT_VEHICLE_SHIP_BUY_VEHICLE_BUTTON                   :{BLACK}Megvesz és átalakít
+STR_BUY_REFIT_VEHICLE_AIRCRAFT_BUY_VEHICLE_BUTTON               :{BLACK}Megvesz és átalakít
+
+STR_BUY_REFIT_VEHICLE_TRAIN_BUY_VEHICLE_TOOLTIP                 :{BLACK}A kijelölt vasúti jármű megvétele és automatikus átalakítása a kiválasztott rakomány szállítására
+STR_BUY_REFIT_VEHICLE_ROAD_VEHICLE_BUY_VEHICLE_TOOLTIP          :{BLACK}A kijelölt közúti jármű megvétele és automatikus átalakítása a kiválasztott rakomány szállítására
+STR_BUY_REFIT_VEHICLE_SHIP_BUY_VEHICLE_TOOLTIP                  :{BLACK}A kijelölt hajó megvétele és automatikus átalakítása a kiválasztott rakomány szállítására
+STR_BUY_REFIT_VEHICLE_AIRCRAFT_BUY_VEHICLE_TOOLTIP              :{BLACK}A kijelölt repülőgép megvétele és automatikus átalakítása a kiválasztott rakomány szállítására
+
 STR_VEHICLE_LIST_PROFIT_THIS_YEAR_LAST_YEAR                     :{TINY_FONT}{BLACK}Idei nyereség: {CURRENCY_LONG} (Tavalyi: {CURRENCY_LONG})
 
 STR_VEHICLE_LIST_AVAILABLE_TRAINS                               :Elérhető vonatok
@@ -3236,6 +3513,12 @@
 STR_GROUP_REMOVE_ALL_VEHICLES                                   :Összes jármű eltávolítása
 
 STR_GROUP_RENAME_CAPTION                                        :{BLACK}Csoport átnevezése
+STR_GROUP_SPECIFIC_NAME_STATION                                 :{STATION} - {STATION}
+STR_GROUP_SPECIFIC_NAME_TOWN                                    :{TOWN} - {TOWN}
+STR_GROUP_SPECIFIC_NAME_TOWN_LOCAL                              :{TOWN} helyi járat
+
+STR_GROUP_PROFIT_THIS_YEAR                                      :{BLACK}Nyereség idén: {CURRENCY_LONG}
+STR_GROUP_PROFIT_LAST_YEAR                                      :{BLACK}Nyereség tavaly: {CURRENCY_LONG}
 
 # Build vehicle window
 STR_BUY_VEHICLE_TRAIN_RAIL_CAPTION                              :Új vasúti járművek
@@ -3548,6 +3831,7 @@
 STR_VEHICLE_DETAILS_CARGO_EMPTY                                 :{LTBLUE}Üres
 STR_VEHICLE_DETAILS_CARGO_FROM                                  :{LTBLUE}{CARGO_LONG} {STATION} állomásról
 STR_VEHICLE_DETAILS_CARGO_FROM_MULT                             :{LTBLUE}{CARGO_LONG} {STATION} állomásról (x{NUM})
+STR_VEHICLE_DETAILS_CARGO_TO                                    :{LTBLUE}{CARGO_SHORT} to {STRING}
 
 STR_VEHICLE_DETAIL_TAB_CARGO                                    :{BLACK}Rakomány
 STR_VEHICLE_DETAILS_TRAIN_CARGO_TOOLTIP                         :{BLACK}A szállított rakomány részletei
@@ -3641,6 +3925,17 @@
 STR_ORDER_CONDITIONAL_REQUIRES_SERVICE                          :Javításra szorul
 STR_ORDER_CONDITIONAL_UNCONDITIONALLY                           :Mindig
 STR_ORDER_CONDITIONAL_REMAINING_LIFETIME                        :Hátralévő élettartam (év)
+STR_ORDER_CONDITIONAL_CARGO_WAITING                             :Várakozó szállítmány
+STR_ORDER_CONDITIONAL_ACCEPTANCE_DROPDOWN                       :Elfogadott szállítmány
+STR_ORDER_CONDITIONAL_FREE_PLATFORMS                            :Szabad helyek
+STR_ORDER_CONDITIONAL_PERCENT                                   :Az idő százaléka
+STR_ORDER_CONDITIONAL_REQUIRES_SERVICE_ORDER                    :Ha javításra szorul {STRING}
+STR_ORDER_CONDITIONAL_CARGO_WAITING_ORDER                       :Következő állomásra {STRING} {STRING} várakozik
+STR_ORDER_CONDITIONAL_ACCEPTANCE                                :Következő állomásra {STRING} {STRING}{P "" s}
+STR_CONDITIONAL_FREE_PLATFORMS                                  :Ugorj a(z) {COMMA} utasításra, ha a következő állomáson {STRING} {COMMA} szabad hely
+STR_CONDITIONAL_PERCENT                                         :Ugorj a(z) {COMMA} utasításra az idő {COMMA} százalékában
+
+STR_ORDER_CONDITIONAL_NEXT_STATION                              :következő állomáson
 
 STR_ORDER_CONDITIONAL_COMPARATOR_TOOLTIP                        :{BLACK}Hogyan viszonyul a jármű kiválasztott adata a megadott értékhez
 STR_ORDER_CONDITIONAL_COMPARATOR_EQUALS                         :egyenlő
@@ -3653,8 +3948,17 @@
 STR_ORDER_CONDITIONAL_COMPARATOR_IS_FALSE                       :hamis
 
 STR_ORDER_CONDITIONAL_VALUE_TOOLTIP                             :{BLACK}Az érték amihez a jármű egy adatát viszonyítjuk
+STR_ORDER_CONDITIONAL_CARGO_TOOLTIP                             :{BLACK}A szállítmány, amihez egy állomás adatát viszonyítjuk
 STR_ORDER_CONDITIONAL_VALUE_CAPT                                :{WHITE}Írd be az értéket amihez viszonyítani szeretnél
 
+STR_ORDER_CONDITIONAL_COMPARATOR_ACCEPTS                        :elfogad
+STR_ORDER_CONDITIONAL_COMPARATOR_DOES_NOT_ACCEPT                :nem fogad el
+STR_ORDER_CONDITIONAL_COMPARATOR_HAS                            :van
+STR_ORDER_CONDITIONAL_COMPARATOR_HAS_NO                         :nincs
+STR_ORDER_CONDITIONAL_COMPARATOR_HAS_LESS_THAN                  :kevesebb, mint
+STR_ORDER_CONDITIONAL_COMPARATOR_HAS_LESS_EQUALS                :nem több, mint
+STR_ORDER_CONDITIONAL_COMPARATOR_HAS_MORE_THAN                  :több, mint
+STR_ORDER_CONDITIONAL_COMPARATOR_HAS_MORE_EQUALS                :nem kevesebb, mint
 STR_ORDERS_SKIP_BUTTON                                          :{BLACK}Kihagy
 STR_ORDERS_SKIP_TOOLTIP                                         :{BLACK}Jelenlegi utasítás átugrása, és a következő aktiválása. Ctrl+kattintásra a kiválasztott utasításra ugrik
 
@@ -3735,6 +4039,7 @@
 
 STR_ORDER_CONDITIONAL_UNCONDITIONAL                             :Ugorj a(z) {COMMA}. utasításra
 STR_ORDER_CONDITIONAL_NUM                                       :Ugorj a(z) {COMMA}. utasításra, ha {STRING} {STRING} {COMMA}
+STR_ORDER_CONDITIONAL_CARGO                                     :Ugorj a(z) {COMMA}. utasításra, ha {STRING} {STRING} {STRING}
 STR_ORDER_CONDITIONAL_TRUE_FALSE                                :Ugorj a(z) {COMMA}. utasításra, ha a '{STRING}' feltétel {STRING}
 
 STR_INVALID_ORDER                                               :{RED} (Hibás utasítás)
@@ -3862,6 +4167,33 @@
 STR_AI_LIST_VERSION                                             :{LTBLUE}Verzió: {ORANGE}{NUM}
 STR_AI_LIST_URL                                                 :{LTBLUE}URL: {ORANGE}{STRING}
 
+######## Trip History
+STR_TRIP_HISTORY                                                :{BLACK}Útinapló
+STR_TRIP_HISTORY_TOOLTIP                                        :{BLACK}Mutasd a legutóbbi 10 utat
+STR_TRIP_HISTORY_RECEIVED_LABEL                                 :{BLACK}Beérkezett
+STR_TRIP_HISTORY_RECEIVED_LABEL_TIP                             :{BLACK}A szállítmány beérkezésének dátuma
+STR_TRIP_HISTORY_PROFIT_LABEL                                   :{BLACK}Bevétel
+STR_TRIP_HISTORY_PROFIT_LABEL_TIP                               :{BLACK}A bevétel utanként
+STR_TRIP_HISTORY_PERCHANGE_LABEL                                :{BLACK}% Változás
+STR_TRIP_HISTORY_PERCHANGE_LABEL_TIP                            :{BLACK}A bevétel változása százalékban a legutóbbi út óta
+STR_TRIP_HISTORY_TBT_LABEL                                      :{BLACK}Útidő
+STR_TRIP_HISTORY_TBT_LABEL_TIP                                  :{BLACK}Az előző és a mostani út között eltelt idő
+STR_TRIP_HISTORY_DAYCHANGE_LABEL                                :{BLACK}Változás
+STR_TRIP_HISTORY_DAYCHANGE_LABEL_TIP                            :{BLACK}A legutóbbi és a mostani út közötti időváltozás
+STR_TRIP_HISTORY_TOTALINCOME                                    :{BLACK}Az összes bevétel az elmúlt {NUM} útból:{LTBLUE} {CURRENCY_SHORT} {BLACK}({LTBLUE}{CURRENCY_SHORT} {BLACK} naponta)
+STR_TRIP_HISTORY_DAYAVERAGE                                     :{BLACK}Átlagos utazási idő:{LTBLUE} {NUM} nap
+STR_TRIP_HISTORY_DAYAVERAGE_IMPROVEMENT                         :{BLACK}Javulás az elmúlt {NUM} út alatt:{LTBLUE} {NUM}%
+STR_TRIP_HISTORY_CAPTION                                        :{WHITE}{VEHICLE} Útinapló
+STR_TRIP_HISTORY_DATE                                           :{BLACK}{DATE_LONG}
+STR_TRIP_HISTORY_PROFIT                                         :{BLACK}{CURRENCY_SHORT}
+STR_TRIP_HISTORY_VIRTUAL_PROFIT                                 :{YELLOW}{CURRENCY_SHORT}
+STR_TRIP_HISTORY_PROFITCHANGEPOS                                :{GREEN}+{NUM}%
+STR_TRIP_HISTORY_PROFITCHANGENEG                                :{RED}{NUM}%
+STR_TRIP_HISTORY_TBT                                            :{BLACK}{NUM} day{P "" s}
+STR_TRIP_HISTORY_TBTCHANGEPOS                                   :{RED}+{NUM}
+STR_TRIP_HISTORY_TBTCHANGENEG                                   :{GREEN}{NUM}
+
+
 STR_AI_LIST_ACCEPT                                              :{BLACK}Elfogad
 STR_AI_LIST_ACCEPT_TOOLTIP                                      :{BLACK}A kijelölt szkript kiválasztása
 STR_AI_LIST_CANCEL                                              :{BLACK}Mégsem
@@ -3906,6 +4238,30 @@
 STR_MESSAGE_ESTIMATED_COST                                      :{WHITE}Becsült ár: {CURRENCY_LONG}
 STR_MESSAGE_ESTIMATED_INCOME                                    :{WHITE}Becsült bevétel: {CURRENCY_LONG}
 
+# Timetable separation UI strings
+STR_TTSEPARATION_AUTO                                           :Automatikus
+STR_TTSEPARATION_MAN_NUM                                        :Követési idő
+STR_TTSEPARATION_MAN_TIME                                       :Járművek
+STR_TTSEPARATION_BUFFERED_AUTO                                  :Bevárós
+STR_TTSEPARATION_OFF                                            :Kikapcsolva
+STR_TTSEPARATION_APPLY                                          :{BLACK}Alkalmaz
+STR_TTSEPARATION_RESET                                          :{BLACK}Visszaállítás
+STR_TTSEPARATION_MODE_DESC                                      :{BLACK}Separation mode
+STR_TTSEPARATION_SETTINGS_DESC                                  :{BLACK}Követési távolság
+STR_TTSEPARATION_SET_XX                                         :{BLACK}Beállítás{STRING}
+STR_TTSEPARATION_SET_NUM                                        :szám
+STR_TTSEPARATION_SET_TIME                                       :idő
+STR_TTSEPARATION_STATUS_DESC                                    :{BLACK}Állapot:{}{STRING}
+STR_TTSEPARATION_STATUS_INCOMPLETE                              :{SILVER}Hiányos{}menetrend
+STR_TTSEPARATION_STATUS_INIT                                    :{YELLOW}Felkészülés
+STR_TTSEPARATION_STATUS_RUNNING                                 :{GREEN}Működik
+STR_TTSEPARATION_STATUS_OFF                                     :{BLACK}Kikapcsolva
+STR_TTSEPARATION_REQ_TIME_DESC_TICKS                            :{NUM} tickenként
+STR_TTSEPARATION_REQ_TIME_DESC_DAYS                             :{NUM} naponta
+STR_TTSEPARATION_REQ_TIME_DESC_MINUTES                          :{NUM} percenként
+STR_TTSEPARATION_REQ_NUM_DESC                                   :{NUM} jármű
+
+
 # Saveload messages
 STR_ERROR_SAVE_STILL_IN_PROGRESS                                :{WHITE}A mentés még tart,{}kérlek várd meg a végét!
 STR_ERROR_AUTOSAVE_FAILED                                       :{WHITE}Automatikus mentés sikertelen
@@ -3972,6 +4328,9 @@
 STR_ERROR_NAME_MUST_BE_UNIQUE                                   :{WHITE}A névnek egyedinek kell lennie
 STR_ERROR_GENERIC_OBJECT_IN_THE_WAY                             :{WHITE}...{1:STRING} van az útban
 STR_ERROR_NOT_ALLOWED_WHILE_PAUSED                              :{WHITE}Szünet közben nem megengedett
+STR_ERROR_NOTHING_TO_DO                                         :{WHITE}... nincs semmi tennivaló
+STR_ERROR_INAPPLICABLE_TRANSFORMATION                           :{WHITE}... teljesíthetetlen átalakítás
+
 
 # Local authority errors
 STR_ERROR_LOCAL_AUTHORITY_REFUSES_TO_ALLOW_THIS                 :{WHITE}{TOWN} önkormányzata nem engedélyezi
@@ -3987,6 +4346,7 @@
 STR_ERROR_ALREADY_AT_SEA_LEVEL                                  :{WHITE}Már tengerszinten van
 STR_ERROR_TOO_HIGH                                              :{WHITE}Túl magas
 STR_ERROR_ALREADY_LEVELLED                                      :{WHITE}... már sík
+STR_ERROR_BRIDGE_TOO_HIGH_AFTER_LOWER_LAND                      :{WHITE}A híd túl magasan lenne
 
 # Company related errors
 STR_ERROR_CAN_T_CHANGE_COMPANY_NAME                             :{WHITE}Nem változtathatod meg a vállalat nevét...
@@ -4046,7 +4406,9 @@
 STR_ERROR_CAN_T_BUILD_DOCK_HERE                                 :{WHITE}Nem építhetsz ide kikötőt...
 STR_ERROR_CAN_T_BUILD_AIRPORT_HERE                              :{WHITE}Nem építhetsz ide repülőteret...
 
+STR_ERROR_ADJOINS_EXISTING                                      :{WHITE}Hozzáadás a jelenlegi állomás területéhez
 STR_ERROR_ADJOINS_MORE_THAN_ONE_EXISTING                        :{WHITE}Több állomással/rakodóhellyel érintkezik
+STR_ERROR_CAN_T_DISTANT_JOIN                                    :{WHITE}Állomás hozzáadása sikertelen
 STR_ERROR_STATION_TOO_SPREAD_OUT                                :{WHITE}... az állomás túl kiterjedt
 STR_ERROR_TOO_MANY_STATIONS_LOADING                             :{WHITE}Túl sok az állomás/rakodóhely
 STR_ERROR_TOO_MANY_STATION_SPECS                                :{WHITE}Túl sok vasútállomás-rész
@@ -4173,6 +4535,7 @@
 STR_ERROR_CAN_T_START_AND_END_ON                                :{WHITE}Nem kezdődhet és végződhet ugyanott
 STR_ERROR_BRIDGEHEADS_NOT_SAME_HEIGHT                           :{WHITE}Hídfők nem egy szinten vannak
 STR_ERROR_BRIDGE_TOO_LOW_FOR_TERRAIN                            :{WHITE}A híd túl alacsony a terepre
+STR_ERROR_BRIDGE_TOO_HIGH_FOR_TERRAIN                           :{WHITE}A híd túl magas a terepre
 STR_ERROR_START_AND_END_MUST_BE_IN                              :{WHITE}A kezdetének és a végének egy vonalban kell lennie
 STR_ERROR_ENDS_OF_BRIDGE_MUST_BOTH                              :{WHITE}... a híd mindkét végének szárazföldön kell lennie
 STR_ERROR_BRIDGE_TOO_LONG                                       :{WHITE}... a híd túl hosszú
@@ -4195,6 +4558,9 @@
 STR_ERROR_CAN_T_PURCHASE_THIS_LAND                              :{WHITE}Nem veheted meg ezt a földterületet...
 STR_ERROR_YOU_ALREADY_OWN_IT                                    :{WHITE}... már a tiéd!
 
+# Clipboard related errors
+STR_ERROR_CAN_T_PASTE_HERE                                      :{WHITE}Nem lehet beilleszteni ide...
+
 # Group related errors
 STR_ERROR_GROUP_CAN_T_CREATE                                    :{WHITE}Csoport létrehozás sikertelen...
 STR_ERROR_GROUP_CAN_T_DELETE                                    :{WHITE}Csoport törlése sikertelen...
@@ -4202,6 +4568,8 @@
 STR_ERROR_GROUP_CAN_T_REMOVE_ALL_VEHICLES                       :{WHITE}Csoport járműveinek törlése sikertelen...
 STR_ERROR_GROUP_CAN_T_ADD_VEHICLE                               :{WHITE}Jármű hozzáadása a csoporthoz sikertelen...
 STR_ERROR_GROUP_CAN_T_ADD_SHARED_VEHICLE                        :{WHITE}Megosztott jármű csoporthoz való hozzáadása sikertelen...
+STR_ERROR_GROUP_CAN_T_CREATE_SPECIFIC_NAME                      :{WHITE}Csoport elnevezése az adott néven sikertelen
+STR_ERROR_GROUP_CAN_T_CREATE_NAME                               :{WHITE}Csoport elnevezése sikertelen
 
 # Generic vehicle errors
 STR_ERROR_TRAIN_IN_THE_WAY                                      :{WHITE}Vonat van az útban
@@ -4422,6 +4790,45 @@
 STR_INDUSTRY_NAME_SUGAR_MINE                                    :Cukorbánya
 STR_INDUSTRY_NAME_SUGAR_MINE.t                                  :cukorbányát
 
+# two/three letter industry name abbreviations
+STR_ABBREV_COAL_MINE                                            :{TINY_FONT}SZÉ
+STR_ABBREV_POWER_STATION                                        :{TINY_FONT}ERŐ
+STR_ABBREV_SAWMILL                                              :{TINY_FONT}FŰR
+STR_ABBREV_FOREST                                               :{TINY_FONT}ERD
+STR_ABBREV_OIL_REFINERY                                         :{TINY_FONT}OLF
+STR_ABBREV_OIL_RIG                                              :{TINY_FONT}OLT
+STR_ABBREV_FACTORY                                              :{TINY_FONT}GYÁ
+STR_ABBREV_PRINTING_WORKS                                       :{TINY_FONT}NYO
+STR_ABBREV_STEEL_MILL                                           :{TINY_FONT}ACÉ
+STR_ABBREV_FARM                                                 :{TINY_FONT}FAR
+STR_ABBREV_COPPER_ORE_MINE                                      :{TINY_FONT}RÉZ
+STR_ABBREV_OIL_WELLS                                            :{TINY_FONT}OLK
+STR_ABBREV_BANK                                                 :{TINY_FONT}BNK
+STR_ABBREV_FOOD_PROCESSING_PLANT                                :{TINY_FONT}KNZ
+STR_ABBREV_PAPER_MILL                                           :{TINY_FONT}PAP
+STR_ABBREV_GOLD_MINE                                            :{TINY_FONT}ARA
+STR_ABBREV_BANK_TROPIC_ARCTIC                                   :{TINY_FONT}BNK
+STR_ABBREV_DIAMOND_MINE                                         :{TINY_FONT}GYÉ
+STR_ABBREV_IRON_ORE_MINE                                        :{TINY_FONT}VAS
+STR_ABBREV_FRUIT_PLANTATION                                     :{TINY_FONT}GYÜ
+STR_ABBREV_RUBBER_PLANTATION                                    :{TINY_FONT}GUM
+STR_ABBREV_WATER_SUPPLY                                         :{TINY_FONT}VÍZ
+STR_ABBREV_WATER_TOWER                                          :{TINY_FONT}VÍT
+STR_ABBREV_FACTORY_2                                            :{TINY_FONT}GYÁ
+STR_ABBREV_FARM_2                                               :{TINY_FONT}FAR
+STR_ABBREV_LUMBER_MILL                                          :{TINY_FONT}FA
+STR_ABBREV_COTTON_CANDY_FOREST                                  :{TINY_FONT}VAT
+STR_ABBREV_CANDY_FACTORY                                        :{TINY_FONT}CKR
+STR_ABBREV_BATTERY_FARM                                         :{TINY_FONT}ELM
+STR_ABBREV_COLA_WELLS                                           :{TINY_FONT}KÓL
+STR_ABBREV_TOY_SHOP                                             :{TINY_FONT}JÁB
+STR_ABBREV_TOY_FACTORY                                          :{TINY_FONT}JGY
+STR_ABBREV_PLASTIC_FOUNTAINS                                    :{TINY_FONT}MŰA
+STR_ABBREV_FIZZY_DRINK_FACTORY                                  :{TINY_FONT}ÜDÍ
+STR_ABBREV_BUBBLE_GENERATOR                                     :{TINY_FONT}BUB
+STR_ABBREV_TOFFEE_QUARRY                                        :{TINY_FONT}TEJ
+STR_ABBREV_SUGAR_MINE                                           :{TINY_FONT}CKR
+
 ############ WARNING, using range 0x6000 for strings that are stored in the savegame
 ############ These strings may never get a new id, or savegames will break!
 ##id 0x6000
@@ -4846,5 +5253,68 @@
 STR_LORRY                                                       :{BLACK}{LORRY}
 STR_PLANE                                                       :{BLACK}{PLANE}
 STR_SHIP                                                        :{BLACK}{SHIP}
+STR_WATCH_WINDOW_TITLE                                          :{WHITE}{STRING} követése.
+STR_WATCH_CLICK_TO_WATCH_COMPANY                                :{BLACK}A vállalat építkezésének követése
+STR_WATCH_CLICK_NEW_WINDOW                                      :{BLACK}Követés új ablakban
+
 
 STR_TOOLBAR_RAILTYPE_VELOCITY                                   :{STRING} ({VELOCITY})
+
+STR_TMPL_RPL_TITLE                                              :{WHITE}Sablon alapú járműcsere
+STR_TMPL_TEMPLATE_REPLACEMENT                                   :Sablon alapú csere
+STR_TMPL_TRAINS_IN_GROUP                                        :{BLACK}Vonatok csoportban
+STR_TMPL_AVAILABLE_TEMPLATES                                    :{BLACK}Elérhető sablonok
+STR_TMPL_DEFINE_TEMPLATE                                        :{BLACK}Létrehozás
+STR_TMPL_EDIT_TEMPLATE                                          :{BLACK}Szerkeszt
+STR_TMPL_CREATE_CLONE_VEH                                       :{BLACK}Másol
+STR_TMPL_DELETE_TEMPLATE                                        :{BLACK}Töröl
+STR_TMPL_RPL_ALL_TMPL                                           :{BLACK}Összes sablon cseréje
+STR_TMPL_NEW_VEHICLE                                            :{BLACK}Új jármű
+STR_TMPL_CONFIRM                                                :{BLACK}Ok
+STR_TMPL_CANCEL                                                 :{BLACK}Mégsem
+STR_TMPL_NEW                                                    :{BLACK}Új járműsablon
+STR_TMPL_REFIT                                                  :{BLACK}Átalakítás
+STR_TMPL_GROUP_INFO                                             :{BLACK}Csoport info: {ORANGE}
+STR_TMPL_TEMPLATE_INFO                                          :{BLACK}Sablon info: {ORANGE}
+STR_TMPL_RPL_START                                              :{BLACK}Csere elkezdése
+STR_TMPL_RPL_STOP                                               :{BLACK}Csere befejezése
+STR_TMPL_TRAIN_OVR_VALUE                                        :{TINY_FONT}{BLACK}Vonat ára: {CURRENCY_SHORT}
+STR_TMPL_TEMPLATE_OVR_VALUE                                     :{TINY_FONT}{BLACK}Ár: {GOLD}{CURRENCY_LONG}
+STR_TMPL_TEMPLATE_OVR_VALUE_nogold                              :{TINY_FONT}{BLACK}Ár: {CURRENCY_LONG}
+STR_TMPL_TEMPLATE_OVR_VALUE_nogoldandcurrency                   :{TINY_FONT}{BLACK}Ár:
+STR_TMPL_TEMPLATE_OVR_VALUE_notinyfont                          :{BLACK}Ár: {GOLD}{CURRENCY_LONG}
+STR_TMPL_TEMPLATE_OVR_VALUE_notinyfontandblack                  :Ár: {GOLD}{CURRENCY_LONG}
+STR_TMPL_WARNING_FREE_WAGON                                     :{RED}Szabad lánc: nem futattható!
+STR_TMPL_TEST                                                   :{ORANGE}Teszt String: {STRING} {STRING}
+STR_TMPL_GROUP_USES_TEMPLATE                                    :{BLACK}Sablon használatban: {NUM}
+STR_TMP_TEMPLATE_IN_USE                                         :Sablon használatban
+STR_TMPL_GROUP_NUM_TRAINS                                       :{BLACK}{NUM}
+STR_TMPL_CREATEGUI_TITLE                                        :{WHITE}Sablonjármű szerkesztése
+STR_TMPL_MAINGUI_DEFINEDGROUPS                                  :{BLACK}A vállalat csoportjai
+STR_TMPL_TMPLRPL_EX_DIFF_RAILTYPE                               :Sablon használata más típusú sínen
+
+STR_TMPL_SET_USEDEPOT                                           :{BLACK}Meglevő járművek használata
+STR_TMPL_SET_USEDEPOT_TIP                                       :{BLACK}Fűtőházban várakozó járművek felhasználása a csere közben, hogy csökkenjenek a költségek
+STR_TMPL_SET_KEEPREMAINDERS                                     :{BLACK}Maradék megtartása
+STR_TMPL_SET_KEEPREMAINDERS_TIP                                 :{BLACK}Egy sabloncsere után tartsa meg az összes járművet a fűtőházban későbbi felhasználásra
+STR_TMPL_SET_REFIT                                              :{BLACK}Átalakítás használata
+STR_TMPL_SET_REFIT_TIP                                          :{BLACK}Bekapcsolva a vonat átalakítása a sablon mintájára. Ha létező vagonokat használsz, akkor a régi átalakítás fog megmaradni.
+
+STR_TMPL_CONFIG_USEDEPOT                                        :meglevő
+STR_TMPL_CONFIG_KEEPREMAINDERS                                  :maradék
+STR_TMPL_CONFIG_REFIT                                           :átalakít
+
+STR_TMPL_NUM_TRAINS_NEED_RPL                                    :# trains to replace:
+
+STR_TMPL_CARGO_SUMMARY                                          :{CARGO_LONG}
+STR_TMPL_CARGO_SUMMARY_MULTI                                    :{CARGO_LONG} (x{NUM})
+
+STR_TMPL_RPLALLGUI_TITLE                                        :{WHITE}Az összes sablon jármű cseréje
+STR_TMPL_RPLALLGUI_INSET_TOP                                    :{BLACK}Válassz járműtípust és járművet
+STR_TMPL_RPLALLGUI_INSET_TOP_1                                  :{BLACK}Mozdonysablonok
+STR_TMPL_RPLALLGUI_INSET_TOP_2                                  :{BLACK}Elérhető mozdonyok
+STR_TMPL_RPLALLGUI_INSET_BOTTOM                                 :{BLACK}Sablonlista (csere után frissül)
+STR_TMPL_RPLALLGUI_BUTTON_RPLALL                                :{BLACK}Összes cseréje
+STR_TMPL_RPLALLGUI_BUTTON_APPLY                                 :{BLACK}Alkalmaz
+STR_TMPL_RPLALLGUI_BUTTON_CANCEL                                :{BLACK}Mégse
+STR_TMPL_RPLALLGUI_USE_TIP                                      :{BLACK}Válassz minden listából egy járművet, és nyomj az Összes cseréjére. Ha a kívánt eredményt kapod a sablonlistában, akkor nyomd meg az Alkalmaz gombot a jóváhagyáshoz.
diff -urNad openttd-1.3.2/src/lang/icelandic.txt openttd-1.3.2-DC3.0RC3/src/lang/icelandic.txt
--- openttd-1.3.2/src/lang/icelandic.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/icelandic.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1955,7 +1955,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Sparka
 STR_NETWORK_CLIENTLIST_BAN                                      :Banna
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Gefa pening
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Tala við alla
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Tala við fyrirtæki
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Einkaskilaboð
@@ -1964,7 +1963,6 @@
 STR_NETWORK_CLIENT                                              :Notandi
 STR_NETWORK_SPECTATORS                                          :Áhorfendur
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Sláðu inn peningaupphæð sem þú vilt láta af hendi rakna
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Ekki vista innslegið lykilorð
@@ -3052,6 +3050,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Endurreisa höfuðstöðvarnar annarsstaðar fyrir 1% af verðmæti fyrirtækis. Shift sýnir áætlaðan kostnað við flutning á höfuðstöðvum
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Nánar
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}Skoða nánar fjölda innviða
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Gefa pening
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}Nýtt Andlit
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Velja nýtt andlit á forstöðumanninn
@@ -3069,6 +3068,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Nafn Fyrirtækis
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Nafn forstjóra
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Sláðu inn peningaupphæð sem þú vilt láta af hendi rakna
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Við erum að leita að flutningsfyrirtæki til að taka yfir okkar rekstri.{}{}Viltu kaupa {COMPANY} fyrir {CURRENCY_LONG}?
 
diff -urNad openttd-1.3.2/src/lang/indonesian.txt openttd-1.3.2-DC3.0RC3/src/lang/indonesian.txt
--- openttd-1.3.2/src/lang/indonesian.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/indonesian.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1909,7 +1909,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Usir
 STR_NETWORK_CLIENTLIST_BAN                                      :Larangan
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Kirim uang
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Bicara ke semua
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Bicara ke perusahaan
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Pesan pribadi
@@ -1918,7 +1917,6 @@
 STR_NETWORK_CLIENT                                              :Klien
 STR_NETWORK_SPECTATORS                                          :Penonton
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Masukkan jumlah uang yang akan diberikan
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Jangan simpan kata sandi yang telah dimasukkan
@@ -3005,6 +3003,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Membangun kembali kantor pusat perusahaan di tempat lain dengan 1% ongkos dari nilai perusahaan. Shift untuk menampilkan perkiraan biaya
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Detail
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}Lihat jumlah infrastruktur lebih detail
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Kirim uang
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}Ganti Wajah
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Pilih wajah baru pimpinan
@@ -3022,6 +3021,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Nama Perusahaan
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Nama Pimpinan
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Masukkan jumlah uang yang akan diberikan
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Kami mencari perusahaan transporasi untuk mengambil alih perusahaan kami.{}{}Anda ingin membeli {COMPANY} senilai {CURRENCY_LONG}?
 
diff -urNad openttd-1.3.2/src/lang/irish.txt openttd-1.3.2-DC3.0RC3/src/lang/irish.txt
--- openttd-1.3.2/src/lang/irish.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/irish.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1659,7 +1659,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Ciceáil
 STR_NETWORK_CLIENTLIST_BAN                                      :Toirmisc
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Tabhair airgead
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Labhair le cách
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Labhair le cuideachta
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Teacht. phríobháideach
@@ -1668,7 +1667,6 @@
 STR_NETWORK_CLIENT                                              :Cliant
 STR_NETWORK_SPECTATORS                                          :Féachadóirí
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Iontráil an méid airgid is mian leat a thabhairt
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Ná sábháil an pasfhocal a iontráladh
@@ -2658,6 +2656,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Ainm na Cuideachta
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Ainm an Bhainisteora
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Iontráil an méid airgid is mian leat a thabhairt
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Tá cuideachta iompair á lorg againn chun seilbh a ghlacadh ar ár gcuideachta.{}{}An bhfuil fonn ort seilbh a ghlacadh ar {COMPANY} ar chostas {CURRENCY_LONG}?
 
diff -urNad openttd-1.3.2/src/lang/italian.txt openttd-1.3.2-DC3.0RC3/src/lang/italian.txt
--- openttd-1.3.2/src/lang/italian.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/italian.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1978,7 +1978,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Espelli
 STR_NETWORK_CLIENTLIST_BAN                                      :Bandisci
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Dona denaro
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Parla a tutti
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Parla alla compagnia
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Messaggio privato
@@ -1987,7 +1986,6 @@
 STR_NETWORK_CLIENT                                              :Client
 STR_NETWORK_SPECTATORS                                          :Spettatori
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Inserire la quantità di denaro da donare
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Non salvare la password inserita
@@ -3079,6 +3077,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Ricostruisce la sede della compagnia in un altro luogo pagando l'1% del valore della compagnia. MAIUSC+clic mostra il costo stimato senza ricostruire la sede
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Dettagli
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}Visualizza i conteggi dettagliati delle infrastrutture
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Dona denaro
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}Nuova faccia
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Seleziona una nuova faccia per il presidente
@@ -3096,6 +3095,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Nome della compagnia
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Nome del presidente
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Inserire la quantità di denaro da donare
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Stiamo cercando una compagnia di trasporti disposta a rilevare la nostra società.{}{} Vorrebbe acquistare la {COMPANY} per {CURRENCY_LONG}?
 
diff -urNad openttd-1.3.2/src/lang/japanese.txt openttd-1.3.2-DC3.0RC3/src/lang/japanese.txt
--- openttd-1.3.2/src/lang/japanese.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/japanese.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1960,7 +1960,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :追放
 STR_NETWORK_CLIENTLIST_BAN                                      :参入禁止
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :送金
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :全員へ発言
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :チームへ発言
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :個人的なメッセージ
@@ -1969,7 +1968,6 @@
 STR_NETWORK_CLIENT                                              :クライアント
 STR_NETWORK_SPECTATORS                                          :観覧者
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}送りたい金額を入力
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}入力したパスワードを保存しない
@@ -3076,6 +3074,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :会社名
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :社長名
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :送金したい総額を入力
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}現在、当{COMPANY}は業績悪化に伴い、債務の肩代わりを条件に社の全資産をお譲り致そうと考えております。{}{}債務{CURRENCY_LONG}を一括代済し、この会社を吸収合併しますか?
 
diff -urNad openttd-1.3.2/src/lang/korean.txt openttd-1.3.2-DC3.0RC3/src/lang/korean.txt
--- openttd-1.3.2/src/lang/korean.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/korean.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1955,7 +1955,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :추방
 STR_NETWORK_CLIENTLIST_BAN                                      :차단
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :돈 보내기
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :모두에게 말하기
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :우리 회사에게 말하기
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :귓속말하기
@@ -1964,7 +1963,6 @@
 STR_NETWORK_CLIENT                                              :접속자
 STR_NETWORK_SPECTATORS                                          :관전자
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}송금하고 싶은 양을 입력하세요.
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}입력한 비밀번호는 저장하지 않기
@@ -3052,6 +3050,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}회사가치의 1% 가격을 들여 본사를 다른 위치로 옮깁니다. SHIFT+클릭하면 예상 가격을 볼 수 있습니다.
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}상세정보
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}기반시설 상세정보 창을 엽니다.
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}돈 보내기
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}새 얼굴
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}사장의 얼굴을 선택합니다.
@@ -3069,6 +3068,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :회사 이름
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :사장 이름
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :송금하고 싶은 양을 입력하세요.
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}저희 회사를 거두어주실 운송 회사를 찾고있습니다.{}{}저희 {COMPANY} 회사를 {CURRENCY_LONG}의 가격으로 인수합병하시겠습니까?
 
diff -urNad openttd-1.3.2/src/lang/latvian.txt openttd-1.3.2-DC3.0RC3/src/lang/latvian.txt
--- openttd-1.3.2/src/lang/latvian.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/latvian.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1932,7 +1932,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Izmest
 STR_NETWORK_CLIENTLIST_BAN                                      :Aizliegt
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Iedot naudu
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Runāt ar visiem
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Runāt ar uzņēmumu
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Privāts ziņojums
@@ -1941,7 +1940,6 @@
 STR_NETWORK_CLIENT                                              :Spēlētājs
 STR_NETWORK_SPECTATORS                                          :Novērotāji
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Ievadiet cik daudz naudas vēlaties dot
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Nesaglabāt ievadīto paroli
@@ -3032,6 +3030,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Pārcelt uzņēmuma centrālo biroju uz citu vietu samaksājot 1% no uzņēmuma vērtības. Shift+klikšķis parāda izmaksu novērtējumu, nemainot biroja atrašanās vietu
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Sīkāk
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}Skatīt detalizētāku infrastruktūras uzskaiti
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Iedot naudu
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}Jauna seja
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Izvēlēties jaunu seju vadītājam
@@ -3049,6 +3048,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Uzņēmuma nosaukums
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Vadītāja vārds
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Ievadiet cik daudz naudas vēlaties dot
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Mēs meklējam transporta uzņēmumu, kurš vēlētos pārņemt mūsējo.{}{}Vai Jūs vēlaties pirkt {COMPANY} par {CURRENCY_LONG}?
 
diff -urNad openttd-1.3.2/src/lang/lithuanian.txt openttd-1.3.2-DC3.0RC3/src/lang/lithuanian.txt
--- openttd-1.3.2/src/lang/lithuanian.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/lithuanian.txt	2013-11-22 05:49:07.000000000 +0100
@@ -2149,7 +2149,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Išmesti (Kick)
 STR_NETWORK_CLIENTLIST_BAN                                      :Užblokuoti
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Duoti pinigų
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Sakyti visiems
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Sakyti kompanijai
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Privati žinutė
@@ -2158,7 +2157,6 @@
 STR_NETWORK_CLIENT                                              :Žaidėjas
 STR_NETWORK_SPECTATORS                                          :Stebėtojai
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Įveskite kiekį pinigų, kurį norite gauti
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Neišsaugotas įvestas slaptažodis
@@ -3246,6 +3244,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Perstatyti įmonės būstinę kitur už 1% įmonė vertės. Shift+Click parodys kainą neperstatant būstinės
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Išsamiau
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}Peržiūrėti detalesnę infrastruktūros informaciją
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Duoti pinigų
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}Naujas veidas
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Pasirink naują veidą
@@ -3263,6 +3262,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Kompanijos pavadinimas
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Direktoriaus vardas
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Įveskite kiekį pinigų, kurį norite gauti
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Mes ieškome, kas galėtų perimti mūsų kompaniją.{}{}Ar jūs norėtumėte pirkti {COMPANY} už {CURRENCY_LONG}?
 
diff -urNad openttd-1.3.2/src/lang/luxembourgish.txt openttd-1.3.2-DC3.0RC3/src/lang/luxembourgish.txt
--- openttd-1.3.2/src/lang/luxembourgish.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/luxembourgish.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1954,7 +1954,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Kick
 STR_NETWORK_CLIENTLIST_BAN                                      :Ban
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Suen ginn
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Jidderengem soen
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Der Firma soen
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Privat Meldung
@@ -1963,7 +1962,6 @@
 STR_NETWORK_CLIENT                                              :Spiller
 STR_NETWORK_SPECTATORS                                          :Zuschauer
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Gëff den Betrag un deenst du wëlls ginn
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Späicher d'Passwuert net
@@ -3051,6 +3049,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Bau d'Firmenhaaptgebai op eng aaner Plaz.Käschten: 1% vun dem Firmenwäert. Shift+Klick weist ongeféier Käschten ouni ze réckelen
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Detailer
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}Detailléiert Infrastrukturen uweisen
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Suen ginn
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}Neit Gesiicht
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Wielt en neit Gesiicht fir den Manager
@@ -3068,6 +3067,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Firmennumm
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Numm vum Manager
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Gëff den Betrag un deenst du wëlls ginn
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Mir sichen eng Transportfirma déi eis Firma iwerhuelen wëll.{}{}Wëlls du {COMPANY} fir {CURRENCY_LONG} kafen?
 
diff -urNad openttd-1.3.2/src/lang/malay.txt openttd-1.3.2-DC3.0RC3/src/lang/malay.txt
--- openttd-1.3.2/src/lang/malay.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/malay.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1788,7 +1788,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Tendang
 STR_NETWORK_CLIENTLIST_BAN                                      :Larang
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Beri wang
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Cakap kepada semua
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Cakap kepada syarikat
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Pesanan peribadi
@@ -1797,7 +1796,6 @@
 STR_NETWORK_CLIENT                                              :Klien
 STR_NETWORK_SPECTATORS                                          :Penyaksi
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Masukkan jumlah wang anda hendak memberikan
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Jangan simpan kata laluan ini
@@ -2876,6 +2874,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Bina semula ibu pejabat syarikat di tempat lain dengan kos 1% nilai syarikat. Shift+Klik untuk menunjukkan anggaran kos tanpa pemindahan HQ
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Butiran
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}Lihat kiraan infrastruktur secara terperinci
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Beri wang
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}Wajah Baru
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Pilih wajah baru untuk pengurus
@@ -2893,6 +2892,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Nama Syarikat
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Nama Pengurus
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Masukkan jumlah wang anda hendak memberikan
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Kami sedang mencari syarikat pengangkutan yang boleh mengambil alih syarikat kami.{}{}Adakah anda ingin membeli {COMPANY} untuk {CURRENCY_LONG}?
 
diff -urNad openttd-1.3.2/src/lang/norwegian_bokmal.txt openttd-1.3.2-DC3.0RC3/src/lang/norwegian_bokmal.txt
--- openttd-1.3.2/src/lang/norwegian_bokmal.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/norwegian_bokmal.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1956,7 +1956,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Kast ut
 STR_NETWORK_CLIENTLIST_BAN                                      :Bannlys
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Gi penger
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Snakk til alle
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Snakk til firma
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Privat beskjed
@@ -1965,7 +1964,6 @@
 STR_NETWORK_CLIENT                                              :Klient
 STR_NETWORK_SPECTATORS                                          :Tilskuere
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Skriv inn hvor mye penger du ønsker å gi
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Ikke lagre passordet
@@ -3053,6 +3051,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Gjenoppbygg (flytt) firmaets hovedkontor et annet sted til en kostnad av 1{NBSP}% av firmaverdien. Shift+klikk viser beregnet kostnad uten å flytte kontoret
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Detaljer
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}Vis detaljert infrastrukturtelling
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Gi penger
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}Nytt ansikt
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Velg nytt ansikt på sjefen
@@ -3070,6 +3069,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Firmanavn
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Sjefens navn
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Skriv inn hvor mye penger du ønsker å gi
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Vi ser etter et transportfirma som er villig til å overta oss.{}{}Vil du kjøpe {COMPANY} for {CURRENCY_LONG}?
 
diff -urNad openttd-1.3.2/src/lang/norwegian_nynorsk.txt openttd-1.3.2-DC3.0RC3/src/lang/norwegian_nynorsk.txt
--- openttd-1.3.2/src/lang/norwegian_nynorsk.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/norwegian_nynorsk.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1803,7 +1803,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Kast ut
 STR_NETWORK_CLIENTLIST_BAN                                      :Svartelist
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Gje pengar
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Snakk til alle
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Snakk til firma
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Privat melding
@@ -1812,7 +1811,6 @@
 STR_NETWORK_CLIENT                                              :Klient
 STR_NETWORK_SPECTATORS                                          :Tilskodarar
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Skriv inn kor mykje pengar du ønskar å gje
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Ikkje lagre passordet
@@ -2897,6 +2895,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Flytt hovudkontoret til firmaet, til ein kostnad av 1{NBSP}% av firmaverdien. Shift+klikk viser prisoverslag utan å flytte hovudkontoret.
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Detaljar
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}Vis detaljert infrastrukturteljing
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Gje pengar
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}Nytt andlet
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Gje sjefen ei andletslyfting
@@ -2914,6 +2913,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Firmanamn
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Namnet til sjefen
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Skriv inn kor mykje pengar du ønskar å gje
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Me ser etter eit firma som er villig til å overta firmaet vårt.{}{}Vil du kjøpe {COMPANY} for {CURRENCY_LONG}?
 
diff -urNad openttd-1.3.2/src/lang/polish.txt openttd-1.3.2-DC3.0RC3/src/lang/polish.txt
--- openttd-1.3.2/src/lang/polish.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/polish.txt	2013-11-22 05:49:07.000000000 +0100
@@ -2334,7 +2334,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Wyrzuć
 STR_NETWORK_CLIENTLIST_BAN                                      :Banuj
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Przekazanie pieniędzy
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Mów do wszystkich
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Mów do firmy
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Prywatna wiadomość
@@ -2343,7 +2342,6 @@
 STR_NETWORK_CLIENT                                              :Klient
 STR_NETWORK_SPECTATORS                                          :Widzowie
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Wprowadź ilość pieniędzy, które chcesz przekazać
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Nie zapisuj podanego hasła
@@ -3431,6 +3429,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Zbuduj siedzibę główną w innym miejscu za cenę 1% wartości firmy. Shift+klik pokazuje szacunkowy koszt bez przenoszenia siedziby
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Szczegóły
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}Zobacz szczegółowe wartości infrastruktury
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Przekazanie pieniędzy
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}Nowa twarz
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Wybierz nową twarz prezesa
@@ -3448,6 +3447,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Nazwa firmy
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Nazwisko prezesa
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Wprowadź ilość pieniędzy, które chcesz przekazać
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Szukamy firmy transportowej, która przejęłaby naszą firmę{}{}Chcesz kupić {COMPANY} za {CURRENCY_LONG}?
 
diff -urNad openttd-1.3.2/src/lang/portuguese.txt openttd-1.3.2-DC3.0RC3/src/lang/portuguese.txt
--- openttd-1.3.2/src/lang/portuguese.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/portuguese.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1953,7 +1953,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Expulsar
 STR_NETWORK_CLIENTLIST_BAN                                      :Banir
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Dar dinheiro
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Falar com todos
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Falar com a empresa
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Mensagem privada
@@ -1962,7 +1961,6 @@
 STR_NETWORK_CLIENT                                              :Cliente
 STR_NETWORK_SPECTATORS                                          :Espectadores
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Insira a quantidade de dinheiro que pretende dar
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Não gravar a palavra-chave introduzida
@@ -3044,6 +3042,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Reconstruir sede da empresa noutro sítio por 1% do valor da empresa. Shift+Clique mostra valor estimado sem mover a sede
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Detalhes
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}Ver contagens de infraestrutura detalhadas
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Dar dinheiro
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}Nova Cara
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Seleccione uma nova cara para o presidente
@@ -3061,6 +3060,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Nome da Empresa
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Nome do Presidente
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Insira a quantidade de dinheiro que pretende dar
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Estamos à procura de uma empresa de transportes para comprar a nossa empresa{}{}Deseja comprar {COMPANY} por {CURRENCY_LONG}?
 
diff -urNad openttd-1.3.2/src/lang/romanian.txt openttd-1.3.2-DC3.0RC3/src/lang/romanian.txt
--- openttd-1.3.2/src/lang/romanian.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/romanian.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1934,7 +1934,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Dă afară
 STR_NETWORK_CLIENTLIST_BAN                                      :Interzice acces
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Donează bani
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Vorbeşte către toţi
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Vorbeşte către companie
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Mesaj privat
@@ -1943,7 +1942,6 @@
 STR_NETWORK_CLIENT                                              :Client
 STR_NETWORK_SPECTATORS                                          :Spectatori
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Introduceţi suma pe care o oferiţi
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Parola introdusă nu se va salva
@@ -3031,6 +3029,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Mută sediul companiei (costă 1% din valoarea companiei). Shift+Click arată estimarea de cost fără a muta sediul companiei
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Detalii
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}Vezi contabilizarea infrastructurii
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Donează bani
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}Schimbă poza
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Alege o nouă poză a preşedintelui
@@ -3048,6 +3047,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Noul nume al companiei
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Noul nume al preşedintelui
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Introduceţi suma pe care o oferiţi
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Căutăm o companie de transport care să preia societatea noastră {}{}Doriţi să cumpăraţi {COMPANY} la preţul de {CURRENCY_LONG}?
 
diff -urNad openttd-1.3.2/src/lang/russian.txt openttd-1.3.2-DC3.0RC3/src/lang/russian.txt
--- openttd-1.3.2/src/lang/russian.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/russian.txt	2013-11-22 05:49:07.000000000 +0100
@@ -501,6 +501,7 @@
 STR_MAP_MENU_MAP_OF_WORLD                                       :Карта мира
 STR_MAP_MENU_EXTRA_VIEW_PORT                                    :Доп. окно просмотра
 STR_MAP_MENU_SIGN_LIST                                          :Список табличек
+STR_MAP_MENU_WATCH_COMPANY                                      :Наблюдать за компанией
 
 ############ range for town menu starts
 STR_TOWN_MENU_TOWN_DIRECTORY                                    :Список городов
@@ -1657,6 +1658,7 @@
 STR_CONFIG_SETTING_TOWN_FOUNDING_FORBIDDEN                      :запрещено
 STR_CONFIG_SETTING_TOWN_FOUNDING_ALLOWED                        :разрешено
 STR_CONFIG_SETTING_TOWN_FOUNDING_ALLOWED_CUSTOM_LAYOUT          :разрешено с выбором сети дорог
+STR_CONFIG_SETTING_TOWN_CONSTRUCTION_COST                       :Увеличивать стоимость строительства около городов: {STRING}
 
 STR_CONFIG_SETTING_EXTRA_TREE_PLACEMENT                         :Размножение деревьев в игре: {STRING}
 STR_CONFIG_SETTING_EXTRA_TREE_PLACEMENT_HELPTEXT                :Настройка возможности самостоятельного размножения деревьев в игре. Это может влиять на работоспособность некоторых предприятий, например, лесопилок.
@@ -2100,13 +2102,13 @@
 
 # Network company list added strings
 STR_NETWORK_COMPANY_LIST_CLIENT_LIST                            :{WHITE}Список клиентов
+STR_TRANSPARENT_TUNNELS_TOOLTIP                                 :{BLACK}Переключение прозрачности туннелей. Ctrl+щелчок - блокировка.
 STR_NETWORK_COMPANY_LIST_SPECTATE                               :{WHITE}Наблюдать
 STR_NETWORK_COMPANY_LIST_NEW_COMPANY                            :{WHITE}Новая компания
 
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Отключить
 STR_NETWORK_CLIENTLIST_BAN                                      :Бан
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Передать деньги
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Сказать всем
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Говорить с компанией
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Личное сообщение
@@ -2115,7 +2117,6 @@
 STR_NETWORK_CLIENT                                              :Клиент
 STR_NETWORK_SPECTATORS                                          :Наблюдатели
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Введите сумму денег, которую вы хотите передать
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Не сохранять пароль
@@ -3231,6 +3232,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Переместить штаб-квартиру компании в другое место за 1% оценочной стоимости капитала компании. Shift+щелчок - оценка стоимости переноса.
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Подробности
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}Посмотреть подробный состав инфраструктуры
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Передать деньги
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}Внешность
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Изменить внешность директора
@@ -3248,6 +3250,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Компания
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Имя директора
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Введите сумму денег, которую вы хотите передать
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Мы ищем транспортную компанию для присоединения к ней.{}{}Вы хотите купить {COMPANY} за {CURRENCY_LONG}?
 
@@ -3764,10 +3767,15 @@
 STR_ORDER_CONDITIONAL_RELIABILITY                               :Надёжность
 STR_ORDER_CONDITIONAL_MAX_SPEED                                 :Макс. скорость
 STR_ORDER_CONDITIONAL_AGE                                       :Возраст (лет)
-STR_ORDER_CONDITIONAL_REQUIRES_SERVICE                          :Требуется обслуживание
 STR_ORDER_CONDITIONAL_UNCONDITIONALLY                           :Всегда
 STR_ORDER_CONDITIONAL_REMAINING_LIFETIME                        :Оставшийся срок службы (лет)
 
+STR_ORDER_CONDITIONAL_ACCEPTANCE                                :Следующая станция {STRING} {STRING}
+STR_ORDER_CONDITIONAL_PERCENT                                   :Процентов времени
+STR_ORDER_CONDITIONAL_FREE_PLATFORMS                            :Свободные платформы
+STR_ORDER_CONDITIONAL_ACCEPTANCE_DROPDOWN                       :Принимает
+STR_ORDER_CONDITIONAL_NEXT_STATION                              :следующая станция
+
 STR_ORDER_CONDITIONAL_COMPARATOR_TOOLTIP                        :{BLACK}Условие перехода
 STR_ORDER_CONDITIONAL_COMPARATOR_EQUALS                         :равно
 STR_ORDER_CONDITIONAL_COMPARATOR_NOT_EQUALS                     :не равно
@@ -3862,6 +3870,16 @@
 STR_ORDER_CONDITIONAL_UNCONDITIONAL                             :Перейти к заданию {COMMA}
 STR_ORDER_CONDITIONAL_NUM                                       :Перейти к заданию {COMMA}, если {STRING} {STRING} {COMMA}
 STR_ORDER_CONDITIONAL_TRUE_FALSE                                :Перейти к заданию {COMMA}, если {STRING} - {STRING}
+STR_CONDITIONAL_FREE_PLATFORMS                                  :Перейти к заданию {COMMA} когда след. станция {STRING} {COMMA} свободн{P ая ые ых} платформ{P а ы ""}
+STR_CONDITIONAL_PERCENT                                         :Перейти к заданию {COMMA} {COMMA} процентов времени
+STR_ORDER_CONDITIONAL_COMPARATOR_ACCEPTS                        :принимает
+STR_ORDER_CONDITIONAL_COMPARATOR_DOES_NOT_ACCEPT                :не принимает
+STR_ORDER_CONDITIONAL_COMPARATOR_HAS                            :имеет
+STR_ORDER_CONDITIONAL_COMPARATOR_HAS_NO                         :не имеет
+STR_ORDER_CONDITIONAL_COMPARATOR_HAS_LESS_THAN                  :имеет меньше чем
+STR_ORDER_CONDITIONAL_COMPARATOR_HAS_LESS_EQUALS                :имеет меньше или равно
+STR_ORDER_CONDITIONAL_COMPARATOR_HAS_MORE_THAN                  :имеет больше чем
+STR_ORDER_CONDITIONAL_COMPARATOR_HAS_MORE_EQUALS                :имеет больше или равно
 
 STR_INVALID_ORDER                                               :{RED} (Неверное место назначения)
 
@@ -4970,3 +4988,7 @@
 STR_SHIP                                                        :{BLACK}{SHIP}
 
 STR_TOOLBAR_RAILTYPE_VELOCITY                                   :{STRING} ({VELOCITY})
+
+STR_WATCH_WINDOW_TITLE                                          :{WHITE}Наблюдение за {STRING}.
+STR_WATCH_CLICK_TO_WATCH_COMPANY                                :{BLACK}Нажмите здесь чтобы наблюдать за строительством компании
+STR_WATCH_CLICK_NEW_WINDOW                                      :{BLACK}Нажмите здесь чтобы открыть новое окно наблюдения
diff -urNad openttd-1.3.2/src/lang/serbian.txt openttd-1.3.2-DC3.0RC3/src/lang/serbian.txt
--- openttd-1.3.2/src/lang/serbian.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/serbian.txt	2013-11-22 05:49:07.000000000 +0100
@@ -2042,7 +2042,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Izbaci
 STR_NETWORK_CLIENTLIST_BAN                                      :Zabrani pristup
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Daj novac
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Razgovaraj sa svima
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Razgovaraj sa ekipom
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Privatna poruka
@@ -2051,7 +2050,6 @@
 STR_NETWORK_CLIENT                                              :Igrač
 STR_NETWORK_SPECTATORS                                          :Posmatrači
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Unesite svotu novca koju želite dati
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Otkaži unetu lozinku
@@ -3131,6 +3129,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Premešta sedište preduzeća na drugu lokaciju za cenu od 1% vrednosti preduzeća. Shift+Klik prikazuje procenu troškova bez premeštanja zgrade
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Detalji
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}Detaljni pregled računa za infrastrukturu
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Daj novac
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}Novo lice
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Izbor novog lica za vlasnika
@@ -3148,6 +3147,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Ime Preduzeća
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Ime vlasnika
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Unesite svotu novca koju želite dati
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}U potrazi smo za preduzećem koje bi preuzelo naše.{}{}Da li biste kupili {COMPANY} za {CURRENCY_LONG}?
 
diff -urNad openttd-1.3.2/src/lang/simplified_chinese.txt openttd-1.3.2-DC3.0RC3/src/lang/simplified_chinese.txt
--- openttd-1.3.2/src/lang/simplified_chinese.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/simplified_chinese.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1954,7 +1954,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :踢出
 STR_NETWORK_CLIENTLIST_BAN                                      :禁止
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :送钱
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :向全体人广播
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :向本公司广播
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :私聊
@@ -1963,7 +1962,6 @@
 STR_NETWORK_CLIENT                                              :客户端
 STR_NETWORK_SPECTATORS                                          :旁观者
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}请输入您想赠与的资金数
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}不保存所输入的密码
@@ -3051,6 +3049,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}以公司市值 1% 的代价重建总部，按住 Shift 键单击可以显示所需资金
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}固定资产维护费明细
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}显示详细的设施情况
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}送钱
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}新的头像
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}为总裁选择新头像
@@ -3068,6 +3067,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :公司名称
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :总裁姓名
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :请输入您想赠与的资金数
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}我们正在寻找一家愿意收购我们的公司。{}{}您愿意收购 {COMPANY} ({CURRENCY_LONG}) 吗？
 
diff -urNad openttd-1.3.2/src/lang/slovak.txt openttd-1.3.2-DC3.0RC3/src/lang/slovak.txt
--- openttd-1.3.2/src/lang/slovak.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/slovak.txt	2013-11-22 05:49:07.000000000 +0100
@@ -2022,7 +2022,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Vyhodit
 STR_NETWORK_CLIENTLIST_BAN                                      :Ban
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Previesť peniaze
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Napísať správu všetkým
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Napísať spoločnosti správu
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Súkromná správa
@@ -2031,7 +2030,6 @@
 STR_NETWORK_CLIENT                                              :Klient
 STR_NETWORK_SPECTATORS                                          :Pozorovatelia
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Vložte čiastku ktorú chcete dať
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Neukladať zadané heslo
@@ -3119,6 +3117,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Sídlo spoločnosti je možné premiestniť za 1% hodnoty spoločnosti. Shift+klik zobrazí predpokladanú cenu
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Detaily
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}Ukázať detailné počty infraštruktúry
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Previesť peniaze
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}Nová tvár
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Vybrať novú tvár prezidenta
@@ -3136,6 +3135,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Názov spoločnosti
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Meno prezidenta
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Vložte čiastku ktorú chcete dať
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Hľadáme záujemcu o kúpu našej spoločnosti{}{}Chcete kúpiť našu spoločnosť {COMPANY} za {CURRENCY_LONG}?
 
diff -urNad openttd-1.3.2/src/lang/slovenian.txt openttd-1.3.2-DC3.0RC3/src/lang/slovenian.txt
--- openttd-1.3.2/src/lang/slovenian.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/slovenian.txt	2013-11-22 05:49:07.000000000 +0100
@@ -2041,7 +2041,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Brcni
 STR_NETWORK_CLIENTLIST_BAN                                      :Blokiraj
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Daj denar
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Pogovor vsem
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Pogovor podjetju
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Zasebno sporočilo
@@ -2050,7 +2049,6 @@
 STR_NETWORK_CLIENT                                              :Gost
 STR_NETWORK_SPECTATORS                                          :Gledalci
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Vpiši znesek denarja za darovanje
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Ne shrani vnešenega gesla
@@ -3127,6 +3125,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Preseli sedež podjetja drugam za ceno 1% vrednosti podjetja. Shift+Klik prikaže predviden strošek brez selitve
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Podrobnosti
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}Podrobni prikaz količine infrastrukture
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Daj denar
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}Nov obraz
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Izberi nov obraz za direktorja
@@ -3144,6 +3143,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Ime podjetja
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Direktorjevo ime
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Vpiši znesek denarja za darovanje
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Iščemo novega lastnika, ki bi prevzel naše podjetje.{}{}Ali želiš odkupiti podjetje {COMPANY} za ceno {CURRENCY_LONG}?
 
diff -urNad openttd-1.3.2/src/lang/spanish.txt openttd-1.3.2-DC3.0RC3/src/lang/spanish.txt
--- openttd-1.3.2/src/lang/spanish.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/spanish.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1955,7 +1955,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Expulsar
 STR_NETWORK_CLIENTLIST_BAN                                      :Banear
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Dar dinero
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Hablar a todos
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Hablar a empresa
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Mensaje privado
@@ -1964,7 +1963,6 @@
 STR_NETWORK_CLIENT                                              :Cliente
 STR_NETWORK_SPECTATORS                                          :Espectadores
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Introduce la cantidad de dinero que deseas dar
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}No guardar la contraseña introducida
@@ -3052,6 +3050,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Reubica la sede de la empresa a cualquier otro lugar, con el coste del 1% del valor total de la empresa. Shift+Click muestra una estimación del precio sin mover la sede
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Detalles
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}Ver informe detallado de infraestructura
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Dar dinero
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}Nueva Cara
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Selecciona nueva cara para el presidente
@@ -3069,6 +3068,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Nombre Empresa
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Nombre del Presidente
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Introduce la cantidad de dinero que deseas dar
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Estamos buscando una empresa de transportes para adquirir la nuestra{}{}¿Desea comprar {COMPANY} por {CURRENCY_LONG}?
 
diff -urNad openttd-1.3.2/src/lang/swedish.txt openttd-1.3.2-DC3.0RC3/src/lang/swedish.txt
--- openttd-1.3.2/src/lang/swedish.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/swedish.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1954,7 +1954,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Kasta ut
 STR_NETWORK_CLIENTLIST_BAN                                      :Bannlys
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Ge pengar
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Prata med alla
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Prata med alla i företaget
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Privat meddelande
@@ -1963,7 +1962,6 @@
 STR_NETWORK_CLIENT                                              :Klient
 STR_NETWORK_SPECTATORS                                          :Publik
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Skriv in mängd pengar som du vill ge
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Spara inte det inmatade lösenordet
@@ -3051,6 +3049,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Flytta högkvarter till annan plats (kostar 1% av företagets värde). Shift+klick visar kostnad utan att flytta högkvarteret
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Detaljer
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}Visa detaljerat antal infrastruktur-element
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Ge pengar
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}Nytt ansikte
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Välj nytt ansikte på VD:n
@@ -3068,6 +3067,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Företagsnamn
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Namn på VD
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Skriv in mängd pengar som du vill ge
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Vi letar efter någon som vill köpa och ta över vårt företag{}{}Vill du köpa {COMPANY} för {CURRENCY_LONG}?
 
diff -urNad openttd-1.3.2/src/lang/tamil.txt openttd-1.3.2-DC3.0RC3/src/lang/tamil.txt
--- openttd-1.3.2/src/lang/tamil.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/tamil.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1753,7 +1753,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :உதை
 STR_NETWORK_CLIENTLIST_BAN                                      :அனுமதிக்காதே
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :பணம் தா
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :அனைவருடனும் பேசு
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :நிறுவனத்திடம் பேசு
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :இரகசிய தகவல்
@@ -1762,7 +1761,6 @@
 STR_NETWORK_CLIENT                                              :Client
 STR_NETWORK_SPECTATORS                                          :கவனிப்பவர்கள்
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}கொடுக்கப்படும் பணத்தின் அளவினை இடவும்
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}கடவுச்சொல்லினை நினைவில் வைத்திருக்காதே
@@ -2746,6 +2744,7 @@
 STR_COMPANY_VIEW_RELOCATE_HQ                                    :{BLACK}HQ வினை நகர்த்தவும்
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}விவரங்கள்
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}விவரமான கட்டட எண்ணிக்கைகளை காட்டு
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}பணம் தா
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}புதிய முகம்
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}மேலாளருக்கு புதிய முகத்தினைத் தேர்ந்தெடு
@@ -2760,6 +2759,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :நிறுவனத்தின் பெயர்
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :மேலாளரின் பெயர்
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :கொடுக்கப்படும் பணத்தின் அளவினை இடவும்
 
 
 # Company infrastructure window
diff -urNad openttd-1.3.2/src/lang/thai.txt openttd-1.3.2-DC3.0RC3/src/lang/thai.txt
--- openttd-1.3.2/src/lang/thai.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/thai.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1955,7 +1955,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :เตะ
 STR_NETWORK_CLIENTLIST_BAN                                      :แบน
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :ให้เงิน
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :พูดกับผู้เล่นทั้งหมด
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :พูดกับผู้เล่นในบริษัทเดียวกัน
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :ข้อความส่วนตัว
@@ -1964,7 +1963,6 @@
 STR_NETWORK_CLIENT                                              :ลูกข่าย
 STR_NETWORK_SPECTATORS                                          :ผู้ชม
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}กรอกจำนวนเงินที่ต้องการจะให้
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}ไม่ทำการเก็บพาสเวิร์ดที่กรอกไว้แล้ว
diff -urNad openttd-1.3.2/src/lang/traditional_chinese.txt openttd-1.3.2-DC3.0RC3/src/lang/traditional_chinese.txt
--- openttd-1.3.2/src/lang/traditional_chinese.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/traditional_chinese.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1954,7 +1954,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :踢除
 STR_NETWORK_CLIENTLIST_BAN                                      :封鎖
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :給錢
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :對全員說話
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :對公司說話
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :私人訊息
@@ -1963,7 +1962,6 @@
 STR_NETWORK_CLIENT                                              :用戶端
 STR_NETWORK_SPECTATORS                                          :旁觀者
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}請輸入你要付出多少資金
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}不要儲存所輸入的密碼
@@ -3068,6 +3066,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :公司名稱
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :總經理姓名
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :請輸入你要付出多少資金
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}我們正在找一間運輸公司收購我們的公司。{}{}您想購買 {COMPANY} 付出 {CURRENCY_LONG} 嗎？
 
diff -urNad openttd-1.3.2/src/lang/turkish.txt openttd-1.3.2-DC3.0RC3/src/lang/turkish.txt
--- openttd-1.3.2/src/lang/turkish.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/turkish.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1962,7 +1962,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :At
 STR_NETWORK_CLIENTLIST_BAN                                      :Yasakla
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Para ver
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Herkesle konuş
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Şirketle konuş
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Özel mesaj
@@ -1971,7 +1970,6 @@
 STR_NETWORK_CLIENT                                              :İstemci
 STR_NETWORK_SPECTATORS                                          :İzleyiciler
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Vermek istediğiniz para miktarını girin
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Girilen parolayı kaydetme
@@ -3059,6 +3057,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Şirket değerinin %1'i karşılığında binanın yerini değiştir. Shift+tıklama şirket binasının yerini değiştirmeden tahmini maliyeti gösterir
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Ayrıntılar
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}Ayrıntılı altyapı sayılarını göster
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Para ver
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}Yeni Surat
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Müdür için yeni surat seç
@@ -3076,6 +3075,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Şirketin ismi
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Yöneticinin ismi
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Vermek istediğiniz para miktarını girin
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Şirketimizi satın alacak birilerini arıyoruz.{}{} {COMPANY} şirketini şu fiyata almak ister misiniz: {CURRENCY_LONG}?
 
diff -urNad openttd-1.3.2/src/lang/ukrainian.txt openttd-1.3.2-DC3.0RC3/src/lang/ukrainian.txt
--- openttd-1.3.2/src/lang/ukrainian.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/ukrainian.txt	2013-11-22 05:49:07.000000000 +0100
@@ -2078,7 +2078,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Відключити гравця
 STR_NETWORK_CLIENTLIST_BAN                                      :Бан
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Дати грошей
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Повідомлення всім
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Повідомлення компанії
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Приватне повідомлення
@@ -2087,7 +2086,6 @@
 STR_NETWORK_CLIENT                                              :Клієнт
 STR_NETWORK_SPECTATORS                                          :Спостерігачі
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Введіть суму грошей, яку Ви хочете віддати
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Не запам'ятовувати введений пароль
@@ -3171,6 +3169,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Перенесення Офісу в інше місце. Коштує 1% від вартості компанії. Утримуйте Shift для показу очікуваних витрат на перенесення
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Деталі
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}Переглянути детальну інформацію про інфраструктуру
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Дати грошей
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}Нове обличчя
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Вибрати нове обличчя керівника
@@ -3188,6 +3187,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Назва компанії
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Ім'я керівника
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Введіть суму грошей, яку Ви хочете віддати
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Ми шукаємо нового власника нашої компанії.{}{}Чи бажаєте Ви купити {COMPANY} за {CURRENCY_LONG}?
 
diff -urNad openttd-1.3.2/src/lang/unfinished/frisian.txt openttd-1.3.2-DC3.0RC3/src/lang/unfinished/frisian.txt
--- openttd-1.3.2/src/lang/unfinished/frisian.txt	2013-07-27 17:09:23.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/unfinished/frisian.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1543,7 +1543,6 @@
 
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Skoppe
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Jouw jild
 
 STR_NETWORK_SERVER                                              :Tsjinner
 
@@ -2166,6 +2165,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Bedriuwsnamme
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Namme fan Direkteur
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Wy sykje in transportbedriuw om ús bedriuw oer te nimmen.{}{}Wolsto {COMPANY} foar {CURRENCY_LONG} keapje?
 
diff -urNad openttd-1.3.2/src/lang/unfinished/macedonian.txt openttd-1.3.2-DC3.0RC3/src/lang/unfinished/macedonian.txt
--- openttd-1.3.2/src/lang/unfinished/macedonian.txt	2013-07-27 17:09:23.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/unfinished/macedonian.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1362,6 +1362,7 @@
 
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}детали за
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}Погледнете детални точки инфраструктура
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}
 
 
 
diff -urNad openttd-1.3.2/src/lang/unfinished/marathi.txt openttd-1.3.2-DC3.0RC3/src/lang/unfinished/marathi.txt
--- openttd-1.3.2/src/lang/unfinished/marathi.txt	2013-07-27 17:09:23.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/unfinished/marathi.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1038,6 +1038,7 @@
 
 
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :व्यवस्थापकाचे नाव
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :
 
 
 # Company infrastructure window
diff -urNad openttd-1.3.2/src/lang/unfinished/persian.txt openttd-1.3.2-DC3.0RC3/src/lang/unfinished/persian.txt
--- openttd-1.3.2/src/lang/unfinished/persian.txt	2013-07-27 17:09:23.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/unfinished/persian.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1719,7 +1719,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :اخراج
 STR_NETWORK_CLIENTLIST_BAN                                      :قدغن کردن
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :پول دادن
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :گفتگو با همه
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :گفتگو با شرکت
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :پیام خصوصی
@@ -1728,7 +1727,6 @@
 STR_NETWORK_CLIENT                                              :سرویس گیرنده
 STR_NETWORK_SPECTATORS                                          :تماشاگران
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}مقدار پولی که می خواهید دریافت نمایید را وارد کنید
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}رمز وارد شده را به خاطر نسپار
@@ -2760,6 +2758,7 @@
 STR_COMPANY_VIEW_VIEW_HQ_BUTTON                                 :{BLACK}دیدن ساختمان مرکزی
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}جزییات
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}مشاهده جزییات تعداد زیرساخت ها
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}پول دادن
 
 
 STR_COMPANY_VIEW_BUY_SHARE_BUTTON                               :{BLACK}25% سهام شرکت را بخر
diff -urNad openttd-1.3.2/src/lang/unfinished/urdu.txt openttd-1.3.2-DC3.0RC3/src/lang/unfinished/urdu.txt
--- openttd-1.3.2/src/lang/unfinished/urdu.txt	2013-07-27 17:09:23.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/unfinished/urdu.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1678,7 +1678,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :ٹھڈا
 STR_NETWORK_CLIENTLIST_BAN                                      :پابندی
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :پیسے دئیں
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :سب سے بات کریں
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :کمپنی سے بات کریں
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :پرائیویٹ پیغام
@@ -1687,7 +1686,6 @@
 STR_NETWORK_CLIENT                                              :کلائینٹ
 STR_NETWORK_SPECTATORS                                          :ناظرین
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}بتائیں آپ کتنے پیسے بھیجنا چاہتے ہیں
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}بتایا گیا پاس ورڈ محفوظ نہ کریں
diff -urNad openttd-1.3.2/src/lang/vietnamese.txt openttd-1.3.2-DC3.0RC3/src/lang/vietnamese.txt
--- openttd-1.3.2/src/lang/vietnamese.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/vietnamese.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1954,7 +1954,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Đá
 STR_NETWORK_CLIENTLIST_BAN                                      :Cấm
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Cho tiền
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Nói với tất cả
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Nói cho công ty
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Thông điệp riêng
@@ -1963,7 +1962,6 @@
 STR_NETWORK_CLIENT                                              :Máy trạm
 STR_NETWORK_SPECTATORS                                          :Người xem
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Nhập số tiền muốn cho đi
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Không được ghi mật khẩu đã nhập
@@ -3051,6 +3049,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Chuyển trụ sở công ty đi nơi khác sẽ cần chi phí là 1% giá trị công ty. . Shift+Click để xem chi phí dự tính
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Chi tiết
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}Xem chi tiết thống kê hạ tầng
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Cho tiền
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}Vẻ mặt mới
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Chọn vẻ mặt của giám đốc
@@ -3068,6 +3067,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Tên Công Ty
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Tên Giám Đốc
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Nhập số tiền muốn cho đi
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Chúng tôi tìm một công ty để chuyển nhượng công việc kinh doanh và tài sản công ty chúng tôi.{}{}Bạn có muốn mua công ty {COMPANY} của chúng tôi với giá {CURRENCY_LONG}?
 
diff -urNad openttd-1.3.2/src/lang/welsh.txt openttd-1.3.2-DC3.0RC3/src/lang/welsh.txt
--- openttd-1.3.2/src/lang/welsh.txt	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/lang/welsh.txt	2013-11-22 05:49:07.000000000 +0100
@@ -1954,7 +1954,6 @@
 # Network client list
 STR_NETWORK_CLIENTLIST_KICK                                     :Cicio
 STR_NETWORK_CLIENTLIST_BAN                                      :Gwahardd
-STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Rhoi arian
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Siarad â phawb
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Siarad a'r cwmni
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Neges breifat
@@ -1963,7 +1962,6 @@
 STR_NETWORK_CLIENT                                              :Gwestai
 STR_NETWORK_SPECTATORS                                          :Gwylwyr
 
-STR_NETWORK_GIVE_MONEY_CAPTION                                  :{WHITE}Nodwch faint o arian yr hoffech chi ei roi
 
 # Network set password
 STR_COMPANY_PASSWORD_CANCEL                                     :{BLACK}Peidio cadw'r cyfrinair a roddwyd
@@ -3051,6 +3049,7 @@
 STR_COMPANY_VIEW_RELOCATE_COMPANY_HEADQUARTERS                  :{BLACK}Ailadeiladu pencadlys cwmni mewn man arall am 1% o werth y cwmni. Mae Shift+Clic yn dangos amcangyfrif o'r gost heb adleoli
 STR_COMPANY_VIEW_INFRASTRUCTURE_BUTTON                          :{BLACK}Manylion
 STR_COMPANY_VIEW_INFRASTRUCTURE_TOOLTIP                         :{BLACK}Gweld cyfansymau tanadeiledd manwl
+STR_COMPANY_VIEW_GIVE_MONEY_BUTTON                              :{BLACK}Rhoi arian
 
 STR_COMPANY_VIEW_NEW_FACE_BUTTON                                :{BLACK}Gwyneb Newydd
 STR_COMPANY_VIEW_NEW_FACE_TOOLTIP                               :{BLACK}Dewiswch wyneb newydd ar gyfer y rheolwr
@@ -3068,6 +3067,7 @@
 
 STR_COMPANY_VIEW_COMPANY_NAME_QUERY_CAPTION                     :Enw Cwmni
 STR_COMPANY_VIEW_PRESIDENT_S_NAME_QUERY_CAPTION                 :Enw Rheolwr
+STR_COMPANY_VIEW_GIVE_MONEY_QUERY_CAPTION                       :Nodwch faint o arian yr hoffech chi ei roi
 
 STR_BUY_COMPANY_MESSAGE                                         :{WHITE}Rydyn ni'n chwilio am rywun i gymryd ein cwmni ni drosodd.{}{}Hoffech chi brynu {COMPANY} am {CURRENCY_LONG}?
 
diff -urNad openttd-1.3.2/src/main_gui.cpp openttd-1.3.2-DC3.0RC3/src/main_gui.cpp
--- openttd-1.3.2/src/main_gui.cpp	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/main_gui.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -31,6 +31,8 @@
 #include "statusbar_gui.h"
 #include "tilehighlight_func.h"
 #include "hotkeys.h"
+#include "industry.h"
+#include "town_map.h"
 
 #include "saveload/saveload.h"
 
@@ -44,9 +46,6 @@
 #include "table/sprites.h"
 #include "table/strings.h"
 
-static int _rename_id = 1;
-static int _rename_what = -1;
-
 void CcGiveMoney(const CommandCost &result, TileIndex tile, uint32 p1, uint32 p2)
 {
 #ifdef ENABLE_NETWORK
@@ -67,24 +66,7 @@
 
 void HandleOnEditText(const char *str)
 {
-	switch (_rename_what) {
-#ifdef ENABLE_NETWORK
-	case 3: { // Give money, you can only give money in excess of loan
-		const Company *c = Company::GetIfValid(_local_company);
-		if (c == NULL) break;
-		Money money = min(c->money - c->current_loan, (Money)(atoi(str) / _currency->rate));
-
-		uint32 money_c = Clamp(ClampToI32(money), 0, 20000000); // Clamp between 20 million and 0
-
-		/* Give 'id' the money, and subtract it from ourself */
-		DoCommandP(0, money_c, _rename_id, CMD_GIVE_MONEY | CMD_MSG(STR_ERROR_INSUFFICIENT_FUNDS), CcGiveMoney, str);
-		break;
-	}
-#endif /* ENABLE_NETWORK */
-		default: NOT_REACHED();
-	}
-
-	_rename_id = _rename_what = -1;
+    NOT_REACHED();
 }
 
 /**
@@ -104,7 +86,7 @@
 	if (_settings_client.sound.click_beep) SndPlayFx(SND_15_BEEP);
 	w->SetDirty();
 
-	if (w->IsWidgetLowered(widget)) {
+	if (w->IsWidgetLowered(widget) && mode == _thd.place_mode) {
 		ResetObjectToPlace();
 		return false;
 	}
@@ -120,16 +102,6 @@
 	if (result.Succeeded() && _settings_client.sound.confirm) SndPlayTileFx(SND_12_EXPLOSION, tile);
 }
 
-#ifdef ENABLE_NETWORK
-void ShowNetworkGiveMoneyWindow(CompanyID company)
-{
-	_rename_id = company;
-	_rename_what = 3;
-	ShowQueryString(STR_EMPTY, STR_NETWORK_GIVE_MONEY_CAPTION, 30, NULL, CS_NUMERAL, QSF_NONE);
-}
-#endif /* ENABLE_NETWORK */
-
-
 /**
  * Zooms a viewport in a window in or out.
  * @param how Zooming direction.
@@ -444,6 +416,58 @@
 		/* Forward the message to the appropriate toolbar (ingame or scenario editor) */
 		InvalidateWindowData(WC_MAIN_TOOLBAR, 0, data, true);
 	}
+       virtual void OnMouseOver(Point pt, int widget)
+       {
+               /* Show tooltip with last month production or town name */
+               if (pt.x != -1 && _game_mode != GM_MENU) {
+                       TileIndex tile;
+                       const bool viewport_is_in_map_mode = (this->viewport->zoom >= ZOOM_LVL_MAX);
+                       if (viewport_is_in_map_mode) {
+                               const int a = ((ScaleByZoom(pt.x, this->viewport->zoom) + this->viewport->virtual_left) >> 2) / ZOOM_LVL_BASE;
+                               const int b = ((ScaleByZoom(pt.y, this->viewport->zoom) + this->viewport->virtual_top) >> 1) / ZOOM_LVL_BASE;
+                               tile = TileVirtXY(b - a, b + a);
+                       } else {
+                               const Point p = GetTileBelowCursor();
+                               tile = TileVirtXY(p.x, p.y);
+                       }
+                       if (tile >= MapSize()) return;
+
+                       switch (GetTileType(tile)) {
+                               case MP_ROAD:
+                                       if (IsRoadDepot(tile)) return;
+                                       /* FALL THROUGH */
+                               case MP_HOUSE: {
+                                       if (HasBit(_display_opt, DO_SHOW_TOWN_NAMES)) return; // No need for a town name tooltip when it is already displayed
+                                       if (!viewport_is_in_map_mode) return;
+                                       const TownID tid = GetTownIndex(tile);
+                                       if (!tid) return;
+                                       SetDParam(0, tid);
+                                       GuiShowTooltips(this, STR_TOWN_NAME_TOOLTIP, 0, NULL, TCC_HOVER);
+                                       break;
+                               }
+                               case MP_INDUSTRY: {
+                                       const Industry *ind = Industry::GetByTile(tile);
+                                       const IndustrySpec *indsp = GetIndustrySpec(ind->type);
+
+                                       StringID str = STR_INDUSTRY_VIEW_TRANSPORTED_TOOLTIP;
+                                       uint prm_count = 0;
+                                       SetDParam(prm_count++, indsp->name);
+                                       for (byte i = 0; i < lengthof(ind->produced_cargo); i++) {
+                                               if (ind->produced_cargo[i] != CT_INVALID) {
+                                                       SetDParam(prm_count++, ind->produced_cargo[i]);
+                                                       SetDParam(prm_count++, ind->last_month_production[i]);
+                                                       SetDParam(prm_count++, ToPercent8(ind->last_month_pct_transported[i]));
+                                                       str++;
+                                               }
+                                       }
+                                       GuiShowTooltips(this, str, 0, NULL, TCC_HOVER);
+                                       break;
+                               }
+                               default:
+                                       return;
+                       }
+               }
+       }
 
 	static Hotkey<MainWindow> global_hotkeys[];
 };
diff -urNad openttd-1.3.2/src/map.cpp openttd-1.3.2-DC3.0RC3/src/map.cpp
--- openttd-1.3.2/src/map.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/map.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -19,16 +19,7 @@
 extern "C" _CRTIMP void __cdecl _assert(void *, void *, unsigned);
 #endif
 
-uint _map_log_x;     ///< 2^_map_log_x == _map_size_x
-uint _map_log_y;     ///< 2^_map_log_y == _map_size_y
-uint _map_size_x;    ///< Size of the map along the X
-uint _map_size_y;    ///< Size of the map along the Y
-uint _map_size;      ///< The number of tiles on the map
-uint _map_tile_mask; ///< _map_size - 1 (to mask the mapsize)
-
-Tile *_m = NULL;          ///< Tiles of the map
-TileExtended *_me = NULL; ///< Extended Tiles of the map
-
+MainMap _main_map; ///< The main tile array.
 
 /**
  * (Re)allocates a map with the given dimension
@@ -37,29 +28,31 @@
  */
 void AllocateMap(uint size_x, uint size_y)
 {
+       DEBUG(map, 2, "Min/max map size %d/%d, max map tiles %d", MIN_MAP_SIZE, MAX_MAP_SIZE, MAX_MAP_TILES);
+       DEBUG(map, 1, "Allocating map of size %dx%d", size_x, size_y);
+
 	/* Make sure that the map size is within the limits and that
 	 * size of both axes is a power of 2. */
-	if (!IsInsideMM(size_x, MIN_MAP_SIZE, MAX_MAP_SIZE + 1) ||
-			!IsInsideMM(size_y, MIN_MAP_SIZE, MAX_MAP_SIZE + 1) ||
+       if (size_x * size_y > MAX_MAP_TILES ||
+                       size_x < MIN_MAP_SIZE ||
+                       size_y < MIN_MAP_SIZE ||
 			(size_x & (size_x - 1)) != 0 ||
 			(size_y & (size_y - 1)) != 0) {
 		error("Invalid map size");
 	}
 
-	DEBUG(map, 1, "Allocating map of size %dx%d", size_x, size_y);
-
-	_map_log_x = FindFirstBit(size_x);
-	_map_log_y = FindFirstBit(size_y);
-	_map_size_x = size_x;
-	_map_size_y = size_y;
-	_map_size = size_x * size_y;
-	_map_tile_mask = _map_size - 1;
+	_main_map.log_x = FindFirstBit(size_x);
+	_main_map.log_y = FindFirstBit(size_y);
+	_main_map.size_x = size_x;
+	_main_map.size_y = size_y;
+	_main_map.size = size_x * size_y;
+	_main_map.tile_mask = _main_map.size - 1;
 
-	free(_m);
-	free(_me);
+	free(_main_map.m);
+	free(_main_map.me);
 
-	_m = CallocT<Tile>(_map_size);
-	_me = CallocT<TileExtended>(_map_size);
+	_main_map.m = CallocT<Tile>(_main_map.size);
+	_main_map.me = CallocT<TileExtended>(_main_map.size);
 }
 
 
@@ -95,7 +88,25 @@
 
 	return TileXY(x, y);
 }
+
+GenericTileIndex TileAddXY(GenericTileIndex tile, int dx, int dy, const char *exp, const char *file, int line)
+{
+	uint x = TileX(tile) + dx;
+	uint y = TileY(tile) + dy;
+
+	if (x >= MapSizeX(MapOf(tile)) || y >= MapSizeY(MapOf(tile))) {
+		char buf[512];
+		snprintf(buf, lengthof(buf), "TILE_ADDXY(%s) when adding 0x%.4X and <0x%.4X, 0x%.4X> failed", exp, IndexOf(tile), dx, dy);
+#if !defined(_MSC_VER) || defined(WINCE)
+		fprintf(stderr, "%s:%d %s\n", file, line, buf);
+#else
+		_assert(buf, (char*)file, line);
 #endif
+	}
+
+	return TileXY<true>(x, y, MapOf(tile));
+}
+#endif /* _DEBUG */
 
 /**
  * This function checks if we add addx/addy to tile, if we
diff -urNad openttd-1.3.2/src/map_func.h openttd-1.3.2-DC3.0RC3/src/map_func.h
--- openttd-1.3.2/src/map_func.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/map_func.h	2013-11-22 05:49:07.000000000 +0100
@@ -12,38 +12,122 @@
 #ifndef MAP_FUNC_H
 #define MAP_FUNC_H
 
+#include "core/bitmath_func.hpp"
 #include "core/math_func.hpp"
 #include "tile_type.h"
 #include "map_type.h"
 #include "direction_func.h"
 
-extern uint _map_tile_mask;
+extern MainMap _main_map;
 
 /**
  * 'Wraps' the given tile to it is within the map. It does
  * this by masking the 'high' bits of.
  * @param x the tile to 'wrap'
  */
+#define TILE_MASK(x) ((x) & _main_map.tile_mask)
 
-#define TILE_MASK(x) ((x) & _map_tile_mask)
+void AllocateMap(uint size_x, uint size_y);
 
 /**
- * Pointer to the tile-array.
- *
- * This variable points to the tile-array which contains the tiles of
- * the map.
+ * Get the map of a tile.
+ * @param tile tile index of the tile
+ * @return the map that contains the tile
  */
-extern Tile *_m;
+template <bool Tgeneric>
+static inline Map *MapOf(typename TileIndexT<Tgeneric>::T tile);
+
+template <>
+inline Map *MapOf<false>(TileIndex tile)
+{
+	return &_main_map;
+}
+
+template <>
+inline Map *MapOf<true>(GenericTileIndex tile)
+{
+	return tile.map;
+}
+
+/** @copydoc MapOf(TileIndexT<Tgeneric>::T) */
+static inline Map *MapOf(TileIndex tile) { return MapOf<false>(tile); }
+/** @copydoc MapOf(TileIndexT<Tgeneric>::T) */
+static inline Map *MapOf(GenericTileIndex tile) { return MapOf<true>(tile); }
 
 /**
- * Pointer to the extended tile-array.
- *
- * This variable points to the extended tile-array which contains the tiles
- * of the map.
+ * Get the index of a tile.
+ * @param tile the tile index of the tile
+ * @return raw index of the tile
  */
-extern TileExtended *_me;
+template <bool Tgeneric>
+static inline RawTileIndex &IndexOf(typename TileIndexT<Tgeneric>::T &tile);
 
-void AllocateMap(uint size_x, uint size_y);
+/** @copydoc IndexOf(TileIndexT<Tgeneric>::T&) */
+template <bool Tgeneric>
+static inline const RawTileIndex &IndexOf(const typename TileIndexT<Tgeneric>::T &tile);
+
+template <>
+inline RawTileIndex &IndexOf<false>(TileIndex &tile)
+{
+	return tile;
+}
+
+template <>
+inline RawTileIndex &IndexOf<true>(GenericTileIndex &tile)
+{
+	return tile.index;
+}
+
+template <>
+inline const RawTileIndex &IndexOf<false>(const TileIndex &tile)
+{
+	return tile;
+}
+
+template <>
+inline const RawTileIndex &IndexOf<true>(const GenericTileIndex &tile)
+{
+	return tile.index;
+}
+
+/** @copydoc IndexOf(TileIndexT<Tgeneric>::T&) */
+static inline RawTileIndex &IndexOf(TileIndex &tile) { return IndexOf<false>(tile); }
+/** @copydoc IndexOf(TileIndexT<Tgeneric>::T&) */
+static inline RawTileIndex &IndexOf(GenericTileIndex &tile) { return IndexOf<true>(tile); }
+/** @copydoc IndexOf(TileIndexT<Tgeneric>::T&) */
+static inline const RawTileIndex &IndexOf(const TileIndex &tile) { return IndexOf<false>(tile); }
+/** @copydoc IndexOf(TileIndexT<Tgeneric>::T&) */
+static inline const RawTileIndex &IndexOf(const GenericTileIndex &tile) { return IndexOf<true>(tile); }
+
+/**
+ * Get the data of a tile.
+ * @param tile index of the tile
+ * @return the tile data
+ */
+template <bool Tgeneric>
+static inline Tile *GetTile(typename TileIndexT<Tgeneric>::T tile)
+{
+	return &(MapOf(tile)->m[IndexOf(tile)]);
+}
+/** @copydoc GetTile(TileIndexT<Tgeneric>::T) */
+static inline Tile *GetTile(TileIndex tile) { return GetTile<false>(tile); }
+/** @copydoc GetTile(TileIndexT<Tgeneric>::T) */
+static inline Tile *GetTile(GenericTileIndex tile) { return GetTile<true>(tile); }
+
+/**
+ * Get the extended data of a tile.
+ * @param tile index of the tile
+ * @return the extended tile data
+ */
+template <bool Tgeneric>
+static inline TileExtended *GetTileEx(typename TileIndexT<Tgeneric>::T tile)
+{
+	return &(MapOf(tile)->me[IndexOf(tile)]);
+}
+/** @copydoc GetTileEx(TileIndexT<Tgeneric>::T) */
+static inline TileExtended *GetTileEx(TileIndex tile) { return GetTileEx<false>(tile); }
+/** @copydoc GetTileEx(TileIndexT<Tgeneric>::T) */
+static inline TileExtended *GetTileEx(GenericTileIndex tile) { return GetTileEx<true>(tile); }
 
 /**
  * Logarithm of the map size along the X side.
@@ -52,8 +136,7 @@
  */
 static inline uint MapLogX()
 {
-	extern uint _map_log_x;
-	return _map_log_x;
+	return _main_map.log_x;
 }
 
 /**
@@ -63,56 +146,57 @@
  */
 static inline uint MapLogY()
 {
-	extern uint _map_log_y;
-	return _map_log_y;
+	return _main_map.log_y;
 }
 
 /**
- * Get the size of the map along the X
+ * Get the size of a map along the X
+ * @param map the map
  * @return the number of tiles along the X of the map
  */
-static inline uint MapSizeX()
+static inline uint MapSizeX(Map *map = &_main_map)
 {
-	extern uint _map_size_x;
-	return _map_size_x;
+	return map->size_x;
 }
 
 /**
- * Get the size of the map along the Y
+ * Get the size of a map along the Y
+ * @param map the map
  * @return the number of tiles along the Y of the map
  */
-static inline uint MapSizeY()
+static inline uint MapSizeY(Map *map = &_main_map)
 {
-	extern uint _map_size_y;
-	return _map_size_y;
+	return map->size_y;
 }
 
 /**
- * Get the size of the map
+ * Get the size of a map
+ * @param map the map
  * @return the number of tiles of the map
  */
-static inline uint MapSize()
+static inline uint MapSize(Map *map = &_main_map)
 {
-	extern uint _map_size;
-	return _map_size;
+	return map->size;
 }
 
 /**
- * Gets the maximum X coordinate within the map, including MP_VOID
+ * Gets the maximum X coordinate within a map, including MP_VOID
+ * @param map the map
  * @return the maximum X coordinate
  */
-static inline uint MapMaxX()
+static inline uint MapMaxX(Map *map = &_main_map)
 {
-	return MapSizeX() - 1;
+	return MapSizeX(map) - 1;
 }
 
 /**
- * Gets the maximum Y coordinate within the map, including MP_VOID
+ * Gets the maximum Y coordinate within a map, including MP_VOID
+ * @param map the map
  * @return the maximum Y coordinate
  */
-static inline uint MapMaxY()
+static inline uint MapMaxY(Map *map = &_main_map)
 {
-	return MapSizeY() - 1;
+	return MapSizeY(map) - 1;
 }
 
 /**
@@ -156,6 +240,114 @@
 typedef int32 TileIndexDiff;
 
 /**
+ * Test if a given tile index is a main map tile index.
+ * @param tile the tile index to test
+ * @return \c true if the index points to the main map, \c false otherwise
+ */
+template <bool Tgeneric>
+static inline bool IsMainMapTile(typename TileIndexT<Tgeneric>::T tile);
+
+template <>
+inline bool IsMainMapTile<false>(TileIndex tile)
+{
+	return true;
+}
+
+template <>
+inline bool IsMainMapTile<true>(GenericTileIndex tile)
+{
+	return MapOf<true>(tile) == &_main_map;
+}
+
+/** @copydoc IsMainMapTile(TileIndexT<Tgeneric>::T) */
+static inline bool IsMainMapTile(TileIndex tile) { return IsMainMapTile<false>(tile); }
+/** @copydoc IsMainMapTile(TileIndexT<Tgeneric>::T) */
+static inline bool IsMainMapTile(GenericTileIndex tile) { return IsMainMapTile<true>(tile); }
+
+/**
+ * Convert a given tile index to a main map tile index.
+ *
+ * @param tile the index to convert
+ * @return the converted index
+ *
+ * @pre IsMainMapTile(tile)
+ */
+template <bool Tgeneric>
+static inline TileIndex AsMainMapTile(typename TileIndexT<Tgeneric>::T tile)
+{
+	assert(IsMainMapTile(tile));
+	return (TileIndex)IndexOf(tile);
+}
+/** @copydoc AsMainMapTile(TileIndexT<Tgeneric>::T) */
+static inline TileIndex AsMainMapTile(TileIndex tile) { return AsMainMapTile<false>(tile); }
+/** @copydoc AsMainMapTile(TileIndexT<Tgeneric>::T) */
+static inline TileIndex AsMainMapTile(GenericTileIndex tile) { return AsMainMapTile<true>(tile); }
+
+/**
+ * Test whether two tiles indices point to the same tile map.
+ * @param a the first tile
+ * @param b the second tile
+ * @return if tiles are on the same map
+ */
+template <bool TgenericA, bool TgenericB>
+static inline bool IsSameMap(typename TileIndexT<TgenericA>::T a, typename TileIndexT<TgenericB>::T b)
+{
+	return MapOf(a) == MapOf(b);
+}
+/** @copydoc IsSameMap(TileIndexT<TgenericA>::T,TileIndexT<TgenericB>::T) */
+static inline bool IsSameMap(TileIndex a, TileIndex b) { return true; }
+/** @copydoc IsSameMap(TileIndexT<TgenericA>::T,TileIndexT<TgenericB>::T) */
+static inline bool IsSameMap(GenericTileIndex a, GenericTileIndex b) { return IsSameMap<true, true>(a, b); }
+
+/**
+ * Test if a given tile index is valid.
+ * @param tile the tile index
+ * @return wheteher the tile index points to an existing tile
+ */
+template <bool Tgeneric>
+static inline bool IsValidTileIndex(typename TileIndexT<Tgeneric>::T tile);
+
+template <>
+inline bool IsValidTileIndex<false>(TileIndex tile)
+{
+	return tile < MapSize();
+}
+
+template <>
+inline bool IsValidTileIndex<true>(GenericTileIndex tile)
+{
+	return MapOf(tile) != NULL && IndexOf(tile) < MapSize(MapOf(tile));
+}
+
+/** @copydoc IsValidTileIndex(TileIndexT<Tgeneric>::T) */
+static inline bool IsValidTileIndex(TileIndex tile) { return IsValidTileIndex<false>(tile); }
+/** @copydoc IsValidTileIndex(TileIndexT<Tgeneric>::T) */
+static inline bool IsValidTileIndex(GenericTileIndex tile) { return IsValidTileIndex<true>(tile); }
+
+/**
+ * Create a tile index.
+ * @param index the index of the tile
+ * @param map the map of the tile
+ *
+ * @pre Tgeneric || map == &_main_map
+ */
+template <bool Tgeneric>
+static inline typename TileIndexT<Tgeneric>::T MakeTileIndex(RawTileIndex index, Map *map);
+
+template <>
+inline TileIndex MakeTileIndex<false>(RawTileIndex index, Map *map)
+{
+	assert(map == &_main_map);
+	return index;
+}
+
+template <>
+inline GenericTileIndex MakeTileIndex<true>(RawTileIndex index, Map *map)
+{
+	return GenericTileIndex(index, map);
+}
+
+/**
  * Returns the TileIndex of a coordinate.
  *
  * @param x The x coordinate of the tile
@@ -168,6 +360,33 @@
 }
 
 /**
+ * Returns the tile index of a coordinate.
+ *
+ * @param x The x coordinate of the tile
+ * @param y The y coordinate of the tile
+ * @param map The map of the tile
+ * @return The tile index calculated by the coordinate
+ */
+template <bool Tgeneric>
+static inline typename TileIndexT<Tgeneric>::T TileXY(uint x, uint y, Map *map);
+
+template <>
+inline TileIndex TileXY<false>(uint x, uint y, Map *map)
+{
+	assert(map == &_main_map);
+	return TileXY(x, y);
+}
+
+template <>
+inline GenericTileIndex TileXY<true>(uint x, uint y, Map *map)
+{
+	return GenericTileIndex(y * MapSizeX(map) + x, map);
+}
+
+/** @copydoc TileXY(uint,uint,Map*) */
+static inline GenericTileIndex TileXY(uint x, uint y, Map *map) { return TileXY<true>(x, y, map); }
+
+/**
  * Calculates an offset for the given coordinate(-offset).
  *
  * This function calculate an offset value which can be added to an
@@ -178,13 +397,13 @@
  * @return The resulting offset value of the given coordinate
  * @see ToTileIndexDiff(TileIndexDiffC)
  */
-static inline TileIndexDiff TileDiffXY(int x, int y)
+static inline TileIndexDiff TileDiffXY(int x, int y, Map *map = &_main_map)
 {
 	/* Multiplication gives much better optimization on MSVC than shifting.
 	 * 0 << shift isn't optimized to 0 properly.
 	 * Typically x and y are constants, and then this doesn't result
 	 * in any actual multiplication in the assembly code.. */
-	return (y * MapSizeX()) + x;
+	return (y * MapSizeX(map)) + x;
 }
 
 /**
@@ -204,21 +423,51 @@
  * @param tile the tile to get the X component of
  * @return the X component
  */
-static inline uint TileX(TileIndex tile)
+template <bool Tgeneric>
+static inline uint TileX(typename TileIndexT<Tgeneric>::T tile);
+
+template <>
+inline uint TileX<false>(TileIndex tile)
 {
 	return tile & MapMaxX();
 }
 
+template <>
+inline uint TileX<true>(GenericTileIndex tile)
+{
+	return IndexOf(tile) % MapSizeX(MapOf(tile));
+}
+
+/** @copydoc TileX(TileIndexT<Tgeneric>::T) */
+static inline uint TileX(TileIndex tile) { return TileX<false>(tile); }
+/** @copydoc TileX(TileIndexT<Tgeneric>::T) */
+static inline uint TileX(GenericTileIndex tile) { return TileX<true>(tile); }
+
 /**
  * Get the Y component of a tile
  * @param tile the tile to get the Y component of
  * @return the Y component
  */
-static inline uint TileY(TileIndex tile)
+template <bool Tgeneric>
+static inline uint TileY(typename TileIndexT<Tgeneric>::T tile);
+
+template <>
+inline uint TileY<false>(TileIndex tile)
 {
 	return tile >> MapLogX();
 }
 
+template <>
+inline uint TileY<true>(GenericTileIndex tile)
+{
+	return IndexOf(tile) / MapSizeX(MapOf(tile));
+}
+
+/** @copydoc TileX(TileIndexT<Tgeneric>::T) */
+static inline uint TileY(TileIndex tile) { return TileY<false>(tile); }
+/** @copydoc TileX(TileIndexT<Tgeneric>::T) */
+static inline uint TileY(GenericTileIndex tile) { return TileY<true>(tile); }
+
 /**
  * Return the offset between to tiles from a TileIndexDiffC struct.
  *
@@ -234,30 +483,77 @@
 	return (tidc.y << MapLogX()) + tidc.x;
 }
 
+/**
+ * Return the offset between two tiles from a TileIndexDiffC struct.
+ *
+ * This function works like #TileDiffXY(int, int) and returns the
+ * difference between two tiles.
+ *
+ * @param tidc The coordinate of the offset as TileIndexDiffC
+ * @return The difference between two tiles.
+ * @see TileDiffXY(int, int)
+ */
+template <bool Tgeneric>
+static inline TileIndexDiff ToTileIndexDiff(TileIndexDiffC tidc, Map *map);
+
+template <>
+inline TileIndexDiff ToTileIndexDiff<false>(TileIndexDiffC tidc, Map *map)
+{
+	assert(map == &_main_map);
+	return ToTileIndexDiff(tidc);
+}
+
+template <>
+inline TileIndexDiff ToTileIndexDiff<true>(TileIndexDiffC tidc, Map *map)
+{
+	return (tidc.y * MapSizeX(map)) + tidc.x;
+}
+
+/** @copydoc ToTileIndexDiff(TileIndexDiffC,Map*) */
+static inline TileIndexDiff ToTileIndexDiff(TileIndexDiffC tidc, Map *map) { return ToTileIndexDiff<true>(tidc, map); }
+
 
 #ifndef _DEBUG
 	/**
-	 * Adds to tiles together.
+	 * Adds a given offset to a tile.
 	 *
-	 * @param x One tile
-	 * @param y Another tile to add
-	 * @return The resulting tile(index)
+	 * @param tile The tile to add to
+	 * @param delta The offset to add
+	 * @return The resulting tile
 	 */
-	#define TILE_ADD(x, y) ((x) + (y))
+	#define TILE_ADD(tile, delta) ((tile) + (delta))
+
+	/**
+	 * Adds a given XY offset to a tile.
+	 *
+	 * @param tile The tile to add an offset on it
+	 * @param x The x offset to add to the tile
+	 * @param y The y offset to add to the tile
+	 * @return The resulting tile
+	 */
+	#define TILE_ADDXY(tile, x, y) ((tile) + TileDiffXY(x, y, MapOf(tile)))
 #else
 	extern TileIndex TileAdd(TileIndex tile, TileIndexDiff add,
 		const char *exp, const char *file, int line);
-	#define TILE_ADD(x, y) (TileAdd((x), (y), #x " + " #y, __FILE__, __LINE__))
-#endif
 
-/**
- * Adds a given offset to a tile.
- *
- * @param tile The tile to add an offset on it
- * @param x The x offset to add to the tile
- * @param y The y offset to add to the tile
- */
-#define TILE_ADDXY(tile, x, y) TILE_ADD(tile, TileDiffXY(x, y))
+	/**
+	 * Adds a given offset to a tile.
+	 *
+	 * @param tile The tile to add to
+	 * @param delta The offset to add
+	 * @return The resulting tile
+	 */
+	#define TILE_ADD(tile, delta) (TileAdd((tile), (delta), #tile " + " #delta, __FILE__, __LINE__))
+
+	GenericTileIndex TileAddXY(GenericTileIndex tile, int x, int y, const char *exp, const char *file, int line);
+
+	static inline TileIndex TileAddXY(TileIndex tile, int x, int y, const char *exp, const char *file, int line)
+	{
+		return AsMainMapTile(TileAddXY(GenericTileIndex(tile), x, y, exp, file, line));
+	}
+
+	#define TILE_ADDXY(tile, ...) TileAddXY((tile), __VA_ARGS__, #tile " + <" #__VA_ARGS__ ">", __FILE__, __LINE__)
+#endif
 
 TileIndex TileAddWrap(TileIndex tile, int addx, int addy);
 
@@ -325,6 +621,55 @@
 	return difference;
 }
 
+/**
+ * Get the offset of transformed northern tile corner.
+ *
+ * When transforming a tile, it's nothern corner can move to other location.
+ * The function retuns difference (TileIndexDiffC) between new and old
+ * locations e.g. when rotating 90 degree left, northern corner becomes
+ * western and the difference is (1, 0).
+ *
+ * Scheme of a tile with corners and offsets: <tt><pre>
+ *               N  (0, 0)
+ *             /   \
+ *    (1, 0)  W     E  (0, 1)
+ *             \   /
+ *               S  (1, 1)
+ * </pre></tt>
+ *
+ * @param transformation The transformation.
+ * @return Offset to new location of northern corner.
+ *
+ * @see TileIndexTransformations
+ */
+static inline TileIndexDiffC TransformedNorthCornerDiffC(DirTransformation transformation)
+{
+	/* lookup tables based on bit arrays */
+	static const byte DIFF_X =
+			0 << DTR_IDENTITY |
+			0 << DTR_ROTATE_90_R |
+			1 << DTR_ROTATE_180 |
+			1 << DTR_ROTATE_90_L |
+			0 << DTR_REFLECT_NE_SW |
+			1 << DTR_REFLECT_W_E |
+			1 << DTR_REFLECT_NW_SE |
+			0 << DTR_REFLECT_N_S;
+	static const byte DIFF_Y =
+			0 << DTR_IDENTITY |
+			1 << DTR_ROTATE_90_R |
+			1 << DTR_ROTATE_180 |
+			0 << DTR_ROTATE_90_L |
+			1 << DTR_REFLECT_NE_SW |
+			1 << DTR_REFLECT_W_E |
+			0 << DTR_REFLECT_NW_SE |
+			0 << DTR_REFLECT_N_S;
+
+	assert(IsValidDirTransform(transformation));
+
+	TileIndexDiffC ret = { (int16)GB(DIFF_X, transformation, 1), (int16)GB(DIFF_Y, transformation, 1) };
+	return ret;
+}
+
 /* Functions to calculate distances */
 uint DistanceManhattan(TileIndex, TileIndex); ///< also known as L1-Norm. Is the shortest distance one could go over diagonal tracks (or roads)
 uint DistanceSquare(TileIndex, TileIndex); ///< euclidian- or L2-Norm squared
@@ -348,6 +693,15 @@
 	return ToTileIndexDiff(_tileoffs_by_diagdir[dir]);
 }
 
+template <bool Tgeneric>
+static inline TileIndexDiff TileOffsByDiagDir(DiagDirection dir, Map *map)
+{
+	extern const TileIndexDiffC _tileoffs_by_diagdir[DIAGDIR_END];
+
+	assert(IsValidDiagDirection(dir));
+	return ToTileIndexDiff<Tgeneric>(_tileoffs_by_diagdir[dir], map);
+}
+
 /**
  * Convert a Direction to a TileIndexDiff.
  *
@@ -362,6 +716,15 @@
 	return ToTileIndexDiff(_tileoffs_by_dir[dir]);
 }
 
+template <bool Tgeneric>
+static inline TileIndexDiff TileOffsByDir(Direction dir, Map *map)
+{
+	extern const TileIndexDiffC _tileoffs_by_dir[DIR_END];
+
+	assert(IsValidDirection(dir));
+	return ToTileIndexDiff<Tgeneric>(_tileoffs_by_dir[dir], map);
+}
+
 /**
  * Adds a DiagDir to a tile.
  *
@@ -369,10 +732,15 @@
  * @param dir The direction in which we want to step
  * @return the moved tile
  */
-static inline TileIndex TileAddByDiagDir(TileIndex tile, DiagDirection dir)
+template <bool Tgeneric>
+static inline typename TileIndexT<Tgeneric>::T TileAddByDiagDir(typename TileIndexT<Tgeneric>::T tile, DiagDirection dir)
 {
-	return TILE_ADD(tile, TileOffsByDiagDir(dir));
+	return TILE_ADDXY(tile, TileIndexDiffCByDiagDir(dir).x, TileIndexDiffCByDiagDir(dir).y);
 }
+/** @copydoc TileAddByDiagDir(TileIndexT<Tgeneric>::T,DiagDirection) */
+static inline TileIndex TileAddByDiagDir(TileIndex tile, DiagDirection dir) { return TileAddByDiagDir<false>(tile, dir); }
+/** @copydoc TileAddByDiagDir(TileIndexT<Tgeneric>::T,DiagDirection) */
+static inline GenericTileIndex TileAddByDiagDir(GenericTileIndex tile, DiagDirection dir) { return TileAddByDiagDir<true>(tile, dir); }
 
 /**
  * Determines the DiagDirection to get from one tile to another.
diff -urNad openttd-1.3.2/src/map_type.h openttd-1.3.2-DC3.0RC3/src/map_type.h
--- openttd-1.3.2/src/map_type.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/map_type.h	2013-11-22 05:49:07.000000000 +0100
@@ -17,13 +17,13 @@
  * Look at docs/landscape.html for the exact meaning of the members.
  */
 struct Tile {
-	byte   type_height; ///< The type (bits 4..7) and height of the northern corner
+	byte   type;        ///< The type
+	byte   height;      ///< The height of the northern corner
 	byte   m1;          ///< Primarily used for ownership information
 	uint16 m2;          ///< Primarily used for indices to towns, industries and stations
 	byte   m3;          ///< General purpose
 	byte   m4;          ///< General purpose
 	byte   m5;          ///< General purpose
-	byte   m6;          ///< Primarily used for bridges and rainforest/desert
 };
 
 /**
@@ -31,7 +31,24 @@
  * Look at docs/landscape.html for the exact meaning of the members.
  */
 struct TileExtended {
-	byte m7; ///< Primarily used for newgrf support
+	byte m6;    ///< Primarily used for bridges and rainforest/desert
+	byte m7;    ///< Primarily used for newgrf support
+};
+
+/** Tile array. */
+struct Map {
+	uint size_x;      ///< Size of the map along the X
+	uint size_y;      ///< Size of the map along the Y
+	uint size;        ///< The number of tiles on the map
+	Tile *m;          ///< Tiles of the map
+	TileExtended *me; ///< Extended Tiles of the map
+};
+
+/** Main tile array. */
+struct MainMap : Map {
+	uint log_x;     ///< 2^log_x == size_x
+	uint log_y;     ///< 2^log_y == size_y
+	uint tile_mask; ///< size - 1 (to mask the mapsize)
 };
 
 /**
@@ -59,9 +76,11 @@
 
 /** Minimal and maximal map width and height */
 static const uint MIN_MAP_SIZE_BITS = 6;                      ///< Minimal size of map is equal to 2 ^ MIN_MAP_SIZE_BITS
-static const uint MAX_MAP_SIZE_BITS = 11;                     ///< Maximal size of map is equal to 2 ^ MAX_MAP_SIZE_BITS
+static const uint MAX_MAP_SIZE_BITS = 20;                     ///< Maximal size of map is equal to 2 ^ MAX_MAP_SIZE_BITS
+static const uint MAX_MAP_TILES_BITS = 26;                    ///< Maximal number of tiles in a map is equal to 2 ^ MAX_MAP_TILES_BITS.
 static const uint MIN_MAP_SIZE      = 1 << MIN_MAP_SIZE_BITS; ///< Minimal map size = 64
-static const uint MAX_MAP_SIZE      = 1 << MAX_MAP_SIZE_BITS; ///< Maximal map size = 2048
+static const uint MAX_MAP_SIZE      = 1 << MAX_MAP_SIZE_BITS; ///< Maximal map size = 8192
+static const uint MAX_MAP_TILES     = 1 << MAX_MAP_TILES_BITS;///< Maximal number of tiles in a map = 2048 * 2048
 
 /**
  * Approximation of the length of a straight track, relative to a diagonal
diff -urNad openttd-1.3.2/src/misc.cpp openttd-1.3.2-DC3.0RC3/src/misc.cpp
--- openttd-1.3.2/src/misc.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/misc.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -59,6 +59,7 @@
 	_pause_mode = PM_UNPAUSED;
 	_fast_forward = 0;
 	_tick_counter = 0;
+	_tick_skip_counter = 0;
 	_cur_tileloop_tile = 1;
 	_thd.redsq = INVALID_TILE;
 	if (reset_settings) MakeNewgameSettingsLive();
@@ -83,6 +84,7 @@
 	InitializeRoadGui();
 	InitializeAirportGui();
 	InitializeDockGui();
+	InitializeGraphPerformance();
 	InitializeObjectGui();
 	InitializeAIGui();
 	InitializeTrees();
@@ -106,6 +108,7 @@
 	InitializeEconomy();
 
 	ResetObjectToPlace();
+	ClearRailPlacementEndpoints();
 
 	GamelogReset();
 	GamelogStartAction(GLAT_START);
diff -urNad openttd-1.3.2/src/misc_gui.cpp openttd-1.3.2-DC3.0RC3/src/misc_gui.cpp
--- openttd-1.3.2/src/misc_gui.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/misc_gui.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -120,14 +120,15 @@
 #	define LANDINFOD_LEVEL 1
 #endif
 		DEBUG(misc, LANDINFOD_LEVEL, "TILE: %#x (%i,%i)", tile, TileX(tile), TileY(tile));
-		DEBUG(misc, LANDINFOD_LEVEL, "type_height  = %#x", _m[tile].type_height);
-		DEBUG(misc, LANDINFOD_LEVEL, "m1           = %#x", _m[tile].m1);
-		DEBUG(misc, LANDINFOD_LEVEL, "m2           = %#x", _m[tile].m2);
-		DEBUG(misc, LANDINFOD_LEVEL, "m3           = %#x", _m[tile].m3);
-		DEBUG(misc, LANDINFOD_LEVEL, "m4           = %#x", _m[tile].m4);
-		DEBUG(misc, LANDINFOD_LEVEL, "m5           = %#x", _m[tile].m5);
-		DEBUG(misc, LANDINFOD_LEVEL, "m6           = %#x", _m[tile].m6);
-		DEBUG(misc, LANDINFOD_LEVEL, "m7           = %#x", _me[tile].m7);
+		DEBUG(misc, LANDINFOD_LEVEL, "type         = %#x", GetTile(tile)->type);
+		DEBUG(misc, LANDINFOD_LEVEL, "height       = %#x", GetTile(tile)->height);
+		DEBUG(misc, LANDINFOD_LEVEL, "m1           = %#x", GetTile(tile)->m1);
+		DEBUG(misc, LANDINFOD_LEVEL, "m2           = %#x", GetTile(tile)->m2);
+		DEBUG(misc, LANDINFOD_LEVEL, "m3           = %#x", GetTile(tile)->m3);
+		DEBUG(misc, LANDINFOD_LEVEL, "m4           = %#x", GetTile(tile)->m4);
+		DEBUG(misc, LANDINFOD_LEVEL, "m5           = %#x", GetTile(tile)->m5);
+		DEBUG(misc, LANDINFOD_LEVEL, "m6           = %#x", GetTileEx(tile)->m6);
+		DEBUG(misc, LANDINFOD_LEVEL, "m7           = %#x", GetTileEx(tile)->m7);
 #undef LANDINFOD_LEVEL
 	}
 
@@ -619,11 +620,13 @@
 	byte paramcount;                  ///< Number of string parameters in #string_id.
 	uint64 params[5];                 ///< The string parameters.
 	TooltipCloseCondition close_cond; ///< Condition for closing the window.
+       char buffer[DRAW_STRING_BUFFER];  ///< Text to draw
 
 	TooltipsWindow(Window *parent, StringID str, uint paramcount, const uint64 params[], TooltipCloseCondition close_tooltip) : Window()
 	{
 		this->parent = parent;
 		this->string_id = str;
+               if (this->paramcount == 0) GetString(this->buffer, str, lastof(this->buffer)); // Get the text while params are still around
 		assert_compile(sizeof(this->params[0]) == sizeof(params[0]));
 		assert(paramcount <= lengthof(this->params));
 		memcpy(this->params, params, sizeof(this->params[0]) * paramcount);
@@ -674,10 +677,14 @@
 		GfxFillRect(r.left, r.top, r.right, r.bottom, PC_BLACK);
 		GfxFillRect(r.left + 1, r.top + 1, r.right - 1, r.bottom - 1, PC_LIGHT_YELLOW);
 
-		for (uint arg = 0; arg < this->paramcount; arg++) {
-			SetDParam(arg, this->params[arg]);
+		if (this->paramcount == 0) {
+			DrawStringMultiLine(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP, r.bottom - WD_FRAMERECT_BOTTOM, this->buffer, TC_FROMSTRING, SA_CENTER);
+		} else {
+			for (uint arg = 0; arg < this->paramcount; arg++) {
+				SetDParam(arg, this->params[arg]);
+			}
+			DrawStringMultiLine(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP, r.bottom - WD_FRAMERECT_BOTTOM, this->string_id, TC_FROMSTRING, SA_CENTER);
 		}
-		DrawStringMultiLine(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP, r.bottom - WD_FRAMERECT_BOTTOM, this->string_id, TC_FROMSTRING, SA_CENTER);
 	}
 
 	virtual void OnMouseLoop()
diff -urNad openttd-1.3.2/src/network/network_command.cpp openttd-1.3.2-DC3.0RC3/src/network/network_command.cpp
--- openttd-1.3.2/src/network/network_command.cpp	2013-07-27 17:09:36.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/network/network_command.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -49,6 +49,7 @@
 	/* 0x19 */ CcStartStopVehicle,
 	/* 0x1A */ CcGame,
 	/* 0x1B */ CcAddVehicleNewGroup,
+	/* 0x1C */ CcPaste,
 };
 
 /**
diff -urNad openttd-1.3.2/src/network/network_gui.cpp openttd-1.3.2-DC3.0RC3/src/network/network_gui.cpp
--- openttd-1.3.2/src/network/network_gui.cpp	2013-07-27 17:09:36.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/network/network_gui.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -31,6 +31,8 @@
 #include "../core/geometry_func.hpp"
 #include "../genworld.h"
 #include "../map_type.h"
+#include "../newgrf.h"
+#include "../error.h"
 
 #include "../widgets/network_widget.h"
 
@@ -1160,6 +1162,14 @@
 			}
 
 			case WID_NSS_GENERATE_GAME: // Start game
+                               {
+                                       int numof_opened_grfs = CountSelectedGRFs (_grfconfig_newgame);
+                                       DEBUG(grf, 0,  "numof_opened_grfs = %d", numof_opened_grfs);
+                                       if ( numof_opened_grfs >= MAX_FILE_SLOTS_IN_NETWORK ) {
+                                               ShowErrorMessage(STR_NEWGRF_ERROR_TOO_MANY_NEWGRFS_LOADED, INVALID_STRING_ID, WL_ERROR);
+                                               break; // break case NSSW_START
+                                       }
+                               }
 				_is_network_server = true;
 				if (_ctrl_pressed) {
 					StartNewGameWithoutGUI(GENERATE_NEW_SEED);
@@ -1643,8 +1653,7 @@
 }
 
 /* The window below gives information about the connected clients
- *  and also makes able to give money to them, kick them (if server)
- *  and stuff like that. */
+ * and also makes able to kick them (if server) and stuff like that. */
 
 extern void DrawCompanyIcon(CompanyID cid, int x, int y);
 
@@ -1676,11 +1685,6 @@
 	NetworkServerKickOrBanIP(ci->client_id, true);
 }
 
-static void ClientList_GiveMoney(const NetworkClientInfo *ci)
-{
-	ShowNetworkGiveMoneyWindow(ci->client_playas);
-}
-
 static void ClientList_SpeakToClient(const NetworkClientInfo *ci)
 {
 	ShowNetworkChatQueryWindow(DESTTYPE_CLIENT, ci->client_id);
@@ -1739,13 +1743,6 @@
 		}
 		this->AddAction(STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL, &ClientList_SpeakToAll);
 
-		if (_network_own_client_id != ci->client_id) {
-			/* We are no spectator and the company we want to give money to is no spectator and money gifts are allowed. */
-			if (Company::IsValidID(_local_company) && Company::IsValidID(ci->client_playas) && _settings_game.economy.give_money) {
-				this->AddAction(STR_NETWORK_CLIENTLIST_GIVE_MONEY, &ClientList_GiveMoney);
-			}
-		}
-
 		/* A server can kick clients (but not himself). */
 		if (_network_server && _network_own_client_id != ci->client_id) {
 			this->AddAction(STR_NETWORK_CLIENTLIST_KICK, &ClientList_Kick);
diff -urNad openttd-1.3.2/src/newgrf_airport.cpp openttd-1.3.2-DC3.0RC3/src/newgrf_airport.cpp
--- openttd-1.3.2/src/newgrf_airport.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/newgrf_airport.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -60,6 +60,7 @@
 	AirportClass::Get(AirportClass::Allocate('SMAL'))->name = STR_AIRPORT_CLASS_SMALL;
 	AirportClass::Get(AirportClass::Allocate('LARG'))->name = STR_AIRPORT_CLASS_LARGE;
 	AirportClass::Get(AirportClass::Allocate('HUB_'))->name = STR_AIRPORT_CLASS_HUB;
+	AirportClass::Get(AirportClass::Allocate('HUGE'))->name = STR_AIRPORT_CLASS_HUGE;
 	AirportClass::Get(AirportClass::Allocate('HELI'))->name = STR_AIRPORT_CLASS_HELIPORTS;
 }
 
diff -urNad openttd-1.3.2/src/newgrf_airport.h openttd-1.3.2-DC3.0RC3/src/newgrf_airport.h
--- openttd-1.3.2/src/newgrf_airport.h	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/newgrf_airport.h	2013-11-22 05:49:07.000000000 +0100
@@ -28,10 +28,14 @@
 };
 
 /** Iterator to iterate over all tiles belonging to an airport spec. */
-class AirportTileTableIterator : public TileIterator {
+template <bool Tgeneric>
+class AirportTileTableIteratorT : public TileIteratorT<Tgeneric> {
+public:
+	typedef typename TileIteratorT<Tgeneric>::TileIndexType TileIndexType;
+
 private:
 	const AirportTileTable *att; ///< The offsets.
-	TileIndex base_tile;         ///< The tile we base the offsets off.
+	TileIndexType base_tile;         ///< The tile we base the offsets off.
 
 public:
 	/**
@@ -39,17 +43,17 @@
 	 * @param att The TileTable we want to iterate over.
 	 * @param base_tile The basetile for all offsets.
 	 */
-	AirportTileTableIterator(const AirportTileTable *att, TileIndex base_tile) : TileIterator(base_tile + ToTileIndexDiff(att->ti)), att(att), base_tile(base_tile)
+	AirportTileTableIteratorT(const AirportTileTable *att, TileIndexType base_tile) : TileIteratorT<Tgeneric>(base_tile + ToTileIndexDiff<Tgeneric>(att->ti, MapOf(base_tile))), att(att), base_tile(base_tile)
 	{
 	}
 
-	inline TileIterator& operator ++()
+	inline TileIteratorT<Tgeneric>& operator ++()
 	{
 		this->att++;
 		if (this->att->ti.x == -0x80) {
-			this->tile = INVALID_TILE;
+			IndexOf(this->tile) = INVALID_TILE_INDEX;
 		} else {
-			this->tile = this->base_tile + ToTileIndexDiff(this->att->ti);
+			this->tile = this->base_tile + ToTileIndexDiff<Tgeneric>(this->att->ti, MapOf(this->base_tile));
 		}
 		return *this;
 	}
@@ -60,18 +64,21 @@
 		return this->att->gfx;
 	}
 
-	virtual AirportTileTableIterator *Clone() const
+	virtual AirportTileTableIteratorT<Tgeneric> *Clone() const
 	{
-		return new AirportTileTableIterator(*this);
+		return new AirportTileTableIteratorT<Tgeneric>(*this);
 	}
 };
 
+typedef AirportTileTableIteratorT<false> AirportTileTableIterator;
+
 /** List of default airport classes. */
 enum AirportClassID {
 	APC_BEGIN     = 0,  ///< Lowest valid airport class id
 	APC_SMALL     = 0,  ///< id for small airports class
 	APC_LARGE,          ///< id for large airports class
 	APC_HUB,            ///< id for hub airports class
+	APC_HUGE,           ///< id for huge airports class
 	APC_HELIPORT,       ///< id for heliports
 	APC_MAX       = 16, ///< maximum number of airport classes
 };
@@ -115,6 +122,8 @@
 	AirportClassID cls_id;                 ///< the class to which this airport type belongs
 	SpriteID preview_sprite;               ///< preview sprite for this airport
 	uint16 maintenance_cost;               ///< maintenance cost multiplier
+	byte max_circle;                       ///< maximum amout of aircrafts in circle area of airport
+
 	/* Newgrf data */
 	bool enabled;                          ///< Entity still available (by default true). Newgrf can disable it, though.
 	struct GRFFileProps grf_prop;          ///< Properties related to the grf file.
diff -urNad openttd-1.3.2/src/newgrf_commons.cpp openttd-1.3.2-DC3.0RC3/src/newgrf_commons.cpp
--- openttd-1.3.2/src/newgrf_commons.cpp	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/newgrf_commons.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -349,6 +349,7 @@
 {
 	switch (_settings_game.game_creation.landscape) {
 		case LT_TROPIC: return GetTropicZone(tile);
+		case LT_TEMPERATE:
 		case LT_ARCTIC: {
 			bool has_snow;
 			switch (GetTileType(tile)) {
diff -urNad openttd-1.3.2/src/newgrf.cpp openttd-1.3.2-DC3.0RC3/src/newgrf.cpp
--- openttd-1.3.2/src/newgrf.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/newgrf.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -2574,13 +2574,13 @@
 						for (uint j = 0; j < SNOW_LINE_DAYS; j++) {
 							table[i][j] = buf->ReadByte();
 							if (_cur.grffile->grf_version >= 8) {
-								if (table[i][j] != 0xFF) table[i][j] = table[i][j] * (1 + MAX_TILE_HEIGHT) / 256;
+								if (table[i][j] != 0xFF) table[i][j] = table[i][j] * (1 + _settings_game.construction.max_heightlevel) / 256;
 							} else {
 								if (table[i][j] >= 128) {
 									/* no snow */
 									table[i][j] = 0xFF;
 								} else {
-									table[i][j] = table[i][j] * (1 + MAX_TILE_HEIGHT) / 128;
+									table[i][j] = table[i][j] * (1 + _settings_game.construction.max_heightlevel) / 128;
 								}
 							}
 						}
@@ -3753,6 +3753,9 @@
 			buf->ReadDWord();
 			break;
 
+		/* day length factor */
+//		case 0x18: return _settings_game.economy.day_length_factor;
+
 		default:
 			ret = CIR_UNKNOWN;
 			break;
@@ -5686,8 +5689,11 @@
 		/* case 0x14: // Tile refresh offset to right   not implemented */
 		/* case 0x15: // Tile refresh offset upwards    not implemented */
 		/* case 0x16: // Tile refresh offset downwards  not implemented */
-		/* case 0x17: // temperate snow line            not implemented */
-
+		
+		case 0x17: // temperate snow line
+			*value = _settings_game.construction.snow_in_temperate;
+			return true;
+			
 		case 0x1A: // Always -1
 			*value = UINT_MAX;
 			return true;
@@ -5712,12 +5718,22 @@
 
 		case 0x20: { // snow line height
 			byte snowline = GetSnowLine();
-			if (_settings_game.game_creation.landscape == LT_ARCTIC && snowline <= MAX_TILE_HEIGHT) {
-				*value = Clamp(snowline * (grffile->grf_version >= 8 ? 1 : TILE_HEIGHT), 0, 0xFE);
-			} else {
-				/* No snow */
-				*value = 0xFF;
-			}
+		    if ( snowline <= _settings_game.construction.max_heightlevel )
+		    {
+                       switch (_settings_game.game_creation.landscape)
+                       {
+                       case LT_ARCTIC:
+                               *value = GetSnowLine();
+                               break;
+                       case LT_TEMPERATE:
+                               if (_settings_game.construction.snow_in_temperate)
+                                       *value = GetSnowLine();
+                               else
+                                       *value = 0xFF;
+                       default:
+                               *value = 0xFF;
+                       };
+		    } else { *value = 0xFF; };
 			return true;
 		}
 
@@ -6369,7 +6385,7 @@
 
 		/* The maximum height of the map. */
 		case 0x14:
-			return MAX_TILE_HEIGHT;
+			return _settings_game.construction.max_heightlevel;
 
 		default:
 			grfmsg(2, "ParamSet: Unknown Patch variable 0x%02X.", param);
@@ -9013,6 +9029,9 @@
 
 	InitializeSortedCargoSpecs();
 
+	/* Create dynamic list of cargo legends for smallmap_gui.cpp. */
+	BuildCargoTypesLegend();
+
 	/* Sort the list of industry types. */
 	SortIndustryTypes();
 
@@ -9169,3 +9188,16 @@
 	_tick_counter = tick_counter;
 	_display_opt  = display_opt;
 }
+
+/**
+ * Returns amount of user selected NewGRFs files.
+ */
+int CountSelectedGRFs(GRFConfig *grfconf)
+{	
+	int i = 0;
+	
+	/* Find last entry in the list */
+	for (const GRFConfig *list = grfconf; list != NULL; list = list->next , i++) {
+	}
+	return i;
+}
diff -urNad openttd-1.3.2/src/newgrf_debug_gui.cpp openttd-1.3.2-DC3.0RC3/src/newgrf_debug_gui.cpp
--- openttd-1.3.2/src/newgrf_debug_gui.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/newgrf_debug_gui.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -50,7 +50,7 @@
  */
 static inline uint GetFeatureIndex(uint window_number)
 {
-	return GB(window_number, 0, 24);
+	return GB(window_number, 0, 27);
 }
 
 /**
@@ -62,8 +62,8 @@
  */
 static inline uint GetInspectWindowNumber(GrfSpecFeature feature, uint index)
 {
-	assert((index >> 24) == 0);
-	return (feature << 24) | index;
+	assert((index >> 27) == 0);
+	return (feature << 27) | index;
 }
 
 /**
@@ -240,7 +240,7 @@
  */
 static inline GrfSpecFeature GetFeatureNum(uint window_number)
 {
-	return (GrfSpecFeature)GB(window_number, 24, 8);
+	return (GrfSpecFeature)GB(window_number, 27, 5);
 }
 
 /**
@@ -459,7 +459,7 @@
 			case WID_NGRFI_PARENT: {
 				const NIHelper *nih   = GetFeatureHelper(this->window_number);
 				uint index = nih->GetParent(GetFeatureIndex(this->window_number));
-				::ShowNewGRFInspectWindow((GrfSpecFeature)GB(index, 24, 8), GetFeatureIndex(index), nih->GetGRFID(GetFeatureIndex(this->window_number)));
+				::ShowNewGRFInspectWindow((GrfSpecFeature)GB(index, 27, 5), GetFeatureIndex(index), nih->GetGRFID(GetFeatureIndex(this->window_number)));
 				break;
 			}
 
diff -urNad openttd-1.3.2/src/newgrf_engine.cpp openttd-1.3.2-DC3.0RC3/src/newgrf_engine.cpp
--- openttd-1.3.2/src/newgrf_engine.cpp	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/newgrf_engine.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -565,7 +565,7 @@
 
 			{
 				const Vehicle *w = v->Next();
-				uint16 altitude = v->z_pos - w->z_pos; // Aircraft height - shadow height
+				uint32 altitude = (uint32)(v->z_pos - w->z_pos); // Aircraft height - shadow height
 				byte airporttype = ATP_TTDP_LARGE;
 
 				const Station *st = GetTargetAirportIfValid(Aircraft::From(v));
@@ -1045,6 +1045,11 @@
 	return group->GetResult() + (info_view ? 0 : (v->Next()->Next()->state % group->GetNumResults()));
 }
 
+//void NewVehicleResolverWrapper(ResolverObject *res, EngineID eid, EngineImageType image_type)
+//{
+////	NewVehicleResolver(res, eid, 0);
+//	VehicleResolverObject object(res, eid, false, CBID_NO_CALLBACK, image_type);
+//}
 
 /**
  * Check if a wagon is currently using a wagon override
@@ -1307,3 +1312,4 @@
 	/* Make sure really all bits are set. */
 	assert(v->grf_cache.cache_valid == (1 << NCVV_END) - 1);
 }
+
diff -urNad openttd-1.3.2/src/newgrf_engine.h openttd-1.3.2-DC3.0RC3/src/newgrf_engine.h
--- openttd-1.3.2/src/newgrf_engine.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/newgrf_engine.h	2013-11-22 05:49:07.000000000 +0100
@@ -99,6 +99,9 @@
 void AlterVehicleListOrder(EngineID engine, uint target);
 void CommitVehicleListOrderChanges();
 
+struct ResolverObject;
+//void NewVehicleResolverWrapper(ResolverObject*, EngineID, EngineImageType image_type);
+
 EngineID GetNewEngineID(const GRFFile *file, VehicleType type, uint16 internal_id);
 
 #endif /* NEWGRF_ENGINE_H */
diff -urNad openttd-1.3.2/src/newgrf.h openttd-1.3.2-DC3.0RC3/src/newgrf.h
--- openttd-1.3.2/src/newgrf.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/newgrf.h	2013-11-22 05:49:07.000000000 +0100
@@ -194,5 +194,8 @@
 
 StringID MapGRFStringID(uint32 grfid, StringID str);
 void ShowNewGRFError();
+int  CountSelectedGRFs (GRFConfig *grfconf);
+
+struct TemplateVehicle;
 
 #endif /* NEWGRF_H */
diff -urNad openttd-1.3.2/src/newgrf_house.cpp openttd-1.3.2-DC3.0RC3/src/newgrf_house.cpp
--- openttd-1.3.2/src/newgrf_house.cpp	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/newgrf_house.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -470,6 +470,8 @@
 		DrawGroundSprite(image, GroundSpritePaletteTransform(image, pal, palette));
 	}
 
+	DrawOverlay(ti, MP_HOUSE);
+
 	DrawNewGRFTileSeq(ti, dts, TO_HOUSES, stage, palette);
 }
 
diff -urNad openttd-1.3.2/src/newgrf_industrytiles.cpp openttd-1.3.2-DC3.0RC3/src/newgrf_industrytiles.cpp
--- openttd-1.3.2/src/newgrf_industrytiles.cpp	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/newgrf_industrytiles.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -181,6 +181,8 @@
 		}
 	}
 
+	DrawOverlay(ti, MP_INDUSTRY);
+
 	DrawNewGRFTileSeq(ti, dts, TO_INDUSTRIES, stage, GENERAL_SPRITE_COLOUR(rnd_colour));
 }
 
diff -urNad openttd-1.3.2/src/newgrf_spritegroup.cpp openttd-1.3.2-DC3.0RC3/src/newgrf_spritegroup.cpp
--- openttd-1.3.2/src/newgrf_spritegroup.cpp	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/newgrf_spritegroup.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -170,7 +170,6 @@
 	return (val >> rot) | (val << (32 - rot));
 }
 
-
 /* Evaluate an adjustment for a variable of the given size.
  * U is the unsigned type and S is the signed type to use. */
 template <typename U, typename S>
diff -urNad openttd-1.3.2/src/object_cmd.cpp openttd-1.3.2-DC3.0RC3/src/object_cmd.cpp
--- openttd-1.3.2/src/object_cmd.cpp	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/object_cmd.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -336,6 +336,56 @@
 	return cost;
 }
 
+/**
+ * Build an object object
+ * @param tile end tile of area dragging
+ * @param flags operations to do
+ * @param p1 start tile of area dragging
+ * @param p2 some bit data.
+ * 1: Orthogonal Iterator 0: Diagonal Iterator
+ * @param text unused
+ * @return the cost of this operation or an error
+ */
+CommandCost CmdBuyLand(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
+{
+	if (p1 >= MapSize()) return CMD_ERROR;
+	
+	Money money = GetAvailableMoneyForCommand();
+	CommandCost cost(EXPENSES_CONSTRUCTION);
+	CommandCost last_error = CMD_ERROR;
+	bool had_success = false;
+	const Company *c = (flags & (DC_AUTO | DC_BANKRUPT)) ? NULL : Company::GetIfValid(_current_company);
+	int limit = (c == NULL) ? INT32_MAX : GB(c->clear_limit, 16, 16);
+	
+	TileArea ta(tile, p1);
+	TileIterator *iter = HasBit(p2, 0) ? (TileIterator*) new DiagonalTileIterator(tile, p1) : new OrthogonalTileIterator(ta);
+	
+	for (; *iter != INVALID_TILE; ++(*iter)) {
+		TileIndex t = *iter;
+		CommandCost ret = DoCommand(t, OBJECT_OWNED_LAND, 0, flags & ~DC_EXEC, CMD_BUILD_OBJECT);
+		if (ret.Failed()) {
+			last_error = ret;
+			
+			if (c != NULL && GB(c->clear_limit, 16, 16) < 1) break;
+			continue;
+		}
+		had_success = true;
+		if (flags & DC_EXEC) {
+			money -= ret.GetCost();
+			if (ret.GetCost() > 0 && money < 0) {
+				_additional_cash_required = ret.GetCost();
+				delete iter;
+				return cost;
+			}
+			DoCommand(t, OBJECT_OWNED_LAND, 0, flags, CMD_BUILD_OBJECT);
+		} else {
+			if(ret.GetCost() != 0 && --limit <= 0) break;
+		}
+		cost.AddCost(ret);
+	}
+	delete iter;
+	return had_success ? cost : last_error;
+}
 
 static Foundation GetFoundation_Object(TileIndex tile, Slope tileh);
 
@@ -586,7 +636,7 @@
 	if (GB(r, 0, 8) < (256 / 4 / (6 - level))) {
 		uint amt = GB(r, 0, 8) / 8 / 4 + 1;
 		if (EconomyIsInRecession()) amt = (amt + 1) >> 1;
-		MoveGoodsToStation(CT_PASSENGERS, amt, ST_HEADQUARTERS, GetTileOwner(tile), stations.GetStations());
+		MoveGoodsToStation(CT_PASSENGERS, amt, ST_HEADQUARTERS, GetTileOwner(tile), stations.GetStations(), tile);
 	}
 
 	/* Top town building generates 90, HQ can make up to 196. The
@@ -595,7 +645,7 @@
 	if (GB(r, 8, 8) < (196 / 4 / (6 - level))) {
 		uint amt = GB(r, 8, 8) / 8 / 4 + 1;
 		if (EconomyIsInRecession()) amt = (amt + 1) >> 1;
-		MoveGoodsToStation(CT_MAIL, amt, ST_HEADQUARTERS, GetTileOwner(tile), stations.GetStations());
+		MoveGoodsToStation(CT_MAIL, amt, ST_HEADQUARTERS, GetTileOwner(tile), stations.GetStations(), tile);
 	}
 }
 
@@ -782,4 +832,5 @@
 	NULL,                        // vehicle_enter_tile_proc
 	GetFoundation_Object,        // get_foundation_proc
 	TerraformTile_Object,        // terraform_tile_proc
+	NULL,                        // copypaste_tile_proc
 };
diff -urNad openttd-1.3.2/src/object_map.h openttd-1.3.2-DC3.0RC3/src/object_map.h
--- openttd-1.3.2/src/object_map.h	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/object_map.h	2013-11-22 05:49:07.000000000 +0100
@@ -24,7 +24,7 @@
 static inline ObjectType GetObjectType(TileIndex t)
 {
 	assert(IsTileType(t, MP_OBJECT));
-	return (ObjectType)_m[t].m5;
+	return (ObjectType)GetTile(t)->m5;
 }
 
 /**
@@ -36,7 +36,7 @@
 static inline ObjectID GetObjectIndex(TileIndex t)
 {
 	assert(IsTileType(t, MP_OBJECT));
-	return _m[t].m2;
+	return GetTile(t)->m2;
 }
 
 /**
@@ -80,7 +80,7 @@
 static inline bool IsCompanyHQ(TileIndex t)
 {
 	assert(IsTileType(t, MP_OBJECT));
-	return _m[t].m5 == OBJECT_HQ;
+	return GetTile(t)->m5 == OBJECT_HQ;
 }
 
 /**
@@ -114,7 +114,7 @@
 static inline byte GetObjectRandomBits(TileIndex t)
 {
 	assert(IsTileType(t, MP_OBJECT));
-	return _m[t].m3;
+	return GetTile(t)->m3;
 }
 
 
@@ -133,12 +133,12 @@
 	SetTileType(t, MP_OBJECT);
 	SetTileOwner(t, o);
 	SetWaterClass(t, wc);
-	_m[t].m2 = index;
-	_m[t].m3 = random;
-	_m[t].m4 = 0;
-	_m[t].m5 = u;
-	SB(_m[t].m6, 2, 4, 0);
-	_me[t].m7 = 0;
+	GetTile(t)->m2 = index;
+	GetTile(t)->m3 = random;
+	GetTile(t)->m4 = 0;
+	GetTile(t)->m5 = u;
+	SB(GetTileEx(t)->m6, 2, 4, 0);
+	GetTileEx(t)->m7 = 0;
 }
 
 #endif /* OBJECT_MAP_H */
diff -urNad openttd-1.3.2/src/openttd.cpp openttd-1.3.2-DC3.0RC3/src/openttd.cpp
--- openttd-1.3.2/src/openttd.cpp	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/openttd.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -57,6 +57,7 @@
 #include "hotkeys.h"
 #include "newgrf.h"
 #include "misc/getoptdata.h"
+#include "clipboard_func.h"
 #include "game/game.hpp"
 #include "game/game_config.hpp"
 #include "town.h"
@@ -452,6 +453,12 @@
 		/* Make sure _settings is filled with _settings_newgame if we switch to a game directly */
 		if (_switch_mode != SM_NONE) MakeNewgameSettingsLive();
 
+       // Check if not too much GRFs are loaded for network game
+       if ( dedicated_host != NULL &&  CountSelectedGRFs ( _grfconfig ) >= MAX_FILE_SLOTS_IN_NETWORK ) {
+               // ShowErrorMessage(STR_NEWGRF_ERROR_TOO_MANY_NEWGRFS_LOADED, INVALID_STRING_ID, WL_ERROR);
+               DEBUG(net, 0, "Too many GRF loaded. Max %d are allowed.\nExiting ...", MAX_FILE_SLOTS_IN_NETWORK );
+       }
+       else {
 #ifdef ENABLE_NETWORK
 		if (_network_available && network_conn != NULL) {
 			const char *port = NULL;
@@ -482,6 +489,7 @@
 
 		/* After the scan we're not used anymore. */
 		delete this;
+	   }
 	}
 };
 
@@ -921,6 +929,24 @@
 	MarkWholeScreenDirty();
 }
 
+/*
+ * Too large size may be stored in settings (especially if switching between between OpenTTD
+ * versions with different map size limits), we have to check if it is valid before generating world.
+ * Simple separate checking of X and Y map sizes is not enough, as their sum is what counts for the limit.
+ * Check the size and decrease the larger of the sizes till the size is in limit.
+ */
+static void FixConfigMapSize()
+{
+	while (_settings_game.game_creation.map_x + _settings_game.game_creation.map_y > MAX_MAP_TILES_BITS) {
+		/* Repeat reducing larger of X/Y dimensions until the map size is within allowable limits */
+		if (_settings_game.game_creation.map_x > _settings_game.game_creation.map_y) {
+			_settings_game.game_creation.map_x--;
+		} else {
+			_settings_game.game_creation.map_y--;
+		}
+	}
+}
+
 static void MakeNewGame(bool from_heightmap, bool reset_settings)
 {
 	_game_mode = GM_NORMAL;
@@ -928,6 +954,7 @@
 	ResetGRFConfig(true);
 
 	GenerateWorldSetCallback(&MakeNewGameDone);
+	FixConfigMapSize();
 	GenerateWorld(from_heightmap ? GWM_HEIGHTMAP : GWM_NEWGAME, 1 << _settings_game.game_creation.map_x, 1 << _settings_game.game_creation.map_y, reset_settings);
 }
 
@@ -943,6 +970,7 @@
 	ResetGRFConfig(true);
 
 	GenerateWorldSetCallback(&MakeNewEditorWorldDone);
+	FixConfigMapSize();
 	GenerateWorld(GWM_EMPTY, 1 << _settings_game.game_creation.map_x, 1 << _settings_game.game_creation.map_y);
 }
 
@@ -1030,8 +1058,13 @@
 		}
 	}
 #endif /* ENABLE_NETWORK */
-	/* Make sure all AI controllers are gone at quitting game */
-	if (new_mode != SM_SAVE_GAME) AI::KillAll();
+	if (new_mode != SM_SAVE_GAME) {
+		/* Make sure all AI controllers are gone at quitting game */
+		AI::KillAll();
+
+		/* Clear the clipboard */
+		ClearClipboard();
+	}
 
 	switch (new_mode) {
 		case SM_EDITOR: // Switch to scenario editor
@@ -1088,6 +1121,7 @@
 		case SM_LOAD_HEIGHTMAP: // Load heightmap from scenario editor
 			SetLocalCompany(OWNER_NONE);
 
+			FixConfigMapSize();
 			GenerateWorld(GWM_HEIGHTMAP, 1 << _settings_game.game_creation.map_x, 1 << _settings_game.game_creation.map_y);
 			MarkWholeScreenDirty();
 			break;
@@ -1130,6 +1164,7 @@
 
 		case SM_GENRANDLAND: // Generate random land within scenario editor
 			SetLocalCompany(OWNER_NONE);
+			FixConfigMapSize();
 			GenerateWorld(GWM_RANDOM, 1 << _settings_game.game_creation.map_x, 1 << _settings_game.game_creation.map_y);
 			/* XXX: set date */
 			MarkWholeScreenDirty();
@@ -1338,7 +1373,15 @@
 		IncreaseDate();
 		RunTileLoop();
 		CallVehicleTicks();
-		CallLandscapeTick();
+//		CallLandscapeTick();
+		_tick_skip_counter++;
+		if ( _tick_skip_counter == _settings_game.economy.slow_down_production )
+		    {
+			_tick_skip_counter = 0;
+//			RunTileLoop();
+			CallLandscapeTick();
+		    }
+
 		ClearStorageChanges(true);
 
 		AI::GameLoop();
diff -urNad openttd-1.3.2/src/openttd.h openttd-1.3.2-DC3.0RC3/src/openttd.h
--- openttd-1.3.2/src/openttd.h	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/openttd.h	2013-11-22 06:03:25.000000000 +0100
@@ -44,7 +44,8 @@
 	DO_SHOW_STATION_NAMES  = 1, ///< Display station names.
 	DO_SHOW_SIGNS          = 2, ///< Display signs.
 	DO_FULL_ANIMATION      = 3, ///< Perform palette animation.
-	DO_FULL_DETAIL         = 5, ///< Also draw details of track and roads.
+	DO_RAIL_FENCES         = 4, ///< Draw rail fences.
+	DO_FULL_DETAIL         = 5, ///< Also draw details of roads.
 	DO_SHOW_WAYPOINT_NAMES = 6, ///< Display waypoint names.
 	DO_SHOW_COMPETITOR_SIGNS = 7, ///< Display signs, station names and waypoint names of opponent companies. Buoys and oilrig-stations are always shown, even if this option is turned off.
 };
diff -urNad openttd-1.3.2/src/order_base.h openttd-1.3.2-DC3.0RC3/src/order_base.h
--- openttd-1.3.2/src/order_base.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/order_base.h	2013-11-22 05:49:07.000000000 +0100
@@ -20,6 +20,7 @@
 #include "station_type.h"
 #include "vehicle_type.h"
 #include "date_type.h"
+#include "date_func.h"
 
 typedef Pool<Order, OrderID, 256, 64000> OrderPool;
 typedef Pool<OrderList, OrderListID, 128, 64000> OrderListPool;
@@ -44,6 +45,8 @@
 	CargoID refit_cargo;  ///< Refit CargoID
 	byte refit_subtype;   ///< Refit subtype
 
+	int8 jump_counter;    ///< Counter for the 'jump xx% of times' option
+
 public:
 	Order *next;          ///< Pointer to next order. If NULL, end of list
 
@@ -133,6 +136,14 @@
 
 	void SetRefit(CargoID cargo, byte subtype = 0);
 
+	/**
+	 * Update the jump_counter of this order.
+	 * @param the jump chance in %.
+	 * @return whether to jump or not.
+	 * @pre IsType(OT_CONDITIONAL) && this->GetConditionVariable() == OCV_PERCENT.
+	 */
+	bool UpdateJumpCounter(uint8 percent);
+
 	/** How must the consist be loaded? */
 	inline OrderLoadFlags GetLoadType() const { return (OrderLoadFlags)GB(this->flags, 4, 4); }
 	/** How must the consist be unloaded? */
@@ -192,13 +203,41 @@
 	uint32 Pack() const;
 	uint16 MapOldOrder() const;
 	void ConvertFromOldSavegame();
+
+	static void PostDestructor(size_t index);
 };
 
 void InsertOrder(Vehicle *v, Order *new_o, VehicleOrderID sel_ord);
 void DeleteOrder(Vehicle *v, VehicleOrderID sel_ord);
 
-/**
- * Shared order list linking together the linked list of orders and the list
+/** Working modes for timetable separation. */
+enum TTSepMode {
+	/** Timetable separation works in fully automatic mode, determining its parameters from the situation in game. */
+	TTS_MODE_AUTO,
+
+	/** Timetable separation is deactivated altogether. */
+	TTS_MODE_OFF,
+
+	/** Timetable separation is active in manual time mode. The amount of time between vehicles is set in ticks by the user. */
+	TTS_MODE_MAN_T,
+
+	/** Timetable separation is active in manual number mode. The user sets a number of vehicles that are supposed to be running
+	 *  the timetable simultaneously. The algorithm acts according to this specification regardless of the actual number of
+	 *  running vehicles.*/
+	TTS_MODE_MAN_N,
+
+	/** Timetable separation works in buffered automatic mode that keeps one vehicle waiting at the first stop as
+	 *  reserve for delay compensation and behaves like full automatic otherwise. */
+	TTS_MODE_BUFFERED_AUTO,
+};
+
+struct TTSepSettings {
+	TTSepMode mode;
+	uint num_veh, sep_ticks;
+	TTSepSettings() : mode(TTS_MODE_AUTO), num_veh(0), sep_ticks(0) { }
+};
+
+/** Shared order list linking together the linked list of orders and the list
  *  of vehicles sharing this order list.
  */
 struct OrderList : OrderListPool::PoolItem<&_orderlist_pool> {
@@ -206,19 +245,29 @@
 	friend void AfterLoadVehicles(bool part_of_load); ///< For instantiating the shared vehicle chain
 	friend const struct SaveLoad *GetOrderListDescription(); ///< Saving and loading of order lists.
 
+	/** Returns the number of running (i.e. not stopped) vehicles in the shared orders list. */
+	int GetNumRunningVehicles();
+
 	Order *first;                     ///< First order of the order list.
 	VehicleOrderID num_orders;        ///< NOSAVE: How many orders there are in the list.
 	VehicleOrderID num_manual_orders; ///< NOSAVE: How many manually added orders are there in the list.
 	uint num_vehicles;                ///< NOSAVE: Number of vehicles that share this order list.
 	Vehicle *first_shared;            ///< NOSAVE: pointer to the first vehicle in the shared order chain.
-
 	Ticks timetable_duration;         ///< NOSAVE: Total duration of the order list
+	Ticks last_timetable_init;        ///< Contains the last absolute time of initialization in ticks.
+	uint separation_counter;          ///< Counts the vehicles that arrive at the first shared order for separation timing.
+	bool is_separation_valid;         ///< Is true if the separation has been initialized since last load or vehicle list change.
+	Ticks current_separation;         ///< The current separation between vehicles in the shared order list.
+	TTSepMode current_sep_mode;       ///< The current mode of vehicle separation.
+	uint num_sep_vehicles;            ///< Number of planned vehicles for separation.
 
 public:
 	/** Default constructor producing an invalid order list. */
 	OrderList(VehicleOrderID num_orders = INVALID_VEH_ORDER_ID)
 		: first(NULL), num_orders(num_orders), num_manual_orders(0), num_vehicles(0), first_shared(NULL),
-		  timetable_duration(0) { }
+		  timetable_duration(0), last_timetable_init(INVALID_TICKS), separation_counter(0),
+		  is_separation_valid(false), current_separation(INVALID_TICKS), current_sep_mode(TTS_MODE_OFF),
+		  num_sep_vehicles(0) { }
 
 	/**
 	 * Create an order list with the given order chain for the given vehicle.
@@ -280,6 +329,26 @@
 	 */
 	inline uint GetNumVehicles() const { return this->num_vehicles; }
 
+	/**
+	 * Returns the amount of separation time between vehicles.
+	 * @return the amount of separation time between vehicles.
+	 */
+	inline uint GetSepTime() const
+	{
+		if (!this->IsCompleteTimetable()) {
+			return 0;
+		} else if (this->is_separation_valid) {
+			return this->current_separation;
+		} else {
+			return this->GetTimetableTotalDuration() / this->GetNumVehicles();
+		}
+	}
+
+	TTSepSettings GetSepSettings();
+
+	void SetSepSettings(TTSepSettings s);
+	void SetSepSettings(TTSepMode Mode, uint Parameter);
+
 	bool IsVehicleInSharedOrdersList(const Vehicle *v) const;
 	int GetPositionInSharedOrderList(const Vehicle *v) const;
 
@@ -313,6 +382,64 @@
 	 */
 	void UpdateOrderTimetable(Ticks delta) { this->timetable_duration += delta; }
 
+	/**
+	 * Gets the last absolute time in Ticks since separation was initalized.
+	 * @return last arrival time of first vehicle at first order.
+	 */
+	inline Ticks GetSeparationInitTime() const
+	{
+		return this->last_timetable_init;
+	}
+
+	/**
+	 * Gets the current value of the timetable separation counter.
+	 * @return the current value of the timetable separation counter.
+	 */
+	inline uint GetSeparationCounter() const
+	{
+		return this->separation_counter;
+	}
+
+	/** Increases the timetable separation counter. */
+	void IncreaseSeparationCounter()
+	{
+		this->separation_counter++;
+	}
+
+	/** Marks timetable separation invalid so it has to be initialized again. */
+	void MarkSeparationInvalid()
+	{
+		if ((this->current_sep_mode == TTS_MODE_AUTO)||(this->current_sep_mode == TTS_MODE_BUFFERED_AUTO))
+			this->is_separation_valid = false;
+	}
+
+	/**
+	 * Returns the new delay for the current vehicle and increases the separation counter.
+	 * @return the new delay
+	 */
+	Ticks SeparateVehicle();
+
+	/**
+	 * Gets whether the timetable separation is currently valid or not.
+	 * @return whether the timetable separation is currently valid or not.
+	 */
+	inline bool IsSeparationValid() const
+	{
+		return this->is_separation_valid;
+	}
+
+	/**
+	 * Gets whether timetable separation is currently switched on or not.
+	 * @return whether the timetable separation is currently switched on or not.
+	 */
+	inline bool IsSeparationOn() const
+	{
+		return this->current_sep_mode != TTS_MODE_OFF;
+	}
+
+	/** Initializes the separation system. */
+	void InitializeSeparation();
+
 	void FreeChain(bool keep_orderlist = false);
 
 	void DebugCheckSanity() const;
diff -urNad openttd-1.3.2/src/order_cmd.cpp openttd-1.3.2-DC3.0RC3/src/order_cmd.cpp
--- openttd-1.3.2/src/order_cmd.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/order_cmd.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -17,6 +17,11 @@
 #include "news_func.h"
 #include "strings_func.h"
 #include "timetable.h"
+#include "station_base.h"
+#include "station_map.h"
+#include "station_func.h"
+#include "map_func.h"
+#include "cargotype.h"
 #include "vehicle_func.h"
 #include "depot_base.h"
 #include "core/pool_func.hpp"
@@ -25,7 +30,9 @@
 #include "station_base.h"
 #include "waypoint_base.h"
 #include "company_base.h"
+#include "infrastructure_func.h"
 #include "order_backup.h"
+#include "cargodest_func.h"
 
 #include "table/strings.h"
 
@@ -119,6 +126,17 @@
 /**
  * Makes this order a Leave Station order.
  */
+
+bool Order::UpdateJumpCounter(byte percent)
+{
+	if(this->jump_counter >= 0) {
+		this->jump_counter += (percent - 100);
+		return true;
+	}
+	this->jump_counter += percent;
+	return false;
+}
+
 void Order::MakeLeaveStation()
 {
 	this->type = OT_LEAVESTATION;
@@ -241,10 +259,26 @@
 	this->refit_subtype = 0;
 	this->wait_time     = 0;
 	this->travel_time   = 0;
+	this->jump_counter  = 0;
 	this->max_speed     = UINT16_MAX;
 }
 
 /**
+ * Invalidating some stuff after removing item from the pool.
+ * @param index index of deleted item.
+ */
+/* static */ void Order::PostDestructor(size_t index)
+{
+	Vehicle *v;
+	FOR_ALL_VEHICLES(v) {
+		if (v->current_order.index == index) v->current_order.index = INVALID_ORDER;
+		if (v->last_order_id == index) v->last_order_id = INVALID_ORDER;
+	}
+
+	InvalidateOrderRouteLinks((OrderID)index);
+}
+
+/**
  *
  * Updates the widgets of a vehicle which contains the order-data
  *
@@ -257,11 +291,13 @@
 		/* Calls SetDirty() too */
 		InvalidateWindowData(WC_VEHICLE_ORDERS,    v->index, data);
 		InvalidateWindowData(WC_VEHICLE_TIMETABLE, v->index, data);
+		InvalidateWindowData(WC_VEHICLE_TRIP_HISTORY, v->index, data);
 		return;
 	}
 
 	SetWindowDirty(WC_VEHICLE_ORDERS,    v->index);
 	SetWindowDirty(WC_VEHICLE_TIMETABLE, v->index);
+	SetWindowDirty(WC_VEHICLE_TRIP_HISTORY, v->index);
 }
 
 /**
@@ -281,6 +317,8 @@
 	this->refit_subtype = other.refit_subtype;
 
 	this->wait_time   = other.wait_time;
+
+	this->jump_counter = other.jump_counter;
 	this->travel_time = other.travel_time;
 	this->max_speed   = other.max_speed;
 }
@@ -529,6 +567,146 @@
 			this->num_vehicles, this->timetable_duration);
 }
 
+/** Returns the number of running (i.e. not stopped) vehicles in the shared orders list. */
+int OrderList::GetNumRunningVehicles()
+{
+	int num_running_vehicles = 0;
+
+	for (const Vehicle *v = this->first_shared; v != NULL; v = v->NextShared()) {
+		if (!(v->vehstatus & (VS_STOPPED | VS_CRASHED))) num_running_vehicles++;
+	}
+
+	return num_running_vehicles;
+}
+
+/** (Re-)Initializes Separation if necessary and possible. */
+void OrderList::InitializeSeparation()
+{
+	// Check whether separation can be used at all
+	if(!this->IsCompleteTimetable() || this->current_sep_mode == TTS_MODE_OFF) {
+		this->is_separation_valid = false;
+		return;
+	}
+
+	// Save current tick count as reference for future timetable start dates and reset the separation counter.
+	this->last_timetable_init = GetCurrentTickCount();
+	this->separation_counter = 0;
+
+	// Calculate separation amount depending on mode of operation.
+	switch (current_sep_mode) {
+	case TTS_MODE_AUTO: {
+		int num_running_vehicles = this->GetNumRunningVehicles();
+		assert(num_running_vehicles > 0);
+
+		this->current_separation = this->GetTimetableTotalDuration() / num_running_vehicles;
+		break;
+	}
+
+	case TTS_MODE_MAN_N:
+		this->current_separation = this->GetTimetableTotalDuration() / this->num_sep_vehicles;
+		break;
+
+	case TTS_MODE_MAN_T:
+		// separation is set manually -> nothing to do
+		break;
+
+	case TTS_MODE_BUFFERED_AUTO: {
+		int num_running_vehicles = this->GetNumRunningVehicles();
+		assert(num_running_vehicles > 0);
+
+		if(num_running_vehicles > 1)
+			num_running_vehicles--;
+
+		this->current_separation = this->GetTimetableTotalDuration() / num_running_vehicles;
+		break;
+	}
+
+	default:
+		NOT_REACHED();
+		break;
+	}
+
+	this->is_separation_valid = true;
+}
+
+/**
+ * Returns the delay setting required for correct separation and increases the separation counter by 1.
+ * @return the delay setting required for correct separation. */
+Ticks OrderList::SeparateVehicle()
+{
+	if (!this->is_separation_valid || this->current_sep_mode == TTS_MODE_OFF)
+		return INVALID_TICKS;
+
+	Ticks result = GetCurrentTickCount() - (this->separation_counter * this->current_separation + this->last_timetable_init);
+	this->separation_counter++;
+
+	return result;
+}
+
+/**
+ * Returns the current separation settings.
+ * @return the current separation settings.
+ */
+TTSepSettings OrderList::GetSepSettings()
+{
+	TTSepSettings result;
+
+	result.mode = this->current_sep_mode;
+	result.sep_ticks = GetSepTime();
+
+	// Depending on the operation mode return either the user setting or the true amount of vehicles running the timetable.
+	result.num_veh = (result.mode == TTS_MODE_MAN_N) ? this->num_sep_vehicles : GetNumVehicles();
+	return result;
+}
+
+/**
+ * Prepares command to set new separation settings.
+ * @param s Contains the new settings to be used for separation.
+ * @todo Clean this up (e.g. via union type)
+ */
+void OrderList::SetSepSettings(TTSepSettings s)
+{
+	uint32 p2 = GB<uint32>(s.mode, 0, 3);
+	AB<uint32, uint>(p2, 3, 28, (s.mode == TTS_MODE_MAN_N) ? s.num_veh : s.sep_ticks);
+	DoCommandP(0, this->first_shared->index, p2, CMD_REINIT_SEPARATION);
+}
+
+/**
+ * Sets new separation settings.
+ * @param mode      Contains the operation mode that is to be used for separation.
+ * @param parameter Depending on the operation mode this contains either the number of vehicles (#TTS_MODE_MAN_N)
+ *                  or the time between vehicles in ticks (#TTS_MODE_MAN_T). For other modes, this is undefined.
+ */
+void OrderList::SetSepSettings(TTSepMode mode, uint32 parameter)
+{
+	this->current_sep_mode = mode;
+
+	switch (this->current_sep_mode)
+	{
+	case TTS_MODE_MAN_N:
+		this->current_separation = this->GetTimetableTotalDuration() / parameter;
+		this->num_sep_vehicles = parameter;
+		break;
+
+	case TTS_MODE_MAN_T:
+		this->current_separation = parameter;
+		this->num_sep_vehicles = this->GetTimetableTotalDuration() / this->current_separation;
+		break;
+
+	case TTS_MODE_AUTO:
+	case TTS_MODE_BUFFERED_AUTO:
+	case TTS_MODE_OFF:
+		/* nothing to do */
+		break;
+
+	default:
+		NOT_REACHED();
+		break;
+	}
+
+	this->is_separation_valid = false;
+}
+
 /**
  * Checks whether the order goes to a station or not, i.e. whether the
  * destination is a station
@@ -640,7 +818,7 @@
 			if (st == NULL) return CMD_ERROR;
 
 			if (st->owner != OWNER_NONE) {
-				CommandCost ret = CheckOwnership(st->owner);
+				CommandCost ret = CheckInfraUsageAllowed(v->type, st->owner);
 				if (ret.Failed()) return ret;
 			}
 
@@ -685,7 +863,7 @@
 
 					if (st == NULL) return CMD_ERROR;
 
-					CommandCost ret = CheckOwnership(st->owner);
+					CommandCost ret = CheckInfraUsageAllowed(v->type, st->owner);
 					if (ret.Failed()) return ret;
 
 					if (!CanVehicleUseStation(v, st) || !st->airport.HasHangar()) {
@@ -696,7 +874,7 @@
 
 					if (dp == NULL) return CMD_ERROR;
 
-					CommandCost ret = CheckOwnership(GetTileOwner(dp->xy));
+					CommandCost ret = CheckInfraUsageAllowed(v->type, GetTileOwner(dp->xy), dp->xy);
 					if (ret.Failed()) return ret;
 
 					switch (v->type) {
@@ -734,7 +912,7 @@
 				case VEH_TRAIN: {
 					if (!(wp->facilities & FACIL_TRAIN)) return_cmd_error(STR_ERROR_CAN_T_ADD_ORDER);
 
-					CommandCost ret = CheckOwnership(wp->owner);
+					CommandCost ret = CheckInfraUsageAllowed(v->type, wp->owner);
 					if (ret.Failed()) return ret;
 					break;
 				}
@@ -742,7 +920,7 @@
 				case VEH_SHIP:
 					if (!(wp->facilities & FACIL_DOCK)) return_cmd_error(STR_ERROR_CAN_T_ADD_ORDER);
 					if (wp->owner != OWNER_NONE) {
-						CommandCost ret = CheckOwnership(wp->owner);
+						CommandCost ret = CheckInfraUsageAllowed(v->type, wp->owner);
 						if (ret.Failed()) return ret;
 					}
 					break;
@@ -763,6 +941,10 @@
 			OrderConditionComparator occ = new_order.GetConditionComparator();
 			if (occ >= OCC_END) return CMD_ERROR;
 			switch (new_order.GetConditionVariable()) {
+				case OCV_CARGO_WAITING:
+				case OCV_CARGO_ACCEPTANCE:
+					if (!CargoSpec::Get(new_order.GetConditionValue())->IsValid()) return CMD_ERROR;
+					/* FALL THROUGH */
 				case OCV_REQUIRES_SERVICE:
 					if (occ != OCC_IS_TRUE && occ != OCC_IS_FALSE) return CMD_ERROR;
 					break;
@@ -772,6 +954,14 @@
 					if (new_order.GetConditionValue() != 0) return CMD_ERROR;
 					break;
 
+				case OCV_FREE_PLATFORMS:
+					if (v->type != VEH_TRAIN) return CMD_ERROR;
+					if (occ == OCC_IS_TRUE || occ == OCC_IS_FALSE) return CMD_ERROR;
+					break;
+
+				case OCV_PERCENT:
+					if (occ != OCC_EQUALS) return CMD_ERROR;
+					/* FALL THROUGH */
 				case OCV_LOAD_PERCENTAGE:
 				case OCV_RELIABILITY:
 					if (new_order.GetConditionValue() > 100) return CMD_ERROR;
@@ -902,6 +1092,8 @@
 		cur_order_id++;
 	}
 
+	PrefillRouteLinks(v);
+
 	/* Make sure to rebuild the whole list */
 	InvalidateWindowClassesData(GetWindowClassForVehicleType(v->type), 0);
 }
@@ -922,6 +1114,20 @@
 }
 
 /**
+ * Get the first cargoID that points to a valid cargo (usually 0)
+ */
+static CargoID GetFirstValidCargo()
+{
+	for (CargoID i = 0; i < NUM_CARGO; i++) {
+		if (CargoSpec::Get(i)->IsValid()) return i;
+	}
+	/* No cargos defined -> 'Houston, we have a problem!' */
+	assert(0);
+	/* Return something to avoid compiler warning */
+	return 0;
+}
+
+/**
  * Delete an order from the orderlist of a vehicle.
  * @param tile unused
  * @param flags operation to perform
@@ -967,6 +1173,17 @@
 }
 
 /**
+ * Invalidate the next unload station of all cargo packets of a vehicle chain.
+ * @param v The vehicle.
+ */
+static void InvalidateNextStation(Vehicle *v)
+{
+	for (; v != NULL; v = v->Next()) {
+		v->cargo.InvalidateNextStation();
+	}
+}
+
+/**
  * Delete an order but skip the parameter validation.
  * @param v       The vehicle to delete the order from.
  * @param sel_ord The id of the order to be deleted.
@@ -977,6 +1194,7 @@
 
 	Vehicle *u = v->FirstShared();
 	DeleteOrderWarnings(u);
+	PrefillRouteLinks(u);
 	for (; u != NULL; u = u->NextShared()) {
 		assert(v->orders.list == u->orders.list);
 
@@ -1005,6 +1223,9 @@
 
 		/* Update any possible open window of the vehicle */
 		InvalidateVehicleOrder(u, sel_ord | (INVALID_VEH_ORDER_ID << 8));
+
+		/* Clear the next unload station of all cargo packets, it might not be in the orders anymore. */
+		InvalidateNextStation(u);
 	}
 
 	/* As we delete an order, the order to skip to will be 'wrong'. */
@@ -1252,15 +1473,20 @@
 			break;
 
 		case MOF_COND_VARIABLE:
+			if (data == OCV_FREE_PLATFORMS && v->type != VEH_TRAIN) return CMD_ERROR;
 			if (data >= OCV_END) return CMD_ERROR;
 			break;
 
 		case MOF_COND_COMPARATOR:
 			if (data >= OCC_END) return CMD_ERROR;
 			switch (order->GetConditionVariable()) {
-				case OCV_UNCONDITIONALLY: return CMD_ERROR;
+				case OCV_UNCONDITIONALLY:
+				case OCV_PERCENT:
+					return CMD_ERROR;
 
 				case OCV_REQUIRES_SERVICE:
+				case OCV_CARGO_ACCEPTANCE:
+				case OCV_CARGO_WAITING:
 					if (data != OCC_IS_TRUE && data != OCC_IS_FALSE) return CMD_ERROR;
 					break;
 
@@ -1276,9 +1502,15 @@
 
 				case OCV_LOAD_PERCENTAGE:
 				case OCV_RELIABILITY:
+				case OCV_PERCENT:
 					if (data > 100) return CMD_ERROR;
 					break;
 
+				case OCV_CARGO_ACCEPTANCE:
+				case OCV_CARGO_WAITING:
+					if (!(data < NUM_CARGO && CargoSpec::Get(data)->IsValid())) return CMD_ERROR;
+					break;
+
 				default:
 					if (data > 2047) return CMD_ERROR;
 					break;
@@ -1294,7 +1526,11 @@
 		switch (mof) {
 			case MOF_NON_STOP:
 				order->SetNonStopType((OrderNonStopFlags)data);
-				if (data & ONSF_NO_STOP_AT_DESTINATION_STATION) order->SetRefit(CT_NO_REFIT);
+				if (data & ONSF_NO_STOP_AT_DESTINATION_STATION) {
+					InvalidateOrderRouteLinks(order->index);
+					order->SetRefit(CT_NO_REFIT);
+				}
+				PrefillRouteLinks(v);
 				break;
 
 			case MOF_STOP_LOCATION:
@@ -1336,6 +1572,8 @@
 			}
 
 			case MOF_COND_VARIABLE: {
+				/* Check whether old conditional variable had a cargo as value */
+				bool old_var_was_cargo = (order->GetConditionVariable() == OCV_CARGO_ACCEPTANCE || order->GetConditionVariable() == OCV_CARGO_WAITING);
 				order->SetConditionVariable((OrderConditionVariable)data);
 
 				OrderConditionComparator occ = order->GetConditionComparator();
@@ -1345,15 +1583,25 @@
 						order->SetConditionValue(0);
 						break;
 
+					case OCV_CARGO_ACCEPTANCE:
+					case OCV_CARGO_WAITING:
+						if (!old_var_was_cargo) order->SetConditionValue((uint16) GetFirstValidCargo());
+						if (occ != OCC_IS_TRUE && occ != OCC_IS_FALSE) order->SetConditionComparator(OCC_IS_TRUE);
+						break;
 					case OCV_REQUIRES_SERVICE:
+						if (old_var_was_cargo) order->SetConditionValue(0);
 						if (occ != OCC_IS_TRUE && occ != OCC_IS_FALSE) order->SetConditionComparator(OCC_IS_TRUE);
 						break;
 
+					case OCV_PERCENT:
+						order->SetConditionComparator(OCC_EQUALS);
+						/* FALL THROUGH */
 					case OCV_LOAD_PERCENTAGE:
 					case OCV_RELIABILITY:
 						if (order->GetConditionValue() > 100) order->SetConditionValue(100);
 						/* FALL THROUGH */
 					default:
+						if (old_var_was_cargo) order->SetConditionValue(0);
 						if (occ == OCC_IS_TRUE || occ == OCC_IS_FALSE) order->SetConditionComparator(OCC_EQUALS);
 						break;
 				}
@@ -1394,6 +1642,9 @@
 				u->current_order.SetLoadType(order->GetLoadType());
 			}
 			InvalidateVehicleOrder(u, VIWD_MODIFY_ORDERS);
+
+			/* Invalidate the next unload station of all packets as we might not unload there anymore. */
+			InvalidateNextStation(u);
 		}
 	}
 
@@ -1502,6 +1753,7 @@
 
 				/* Link this vehicle in the shared-list */
 				dst->AddToShared(src);
+				PrefillRouteLinks(dst);
 
 				InvalidateVehicleOrder(dst, VIWD_REMOVE_ALL_ORDERS);
 				InvalidateVehicleOrder(src, VIWD_MODIFY_ORDERS);
@@ -1566,6 +1818,7 @@
 					dst->orders.list = new OrderList(first, dst);
 				}
 
+				PrefillRouteLinks(dst);
 				InvalidateVehicleOrder(dst, VIWD_REMOVE_ALL_ORDERS);
 
 				InvalidateWindowClassesData(GetWindowClassForVehicleType(dst->type), 0);
@@ -1804,6 +2057,9 @@
 		if (!keep_orderlist) v->orders.list = NULL;
 	}
 
+	/* Invalidate the next unload station of all cargo. */
+	InvalidateNextStation(v);
+
 	if (reset_order_indices) {
 		v->cur_implicit_order_index = v->cur_real_order_index = 0;
 		if (v->current_order.IsType(OT_LOADING)) {
@@ -1869,6 +2125,52 @@
 	}
 }
 
+/* Get the number of free (train) platforms in a station.
+ * @param st_id The StationID of the station.
+ * @return The number of free train platforms.
+ */
+static uint16 GetFreeStationPlatforms(StationID st_id)
+{
+	assert(Station::IsValidID(st_id));
+	const Station *st = Station::Get(st_id);
+	if (!(st->facilities & FACIL_TRAIN)) return 0;
+	bool is_free;
+	TileIndex t2;
+	uint16 counter = 0;
+	TILE_AREA_LOOP(t1, st->train_station) {
+		if (st->TileBelongsToRailStation(t1)) {
+			/* We only proceed if this tile is a track tile and the north(-east/-west) end of the platform */
+			if (IsCompatibleTrainStationTile(t1 + TileOffsByDiagDir(GetRailStationAxis(t1) == AXIS_X ? DIAGDIR_NE : DIAGDIR_NW), t1) || IsStationTileBlocked(t1)) continue;
+			is_free = true;
+			t2 = t1;
+			do {
+				if (GetStationReservationTrackBits(t2)) {
+					is_free = false;
+					break;
+				}
+				t2 += TileOffsByDiagDir(GetRailStationAxis(t1) == AXIS_X ? DIAGDIR_SW : DIAGDIR_SE);
+			} while (IsCompatibleTrainStationTile(t2, t1));
+			if (is_free) counter++;
+		}
+	}
+	return counter;
+}
+
+/** Gets the next 'real' station in the order list
+ * @param v the vehicle in question
+ * @param order the current (conditional) order
+ * @return the StationID of the next valid station in the order list, or INVALID_STATION if there is none.
+ */
+static StationID GetNextRealStation(const Vehicle *v, const Order *order, int conditional_depth = 0)
+{
+	if (order->IsType(OT_GOTO_STATION)) {
+		if (Station::IsValidID(order->GetDestination())) return order->GetDestination();
+	}
+	//nothing conditional about this
+	if (conditional_depth > v->GetNumOrders()) return INVALID_STATION;
+	return GetNextRealStation(v, (order->next != NULL) ? order->next : v->GetFirstOrder(), ++conditional_depth);
+}
+
 /**
  * Process a conditional order and determine the next order.
  * @param order the order the vehicle currently has
@@ -1890,6 +2192,27 @@
 		case OCV_AGE:                skip_order = OrderConditionCompare(occ, v->age / DAYS_IN_LEAP_YEAR,        value); break;
 		case OCV_REQUIRES_SERVICE:   skip_order = OrderConditionCompare(occ, v->NeedsServicing(),               value); break;
 		case OCV_UNCONDITIONALLY:    skip_order = true; break;
+		case OCV_CARGO_WAITING: {
+			StationID next_station = GetNextRealStation(v, order);
+			if (Station::IsValidID(next_station)) skip_order = OrderConditionCompare(occ, !Station::Get(next_station)->goods[value].cargo.Empty(), value);
+				break;
+		}
+		case OCV_CARGO_ACCEPTANCE: {
+			StationID next_station = GetNextRealStation(v, order);
+			if (Station::IsValidID(next_station)) skip_order = OrderConditionCompare(occ, HasBit(Station::Get(next_station)->goods[value].acceptance_pickup, GoodsEntry::GES_ACCEPTANCE), value);
+			break;
+		}
+		case OCV_FREE_PLATFORMS: {
+			StationID next_station = GetNextRealStation(v, order);
+			if (Station::IsValidID(next_station)) skip_order = OrderConditionCompare(occ, GetFreeStationPlatforms(next_station), value);
+			break;
+		}
+		case OCV_PERCENT: {
+			/* get a non-const reference to the current order */
+			Order *ord = (Order *)order;
+			skip_order = ord->UpdateJumpCounter((byte)value);
+			break;
+		}
 		case OCV_REMAINING_LIFETIME: skip_order = OrderConditionCompare(occ, max(v->max_age - v->age + DAYS_IN_LEAP_YEAR - 1, 0) / DAYS_IN_LEAP_YEAR, value); break;
 		default: NOT_REACHED();
 	}
@@ -2015,7 +2338,12 @@
 	}
 
 	v->current_order = *order;
+	/* Set the index of the current order to the index of the implicit order,
+	 * this is needed as the index is used for route link generation. */
+	Order *implicit_order = v->GetOrder(v->cur_implicit_order_index);
+	v->current_order.index = implicit_order->index;
 	return UpdateOrderDest(v, order, conditional_depth + 1, pbs_look_ahead);
+
 }
 
 /**
@@ -2098,6 +2426,10 @@
 
 	/* Otherwise set it, and determine the destination tile. */
 	v->current_order = *order;
+	/* Set the index of the current order to the index of the implicit order,
+	 * this is needed as the index is used for route link generation. */
+	Order *implicit_order = v->GetOrder(v->cur_implicit_order_index);
+	v->current_order.index = implicit_order->index;
 
 	InvalidateVehicleOrder(v, VIWD_MODIFY_ORDERS);
 	switch (v->type) {
diff -urNad openttd-1.3.2/src/order_gui.cpp openttd-1.3.2-DC3.0RC3/src/order_gui.cpp
--- openttd-1.3.2/src/order_gui.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/order_gui.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -26,6 +26,7 @@
 #include "station_base.h"
 #include "waypoint_base.h"
 #include "core/geometry_func.hpp"
+#include "infrastructure_func.h"
 #include "hotkeys.h"
 #include "aircraft.h"
 #include "engine_func.h"
@@ -154,6 +155,10 @@
 	OCV_AGE,
 	OCV_REMAINING_LIFETIME,
 	OCV_REQUIRES_SERVICE,
+	OCV_CARGO_WAITING,
+	OCV_CARGO_ACCEPTANCE,
+	OCV_FREE_PLATFORMS,
+	OCV_PERCENT,
 	OCV_UNCONDITIONALLY,
 };
 
@@ -169,6 +174,30 @@
 	INVALID_STRING_ID,
 };
 
+static const StringID _order_conditional_condition_has[] = {
+	STR_ORDER_CONDITIONAL_COMPARATOR_HAS,
+	STR_ORDER_CONDITIONAL_COMPARATOR_HAS_NO,
+	STR_ORDER_CONDITIONAL_COMPARATOR_HAS_LESS_THAN,
+	STR_ORDER_CONDITIONAL_COMPARATOR_HAS_LESS_EQUALS,
+	STR_ORDER_CONDITIONAL_COMPARATOR_HAS_MORE_THAN,
+	STR_ORDER_CONDITIONAL_COMPARATOR_HAS_MORE_EQUALS,
+	STR_ORDER_CONDITIONAL_COMPARATOR_HAS,
+	STR_ORDER_CONDITIONAL_COMPARATOR_HAS_NO,
+	INVALID_STRING_ID,
+};
+
+static const StringID _order_conditional_condition_accepts[] = {
+	STR_NULL,
+	STR_NULL,
+	STR_NULL,
+	STR_NULL,
+	STR_NULL,
+	STR_NULL,
+	STR_ORDER_CONDITIONAL_COMPARATOR_ACCEPTS,
+	STR_ORDER_CONDITIONAL_COMPARATOR_DOES_NOT_ACCEPT,
+	INVALID_STRING_ID,
+};
+
 extern uint ConvertSpeedToDisplaySpeed(uint speed);
 extern uint ConvertDisplaySpeedToSpeed(uint speed);
 
@@ -317,20 +346,46 @@
 			SetDParam(1, order->GetDestination());
 			break;
 
-		case OT_CONDITIONAL:
+		case OT_CONDITIONAL: {
 			SetDParam(1, order->GetConditionSkipToOrder() + 1);
-			if (order->GetConditionVariable() == OCV_UNCONDITIONALLY) {
+			const OrderConditionVariable ocv = order->GetConditionVariable( );
+			/* handle some non-ordinary cases seperately */
+			if ( ocv == OCV_UNCONDITIONALLY ) {
 				SetDParam(0, STR_ORDER_CONDITIONAL_UNCONDITIONAL);
+			} else if ( ocv == OCV_PERCENT ) {
+				SetDParam( 0, STR_CONDITIONAL_PERCENT );
+				SetDParam( 2, order->GetConditionValue( ) );
+			} else if ( ocv == OCV_FREE_PLATFORMS ) {
+				SetDParam( 0, STR_CONDITIONAL_FREE_PLATFORMS );
+				SetDParam( 2, STR_ORDER_CONDITIONAL_COMPARATOR_HAS + order->GetConditionComparator() );
+				SetDParam( 3, order->GetConditionValue( ) );
 			} else {
 				OrderConditionComparator occ = order->GetConditionComparator();
-				SetDParam(0, (occ == OCC_IS_TRUE || occ == OCC_IS_FALSE) ? STR_ORDER_CONDITIONAL_TRUE_FALSE : STR_ORDER_CONDITIONAL_NUM);
-				SetDParam(2, STR_ORDER_CONDITIONAL_LOAD_PERCENTAGE + order->GetConditionVariable());
-				SetDParam(3, STR_ORDER_CONDITIONAL_COMPARATOR_EQUALS + occ);
+				bool is_cargo = ocv == OCV_CARGO_ACCEPTANCE || ocv == OCV_CARGO_WAITING;
+				SetDParam( 0, is_cargo ? STR_ORDER_CONDITIONAL_CARGO : (occ == OCC_IS_TRUE || occ == OCC_IS_FALSE) ? STR_ORDER_CONDITIONAL_TRUE_FALSE : STR_ORDER_CONDITIONAL_NUM );
+				SetDParam( 2, (ocv == OCV_CARGO_ACCEPTANCE || ocv == OCV_CARGO_WAITING || ocv == OCV_FREE_PLATFORMS) ? STR_ORDER_CONDITIONAL_NEXT_STATION : STR_ORDER_CONDITIONAL_LOAD_PERCENTAGE + ocv );
 
 				uint value = order->GetConditionValue();
-				if (order->GetConditionVariable() == OCV_MAX_SPEED) value = ConvertSpeedToDisplaySpeed(value);
+				switch ( ocv ) {
+					case OCV_CARGO_ACCEPTANCE:
+						SetDParam( 3, STR_ORDER_CONDITIONAL_COMPARATOR_ACCEPTS + occ - OCC_IS_TRUE );
+						SetDParam( 4, CargoSpec::Get( value )->name );
+						break;
+					case OCV_CARGO_WAITING:
+						SetDParam( 3, STR_ORDER_CONDITIONAL_COMPARATOR_HAS + occ - OCC_IS_TRUE );
+						SetDParam( 4, CargoSpec::Get( value )->name );
+						break;
+					case OCV_REQUIRES_SERVICE:
+						SetDParam( 3, STR_ORDER_CONDITIONAL_COMPARATOR_EQUALS + occ );
+						break;
+					case OCV_MAX_SPEED:
+						value = ConvertSpeedToDisplaySpeed( value );
+						/* FALL THROUGH */
+					default:
+						SetDParam( 3, STR_ORDER_CONDITIONAL_COMPARATOR_EQUALS + occ );
 				SetDParam(4, value);
 			}
+			}
 
 			if (timetable && order->wait_time > 0) {
 				SetDParam(5, STR_TIMETABLE_AND_TRAVEL_FOR);
@@ -338,6 +393,7 @@
 			} else {
 				SetDParam(5, STR_EMPTY);
 			}
+                }
 			break;
 
 		default: NOT_REACHED();
@@ -356,7 +412,7 @@
 	/* check depot first */
 	switch (GetTileType(tile)) {
 		case MP_RAILWAY:
-			if (v->type == VEH_TRAIN && IsTileOwner(tile, _local_company)) {
+			if (v->type == VEH_TRAIN && IsInfraTileUsageAllowed(VEH_TRAIN, v->owner, tile)) {
 				if (IsRailDepot(tile)) {
 					order.MakeGoToDepot(GetDepotIndex(tile), ODTFB_PART_OF_ORDERS,
 							_settings_client.gui.new_nonstop ? ONSF_NO_STOP_AT_INTERMEDIATE_STATIONS : ONSF_STOP_EVERYWHERE);
@@ -377,7 +433,7 @@
 
 		case MP_STATION:
 			if (v->type != VEH_AIRCRAFT) break;
-			if (IsHangar(tile) && IsTileOwner(tile, _local_company)) {
+			if (IsHangar(tile) && IsInfraTileUsageAllowed(VEH_AIRCRAFT, v->owner, tile)) {
 				order.MakeGoToDepot(GetStationIndex(tile), ODTFB_PART_OF_ORDERS, ONSF_STOP_EVERYWHERE);
 				if (_ctrl_pressed) order.SetDepotOrderType((OrderDepotTypeFlags)(order.GetDepotOrderType() ^ ODTFB_SERVICE));
 				return order;
@@ -386,7 +442,7 @@
 
 		case MP_WATER:
 			if (v->type != VEH_SHIP) break;
-			if (IsShipDepot(tile) && IsTileOwner(tile, _local_company)) {
+			if (IsShipDepot(tile) && IsInfraTileUsageAllowed(VEH_SHIP, v->owner, tile)) {
 				order.MakeGoToDepot(GetDepotIndex(tile), ODTFB_PART_OF_ORDERS, ONSF_STOP_EVERYWHERE);
 				if (_ctrl_pressed) order.SetDepotOrderType((OrderDepotTypeFlags)(order.GetDepotOrderType() ^ ODTFB_SERVICE));
 				return order;
@@ -400,7 +456,7 @@
 	/* check waypoint */
 	if (IsRailWaypointTile(tile) &&
 			v->type == VEH_TRAIN &&
-			IsTileOwner(tile, _local_company)) {
+			IsInfraTileUsageAllowed(VEH_TRAIN, v->owner, tile)) {
 		order.MakeGoToWaypoint(Waypoint::GetByTile(tile)->index);
 		if (_settings_client.gui.new_nonstop != _ctrl_pressed) order.SetNonStopType(ONSF_NO_STOP_AT_ANY_STATION);
 		return order;
@@ -415,7 +471,7 @@
 		StationID st_index = GetStationIndex(tile);
 		const Station *st = Station::Get(st_index);
 
-		if (st->owner == _local_company || st->owner == OWNER_NONE) {
+		if (IsInfraUsageAllowed(v->type, v->owner, st->owner)) {
 			byte facil;
 			(facil = FACIL_DOCK, v->type == VEH_SHIP) ||
 			(facil = FACIL_TRAIN, v->type == VEH_TRAIN) ||
@@ -507,6 +563,11 @@
 		/* WID_O_SEL_TOP_ROW */
 		DP_ROW_LOAD        = 0, ///< Display 'load' / 'unload' / 'refit' buttons in the top row of the ship/airplane order window.
 		DP_ROW_DEPOT       = 1, ///< Display 'refit' / 'service' buttons in the top row of the ship/airplane order window.
+
+                /* WID_O_SEL_COND_VALUE */
+                DP_COND_VALUE_NUMBER = 0, ///< Display number widget
+                DP_COND_VALUE_CARGO  = 1, ///< Display dropdown widget cargo types
+
 		DP_ROW_CONDITIONAL = 2, ///< Display the conditional order buttons in the top row of the ship/airplane order window.
 
 		/* WID_O_SEL_BOTTOM_MIDDLE */
@@ -521,6 +582,8 @@
 	Scrollbar *vscroll;
 	bool can_do_refit;     ///< Vehicle chain can be refitted in depot.
 	bool can_do_autorefit; ///< Vehicle chain can be auto-refitted.
+	StringID cargo_names_list[NUM_CARGO + 1];
+	uint32 cargo_bitmask;
 
 	/**
 	 * Return the memorised selected order.
@@ -554,6 +617,23 @@
 	}
 
 	/**
+	 * Determine which strings should be displayed in the conditional comparator dropdown
+	 *
+	 * @param order the order to evaluate
+	 * @return the StringIDs to display
+	 */
+	static const StringID *GetComparatorStrings(const Order *order)
+	{
+		if (order == NULL) return _order_conditional_condition;
+		switch (order->GetConditionVariable()) {
+			case OCV_FREE_PLATFORMS:   //fall through
+			case OCV_CARGO_WAITING:    return _order_conditional_condition_has;     break;
+			case OCV_CARGO_ACCEPTANCE: return _order_conditional_condition_accepts; break;
+			default:                   return _order_conditional_condition;         break;
+		}
+	}
+
+	/**
 	 * Handle the click on the goto button.
 	 * @param i Dummy parameter.
 	 */
@@ -623,6 +703,8 @@
 		order.SetDepotActionType(ODATFB_NEAREST_DEPOT);
 
 		DoCommandP(this->vehicle->tile, this->vehicle->index + (this->OrderGetSel() << 20), order.Pack(), CMD_INSERT_ORDER | CMD_MSG(STR_ERROR_CAN_T_INSERT_NEW_ORDER));
+		MarkAllRoutePathsDirty(this->vehicle);
+		MarkAllRouteStopoversDirty(this->vehicle);
 	}
 
 	/**
@@ -734,6 +816,8 @@
 		/* When networking, move one order lower */
 		int selected = this->selected_order + (int)_networking;
 
+		MarkAllRoutePathsDirty(this->vehicle);
+		MarkAllRouteStopoversDirty(this->vehicle);
 		if (DoCommandP(this->vehicle->tile, this->vehicle->index, this->OrderGetSel(), CMD_DELETE_ORDER | CMD_MSG(STR_ERROR_CAN_T_DELETE_THIS_ORDER))) {
 			this->selected_order = selected >= this->vehicle->GetNumOrders() ? -1 : selected;
 			this->UpdateButtonState();
@@ -827,6 +911,12 @@
 		this->OnInvalidateData(VIWD_MODIFY_ORDERS);
 	}
 
+	~OrdersWindow()
+	{
+		MarkAllRouteStopoversDirty(this->vehicle);
+		FocusWindowById(WC_VEHICLE_VIEW, this->window_number);
+	}
+
 	virtual void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize)
 	{
 		switch (widget) {
@@ -857,6 +947,18 @@
 				break;
 			}
 		}
+
+
+		/* Create cargo bitmask */
+		assert_compile(NUM_CARGO <= 32);
+		for (CargoID c = 0; c < NUM_CARGO; c++) {
+			if (CargoSpec::Get(c)->IsValid()) {
+				this->cargo_names_list[c] = CargoSpec::Get(c)->name;
+				SetBit(this->cargo_bitmask, c);
+	}
+		}
+		this->cargo_bitmask = ~this->cargo_bitmask;
+		this->cargo_names_list[NUM_CARGO] = INVALID_STRING_ID;
 	}
 
 	/**
@@ -1067,11 +1169,22 @@
 					} else {
 						train_row_sel->SetDisplayedPlane(DP_GROUNDVEHICLE_ROW_CONDITIONAL);
 					}
-					OrderConditionVariable ocv = order->GetConditionVariable();
+					OrderConditionVariable ocv = (order == NULL) ? OCV_LOAD_PERCENTAGE : order->GetConditionVariable();
+                                        bool is_cargo = ocv == OCV_CARGO_ACCEPTANCE || ocv == OCV_CARGO_WAITING;
+
+                                        if (this->vehicle->type != VEH_SHIP && this->vehicle->type != VEH_AIRCRAFT) {
+					    if (is_cargo) {
+                                        	this->GetWidget<NWidgetCore>(WID_O_COND_CARGO)->widget_data      = cargo_names_list[order == NULL ? 0 : order->GetConditionValue()];
+                                        	this->GetWidget<NWidgetStacked>(WID_O_SEL_COND_VALUE)->SetDisplayedPlane(DP_COND_VALUE_CARGO);
+                                    	    } else {
+                                        	this->GetWidget<NWidgetStacked>(WID_O_SEL_COND_VALUE)->SetDisplayedPlane(DP_COND_VALUE_NUMBER);
+                                    	    }
+					}
+
 					/* Set the strings for the dropdown boxes. */
 					this->GetWidget<NWidgetCore>(WID_O_COND_VARIABLE)->widget_data   = STR_ORDER_CONDITIONAL_LOAD_PERCENTAGE + (order == NULL ? 0 : ocv);
-					this->GetWidget<NWidgetCore>(WID_O_COND_COMPARATOR)->widget_data = _order_conditional_condition[order == NULL ? 0 : order->GetConditionComparator()];
-					this->SetWidgetDisabledState(WID_O_COND_COMPARATOR, ocv == OCV_UNCONDITIONALLY);
+					this->GetWidget<NWidgetCore>(WID_O_COND_COMPARATOR)->widget_data = GetComparatorStrings(order)[order == NULL ? 0 : order->GetConditionComparator()];
+					this->SetWidgetDisabledState(WID_O_COND_COMPARATOR, ocv == OCV_UNCONDITIONALLY || ocv == OCV_PERCENT);
 					this->SetWidgetDisabledState(WID_O_COND_VALUE, ocv == OCV_REQUIRES_SERVICE || ocv == OCV_UNCONDITIONALLY);
 					break;
 				}
@@ -1198,6 +1311,8 @@
 						order.MakeConditional(order_id);
 
 						DoCommandP(this->vehicle->tile, this->vehicle->index + (this->OrderGetSel() << 20), order.Pack(), CMD_INSERT_ORDER | CMD_MSG(STR_ERROR_CAN_T_INSERT_NEW_ORDER));
+						MarkAllRoutePathsDirty(this->vehicle);
+						MarkAllRouteStopoversDirty(this->vehicle);
 					}
 					ResetObjectToPlace();
 					break;
@@ -1304,6 +1419,12 @@
 				}
 				break;
 
+			case WID_O_COND_CARGO: {
+				uint value = this->vehicle->GetOrder(this->OrderGetSel())->GetConditionValue();
+				ShowDropDownMenu(this, cargo_names_list, value, WID_O_COND_CARGO, 0, cargo_bitmask);
+				break;
+			}
+
 			case WID_O_TIMETABLE_VIEW:
 				ShowTimetableWindow(this->vehicle);
 				break;
@@ -1319,7 +1440,11 @@
 
 			case WID_O_COND_COMPARATOR: {
 				const Order *o = this->vehicle->GetOrder(this->OrderGetSel());
-				ShowDropDownMenu(this, _order_conditional_condition, o->GetConditionComparator(), WID_O_COND_COMPARATOR, 0, (o->GetConditionVariable() == OCV_REQUIRES_SERVICE) ? 0x3F : 0xC0);
+				OrderConditionVariable cond_var = o->GetConditionVariable();
+				ShowDropDownMenu(this, GetComparatorStrings( o ), o->GetConditionComparator(), WID_O_COND_COMPARATOR, 0, 
+						(cond_var == OCV_REQUIRES_SERVICE ||
+					cond_var == OCV_CARGO_ACCEPTANCE ||
+					cond_var == OCV_CARGO_WAITING) ? 0x3F : 0xC0);
 				break;
 			}
 
@@ -1349,6 +1474,7 @@
 					value = ConvertDisplaySpeedToSpeed(value);
 					break;
 
+				case OCV_PERCENT:
 				case OCV_RELIABILITY:
 				case OCV_LOAD_PERCENTAGE:
 					value = Clamp(value, 0, 100);
@@ -1401,6 +1527,10 @@
 			case WID_O_COND_COMPARATOR:
 				DoCommandP(this->vehicle->tile, this->vehicle->index + (this->OrderGetSel() << 20), MOF_COND_COMPARATOR | index << 4,  CMD_MODIFY_ORDER | CMD_MSG(STR_ERROR_CAN_T_MODIFY_THIS_ORDER));
 				break;
+
+			case WID_O_COND_CARGO:
+				DoCommandP(this->vehicle->tile, this->vehicle->index + (this->OrderGetSel() << 20), MOF_COND_VALUE | index << 4, CMD_MODIFY_ORDER | CMD_MSG(STR_ERROR_CAN_T_MODIFY_THIS_ORDER));
+				break;
 		}
 	}
 
@@ -1451,6 +1581,8 @@
 			if (cmd.IsType(OT_NOTHING)) return;
 
 			if (DoCommandP(this->vehicle->tile, this->vehicle->index + (this->OrderGetSel() << 20), cmd.Pack(), CMD_INSERT_ORDER | CMD_MSG(STR_ERROR_CAN_T_INSERT_NEW_ORDER))) {
+				MarkAllRoutePathsDirty(this->vehicle);
+				MarkAllRouteStopoversDirty(this->vehicle);
 				/* With quick goto the Go To button stays active */
 				if (!_settings_client.gui.quick_goto) ResetObjectToPlace();
 			}
@@ -1512,6 +1644,22 @@
 		/* Update the scroll bar */
 		this->vscroll->SetCapacityFromWidget(this, WID_O_ORDER_LIST);
 	}
+       virtual void OnFocus()
+       {
+               MarkAllRoutePathsDirty(this->vehicle);
+               MarkAllRouteStopoversDirty(this->vehicle);
+       }
+
+       virtual void OnFocusLost()
+       {
+               MarkAllRoutePathsDirty(this->vehicle);
+               MarkAllRouteStopoversDirty(this->vehicle);
+       }
+
+       const Vehicle *GetVehicle()
+       {
+               return this->vehicle;
+       }
 
 	static Hotkey<OrdersWindow> order_hotkeys[];
 };
@@ -1576,10 +1724,14 @@
 															SetDataTip(STR_NULL, STR_ORDER_CONDITIONAL_VARIABLE_TOOLTIP), SetResize(1, 0),
 				NWidget(WWT_DROPDOWN, COLOUR_GREY, WID_O_COND_COMPARATOR), SetMinimalSize(124, 12), SetFill(1, 0),
 															SetDataTip(STR_NULL, STR_ORDER_CONDITIONAL_COMPARATOR_TOOLTIP), SetResize(1, 0),
+				NWidget(NWID_SELECTION, INVALID_COLOUR, WID_O_SEL_COND_VALUE),
 				NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_O_COND_VALUE), SetMinimalSize(124, 12), SetFill(1, 0),
 															SetDataTip(STR_BLACK_COMMA, STR_ORDER_CONDITIONAL_VALUE_TOOLTIP), SetResize(1, 0),
+				NWidget(WWT_DROPDOWN, COLOUR_GREY, WID_O_COND_CARGO), SetMinimalSize(124, 12), SetFill(1, 0),
+					SetDataTip(STR_NULL, STR_ORDER_CONDITIONAL_CARGO_TOOLTIP), SetResize(1, 0),
 			EndContainer(),
 		EndContainer(),
+		EndContainer(),
 		NWidget(WWT_PUSHIMGBTN, COLOUR_GREY, WID_O_SHARED_ORDER_LIST), SetMinimalSize(12, 12), SetDataTip(SPR_SHARED_ORDERS_ICON, STR_ORDERS_VEH_WITH_SHARED_ORDERS_LIST_TOOLTIP),
 	EndContainer(),
 
diff -urNad openttd-1.3.2/src/order_type.h openttd-1.3.2-DC3.0RC3/src/order_type.h
--- openttd-1.3.2/src/order_type.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/order_type.h	2013-11-22 05:49:07.000000000 +0100
@@ -117,6 +117,10 @@
 	OCV_REQUIRES_SERVICE,   ///< Skip when the vehicle requires service
 	OCV_UNCONDITIONALLY,    ///< Always skip
 	OCV_REMAINING_LIFETIME, ///< Skip based on the remaining lifetime
+	OCV_CARGO_WAITING,    ///< Skip if specified cargo is waiting at next station
+	OCV_CARGO_ACCEPTANCE, ///< Skip if specified cargo is accepted at next station
+	OCV_FREE_PLATFORMS,   ///< Skip based on free platforms at next station
+	OCV_PERCENT,          ///< Skip xx percent of times
 	OCV_END
 };
 
diff -urNad openttd-1.3.2/src/os/macosx/osx_stdafx.h openttd-1.3.2-DC3.0RC3/src/os/macosx/osx_stdafx.h
--- openttd-1.3.2/src/os/macosx/osx_stdafx.h	2013-07-27 17:09:32.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/os/macosx/osx_stdafx.h	2013-11-22 05:49:07.000000000 +0100
@@ -45,6 +45,7 @@
 #define ScriptOrder OTTDScriptOrder
 #define Palette     OTTDPalette
 #define GlyphID     OTTDGlyphID
+#define RoutingFlags OTTDRoutingFlags
 
 #include <CoreServices/CoreServices.h>
 #include <ApplicationServices/ApplicationServices.h>
@@ -55,6 +56,7 @@
 #undef ScriptOrder
 #undef Palette
 #undef GlyphID
+#undef RoutingFlags
 
 /* remove the variables that CoreServices defines, but we define ourselves too */
 #undef bool
diff -urNad openttd-1.3.2/src/overlay_cmd.cpp openttd-1.3.2-DC3.0RC3/src/overlay_cmd.cpp
--- openttd-1.3.2/src/overlay_cmd.cpp	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/overlay_cmd.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -0,0 +1,65 @@
+/* $Id$ */
+
+/** @file overlay_cmd.cpp Handling of overlays. */
+
+#include "stdafx.h"
+#include "tile_type.h"
+#include "tile_cmd.h"
+#include "overlay.h"
+#include "station_func.h"
+#include "viewport_func.h"
+#include "overlay_cmd.h"
+
+Overlays* Overlays::instance = NULL;
+
+Overlays* Overlays::Instance() 
+{
+	if (instance == NULL)
+		instance = new Overlays();
+	return instance;
+};
+
+void Overlays::AddStation(const Station* st)
+{
+	this->catchmentOverlay.insert(st);
+};
+
+void Overlays::RemoveStation(const Station* st) 
+{
+	this->catchmentOverlay.erase(st);
+};
+
+void Overlays::ToggleStation(const Station* st) 
+{
+	if(this->HasStation(st)) {
+		this->RemoveStation(st);
+	} else {
+		this->AddStation(st);
+	}
+};
+
+void Overlays::Clear() 
+{
+	this->catchmentOverlay.clear();
+};
+
+bool Overlays::IsTileInCatchmentArea(const TileInfo* ti, CatchmentType type) 
+{
+	for(std::set<const Station *>::iterator iter = catchmentOverlay.begin();iter != catchmentOverlay.end();) {
+		const Station *st = *iter;
+		if( st->IsTileInCatchmentArea(ti, type))
+			return true;
+		iter++;
+	}
+	return false;
+};
+
+bool Overlays::HasStation(const Station* st) 
+{
+	return (this->catchmentOverlay.find(st) != this->catchmentOverlay.end());
+};
+
+Overlays::~Overlays() 
+{
+	this->catchmentOverlay.clear();
+};
diff -urNad openttd-1.3.2/src/overlay_cmd.h openttd-1.3.2-DC3.0RC3/src/overlay_cmd.h
--- openttd-1.3.2/src/overlay_cmd.h	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/overlay_cmd.h	2013-11-22 05:49:07.000000000 +0100
@@ -0,0 +1,38 @@
+/* $Id$ */
+
+/** @file overlay_cmd.h Functions related to overlays. */
+
+#ifndef OVERLAY_CMD_H
+#define OVERLAY_CMD_H
+
+#include "tile_type.h"
+#include "tile_cmd.h"
+#include "station_base.h"
+#include <set>
+
+class Overlays {
+	
+	std::set<const Station *> catchmentOverlay;
+
+protected:
+	static Overlays* instance;
+	
+public:
+	static Overlays* Instance();
+
+	void AddStation(const Station* st);
+
+	void RemoveStation(const Station *st);
+
+	void ToggleStation(const Station* st);
+	
+	void Clear();
+
+	bool IsTileInCatchmentArea(const TileInfo* ti, CatchmentType type);
+
+	bool HasStation(const Station* st);
+
+	virtual ~Overlays();
+};
+
+#endif // OVERLAY_CMD_H
diff -urNad openttd-1.3.2/src/overlay.h openttd-1.3.2-DC3.0RC3/src/overlay.h
--- openttd-1.3.2/src/overlay.h	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/overlay.h	2013-11-22 05:49:07.000000000 +0100
@@ -0,0 +1,73 @@
+/* $Id$ */
+
+/** @file overlay.h Functions related to overlays. */
+
+#ifndef OVERLAY_H
+#define OVERLAY_H
+
+#include "stdafx.h"
+#include "openttd.h"
+#include "core/bitmath_func.hpp"
+#include "gfx_func.h"
+
+/**
+ * Transparency option bits: which position in _transparency_opt stands for which transparency.
+ * If you change the order, change the order of the ShowTransparencyToolbar() stuff in transparency_gui.cpp too.
+ * If you add or remove an option don't forget to change the transparency 'hot keys' in main_gui.cpp.
+ */
+enum OverlayOption {
+	OO_COVERAGES = 0,  ///< coverage
+	OO_END,
+};
+
+typedef uint OverlayOptionBits; ///< overlay option bits
+extern OverlayOptionBits _overlay_opt;
+extern OverlayOptionBits _overlay_lock;
+
+/**
+ * Check if the overlay option bit is set
+ * and if we aren't in the game menu (there's no overlay)
+ *
+ * @param to the structure which overlay option is ask for
+ */
+static inline bool IsOverlaySet(OverlayOption to)
+{
+	return (HasBit(_overlay_opt, to) && _game_mode != GM_MENU);
+}
+
+/**
+ * Toggle the overlay option bit
+ *
+ * @param to the overlay option to be toggled
+ */
+static inline void ToggleOverlay(OverlayOption to)
+{
+	ToggleBit(_overlay_opt, to);
+}
+
+/**
+ * Toggle the overlay lock bit
+ *
+ * @param to the overlay option to be locked or unlocked
+ */
+static inline void ToggleOverlayLock(OverlayOption to)
+{
+	ToggleBit(_overlay_lock, to);
+}
+
+/** Set or clear all non-locked overlay options */
+static inline void ResetRestoreAllOverlays()
+{
+	/* if none of the non-locked options are set */
+	if ((_overlay_opt & ~_overlay_lock) == 0) {
+		/* set all non-locked options */
+		_overlay_opt |= GB(~_overlay_lock, 0, OO_END);
+	} else {
+		/* clear all non-locked options */
+		_overlay_opt &= _overlay_lock;
+	}
+
+	MarkWholeScreenDirty();
+}
+
+#endif /* OVERLAY_H */
diff -urNad openttd-1.3.2/src/pathfinder/follow_track.hpp openttd-1.3.2-DC3.0RC3/src/pathfinder/follow_track.hpp
--- openttd-1.3.2/src/pathfinder/follow_track.hpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/pathfinder/follow_track.hpp	2013-11-22 05:49:07.000000000 +0100
@@ -19,6 +19,7 @@
 #include "../tunnelbridge.h"
 #include "../tunnelbridge_map.h"
 #include "../depot_map.h"
+#include "../infrastructure_func.h"
 #include "pf_performance_timer.hpp"
 
 /**
@@ -298,6 +299,11 @@
 				m_err = EC_NO_WAY;
 				return false;
 			}
+			/* road stops shouldn't be entered unless allowed to */
+			if (!IsInfraTileUsageAllowed(VEH_ROAD, m_veh_owner, m_new_tile)) {
+				m_err = EC_OWNER;
+				return false;
+			}
 		}
 
 		/* single tram bits can only be entered from one direction */
@@ -316,8 +322,8 @@
 				m_err = EC_NO_WAY;
 				return false;
 			}
-			/* don't try to enter other company's depots */
-			if (GetTileOwner(m_new_tile) != m_veh_owner) {
+			/* don't try to enter other company's depots if not allowed */
+			if (!IsInfraTileUsageAllowed(VEH_ROAD, m_veh_owner, m_new_tile)) {
 				m_err = EC_OWNER;
 				return false;
 			}
@@ -330,8 +336,8 @@
 			}
 		}
 
-		/* rail transport is possible only on tiles with the same owner as vehicle */
-		if (IsRailTT() && GetTileOwner(m_new_tile) != m_veh_owner) {
+		/* rail transport is possible only on allowed tiles */
+		if (IsRailTT() && !IsInfraTileUsageAllowed(VEH_TRAIN, m_veh_owner, m_new_tile)) {
 			/* different owner */
 			m_err = EC_NO_WAY;
 			return false;
diff -urNad openttd-1.3.2/src/pathfinder/npf/npf.cpp openttd-1.3.2-DC3.0RC3/src/pathfinder/npf/npf.cpp
--- openttd-1.3.2/src/pathfinder/npf/npf.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/pathfinder/npf/npf.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -14,6 +14,7 @@
 #include "../../viewport_func.h"
 #include "../../ship.h"
 #include "../../roadstop_base.h"
+#include "../../infrastructure_func.h"
 #include "../pathfinder_func.h"
 #include "../pathfinder_type.h"
 #include "../follow_track.hpp"
@@ -331,8 +332,12 @@
 
 		case MP_ROAD:
 			cost = NPF_TILE_LENGTH;
+                       /* Increase the cost for two-way roads */
+                       if (IsNormalRoadTile(tile) && GetDisallowedRoadDirections(tile) == DRD_NONE) cost += _settings_game.pf.npf.npf_road_two_way_penalty;
 			/* Increase the cost for level crossings */
 			if (IsLevelCrossing(tile)) cost += _settings_game.pf.npf.npf_crossing_penalty;
+			/* Increase the cost for juctions with trafficlights. */
+			if (HasTrafficLights(tile)) cost += _settings_game.pf.npf.npf_road_trafficlight_penalty;
 			break;
 
 		case MP_STATION: {
@@ -662,25 +667,31 @@
  */
 static bool CanEnterTileOwnerCheck(Owner owner, TileIndex tile, DiagDirection enterdir)
 {
-	if (IsTileType(tile, MP_RAILWAY) || // Rail tile (also rail depot)
-			HasStationTileRail(tile) ||     // Rail station tile/waypoint
-			IsRoadDepotTile(tile) ||        // Road depot tile
-			IsStandardRoadStopTile(tile)) { // Road station tile (but not drive-through stops)
-		return IsTileOwner(tile, owner);  // You need to own these tiles entirely to use them
-	}
-
 	switch (GetTileType(tile)) {
+		case MP_RAILWAY:
+			return IsInfraTileUsageAllowed(VEH_TRAIN, owner, tile); // Rail tile (also rail depot)
+
 		case MP_ROAD:
 			/* rail-road crossing : are we looking at the railway part? */
 			if (IsLevelCrossing(tile) &&
 					DiagDirToAxis(enterdir) != GetCrossingRoadAxis(tile)) {
-				return IsTileOwner(tile, owner); // Railway needs owner check, while the street is public
+				return IsInfraTileUsageAllowed(VEH_TRAIN, owner, tile); // Railway needs owner check, while the street is public
+			} else if (IsRoadDepot(tile)) { // Road depot tile
+				return IsInfraTileUsageAllowed(VEH_ROAD, owner, tile);
+			}
+			break;
+
+		case MP_STATION:
+			if (HasStationRail(tile)) { // Rail station tile/waypoint
+				return IsInfraTileUsageAllowed(VEH_TRAIN, owner, tile);
+			} else if (IsStandardRoadStopTile(tile)) { // Road station tile (but not drive-through stops)
+				return IsInfraTileUsageAllowed(VEH_ROAD, owner, tile);
 			}
 			break;
 
 		case MP_TUNNELBRIDGE:
 			if (GetTunnelBridgeTransportType(tile) == TRANSPORT_RAIL) {
-				return IsTileOwner(tile, owner);
+				return IsInfraTileUsageAllowed(VEH_TRAIN, owner, tile);
 			}
 			break;
 
diff -urNad openttd-1.3.2/src/pathfinder/yapf/nodelist.hpp openttd-1.3.2-DC3.0RC3/src/pathfinder/yapf/nodelist.hpp
--- openttd-1.3.2/src/pathfinder/yapf/nodelist.hpp	2013-07-27 17:09:38.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/pathfinder/yapf/nodelist.hpp	2013-11-22 05:49:07.000000000 +0100
@@ -21,7 +21,7 @@
  *  Implements open list, closed list and priority queue for A-star
  *  path finder.
  */
-template <class Titem_, int Thash_bits_open_, int Thash_bits_closed_>
+template <class Titem_, int Thash_bits_open_, int Thash_bits_closed_, int Tnum_array_items_ = 65536>
 class CNodeList_HashTableT {
 public:
 	/** make Titem_ visible from outside of class */
@@ -29,7 +29,7 @@
 	/** make Titem_::Key a property of HashTable */
 	typedef typename Titem_::Key Key;
 	/** type that we will use as item container */
-	typedef SmallArray<Titem_, 65536, 256> CItemArray;
+	typedef SmallArray<Titem_, Tnum_array_items_, 256> CItemArray;
 	/** how pointers to open nodes will be stored */
 	typedef CHashTableT<Titem_, Thash_bits_open_  > COpenList;
 	/** how pointers to closed nodes will be stored */
diff -urNad openttd-1.3.2/src/pathfinder/yapf/yapf_cargo.cpp openttd-1.3.2-DC3.0RC3/src/pathfinder/yapf/yapf_cargo.cpp
--- openttd-1.3.2/src/pathfinder/yapf/yapf_cargo.cpp	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/pathfinder/yapf/yapf_cargo.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -0,0 +1,442 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file yapf_cargo.cpp Implementation of YAPF for cargo routing. */
+
+#include "../../stdafx.h"
+#include "../../cargodest_base.h"
+#include "../../station_base.h"
+#include "../../town.h"
+#include "yapf.hpp"
+
+
+/** YAPF node key for cargo routing. */
+struct CYapfRouteLinkNodeKeyT {
+	RouteLink *m_link;
+
+	/** Initialize this node key. */
+	inline void Set(RouteLink *link)
+	{
+		this->m_link = link;
+	}
+
+	/** Calculate the hash of this cargo/route key. */
+	inline int CalcHash() const
+	{
+		return (int)(size_t)this->m_link >> 4;
+	}
+
+	inline bool operator == (const CYapfRouteLinkNodeKeyT& other) const
+	{
+		return this->m_link == other.m_link;
+	}
+
+	void Dump(DumpTarget &dmp) const
+	{
+		dmp.WriteLine("m_link = %u", this->m_link->GetDestination());
+	}
+};
+
+/** YAPF node class for cargo routing. */
+struct CYapfRouteLinkNodeT : public CYapfNodeT<CYapfRouteLinkNodeKeyT, CYapfRouteLinkNodeT> {
+	typedef CYapfNodeT<CYapfRouteLinkNodeKeyT, CYapfRouteLinkNodeT> Base;
+
+	uint m_num_transfers; ///< Number of transfers to reach this node.
+
+	/** Initialize this node. */
+	inline void Set(CYapfRouteLinkNodeT *parent, RouteLink *link)
+	{
+		Base::Set(parent, false);
+		this->m_key.Set(link);
+		this->m_num_transfers = (parent != NULL) ? parent->m_num_transfers : 0;
+	}
+
+	/** Get the route link of this node. */
+	inline RouteLink *GetRouteLink() const { return this->m_key.m_link; }
+
+	/** Get the number of transfers needed to reach this node. */
+	inline int GetNumberOfTransfers() const { return this->m_num_transfers; }
+};
+
+typedef CNodeList_HashTableT<CYapfRouteLinkNodeT, 8, 10, 2048> CRouteLinkNodeList;
+
+/** Route link follower. */
+struct CFollowRouteLinkT {
+	CargoID m_cid;
+	RouteLink *m_old_link;
+	RouteLinkList *m_new_links;
+
+	CFollowRouteLinkT(CargoID cid) : m_cid(cid) {}
+
+	/** Fill in route links reachable by this route link. */
+	inline bool Follow(RouteLink *from)
+	{
+		this->m_old_link = from;
+
+		Station *st = Station::Get(from->GetDestination());
+		m_new_links = &st->goods[this->m_cid].routes;
+		return !this->m_new_links->empty();
+	}
+};
+
+/** YAPF cost provider for route links. */
+template <class Types>
+class CYapfCostRouteLinkT {
+	typedef typename Types::Tpf Tpf;                     ///< The pathfinder class (derived from THIS class).
+	typedef typename Types::TrackFollower Follower;      ///< The route follower.
+	typedef typename Types::NodeList::Titem Node;        ///< This will be our node type.
+
+	static const int PENALTY_DIVISOR      = 16;          ///< Penalty factor divisor for fixed-point arithmetics.
+	static const int LOCAL_PENALTY_FACTOR = 16;          ///< Penalty factor for source-local delivery.
+	static const int RF_DISTANCE_FACTOR   = 2;           ///< Vehicle modifier for "cheap" cargo packets.
+	static const int RF_TIME_FACTOR       = 3;           ///< Time modifier for "fast" cargo packets.
+
+	/** To access inherited path finder. */
+	inline Tpf& Yapf() { return *static_cast<Tpf*>(this); }
+	inline const Tpf& Yapf() const { return *static_cast<const Tpf*>(this); }
+
+	/** Check if this is a valid connection. */
+	inline bool ValidLink(Node &n, const RouteLink *link, const RouteLink *parent) const
+	{
+		/* If the parent link has an owner, and the owner is different to
+		 * the new owner, discard the node. Otherwise cargo could switch
+		 * companies at oil rigs, which would mess up payment. */
+		if (parent->GetOwner() != INVALID_OWNER && link->GetOwner() != parent->GetOwner()) return false;
+
+		/* Check for no loading/no unloading when transferring. */
+		if (link->GetOriginOrderId() != parent->GetDestOrderId() || (Order::Get(link->GetOriginOrderId())->GetUnloadType() & OUFB_UNLOAD) != 0) {
+			/* Can't transfer if the current order prohibits loading. */
+			if ((Order::Get(link->GetOriginOrderId())->GetLoadType() & OLFB_NO_LOAD) != 0) return false;
+
+			/* Can't transfer if the last order prohibits unloading. */
+			if (parent->GetDestOrderId() != INVALID_ORDER && (Order::Get(parent->GetDestOrderId())->GetUnloadType() & OUFB_NO_UNLOAD) != 0) return false;
+
+			/* Increase transfer counter and stop if max number of transfers is exceeded. */
+			if (++n.m_num_transfers > Yapf().PfGetSettings().route_max_transfers) return false;
+		}
+
+		return true;
+	}
+
+	/** Cost of a single route link. */
+	inline int RouteLinkCost(const RouteLink *link, const RouteLink *parent) const
+	{
+		int cost = 0;
+
+		/* Distance cost. */
+		const Station *from = Station::Get(parent->GetDestination());
+		const Station *to = Station::Get(link->GetDestination());
+		cost = DistanceManhattan(from->xy, to->xy) * this->Yapf().PfGetSettings().route_distance_factor;
+
+		/* Modulate the distance by a vehicle-type specific factor to
+		 * simulate the different costs. Cost is doubled if the cargo
+		 * wants to go cheap. */
+		assert_compile(lengthof(_settings_game.pf.yapf.route_mode_cost_factor) == VEH_AIRCRAFT + 1);
+		byte dfactor = this->Yapf().PfGetSettings().route_mode_cost_factor[link->GetVehicleType()];
+		if (HasBit(this->Yapf().GetFlags(), RF_WANT_CHEAP)) dfactor *= RF_DISTANCE_FACTOR;
+		cost *= dfactor;
+
+		/* Factor for the time penalties based on whether the cargo wants to go fast. */
+		uint time_factor = HasBit(this->Yapf().GetFlags(), RF_WANT_FAST) ? RF_TIME_FACTOR : 1;
+
+		/* Transfer penalty when switching vehicles or forced unloading. */
+		if (link->GetOriginOrderId() != parent->GetDestOrderId() || (Order::Get(link->GetOriginOrderId())->GetUnloadType() & OUFB_UNLOAD) != 0) {
+			cost += this->Yapf().PfGetSettings().route_transfer_cost;
+
+			/* Penalty for time since the last vehicle arrived. */
+			cost += link->GetWaitTime() * this->Yapf().PfGetSettings().route_station_last_veh_factor * time_factor / PENALTY_DIVISOR;
+
+			/* Penalty for cargo waiting on our link. */
+			cost += (from->goods[this->Yapf().GetCargoID()].cargo.CountForNextHop(link->GetOriginOrderId()) * this->Yapf().PfGetSettings().route_station_waiting_factor) / PENALTY_DIVISOR;
+		}
+
+		/* Penalty for travel time. */
+		cost += (link->GetTravelTime() * this->Yapf().PfGetSettings().route_travel_time_factor * time_factor) / PENALTY_DIVISOR;
+
+		return cost;
+	}
+
+public:
+	/** Called by YAPF to calculate the cost from the origin to the given node. */
+	inline bool PfCalcCost(Node& n, const Follower *follow)
+	{
+		int segment_cost = 0;
+
+		if (this->Yapf().PfDetectDestination(n)) {
+			Station *st = Station::Get(n.m_parent->GetRouteLink()->GetDestination());
+			/* Discard node if the station doesn't accept the cargo type. */
+			if (!HasBit(st->goods[follow->m_cid].acceptance_pickup, GoodsEntry::GES_ACCEPTANCE)) return false;
+			/* Destination node, get delivery cost. Parent has the station. */
+			segment_cost += this->Yapf().DeliveryCost(st);
+			/* If this link comes from an origin station, penalize it to encourage
+			 * delivery using other stations. */
+			if (n.m_parent->GetRouteLink()->GetDestOrderId() == INVALID_ORDER) segment_cost *= LOCAL_PENALTY_FACTOR;
+		} else {
+			RouteLink *link = n.GetRouteLink();
+			RouteLink *parent = n.m_parent->GetRouteLink();
+
+			/* Check if the link is a valid connection. */
+			if (!this->ValidLink(n, link, parent)) return false;
+
+			/* Cost of the single route link. */
+			segment_cost += this->RouteLinkCost(link, parent);
+		}
+
+		/* Apply it. */
+		n.m_cost = n.m_parent->m_cost + segment_cost;
+		return n.m_cost <= this->Yapf().GetMaxCost();
+	}
+};
+
+/** YAPF origin provider for route links. */
+template <class Types>
+class CYapfOriginRouteLinkT {
+	typedef typename Types::Tpf Tpf;                     ///< The pathfinder class (derived from THIS class).
+	typedef typename Types::NodeList::Titem Node;        ///< This will be our node type.
+
+	CargoID   m_cid;
+	TileIndex m_src;
+	OrderID   m_order;
+	byte      m_flags;
+	SmallVector<RouteLink, 2> m_origin;
+
+	/** To access inherited path finder. */
+	inline Tpf& Yapf() { return *static_cast<Tpf*>(this); }
+
+public:
+	/** Get the current cargo type. */
+	inline CargoID GetCargoID() const
+	{
+		return this->m_cid;
+	}
+
+	/** Get the cargo routing flags. */
+	inline byte GetFlags() const
+	{
+		return this->m_flags;
+	}
+
+	/** Set origin. */
+	void SetOrigin(CargoID cid, TileIndex src, const StationList *stations, bool cargo_creation, OrderID order, byte flags)
+	{
+		this->m_cid = cid;
+		this->m_src = src;
+		this->m_order = order;
+		this->m_flags = flags;
+		/* Create fake links for the origin stations. */
+		for (const Station * const *st = stations->Begin(); st != stations->End(); st++) {
+			if (cargo_creation) {
+				/* Exclusive rights in effect? Only serve those stations. */
+				if ((*st)->town->exclusive_counter > 0 && (*st)->town->exclusivity != (*st)->owner) continue;
+				/* Selectively servicing stations, and not this one. */
+				if (_settings_game.order.selectgoods && (*st)->goods[cid].last_speed == 0) continue;
+			}
+
+			*this->m_origin.Append() = RouteLink((*st)->index, INVALID_ORDER, this->m_order);
+		}
+	}
+
+	/** Called when YAPF needs to place origin nodes into the open list. */
+	void PfSetStartupNodes()
+	{
+		for (RouteLink *link = this->m_origin.Begin(); link != this->m_origin.End(); link++) {
+			Node &n = this->Yapf().CreateNewNode();
+			n.Set(NULL, link);
+			/* Prefer stations closer to the source tile. */
+			n.m_cost = DistanceSquare(this->m_src, Station::Get(link->GetDestination())->xy) * this->Yapf().PfGetSettings().route_distance_factor;
+			this->Yapf().AddStartupNode(n);
+		}
+	}
+};
+
+/** YAPF destination provider for route links. */
+template <class Types>
+class CYapfDestinationRouteLinkT {
+	typedef typename Types::Tpf Tpf;                     ///< The pathfinder class (derived from THIS class).
+	typedef typename Types::NodeList::Titem Node;        ///< This will be our node type.
+
+	TileArea m_dest;
+	int m_max_cost;            ///< Maximum node cost.
+
+	/** To access inherited path finder. */
+	inline Tpf& Yapf() { return *static_cast<Tpf*>(this); }
+
+public:
+	/** Get the maximum allowed node cost. */
+	inline int GetMaxCost() const
+	{
+		return this->m_max_cost;
+	}
+
+	/** Set destination. */
+	void SetDestination(const TileArea &dest, uint max_cost)
+	{
+		this->m_dest = dest;
+		this->m_max_cost = max_cost;
+	}
+
+	/** Cost for delivering the cargo to the final destination tile. */
+	inline int DeliveryCost(Station *st)
+	{
+		int x = TileX(this->m_dest.tile);
+		int y = TileY(this->m_dest.tile);
+
+		/* Inside the station area? Delivery costs "nothing". */
+		if (st->rect.PtInExtendedRect(x, y)) return 0;
+
+		int dist_x = x < st->rect.left ? x - st->rect.left : x - st->rect.right;
+		int dist_y = y < st->rect.top  ? y - st->rect.top  : y - st->rect.bottom;
+
+		return (dist_x * dist_x + dist_y * dist_y) * this->Yapf().PfGetSettings().route_distance_factor;
+	}
+
+	/** Called by YAPF to detect if the station reaches the destination. */
+	inline bool PfDetectDestination(StationID st_id) const
+	{
+		const Station *st = Station::Get(st_id);
+		return st->rect.AreaInExtendedRect(this->m_dest, st->GetCatchmentRadius());
+	}
+
+	/** Called by YAPF to detect if the node reaches the destination. */
+	inline bool PfDetectDestination(const Node& n) const
+	{
+		return n.GetRouteLink() == NULL;
+	}
+
+	/** Called by YAPF to calculate the estimated cost to the destination. */
+	inline bool PfCalcEstimate(Node& n)
+	{
+		if (this->PfDetectDestination(n)) {
+			n.m_estimate = n.m_cost;
+			return true;
+		}
+
+		/* Estimate based on Manhattan distance to destination. */
+		Station *from = Station::Get(n.GetRouteLink()->GetDestination());
+		int d = DistanceManhattan(from->xy, this->m_dest.tile) * this->Yapf().PfGetSettings().route_distance_factor;
+
+		n.m_estimate = n.m_cost + d;
+		assert(n.m_estimate >= n.m_parent->m_estimate);
+		return true;
+	}
+};
+
+/** Main route finding class. */
+template <class Types>
+class CYapfFollowRouteLinkT {
+	typedef typename Types::Tpf Tpf;                     ///< The pathfinder class (derived from THIS class).
+	typedef typename Types::TrackFollower Follower;      ///< The route follower.
+	typedef typename Types::NodeList::Titem Node;        ///< This will be our node type.
+
+	/** To access inherited path finder. */
+	inline Tpf& Yapf() { return *static_cast<Tpf*>(this); }
+
+public:
+	/** Called by YAPF to move from the given node to the next nodes. */
+	inline void PfFollowNode(Node& old_node)
+	{
+		Follower f(this->Yapf().GetCargoID());
+
+		if (this->Yapf().PfDetectDestination(old_node.GetRouteLink()->GetDestination()) && (old_node.GetRouteLink()->GetDestOrderId() == INVALID_ORDER || (Order::Get(old_node.GetRouteLink()->GetDestOrderId())->GetUnloadType() & OUFB_NO_UNLOAD) == 0)) {
+			/* Possible destination? Add sentinel node for final delivery. */
+			Node &n = this->Yapf().CreateNewNode();
+			n.Set(&old_node, NULL);
+			this->Yapf().AddNewNode(n, f);
+		}
+
+		if (f.Follow(old_node.GetRouteLink())) {
+			for (RouteLinkList::iterator link = f.m_new_links->begin(); link != f.m_new_links->end(); ++link) {
+				/* Add new node. */
+				Node &n = this->Yapf().CreateNewNode();
+				n.Set(&old_node, *link);
+				this->Yapf().AddNewNode(n, f);
+			}
+		}
+	}
+
+	/** Return debug report character to identify the transportation type. */
+	inline char TransportTypeChar() const
+	{
+		return 'c';
+	}
+
+	/** Find the best cargo routing from a station to a destination. */
+	static RouteLink *ChooseRouteLink(CargoID cid, const StationList *stations, TileIndex src, const TileArea &dest, StationID *start_station, StationID *next_unload, byte flags, bool *found, OrderID order, int max_cost)
+	{
+		/* Initialize pathfinder instance. */
+		Tpf pf;
+		pf.SetOrigin(cid, src, stations, start_station != NULL, order, flags);
+		pf.SetDestination(dest, max_cost);
+
+		*next_unload = INVALID_STATION;
+
+		/* Do it. Exit if we didn't find a path. */
+		bool res = pf.FindPath(NULL);
+		if (found != NULL) *found = res;
+		if (!res) return NULL;
+
+		/* Walk back to find the start node. */
+		Node *node = pf.GetBestNode();
+		while (node->m_parent->m_parent != NULL) {
+			/* Transfer? Then save transfer station as next unload station. */
+			if (node->GetRouteLink() == NULL || (node->GetRouteLink()->GetOriginOrderId() != node->m_parent->GetRouteLink()->GetDestOrderId())) {
+				*next_unload = node->m_parent->GetRouteLink()->GetDestination();
+			}
+
+			node = node->m_parent;
+		}
+
+		/* Save result. */
+		if (start_station != NULL) {
+			*start_station = node->m_parent->GetRouteLink()->GetDestination();
+			/* Path starts and ends at the same station, do local delivery. */
+			if (*start_station == pf.GetBestNode()->m_parent->GetRouteLink()->GetDestination()) return NULL;
+		}
+		return node->GetRouteLink();
+	}
+};
+
+/** Config struct for route link finding. */
+template <class Tpf_>
+struct CYapfRouteLink_TypesT {
+	typedef CYapfRouteLink_TypesT<Tpf_> Types;
+
+	typedef Tpf_               Tpf;           ///< Pathfinder type
+	typedef CFollowRouteLinkT  TrackFollower; ///< Node follower
+	typedef CRouteLinkNodeList NodeList;      ///< Node list type
+	typedef Vehicle            VehicleType;   ///< Dummy type
+
+	typedef CYapfBaseT<Types>                 PfBase;        ///< Base pathfinder class
+	typedef CYapfFollowRouteLinkT<Types>      PfFollow;      ///< Node follower
+	typedef CYapfOriginRouteLinkT<Types>      PfOrigin;      ///< Origin provider
+	typedef CYapfDestinationRouteLinkT<Types> PfDestination; ///< Destination/distance provider
+	typedef CYapfSegmentCostCacheNoneT<Types> PfCache;       ///< Cost cache provider
+	typedef CYapfCostRouteLinkT<Types>        PfCost;        ///< Cost provider
+};
+
+struct CYapfRouteLink : CYapfT<CYapfRouteLink_TypesT<CYapfRouteLink> > {};
+
+
+/**
+ * Find the best cargo routing from a station to a destination.
+ * @param cid      Cargo type to route.
+ * @param stations Set of possible originating stations.
+ * @param dest     Destination tile area.
+ * @param[out] start_station Station the best route link originates from.
+ * @param[out] next_unload Next station the cargo should be unloaded from the vehicle.
+ * @param flags    Routing flags of the cargo.
+ * @param[out] found True if a link was found.
+ * @param order    Order the vehicle arrived at the origin station.
+ * @param max_cost Maxmimum allowed node cost.
+ * @return The best RouteLink to the target or NULL if either no link found or one of the origin stations is the best destination.
+ */
+RouteLink *YapfChooseRouteLink(CargoID cid, const StationList *stations, TileIndex src, const TileArea &dest, StationID *start_station, StationID *next_unload, byte flags, bool *found, OrderID order, int max_cost)
+{
+	return CYapfRouteLink::ChooseRouteLink(cid, stations, src, dest, start_station, next_unload, flags, found, order, max_cost);
+}
diff -urNad openttd-1.3.2/src/pathfinder/yapf/yapf.h openttd-1.3.2-DC3.0RC3/src/pathfinder/yapf/yapf.h
--- openttd-1.3.2/src/pathfinder/yapf/yapf.h	2013-07-27 17:09:37.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/pathfinder/yapf/yapf.h	2013-11-22 05:49:07.000000000 +0100
@@ -15,6 +15,8 @@
 #include "../../direction_type.h"
 #include "../../track_type.h"
 #include "../../vehicle_type.h"
+#include "../../cargodest_type.h"
+#include "../../order_type.h"
 #include "../pathfinder_type.h"
 
 /**
@@ -97,4 +99,6 @@
  */
 bool YapfTrainFindNearestSafeTile(const Train *v, TileIndex tile, Trackdir td, bool override_railtype);
 
+RouteLink *YapfChooseRouteLink(CargoID cid, const StationList *stations, TileIndex src, const TileArea &dest, StationID *start_station, StationID *next_unload, byte flags, bool *found = NULL, OrderID order = INVALID_ORDER, int max_cost = INT_MAX);
+
 #endif /* YAPF_H */
diff -urNad openttd-1.3.2/src/pathfinder/yapf/yapf_node.hpp openttd-1.3.2-DC3.0RC3/src/pathfinder/yapf/yapf_node.hpp
--- openttd-1.3.2/src/pathfinder/yapf/yapf_node.hpp	2013-07-27 17:09:38.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/pathfinder/yapf/yapf_node.hpp	2013-11-22 05:49:07.000000000 +0100
@@ -54,9 +54,8 @@
 	int         m_cost;
 	int         m_estimate;
 
-	inline void Set(Node *parent, TileIndex tile, Trackdir td, bool is_choice)
+	inline void Set(Node *parent, bool is_choice)
 	{
-		m_key.Set(tile, td);
 		m_hash_next = NULL;
 		m_parent = parent;
 		m_cost = 0;
@@ -65,8 +64,6 @@
 
 	inline Node *GetHashNext() {return m_hash_next;}
 	inline void SetHashNext(Node *pNext) {m_hash_next = pNext;}
-	inline TileIndex GetTile() const {return m_key.m_tile;}
-	inline Trackdir GetTrackdir() const {return m_key.m_td;}
 	inline const Tkey_& GetKey() const {return m_key;}
 	inline int GetCost() const {return m_cost;}
 	inline int GetCostEstimate() const {return m_estimate;}
@@ -81,4 +78,21 @@
 	}
 };
 
+/** Yapf Node base for trackdir based specialisation. */
+template <class Tkey_, class Tnode>
+struct CYapfNodeTrackT : public CYapfNodeT<Tkey_, Tnode>
+{
+	typedef CYapfNodeT<Tkey_, Tnode> Base;
+	typedef Tnode                    Node;
+
+	inline void Set(Node *parent, TileIndex tile, Trackdir td, bool is_choice)
+	{
+		Base::Set(parent, is_choice);
+		this->m_key.Set(tile, td);
+	}
+
+	inline TileIndex GetTile() const { return this->m_key.m_tile; }
+	inline Trackdir GetTrackdir() const { return this->m_key.m_td; }
+};
+
 #endif /* YAPF_NODE_HPP */
diff -urNad openttd-1.3.2/src/pathfinder/yapf/yapf_node_rail.hpp openttd-1.3.2-DC3.0RC3/src/pathfinder/yapf/yapf_node_rail.hpp
--- openttd-1.3.2/src/pathfinder/yapf/yapf_node_rail.hpp	2013-07-27 17:09:38.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/pathfinder/yapf/yapf_node_rail.hpp	2013-11-22 05:49:07.000000000 +0100
@@ -190,9 +190,9 @@
 /** Yapf Node for rail YAPF */
 template <class Tkey_>
 struct CYapfRailNodeT
-	: CYapfNodeT<Tkey_, CYapfRailNodeT<Tkey_> >
+	: CYapfNodeTrackT<Tkey_, CYapfRailNodeT<Tkey_> >
 {
-	typedef CYapfNodeT<Tkey_, CYapfRailNodeT<Tkey_> > base;
+	typedef CYapfNodeTrackT<Tkey_, CYapfRailNodeT<Tkey_> > base;
 	typedef CYapfRailSegment CachedData;
 
 	CYapfRailSegment *m_segment;
diff -urNad openttd-1.3.2/src/pathfinder/yapf/yapf_node_road.hpp openttd-1.3.2-DC3.0RC3/src/pathfinder/yapf/yapf_node_road.hpp
--- openttd-1.3.2/src/pathfinder/yapf/yapf_node_road.hpp	2013-07-27 17:09:38.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/pathfinder/yapf/yapf_node_road.hpp	2013-11-22 05:49:07.000000000 +0100
@@ -15,9 +15,9 @@
 /** Yapf Node for road YAPF */
 template <class Tkey_>
 struct CYapfRoadNodeT
-	: CYapfNodeT<Tkey_, CYapfRoadNodeT<Tkey_> >
+	: CYapfNodeTrackT<Tkey_, CYapfRoadNodeT<Tkey_> >
 {
-	typedef CYapfNodeT<Tkey_, CYapfRoadNodeT<Tkey_> > base;
+	typedef CYapfNodeTrackT<Tkey_, CYapfRoadNodeT<Tkey_> > base;
 
 	TileIndex       m_segment_last_tile;
 	Trackdir        m_segment_last_td;
diff -urNad openttd-1.3.2/src/pathfinder/yapf/yapf_node_ship.hpp openttd-1.3.2-DC3.0RC3/src/pathfinder/yapf/yapf_node_ship.hpp
--- openttd-1.3.2/src/pathfinder/yapf/yapf_node_ship.hpp	2013-07-27 17:09:38.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/pathfinder/yapf/yapf_node_ship.hpp	2013-11-22 05:49:07.000000000 +0100
@@ -15,7 +15,7 @@
 /** Yapf Node for ships */
 template <class Tkey_>
 struct CYapfShipNodeT
-	: CYapfNodeT<Tkey_, CYapfShipNodeT<Tkey_> >
+	: CYapfNodeTrackT<Tkey_, CYapfShipNodeT<Tkey_> >
 {
 
 };
diff -urNad openttd-1.3.2/src/pathfinder/yapf/yapf_road.cpp openttd-1.3.2-DC3.0RC3/src/pathfinder/yapf/yapf_road.cpp
--- openttd-1.3.2/src/pathfinder/yapf/yapf_road.cpp	2013-07-27 17:09:37.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/pathfinder/yapf/yapf_road.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -90,7 +90,12 @@
 		} else {
 			/* non-diagonal trackdir */
 			cost = YAPF_TILE_CORNER_LENGTH + Yapf().PfGetSettings().road_curve_penalty;
+
+			/* Extra cost for traffic lights. */
+			if (HasTrafficLights(tile)) cost += Yapf().PfGetSettings().road_trafficlight_penalty;
 		}
+               /* extra cost for two way road */
+               if (IsNormalRoadTile(tile) && GetDisallowedRoadDirections(tile) == DRD_NONE) cost += Yapf().PfGetSettings().road_two_way_penalty;
 		return cost;
 	}
 
diff -urNad openttd-1.3.2/src/pbs.cpp openttd-1.3.2-DC3.0RC3/src/pbs.cpp
--- openttd-1.3.2/src/pbs.cpp	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/pbs.cpp	2013-11-22 07:00:11.000000000 +0100
@@ -101,8 +101,7 @@
 		case MP_ROAD:
 			if (IsLevelCrossing(tile) && !HasCrossingReservation(tile)) {
 				SetCrossingReservation(tile, true);
-				BarCrossing(tile);
-				MarkTileDirtyByTile(tile); // crossing barred, make tile dirty
+				UpdateLevelCrossing(tile, false);
 				return true;
 			}
 			break;
diff -urNad openttd-1.3.2/src/rail_cmd.cpp openttd-1.3.2-DC3.0RC3/src/rail_cmd.cpp
--- openttd-1.3.2/src/rail_cmd.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/rail_cmd.cpp	2013-11-22 06:03:25.000000000 +0100
@@ -11,6 +11,7 @@
 
 #include "stdafx.h"
 #include "cmd_helper.h"
+#include "copypaste_cmd.h"
 #include "viewport_func.h"
 #include "command_func.h"
 #include "depot_base.h"
@@ -33,6 +34,7 @@
 #include "strings_func.h"
 #include "company_gui.h"
 #include "object_map.h"
+#include "clipboard_gui.h"
 
 #include "table/strings.h"
 #include "table/railtypes.h"
@@ -42,6 +44,7 @@
 typedef SmallVector<Train *, 16> TrainList;
 
 RailtypeInfo _railtypes[RAILTYPE_END];
+TileIndex _rail_track_endtile; ///< The end of a rail track; as hidden return from the rail build/remove command for GUI purposes.
 
 assert_compile(sizeof(_original_railtypes) <= sizeof(_railtypes));
 
@@ -400,39 +403,43 @@
 }
 
 /**
- * Build a single piece of rail
- * @param tile tile  to build on
+ * Build a set of rail tracks on a given tile
+ * @param tile tile to build on
  * @param flags operation to perform
  * @param p1 railtype of being built piece (normal, mono, maglev)
- * @param p2 rail track to build
+ * @param p2 TrackBits to build
  * @param text unused
  * @return the cost of this operation or an error
  */
-CommandCost CmdBuildSingleRail(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
+CommandCost CmdBuildSingleRails(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
 {
 	RailType railtype = Extract<RailType, 0, 4>(p1);
-	Track track = Extract<Track, 0, 3>(p2);
+	TrackBits trackbits = (TrackBits)GB(p2, 0, 6);
 	CommandCost cost(EXPENSES_CONSTRUCTION);
 
-	if (!ValParamRailtype(railtype) || !ValParamTrackOrientation(track)) return CMD_ERROR;
+	if (!ValParamRailtype(railtype)) return CMD_ERROR;
 
 	Slope tileh = GetTileSlope(tile);
-	TrackBits trackbit = TrackToTrackBits(track);
+	TrackBits currbits = TRACK_BIT_NONE;
+
+	/* whether the tile needs to be cleared and built from scratch */
+	bool make_new_rail_tile = true;
 
 	switch (GetTileType(tile)) {
 		case MP_RAILWAY: {
 			CommandCost ret = CheckTileOwnership(tile);
 			if (ret.Failed()) return ret;
 
-			if (!IsPlainRail(tile)) return CMD_ERROR;
+			if (!IsPlainRail(tile)) break;
 
 			if (!IsCompatibleRail(GetRailType(tile), railtype)) return_cmd_error(STR_ERROR_IMPOSSIBLE_TRACK_COMBINATION);
 
-			ret = CheckTrackCombination(tile, trackbit, flags);
-			if (ret.Succeeded()) ret = EnsureNoTrainOnTrack(tile, track);
+			currbits = GetTrackBits(tile);
+			ret = CheckTrackCombination(tile, trackbits, flags);
+			if (ret.Succeeded()) ret = EnsureNoTrainOnTrackBits(tile, trackbits & ~currbits);
 			if (ret.Failed()) return ret;
 
-			ret = CheckRailSlope(tileh, trackbit, GetTrackBits(tile), tile);
+			ret = CheckRailSlope(tileh, trackbits, GetTrackBits(tile), tile);
 			if (ret.Failed()) return ret;
 			cost.AddCost(ret);
 
@@ -449,20 +456,21 @@
 				}
 			}
 
-			if (flags & DC_EXEC) {
+			if ((trackbits & ~currbits) && (flags & DC_EXEC)) {
 				SetRailGroundType(tile, RAIL_GROUND_BARREN);
-				TrackBits bits = GetTrackBits(tile);
-				SetTrackBits(tile, bits | trackbit);
+				SetTrackBits(tile, currbits | trackbits);
 				/* Subtract old infrastructure count. */
-				uint pieces = CountBits(bits);
-				if (TracksOverlap(bits)) pieces *= pieces;
+				uint pieces = CountBits(currbits);
+				if (TracksOverlap(currbits)) pieces *= pieces;
 				Company::Get(GetTileOwner(tile))->infrastructure.rail[GetRailType(tile)] -= pieces;
 				/* Add new infrastructure count. */
-				pieces = CountBits(bits | trackbit);
-				if (TracksOverlap(bits | trackbit)) pieces *= pieces;
+				pieces = CountBits(currbits | trackbits);
+				if (TracksOverlap(currbits | trackbits)) pieces *= pieces;
 				Company::Get(GetTileOwner(tile))->infrastructure.rail[GetRailType(tile)] += pieces;
 				DirtyCompanyInfrastructureWindows(GetTileOwner(tile));
 			}
+
+			make_new_rail_tile = false;
 			break;
 		}
 
@@ -506,61 +514,85 @@
 
 				road |= tram;
 
-				if ((track == TRACK_X && road == ROAD_Y) ||
-						(track == TRACK_Y && road == ROAD_X)) {
+                               if ((trackbits == TRACK_BIT_X && road == ROAD_Y) ||
+                                               (trackbits == TRACK_BIT_Y && road == ROAD_X)) {
 					if (flags & DC_EXEC) {
-						MakeRoadCrossing(tile, GetRoadOwner(tile, ROADTYPE_ROAD), GetRoadOwner(tile, ROADTYPE_TRAM), _current_company, (track == TRACK_X ? AXIS_Y : AXIS_X), railtype, roadtypes, GetTownIndex(tile));
+                                                MakeRoadCrossing(tile, GetRoadOwner(tile, ROADTYPE_ROAD), GetRoadOwner(tile, ROADTYPE_TRAM), _current_company, (trackbits == TRACK_BIT_X ? AXIS_Y : AXIS_X), railtype, roadtypes, GetTownIndex(tile));
 						UpdateLevelCrossing(tile, false);
 						Company::Get(_current_company)->infrastructure.rail[railtype] += LEVELCROSSING_TRACKBIT_FACTOR;
 						DirtyCompanyInfrastructureWindows(_current_company);
 					}
-					break;
+                                       make_new_rail_tile = false;
 				}
+                       } else if (IsLevelCrossing(tile)) {
+                               currbits = GetCrossingRailBits(tile);
+                               if (trackbits == currbits) return_cmd_error(STR_ERROR_ALREADY_BUILT);
 			}
 
-			if (IsLevelCrossing(tile) && GetCrossingRailBits(tile) == trackbit) {
-				return_cmd_error(STR_ERROR_ALREADY_BUILT);
-			}
-			/* FALL THROUGH */
+                       break;
 		}
 
-		default: {
-			/* Will there be flat water on the lower halftile? */
-			bool water_ground = IsTileType(tile, MP_WATER) && IsSlopeWithOneCornerRaised(tileh);
+               default:
+                       break;
+       }
 
-			CommandCost ret = CheckRailSlope(tileh, trackbit, TRACK_BIT_NONE, tile);
-			if (ret.Failed()) return ret;
-			cost.AddCost(ret);
+       if (make_new_rail_tile) {
+               /* Will there be flat water on the lower halftile? */
+               bool water_ground = IsTileType(tile, MP_WATER) && IsSlopeWithOneCornerRaised(tileh);
 
-			ret = DoCommand(tile, 0, 0, flags, CMD_LANDSCAPE_CLEAR);
-			if (ret.Failed()) return ret;
-			cost.AddCost(ret);
+               CommandCost ret = CheckRailSlope(tileh, trackbits, TRACK_BIT_NONE, tile);
+               if (ret.Failed()) return ret;
+               cost.AddCost(ret);
 
-			if (water_ground) {
-				cost.AddCost(-_price[PR_CLEAR_WATER]);
-				cost.AddCost(_price[PR_CLEAR_ROUGH]);
-			}
+               ret = DoCommand(tile, 0, 0, flags, CMD_LANDSCAPE_CLEAR);
+               if (ret.Failed()) return ret;
+               cost.AddCost(ret);
+               currbits = TRACK_BIT_NONE; // the tile is clear now
 
-			if (flags & DC_EXEC) {
-				MakeRailNormal(tile, _current_company, trackbit, railtype);
-				if (water_ground) SetRailGroundType(tile, RAIL_GROUND_WATER);
-				Company::Get(_current_company)->infrastructure.rail[railtype]++;
-				DirtyCompanyInfrastructureWindows(_current_company);
-			}
-			break;
+               if (water_ground) {
+                       cost.AddCost(-_price[PR_CLEAR_WATER]);
+                       cost.AddCost(_price[PR_CLEAR_ROUGH]);
+               }
+
+               if (flags & DC_EXEC) {
+                       MakeRailNormal(tile, _current_company, trackbits, railtype);
+                       if (water_ground) SetRailGroundType(tile, RAIL_GROUND_WATER);
+                       Company::Get(_current_company)->infrastructure.rail[railtype]++;
+                       DirtyCompanyInfrastructureWindows(_current_company);
 		}
 	}
 
 	if (flags & DC_EXEC) {
 		MarkTileDirtyByTile(tile);
-		AddTrackToSignalBuffer(tile, track, _current_company);
-		YapfNotifyTrackLayoutChange(tile, track);
+               Track track;
+               FOR_EACH_SET_TRACK(track, trackbits & ~currbits) {
+                       AddTrackToSignalBuffer(tile, track, _current_company);
+                       YapfNotifyTrackLayoutChange(tile, track);
+               }
 	}
 
-	cost.AddCost(RailBuildCost(railtype));
+       cost.AddCost(CountBits(trackbits & ~currbits) * RailBuildCost(railtype));
+	_rail_track_endtile = tile;
 	return cost;
 }
 
+ /**
+ * Build a single piece of rail
+ * @param tile tile  to build on
+ * @param flags operation to perform
+ * @param p1 railtype of being built piece (normal, mono, maglev)
+ * @param p2 rail track to build
+ * @param text unused
+ * @return the cost of this operation or an error
+ */
+CommandCost CmdBuildSingleRail(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
+{
+       Track track = Extract<Track, 0, 3>(p2);
+       if (!ValParamTrackOrientation(track)) return CMD_ERROR;
+
+       return CmdBuildSingleRails(tile, flags, p1, TrackToTrackBits(track), text);
+}
+
 /**
  * Remove a single piece of track
  * @param tile tile to remove track from
@@ -702,6 +734,7 @@
 		if (v != NULL) TryPathReserve(v, true);
 	}
 
+	_rail_track_endtile = tile;
 	return cost;
 }
 
@@ -1039,28 +1072,26 @@
 	/* you can not convert a signal if no signal is on track */
 	if (convert_signal && !HasSignalOnTrack(tile, track)) return_cmd_error(STR_ERROR_THERE_ARE_NO_SIGNALS);
 
-	CommandCost cost;
+	CommandCost cost(EXPENSES_CONSTRUCTION);
 	if (!HasSignalOnTrack(tile, track)) {
 		/* build new signals */
-		cost = CommandCost(EXPENSES_CONSTRUCTION, _price[PR_BUILD_SIGNALS]);
+		cost.AddCost(_price[PR_BUILD_SIGNALS]);
 	} else {
 		if (p2 != 0 && sigvar != GetSignalVariant(tile, track)) {
 			/* convert signals <-> semaphores */
-			cost = CommandCost(EXPENSES_CONSTRUCTION, _price[PR_BUILD_SIGNALS] + _price[PR_CLEAR_SIGNALS]);
-
+			cost.AddCost(_price[PR_BUILD_SIGNALS] + _price[PR_CLEAR_SIGNALS]);
 		} else if (convert_signal) {
 			/* convert button pressed */
 			if (ctrl_pressed || GetSignalVariant(tile, track) != sigvar) {
 				/* convert electric <-> semaphore */
-				cost = CommandCost(EXPENSES_CONSTRUCTION, _price[PR_BUILD_SIGNALS] + _price[PR_CLEAR_SIGNALS]);
-			} else {
+				cost .AddCost(_price[PR_BUILD_SIGNALS] + _price[PR_CLEAR_SIGNALS]);
+			} else if (GetSignalType(tile, track) != sigtype) {
 				/* it is free to change signal type: normal-pre-exit-combo */
-				cost = CommandCost();
+			} else {
+				return_cmd_error(STR_ERROR_ALREADY_BUILT);
 			}
-
 		} else {
 			/* it is free to change orientation/pre-exit-combo signals */
-			cost = CommandCost();
 		}
 	}
 
@@ -2351,7 +2382,9 @@
 
 		DrawTrackBits(ti, rails);
 
-		if (HasBit(_display_opt, DO_FULL_DETAIL)) DrawTrackDetails(ti, rti);
+		if (HasBit(_display_opt, DO_RAIL_FENCES)) DrawTrackDetails(ti, rti);
+
+		DrawOverlay(ti, MP_RAILWAY);
 
 		if (HasCatenaryDrawn(GetRailType(ti->tile))) DrawCatenary(ti);
 
@@ -2428,6 +2461,8 @@
 		int depot_sprite = GetCustomRailSprite(rti, ti->tile, RTSG_DEPOT);
 		relocation = depot_sprite != 0 ? depot_sprite - SPR_RAIL_DEPOT_SE_1 : rti->GetRailtypeSpriteOffset();
 
+		DrawOverlay(ti, MP_RAILWAY);
+
 		if (HasCatenaryDrawn(GetRailType(ti->tile))) DrawCatenary(ti);
 
 		DrawRailTileSeq(ti, dts, TO_BUILDINGS, relocation, 0, _drawtile_track_palette);
@@ -2495,6 +2530,7 @@
 	}
 
 	switch (_settings_game.game_creation.landscape) {
+		case LT_TEMPERATE: 
 		case LT_ARCTIC: {
 			int z;
 			Slope slope = GetTileSlope(tile, &z);
@@ -2988,6 +3024,205 @@
 	return DoCommand(tile, 0, 0, flags, CMD_LANDSCAPE_CLEAR);
 }
 
+void CopyPastePlaceTracks(GenericTileIndex tile, RailType railtype, TrackBits tracks)
+{
+	if (IsMainMapTile(tile)) {
+		_current_pasting->DoCommand(AsMainMapTile(tile), railtype, tracks, CMD_BUILD_SINGLE_RAILS | CMD_MSG(STR_ERROR_CAN_T_BUILD_RAILROAD_TRACK));
+	} else {
+		MakeRailNormal(tile, OWNER_NONE, tracks, railtype);
+	}
+}
+
+/**
+ * Estimate signal paste cost.
+ * @param tile The tile where to paste.
+ * @param tile The track where to put the signal (it may not exist, yet).
+ * @param variant The variant of the signal (semaphore/electric)
+ * @param type The type of the signal (normal/combo/pbs)
+ * @param no_sig_trackdir Signal orientation, the trackdir where a signal is NOT present (INVALID_TRACKDIR = two way signal)
+ */
+static CommandCost EstimateSignalPasteCost(TileIndex tile, Track track, SignalVariant variant, SignalType type, Trackdir no_sig_trackdir)
+{
+	switch (GetTileType(tile)) {
+		case MP_CLEAR:
+		case MP_TREES:
+			return CommandCost(EXPENSES_CONSTRUCTION, _price[PR_BUILD_SIGNALS]);
+
+		case MP_RAILWAY:
+			if (!IsPlainRail(tile)) return CMD_ERROR;
+			if (TracksOverlap(GetTrackBits(tile) | TrackToTrackBits(track))) return_cmd_error(STR_ERROR_NO_SUITABLE_RAILROAD_TRACK);
+			if (!HasSignalOnTrack(tile, track)) return CommandCost(EXPENSES_CONSTRUCTION, _price[PR_BUILD_SIGNALS]);
+			if (GetSignalVariant(tile, track) != variant) return CommandCost(EXPENSES_CONSTRUCTION, _price[PR_CLEAR_SIGNALS] + _price[PR_BUILD_SIGNALS]);
+			if (GetSignalType(tile, track) != type) return CommandCost(EXPENSES_CONSTRUCTION, 0);
+			if (IsValidTrackdir(no_sig_trackdir)) {
+				assert(TrackdirToTrack(no_sig_trackdir) == track);
+				if (HasSignalOnTrackdir(tile, no_sig_trackdir)) return CommandCost(EXPENSES_CONSTRUCTION, 0);
+			} else {
+				assert(!IsPbsSignal(type));
+				if (!HasSignalOnTrackdir(tile, TrackToTrackdir(track)) || !HasSignalOnTrackdir(tile, ReverseTrackdir(TrackToTrackdir(track)))) {
+					return CommandCost(EXPENSES_CONSTRUCTION, 0);
+				}
+			}
+			return_cmd_error(STR_ERROR_ALREADY_BUILT);
+
+		case MP_ROAD:
+			return_cmd_error(STR_ERROR_MUST_REMOVE_ROAD_FIRST);
+
+		default:
+			break;
+	}
+	return CMD_ERROR;
+}
+
+static void CopyPastePlaceSignal(GenericTileIndex tile, Track track, SignalVariant variant, SignalType type, Trackdir no_sig_trackdir)
+{
+	if (IsMainMapTile(tile)) {
+		TileIndex t = AsMainMapTile(tile);
+		if (!(_current_pasting->dc_flags & DC_EXEC)) {
+			_current_pasting->CollectCost(EstimateSignalPasteCost(t, track, variant, type, no_sig_trackdir), t, STR_ERROR_CAN_T_BUILD_SIGNALS_HERE);
+		} else {
+			/* build the signal */
+			uint32 p1 = track | (variant << 4) | (type << 5);
+			if (IsTileType(t, MP_RAILWAY) && HasSignalOnTrack(t, track)) p1 |= (1 << 8); // convert existing
+			_current_pasting->DoCommand(t, p1, 0, CMD_BUILD_SIGNALS | CMD_MSG(STR_ERROR_CAN_T_BUILD_SIGNALS_HERE));
+
+			/* cycle until the proper signal side  */
+			if ((_current_pasting->last_result.Succeeded() || _current_pasting->last_result.GetErrorMessage() == STR_ERROR_ALREADY_BUILT)) {
+				if (IsValidTrackdir(no_sig_trackdir)) {
+					assert(TrackdirToTrack(no_sig_trackdir) == track);
+					while (HasSignalOnTrackdir(t, no_sig_trackdir)) {
+						_current_pasting->DoCommand(t, track, 0, CMD_BUILD_SIGNALS);
+						if (_current_pasting->last_result.Failed()) break;
+					}
+				} else {
+					assert(!IsPbsSignal(GetSignalType(t, track)));
+					while (!HasSignalOnTrackdir(t, TrackToTrackdir(track)) ||
+							!HasSignalOnTrackdir(t, ReverseTrackdir(TrackToTrackdir(track)))) {
+						_current_pasting->DoCommand(t, track, 0, CMD_BUILD_SIGNALS);
+						if (_current_pasting->last_result.Failed()) break;
+					}
+				}
+			}
+		}
+	} else {
+		SetHasSignals(tile, true);
+		SetPresentSignals(tile, GetPresentSignals(tile) | SignalOnTrack(track));
+		SetSignalVariant(tile, track, variant);
+		SetSignalType(tile, track, type);
+		if (IsValidTrackdir(no_sig_trackdir)) {
+			assert(TrackdirToTrack(no_sig_trackdir) == track);
+			while (HasSignalOnTrackdir(tile, no_sig_trackdir)) CycleSignalSide(tile, track);
+		}
+	}
+}
+
+static void CopyPastePlaceRailDepot(GenericTileIndex tile, RailType railtype, DiagDirection dir)
+{
+	if (IsMainMapTile(tile)) {
+		TileIndex t = AsMainMapTile(tile);
+		if (IsRailDepotTile(t) && IsTileOwner(t, _current_company) &&
+				GetRailDepotDirection(t) == dir && GetRailType(t) == railtype) {
+			_current_pasting->CollectError(t, STR_ERROR_ALREADY_BUILT, STR_ERROR_CAN_T_BUILD_TRAIN_DEPOT);
+		} else {
+			_current_pasting->DoCommand(t, railtype, dir, CMD_BUILD_TRAIN_DEPOT | CMD_MSG(STR_ERROR_CAN_T_BUILD_TRAIN_DEPOT));
+		}
+	} else {
+		MakeRailDepot(tile, OWNER_NONE, 0, dir, railtype);
+	}
+}
+
+/**
+ * Test a given rail tile if there is any contented to be copied from it.
+ * @param tile the tile to test
+ * @param mode copy-paste mode
+ * @param company the #Company to check ownership against to
+ * @param preview (out, may be NULL) information on how to higlight preview of the tile
+ * @return whether this tile needs to be copy-pasted
+ */
+bool TestRailTileCopyability(GenericTileIndex tile, CopyPasteMode mode, CompanyID company = _current_company, TileContentPastePreview *preview = NULL)
+{
+	if (preview != NULL) MemSetT(preview, 0);
+
+	if (!(mode & CPM_WITH_RAIL_TRANSPORT)) return false;
+	if (IsMainMapTile(tile) && !IsTileOwner(tile, company)) return false;
+
+	if (preview != NULL) {
+		switch (GetRailTileType(tile)) {
+			case RAIL_TILE_NORMAL:
+			case RAIL_TILE_SIGNALS:
+				preview->highlight_track_bits = GetTrackBits(tile);
+				break;
+
+			case RAIL_TILE_DEPOT:
+				preview->highlight_tile_rect = true;
+				preview->highlight_track_bits = TrackToTrackBits(GetRailDepotTrack(tile));
+				break;
+		}
+	}
+
+	return true;
+}
+
+void CopyPasteTile_Rail(GenericTileIndex src_tile, GenericTileIndex dst_tile, const CopyPasteParams &copy_paste)
+{
+	if (!TestRailTileCopyability(src_tile, copy_paste.mode)) return;
+
+	/* Terraform tiles if needed */
+	if (IsMainMapTile(dst_tile) && ((copy_paste.mode & CPM_TERRAFORM_MASK) == CPM_TERRAFORM_MINIMAL)) {
+		CopyPasteHeights(GenericTileArea(src_tile, 1, 1), dst_tile, copy_paste.transformation, copy_paste.height_delta);
+		if (IsPastingInterrupted()) return;
+	}
+
+	RailType railtype = (copy_paste.mode & CPM_CONVERT_RAILTYPE) ? copy_paste.railtype : GetRailType(src_tile);
+
+	switch (GetRailTileType(src_tile)) {
+		case RAIL_TILE_NORMAL:
+			/* copy/paste tracks */
+			CopyPastePlaceTracks(dst_tile, railtype, TransformTrackBits(GetTrackBits(src_tile), copy_paste.transformation));
+			break;
+
+		case RAIL_TILE_SIGNALS: {
+			/* copy/paste tracks */
+			CopyPastePlaceTracks(dst_tile, railtype, TransformTrackBits(GetTrackBits(src_tile), copy_paste.transformation));
+			if (IsPastingInterrupted()) return;
+
+			/* copy/paste signals */
+			Track src_track;
+			uint signal_bits = GetPresentSignals(src_tile);
+			FOR_EACH_SET_TRACK(src_track, GetTrackBits(src_tile)) {
+				/* extract signal bits related to curent track */
+				uint track_signal_bits = signal_bits & SignalOnTrack(src_track);
+				if (track_signal_bits == 0) continue;
+				signal_bits &= ~track_signal_bits;
+
+				/* calculate trackdir pointing to the back of the signal (INVALID_TRACKDIR for two-way signals) */
+				Trackdir dst_no_sig_trackdir;
+				if (HasExactlyOneBit(track_signal_bits)) {
+					dst_no_sig_trackdir = TransformTrackdir(TrackToTrackdir(src_track), copy_paste.transformation);
+					if (HasSignalOnTrackdir(src_tile, TrackToTrackdir(src_track)) != ((copy_paste.mode & CPM_MIRROR_SIGNALS) != 0)) {
+						dst_no_sig_trackdir = ReverseTrackdir(dst_no_sig_trackdir);
+					}
+				} else {
+					dst_no_sig_trackdir = INVALID_TRACKDIR;
+				}
+
+				/* place the signal */
+				CopyPastePlaceSignal(dst_tile, TransformTrack(src_track, copy_paste.transformation), GetSignalVariant(src_tile, src_track), GetSignalType(src_tile, src_track), dst_no_sig_trackdir);
+				if (IsPastingInterrupted()) return;
+
+				if (signal_bits == 0) break; // no more signals to paste
+			}
+			break;
+		}
+
+		case RAIL_TILE_DEPOT: // Rail depot
+			CopyPastePlaceRailDepot(dst_tile, railtype, TransformDiagDir(GetRailDepotDirection(src_tile), copy_paste.transformation));
+			break;
+
+		default:
+			NOT_REACHED(); // corrupted tile data?
+	}
+}
 
 extern const TileTypeProcs _tile_type_rail_procs = {
 	DrawTile_Track,           // draw_tile_proc
@@ -3004,4 +3239,5 @@
 	VehicleEnter_Track,       // vehicle_enter_tile_proc
 	GetFoundation_Track,      // get_foundation_proc
 	TerraformTile_Track,      // terraform_tile_proc
+	CopyPasteTile_Rail,       // copypaste_tile_proc
 };
diff -urNad openttd-1.3.2/src/rail.cpp openttd-1.3.2-DC3.0RC3/src/rail.cpp
--- openttd-1.3.2/src/rail.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/rail.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -149,10 +149,23 @@
 	TRACKDIR_BIT_X_NE | TRACKDIR_BIT_Y_SE, ///< 30 SLOPE_STEEP_E -> inclined for diagonal track
 };
 
+/** Lookup table to transform a Track by a given DirTransformation. */
+extern const byte _track_transformation_map[DTR_END][TRACK_END] = {
+	{ TRACK_X, TRACK_Y, TRACK_UPPER, TRACK_LOWER, TRACK_LEFT,  TRACK_RIGHT }, // DTR_IDENTITY
+	{ TRACK_Y, TRACK_X, TRACK_RIGHT, TRACK_LEFT,  TRACK_UPPER, TRACK_LOWER }, // DTR_ROTATE_90_R
+	{ TRACK_X, TRACK_Y, TRACK_LOWER, TRACK_UPPER, TRACK_RIGHT, TRACK_LEFT  }, // DTR_ROTATE_180
+	{ TRACK_Y, TRACK_X, TRACK_LEFT,  TRACK_RIGHT, TRACK_LOWER, TRACK_UPPER }, // DTR_ROTATE_90_L
+	{ TRACK_X, TRACK_Y, TRACK_RIGHT, TRACK_LEFT,  TRACK_LOWER, TRACK_UPPER }, // DTR_REFLECT_NE_SW
+	{ TRACK_Y, TRACK_X, TRACK_LOWER, TRACK_UPPER, TRACK_LEFT,  TRACK_RIGHT }, // DTR_REFLECT_W_E
+	{ TRACK_X, TRACK_Y, TRACK_LEFT,  TRACK_RIGHT, TRACK_UPPER, TRACK_LOWER }, // DTR_REFLECT_NW_SE
+	{ TRACK_Y, TRACK_X, TRACK_UPPER, TRACK_LOWER, TRACK_RIGHT, TRACK_LEFT  }  // DTR_REFLECT_N_S
+};
+
 /**
  * Return the rail type of tile, or INVALID_RAILTYPE if this is no rail tile.
  */
-RailType GetTileRailType(TileIndex tile)
+template <bool Tgeneric>
+RailType GetTileRailType(typename TileIndexT<Tgeneric>::T tile)
 {
 	switch (GetTileType(tile)) {
 		case MP_RAILWAY:
@@ -176,6 +189,9 @@
 	}
 	return INVALID_RAILTYPE;
 }
+/* instantiate */
+template RailType GetTileRailType<false>(TileIndex tile);
+template RailType GetTileRailType<true>(GenericTileIndex tile);
 
 /**
  * Finds out if a company has a certain railtype available
diff -urNad openttd-1.3.2/src/rail_gui.cpp openttd-1.3.2-DC3.0RC3/src/rail_gui.cpp
--- openttd-1.3.2/src/rail_gui.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/rail_gui.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -49,6 +49,8 @@
 static SignalVariant _cur_signal_variant;    ///< set the signal variant (for signal GUI)
 static SignalType _cur_signal_type;          ///< set the signal type (for signal GUI)
 
+extern TileIndex _rail_track_endtile; // rail_cmd.cpp
+
 /* Map the setting: default_signal_type to the corresponding signal type */
 static const SignalType _default_signal_type[] = {SIGTYPE_NORMAL, SIGTYPE_PBS, SIGTYPE_PBS_ONEWAY};
 
@@ -88,9 +90,9 @@
 	if (result.Succeeded() && _settings_client.sound.confirm) SndPlayTileFx(SND_20_SPLAT_2, tile);
 }
 
-static void GenericPlaceRail(TileIndex tile, int cmd)
+static bool GenericPlaceRail(TileIndex tile, Track track)
 {
-	DoCommandP(tile, _cur_railtype, cmd,
+	return DoCommandP(tile, _cur_railtype, track,
 			_remove_button_clicked ?
 			CMD_REMOVE_SINGLE_RAIL | CMD_MSG(STR_ERROR_CAN_T_REMOVE_RAILROAD_TRACK) :
 			CMD_BUILD_SINGLE_RAIL | CMD_MSG(STR_ERROR_CAN_T_BUILD_RAILROAD_TRACK),
@@ -279,6 +281,17 @@
 }
 
 /**
+ * Place a rail tunnel.
+ * @param tile Position of the first tile of the tunnel.
+ */
+static void PlaceRail_Tunnel(TileIndex tile)
+{
+	if (DoCommandP(tile, _cur_railtype | (TRANSPORT_RAIL << 8), 0, CMD_BUILD_TUNNEL | CMD_MSG(STR_ERROR_CAN_T_BUILD_TUNNEL_HERE), CcBuildRailTunnel)) {
+		StoreRailPlacementEndpoints(tile, _build_tunnel_endtile, TileX(tile) == TileX(_build_tunnel_endtile) ? TRACK_Y : TRACK_X, false);
+	}
+}
+
+/**
  * Toggles state of the Remove button of Build rail toolbar
  * @param w window the button belongs to
  */
@@ -346,9 +359,9 @@
 	}
 }
 
-static void DoRailroadTrack(int mode)
+static bool DoRailroadTrack(TileIndex start_tile, TileIndex end_tile, Track track)
 {
-	DoCommandP(TileVirtXY(_thd.selstart.x, _thd.selstart.y), TileVirtXY(_thd.selend.x, _thd.selend.y), _cur_railtype | (mode << 4),
+	return DoCommandP(start_tile, end_tile, _cur_railtype | (track << 4),
 			_remove_button_clicked ?
 			CMD_REMOVE_RAILROAD_TRACK | CMD_MSG(STR_ERROR_CAN_T_REMOVE_RAILROAD_TRACK) :
 			CMD_BUILD_RAILROAD_TRACK  | CMD_MSG(STR_ERROR_CAN_T_BUILD_RAILROAD_TRACK));
@@ -356,14 +369,15 @@
 
 static void HandleAutodirPlacement()
 {
-	int trackstat = _thd.drawstyle & HT_DIR_MASK; // 0..5
+	Track track = (Track)(_thd.drawstyle & HT_DIR_MASK); // 0..5
+	TileIndex start_tile = TileVirtXY(_thd.selstart.x, _thd.selstart.y);
+	TileIndex end_tile = TileVirtXY(_thd.selend.x, _thd.selend.y);
 
-	if (_thd.drawstyle & HT_RAIL) { // one tile case
-		GenericPlaceRail(TileVirtXY(_thd.selend.x, _thd.selend.y), trackstat);
-		return;
+	if (_thd.drawstyle & HT_RAIL ?
+			GenericPlaceRail(end_tile, track) : // one tile case
+			DoRailroadTrack(start_tile, end_tile, track)) { // longer track
+		StoreRailPlacementEndpoints(start_tile, _rail_track_endtile, track, true);
 	}
-
-	DoRailroadTrack(trackstat);
 }
 
 /**
@@ -409,6 +423,20 @@
 			CcPlaySound1E);
 }
 
+typedef CursorID (RailtypeInfo::Cursor::* RailCursorType);
+
+static const RailCursorType RAIL_CURSOR_NS       = &RailtypeInfo::Cursor::rail_ns;
+static const RailCursorType RAIL_CURSOR_X        = &RailtypeInfo::Cursor::rail_swne;
+static const RailCursorType RAIL_CURSOR_EW       = &RailtypeInfo::Cursor::rail_ew;
+static const RailCursorType RAIL_CURSOR_Y        = &RailtypeInfo::Cursor::rail_nwse;
+static const RailCursorType RAIL_CURSOR_AUTORAIL = &RailtypeInfo::Cursor::autorail;
+
+void HandleRailPlacePushButton(Window *w, int widget, RailCursorType cursor, HighLightStyle mode)
+{
+	if (_ctrl_pressed) mode |= HT_POLY;
+	HandlePlacePushButton(w, widget, GetRailTypeInfo(_cur_railtype)->cursor.*cursor, mode);
+}
+
 
 /** Rail toolbar management class. */
 struct BuildRailToolbarWindow : Window {
@@ -490,6 +518,24 @@
 		}
 	}
 
+	virtual void DrawWidget(const Rect &r, int widget) const
+	{
+		switch (widget) {
+			case WID_RAT_BUILD_NS:
+			case WID_RAT_BUILD_X:
+			case WID_RAT_BUILD_EW:
+			case WID_RAT_BUILD_Y:
+			case WID_RAT_AUTORAIL:
+				if (this->IsWidgetLowered(widget) && _thd.place_mode & HT_POLY) {
+					DrawSprite(SPR_BLOT, PALETTE_TO_WHITE, r.left + WD_IMGBTN_LEFT, r.top + WD_IMGBTN_TOP);
+				}
+				break;
+
+			default:
+				break;
+		}
+	}
+
 	virtual void SetStringParameters(int widget) const
 	{
 		if (widget == WID_RAT_CAPTION) {
@@ -511,27 +557,27 @@
 		_remove_button_clicked = false;
 		switch (widget) {
 			case WID_RAT_BUILD_NS:
-				HandlePlacePushButton(this, WID_RAT_BUILD_NS, GetRailTypeInfo(_cur_railtype)->cursor.rail_ns, HT_LINE | HT_DIR_VL);
+				HandleRailPlacePushButton(this, WID_RAT_BUILD_NS, RAIL_CURSOR_NS, HT_LINE | HT_DIR_VL);
 				this->last_user_action = widget;
 				break;
 
 			case WID_RAT_BUILD_X:
-				HandlePlacePushButton(this, WID_RAT_BUILD_X, GetRailTypeInfo(_cur_railtype)->cursor.rail_swne, HT_LINE | HT_DIR_X);
+				HandleRailPlacePushButton(this, WID_RAT_BUILD_X, RAIL_CURSOR_X, HT_LINE | HT_DIR_X);
 				this->last_user_action = widget;
 				break;
 
 			case WID_RAT_BUILD_EW:
-				HandlePlacePushButton(this, WID_RAT_BUILD_EW, GetRailTypeInfo(_cur_railtype)->cursor.rail_ew, HT_LINE | HT_DIR_HL);
+				HandleRailPlacePushButton(this, WID_RAT_BUILD_EW, RAIL_CURSOR_EW, HT_LINE | HT_DIR_HL);
 				this->last_user_action = widget;
 				break;
 
 			case WID_RAT_BUILD_Y:
-				HandlePlacePushButton(this, WID_RAT_BUILD_Y, GetRailTypeInfo(_cur_railtype)->cursor.rail_nwse, HT_LINE | HT_DIR_Y);
+				HandleRailPlacePushButton(this, WID_RAT_BUILD_Y, RAIL_CURSOR_Y, HT_LINE | HT_DIR_Y);
 				this->last_user_action = widget;
 				break;
 
 			case WID_RAT_AUTORAIL:
-				HandlePlacePushButton(this, WID_RAT_AUTORAIL, GetRailTypeInfo(_cur_railtype)->cursor.autorail, HT_RAIL);
+				HandleRailPlacePushButton(this, WID_RAT_AUTORAIL, RAIL_CURSOR_AUTORAIL, HT_RAIL);
 				this->last_user_action = widget;
 				break;
 
@@ -607,6 +653,14 @@
 
 	virtual void OnPlaceObject(Point pt, TileIndex tile)
 	{
+		/* Test if we are in "polyline" mode. */
+		if (_thd.drawstyle & HT_POLY) {
+			/* There is no drag-dropping while in "polyline" mode, we build the track
+			 * immidiately after pushing mouse button down. */
+			HandleAutodirPlacement();
+			return;
+		}
+
 		switch (this->last_user_action) {
 			case WID_RAT_BUILD_NS:
 				VpStartPlaceSizing(tile, VPM_FIX_VERTICAL | VPM_RAILDIRS, DDSP_PLACE_RAIL);
@@ -655,7 +709,7 @@
 				break;
 
 			case WID_RAT_BUILD_TUNNEL:
-				DoCommandP(tile, _cur_railtype | (TRANSPORT_RAIL << 8), 0, CMD_BUILD_TUNNEL | CMD_MSG(STR_ERROR_CAN_T_BUILD_TUNNEL_HERE), CcBuildRailTunnel);
+				PlaceRail_Tunnel(tile);
 				break;
 
 			case WID_RAT_CONVERT_RAIL:
@@ -758,13 +812,15 @@
 };
 
 const uint16 _railtoolbar_autorail_keys[] = {'5', 'A' | WKC_GLOBAL_HOTKEY, 0};
+const uint16 _railtoolbar_polyline_autorail_keys[] = {'5' | WKC_CTRL, 'A' | WKC_GLOBAL_HOTKEY | WKC_CTRL, 0};
 
 Hotkey<BuildRailToolbarWindow> BuildRailToolbarWindow::railtoolbar_hotkeys[] = {
 	Hotkey<BuildRailToolbarWindow>('1', "build_ns", WID_RAT_BUILD_NS),
 	Hotkey<BuildRailToolbarWindow>('2', "build_x", WID_RAT_BUILD_X),
 	Hotkey<BuildRailToolbarWindow>('3', "build_ew", WID_RAT_BUILD_EW),
 	Hotkey<BuildRailToolbarWindow>('4', "build_y", WID_RAT_BUILD_Y),
-	Hotkey<BuildRailToolbarWindow>(_railtoolbar_autorail_keys, "autorail", WID_RAT_AUTORAIL),
+	Hotkey<BuildRailToolbarWindow>(_railtoolbar_autorail_keys, "autorail", WID_RAT_AUTORAIL),           // without CTRL
+	Hotkey<BuildRailToolbarWindow>(_railtoolbar_polyline_autorail_keys, "polyrail", WID_RAT_AUTORAIL),  // with CTRL
 	Hotkey<BuildRailToolbarWindow>('6', "demolish", WID_RAT_DEMOLISH),
 	Hotkey<BuildRailToolbarWindow>('7', "depot", WID_RAT_BUILD_DEPOT),
 	Hotkey<BuildRailToolbarWindow>('8', "waypoint", WID_RAT_BUILD_WAYPOINT),
diff -urNad openttd-1.3.2/src/rail.h openttd-1.3.2-DC3.0RC3/src/rail.h
--- openttd-1.3.2/src/rail.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/rail.h	2013-11-22 05:49:07.000000000 +0100
@@ -141,7 +141,7 @@
 		SpriteID signals[SIGTYPE_END][2][2]; ///< signal GUI sprites (type, variant, state)
 	} gui_sprites;
 
-	struct {
+	struct Cursor {
 		CursorID rail_ns;    ///< Cursor for building rail in N-S direction
 		CursorID rail_swne;  ///< Cursor for building rail in X direction
 		CursorID rail_ew;    ///< Cursor for building rail in E-W direction
diff -urNad openttd-1.3.2/src/rail_map.h openttd-1.3.2-DC3.0RC3/src/rail_map.h
--- openttd-1.3.2/src/rail_map.h	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/rail_map.h	2013-11-22 05:49:07.000000000 +0100
@@ -34,11 +34,16 @@
  * @pre IsTileType(t, MP_RAILWAY)
  * @return the RailTileType
  */
-static inline RailTileType GetRailTileType(TileIndex t)
+template <bool Tgeneric>
+static inline RailTileType GetRailTileType(typename TileIndexT<Tgeneric>::T t)
 {
 	assert(IsTileType(t, MP_RAILWAY));
-	return (RailTileType)GB(_m[t].m5, 6, 2);
+	return (RailTileType)GB(GetTile(t)->m5, 6, 2);
 }
+/** @copydoc GetRailTileType(TileIndexT<Tgeneric>::T) */
+static inline RailTileType GetRailTileType(TileIndex t) { return GetRailTileType<false>(t); }
+/** @copydoc GetRailTileType(TileIndexT<Tgeneric>::T) */
+static inline RailTileType GetRailTileType(GenericTileIndex t) { return GetRailTileType<true>(t); }
 
 /**
  * Returns whether this is plain rails, with or without signals. Iow, if this
@@ -47,21 +52,31 @@
  * @pre IsTileType(t, MP_RAILWAY)
  * @return true if and only if the tile is normal rail (with or without signals)
  */
-static inline bool IsPlainRail(TileIndex t)
+template <bool Tgeneric>
+static inline bool IsPlainRail(typename TileIndexT<Tgeneric>::T t)
 {
 	RailTileType rtt = GetRailTileType(t);
 	return rtt == RAIL_TILE_NORMAL || rtt == RAIL_TILE_SIGNALS;
 }
+/** @copydoc IsPlainRail(TileIndexT<Tgeneric>::T) */
+static inline bool IsPlainRail(TileIndex t) { return IsPlainRail<false>(t); }
+/** @copydoc IsPlainRail(TileIndexT<Tgeneric>::T) */
+static inline bool IsPlainRail(GenericTileIndex t) { return IsPlainRail<true>(t); }
 
 /**
  * Checks whether the tile is a rail tile or rail tile with signals.
  * @param t the tile to get the information from
  * @return true if and only if the tile is normal rail (with or without signals)
  */
-static inline bool IsPlainRailTile(TileIndex t)
+template <bool Tgeneric>
+static inline bool IsPlainRailTile(typename TileIndexT<Tgeneric>::T t)
 {
 	return IsTileType(t, MP_RAILWAY) && IsPlainRail(t);
 }
+/** @copydoc IsPlainRailTile(TileIndexT<Tgeneric>::T) */
+static inline bool IsPlainRailTile(TileIndex t) { return IsPlainRailTile<false>(t); }
+/** @copydoc IsPlainRailTile(TileIndexT<Tgeneric>::T) */
+static inline bool IsPlainRailTile(GenericTileIndex t) { return IsPlainRailTile<true>(t); }
 
 
 /**
@@ -81,11 +96,16 @@
  * @param signals whether the rail tile should have signals or not
  * @pre IsPlainRailTile(tile)
  */
-static inline void SetHasSignals(TileIndex tile, bool signals)
+template <bool Tgeneric>
+static inline void SetHasSignals(typename TileIndexT<Tgeneric>::T tile, bool signals)
 {
 	assert(IsPlainRailTile(tile));
-	SB(_m[tile].m5, 6, 1, signals);
+	SB(GetTile(tile)->m5, 6, 1, signals);
 }
+/** @copydoc SetHasSignals(TileIndexT<Tgeneric>::T,bool) */
+static inline void SetHasSignals(TileIndex tile, bool signals) { SetHasSignals<false>(tile, signals); }
+/** @copydoc SetHasSignals(TileIndexT<Tgeneric>::T,bool) */
+static inline void SetHasSignals(GenericTileIndex tile, bool signals) { SetHasSignals<true>(tile, signals); }
 
 /**
  * Is this rail tile a rail depot?
@@ -93,40 +113,60 @@
  * @pre IsTileType(t, MP_RAILWAY)
  * @return true if and only if the tile is a rail depot
  */
-static inline bool IsRailDepot(TileIndex t)
+template <bool Tgeneric>
+static inline bool IsRailDepot(typename TileIndexT<Tgeneric>::T t)
 {
 	return GetRailTileType(t) == RAIL_TILE_DEPOT;
 }
+/** @copydoc IsRailDepot(TileIndexT<Tgeneric>::T) */
+static inline bool IsRailDepot(TileIndex t) { return IsRailDepot<false>(t); }
+/** @copydoc IsRailDepot(TileIndexT<Tgeneric>::T) */
+static inline bool IsRailDepot(GenericTileIndex t) { return IsRailDepot<true>(t); }
 
 /**
  * Is this tile rail tile and a rail depot?
  * @param t the tile to get the information from
  * @return true if and only if the tile is a rail depot
  */
-static inline bool IsRailDepotTile(TileIndex t)
+template <bool Tgeneric>
+static inline bool IsRailDepotTile(typename TileIndexT<Tgeneric>::T t)
 {
 	return IsTileType(t, MP_RAILWAY) && IsRailDepot(t);
 }
+/** @copydoc IsRailDepotTile(TileIndexT<Tgeneric>::T) */
+static inline bool IsRailDepotTile(TileIndex t) { return IsRailDepotTile<false>(t); }
+/** @copydoc IsRailDepotTile(TileIndexT<Tgeneric>::T) */
+static inline bool IsRailDepotTile(GenericTileIndex t) { return IsRailDepotTile<true>(t); }
 
 /**
  * Gets the rail type of the given tile
  * @param t the tile to get the rail type from
  * @return the rail type of the tile
  */
-static inline RailType GetRailType(TileIndex t)
+template <bool Tgeneric>
+static inline RailType GetRailType(typename TileIndexT<Tgeneric>::T t)
 {
-	return (RailType)GB(_m[t].m3, 0, 4);
+	return (RailType)GB(GetTile(t)->m3, 0, 4);
 }
+/** @copydoc GetRailType(TileIndexT<Tgeneric>::T) */
+static inline RailType GetRailType(TileIndex t) { return GetRailType<false>(t); }
+/** @copydoc GetRailType(TileIndexT<Tgeneric>::T) */
+static inline RailType GetRailType(GenericTileIndex t) { return GetRailType<true>(t); }
 
 /**
  * Sets the rail type of the given tile
  * @param t the tile to set the rail type of
  * @param r the new rail type for the tile
  */
-static inline void SetRailType(TileIndex t, RailType r)
+template <bool Tgeneric>
+static inline void SetRailType(typename TileIndexT<Tgeneric>::T t, RailType r)
 {
-	SB(_m[t].m3, 0, 4, r);
+	SB(GetTile(t)->m3, 0, 4, r);
 }
+/** @copydoc SetRailType(TileIndexT<Tgeneric>::T,RailType) */
+static inline void SetRailType(TileIndex t, RailType r) { SetRailType<false>(t, r); }
+/** @copydoc SetRailType(TileIndexT<Tgeneric>::T,RailType) */
+static inline void SetRailType(GenericTileIndex t, RailType r) { SetRailType<true>(t, r); }
 
 
 /**
@@ -134,22 +174,32 @@
  * @param tile the tile to get the track bits from
  * @return the track bits of the tile
  */
-static inline TrackBits GetTrackBits(TileIndex tile)
+template <bool Tgeneric>
+static inline TrackBits GetTrackBits(typename TileIndexT<Tgeneric>::T tile)
 {
 	assert(IsPlainRailTile(tile));
-	return (TrackBits)GB(_m[tile].m5, 0, 6);
+	return (TrackBits)GB(GetTile(tile)->m5, 0, 6);
 }
+/** @copydoc GetTrackBits(TileIndexT<Tgeneric>::T) */
+static inline TrackBits GetTrackBits(TileIndex tile) { return GetTrackBits<false>(tile); }
+/** @copydoc GetTrackBits(TileIndexT<Tgeneric>::T) */
+static inline TrackBits GetTrackBits(GenericTileIndex tile) { return GetTrackBits<true>(tile); }
 
 /**
  * Sets the track bits of the given tile
  * @param t the tile to set the track bits of
  * @param b the new track bits for the tile
  */
-static inline void SetTrackBits(TileIndex t, TrackBits b)
+template <bool Tgeneric>
+static inline void SetTrackBits(typename TileIndexT<Tgeneric>::T t, TrackBits b)
 {
 	assert(IsPlainRailTile(t));
-	SB(_m[t].m5, 0, 6, b);
+	SB(GetTile(t)->m5, 0, 6, b);
 }
+/** @copydoc SetTrackBits(TileIndexT<Tgeneric>::T,TrackBits) */
+static inline void SetTrackBits(TileIndex t, TrackBits b) { SetTrackBits<false>(t, b); }
+/** @copydoc SetTrackBits(TileIndexT<Tgeneric>::T,TrackBits) */
+static inline void SetTrackBits(GenericTileIndex t, TrackBits b) { SetTrackBits<true>(t, b); }
 
 /**
  * Returns whether the given track is present on the given tile.
@@ -158,10 +208,15 @@
  * @pre IsPlainRailTile(tile)
  * @return true if and only if the given track exists on the tile
  */
-static inline bool HasTrack(TileIndex tile, Track track)
+template <bool Tgeneric>
+static inline bool HasTrack(typename TileIndexT<Tgeneric>::T tile, Track track)
 {
 	return HasBit(GetTrackBits(tile), track);
 }
+/** @copydoc HasTrack(TileIndexT<Tgeneric>::T,Track) */
+static inline bool HasTrack(TileIndex tile, Track track) { return HasTrack<false>(tile, track); }
+/** @copydoc HasTrack(TileIndexT<Tgeneric>::T,Track) */
+static inline bool HasTrack(GenericTileIndex tile, Track track) { return HasTrack<true>(tile, track); }
 
 /**
  * Returns the direction the depot is facing to
@@ -169,10 +224,15 @@
  * @pre IsRailDepotTile(t)
  * @return the direction the depot is facing
  */
-static inline DiagDirection GetRailDepotDirection(TileIndex t)
+template <bool Tgeneric>
+static inline DiagDirection GetRailDepotDirection(typename TileIndexT<Tgeneric>::T t)
 {
-	return (DiagDirection)GB(_m[t].m5, 0, 2);
+	return (DiagDirection)GB(GetTile(t)->m5, 0, 2);
 }
+/** @copydoc GetRailDepotDirection(TileIndexT<Tgeneric>::T) */
+static inline DiagDirection GetRailDepotDirection(TileIndex t) { return GetRailDepotDirection<false>(t); }
+/** @copydoc GetRailDepotDirection(TileIndexT<Tgeneric>::T) */
+static inline DiagDirection GetRailDepotDirection(GenericTileIndex t) { return GetRailDepotDirection<true>(t); }
 
 /**
  * Returns the track of a depot, ignoring direction
@@ -180,10 +240,15 @@
  * @param t the tile to get the depot track from
  * @return the track of the depot
  */
-static inline Track GetRailDepotTrack(TileIndex t)
+template <bool Tgeneric>
+static inline Track GetRailDepotTrack(typename TileIndexT<Tgeneric>::T t)
 {
 	return DiagDirToDiagTrack(GetRailDepotDirection(t));
 }
+/** @copydoc GetRailDepotTrack(TileIndexT<Tgeneric>::T) */
+static inline Track GetRailDepotTrack(TileIndex t) { return GetRailDepotTrack<false>(t); }
+/** @copydoc GetRailDepotTrack(TileIndexT<Tgeneric>::T) */
+static inline Track GetRailDepotTrack(GenericTileIndex t) { return GetRailDepotTrack<true>(t); }
 
 
 /**
@@ -195,10 +260,10 @@
 static inline TrackBits GetRailReservationTrackBits(TileIndex t)
 {
 	assert(IsPlainRailTile(t));
-	byte track_b = GB(_m[t].m2, 8, 3);
+	byte track_b = GB(GetTile(t)->m2, 8, 3);
 	Track track = (Track)(track_b - 1);    // map array saves Track+1
 	if (track_b == 0) return TRACK_BIT_NONE;
-	return (TrackBits)(TrackToTrackBits(track) | (HasBit(_m[t].m2, 11) ? TrackToTrackBits(TrackToOppositeTrack(track)) : 0));
+	return (TrackBits)(TrackToTrackBits(track) | (HasBit(GetTile(t)->m2, 11) ? TrackToTrackBits(TrackToOppositeTrack(track)) : 0));
 }
 
 /**
@@ -213,8 +278,8 @@
 	assert(b != INVALID_TRACK_BIT);
 	assert(!TracksOverlap(b));
 	Track track = RemoveFirstTrack(&b);
-	SB(_m[t].m2, 8, 3, track == INVALID_TRACK ? 0 : track + 1);
-	SB(_m[t].m2, 11, 1, (byte)(b != TRACK_BIT_NONE));
+	SB(GetTile(t)->m2, 8, 3, track == INVALID_TRACK ? 0 : track + 1);
+	SB(GetTile(t)->m2, 11, 1, (byte)(b != TRACK_BIT_NONE));
 }
 
 /**
@@ -259,7 +324,7 @@
 static inline bool HasDepotReservation(TileIndex t)
 {
 	assert(IsRailDepot(t));
-	return HasBit(_m[t].m5, 4);
+	return HasBit(GetTile(t)->m5, 4);
 }
 
 /**
@@ -271,7 +336,7 @@
 static inline void SetDepotReservation(TileIndex t, bool b)
 {
 	assert(IsRailDepot(t));
-	SB(_m[t].m5, 4, 1, (byte)b);
+	SB(GetTile(t)->m5, 4, 1, (byte)b);
 }
 
 /**
@@ -291,20 +356,30 @@
 	return s == SIGTYPE_PBS || s == SIGTYPE_PBS_ONEWAY;
 }
 
-static inline SignalType GetSignalType(TileIndex t, Track track)
+template <bool Tgeneric>
+static inline SignalType GetSignalType(typename TileIndexT<Tgeneric>::T t, Track track)
 {
 	assert(GetRailTileType(t) == RAIL_TILE_SIGNALS);
 	byte pos = (track == TRACK_LOWER || track == TRACK_RIGHT) ? 4 : 0;
-	return (SignalType)GB(_m[t].m2, pos, 3);
+	return (SignalType)GB(GetTile(t)->m2, pos, 3);
 }
+/** @copydoc GetSignalType(TileIndexT<Tgeneric>::T,Track) */
+static inline SignalType GetSignalType(TileIndex t, Track track) { return GetSignalType<false>(t, track); }
+/** @copydoc GetSignalType(TileIndexT<Tgeneric>::T,Track) */
+static inline SignalType GetSignalType(GenericTileIndex t, Track track) { return GetSignalType<true>(t, track); }
 
-static inline void SetSignalType(TileIndex t, Track track, SignalType s)
+template <bool Tgeneric>
+static inline void SetSignalType(typename TileIndexT<Tgeneric>::T t, Track track, SignalType s)
 {
 	assert(GetRailTileType(t) == RAIL_TILE_SIGNALS);
 	byte pos = (track == TRACK_LOWER || track == TRACK_RIGHT) ? 4 : 0;
-	SB(_m[t].m2, pos, 3, s);
-	if (track == INVALID_TRACK) SB(_m[t].m2, 4, 3, s);
+	SB(GetTile(t)->m2, pos, 3, s);
+	if (track == INVALID_TRACK) SB(GetTile(t)->m2, 4, 3, s);
 }
+/** @copydoc SetSignalType(TileIndexT<Tgeneric>::T,Track,SignalType) */
+static inline void SetSignalType(TileIndex t, Track track, SignalType s) { SetSignalType<false>(t, track, s); }
+/** @copydoc SetSignalType(TileIndexT<Tgeneric>::T,Track,SignalType) */
+static inline void SetSignalType(GenericTileIndex t, Track track, SignalType s) { SetSignalType<true>(t, track, s); }
 
 static inline bool IsPresignalEntry(TileIndex t, Track track)
 {
@@ -322,28 +397,43 @@
 	return GetSignalType(t, track) != SIGTYPE_PBS;
 }
 
-static inline void CycleSignalSide(TileIndex t, Track track)
+template <bool Tgeneric>
+static inline void CycleSignalSide(typename TileIndexT<Tgeneric>::T t, Track track)
 {
 	byte sig;
 	byte pos = (track == TRACK_LOWER || track == TRACK_RIGHT) ? 4 : 6;
 
-	sig = GB(_m[t].m3, pos, 2);
+	sig = GB(GetTile(t)->m3, pos, 2);
 	if (--sig == 0) sig = IsPbsSignal(GetSignalType(t, track)) ? 2 : 3;
-	SB(_m[t].m3, pos, 2, sig);
+	SB(GetTile(t)->m3, pos, 2, sig);
 }
+/** @copydoc CycleSignalSide(TileIndexT<Tgeneric>::T,Track) */
+static inline void CycleSignalSide(TileIndex t, Track track) { CycleSignalSide<false>(t, track); }
+/** @copydoc CycleSignalSide(TileIndexT<Tgeneric>::T,Track) */
+static inline void CycleSignalSide(GenericTileIndex t, Track track) { CycleSignalSide<true>(t, track); }
 
-static inline SignalVariant GetSignalVariant(TileIndex t, Track track)
+template <bool Tgeneric>
+static inline SignalVariant GetSignalVariant(typename TileIndexT<Tgeneric>::T t, Track track)
 {
 	byte pos = (track == TRACK_LOWER || track == TRACK_RIGHT) ? 7 : 3;
-	return (SignalVariant)GB(_m[t].m2, pos, 1);
+	return (SignalVariant)GB(GetTile(t)->m2, pos, 1);
 }
+/** @copydoc GetSignalVariant(TileIndexT<Tgeneric>::T,Track) */
+static inline SignalVariant GetSignalVariant(TileIndex t, Track track) { return GetSignalVariant<false>(t, track); }
+/** @copydoc GetSignalVariant(TileIndexT<Tgeneric>::T,Track) */
+static inline SignalVariant GetSignalVariant(GenericTileIndex t, Track track) { return GetSignalVariant<true>(t, track); }
 
-static inline void SetSignalVariant(TileIndex t, Track track, SignalVariant v)
+template <bool Tgeneric>
+static inline void SetSignalVariant(typename TileIndexT<Tgeneric>::T t, Track track, SignalVariant v)
 {
 	byte pos = (track == TRACK_LOWER || track == TRACK_RIGHT) ? 7 : 3;
-	SB(_m[t].m2, pos, 1, v);
-	if (track == INVALID_TRACK) SB(_m[t].m2, 7, 1, v);
+	SB(GetTile(t)->m2, pos, 1, v);
+	if (track == INVALID_TRACK) SB(GetTile(t)->m2, 7, 1, v);
 }
+/** @copydoc SetSignalVariant(TileIndexT<Tgeneric>::T,Track,SignalVariant) */
+static inline void SetSignalVariant(TileIndex t, Track track, SignalVariant v) { SetSignalVariant<false>(t, track, v); }
+/** @copydoc SetSignalVariant(TileIndexT<Tgeneric>::T,Track,SignalVariant) */
+static inline void SetSignalVariant(GenericTileIndex t, Track track, SignalVariant v) { SetSignalVariant<true>(t, track, v); }
 
 /**
  * Set the states of the signals (Along/AgainstTrackDir)
@@ -352,7 +442,7 @@
  */
 static inline void SetSignalStates(TileIndex tile, uint state)
 {
-	SB(_m[tile].m4, 4, 4, state);
+	SB(GetTile(tile)->m4, 4, 4, state);
 }
 
 /**
@@ -362,7 +452,7 @@
  */
 static inline uint GetSignalStates(TileIndex tile)
 {
-	return GB(_m[tile].m4, 4, 4);
+	return GB(GetTile(tile)->m4, 4, 4);
 }
 
 /**
@@ -381,20 +471,30 @@
  * @param tile    the tile to set the present signals for
  * @param signals the signals that have to be present
  */
-static inline void SetPresentSignals(TileIndex tile, uint signals)
+template <bool Tgeneric>
+static inline void SetPresentSignals(typename TileIndexT<Tgeneric>::T tile, uint signals)
 {
-	SB(_m[tile].m3, 4, 4, signals);
+	SB(GetTile(tile)->m3, 4, 4, signals);
 }
+/** @copydoc SetPresentSignals(TileIndexT<Tgeneric>::T,uint) */
+static inline void SetPresentSignals(TileIndex tile, uint signals) { SetPresentSignals<false>(tile, signals); }
+/** @copydoc SetPresentSignals(TileIndexT<Tgeneric>::T,uint) */
+static inline void SetPresentSignals(GenericTileIndex tile, uint signals) { SetPresentSignals<true>(tile, signals); }
 
 /**
  * Get whether the given signals are present (Along/AgainstTrackDir)
  * @param tile the tile to get the present signals for
  * @return the signals that are present
  */
-static inline uint GetPresentSignals(TileIndex tile)
+template <bool Tgeneric>
+static inline uint GetPresentSignals(typename TileIndexT<Tgeneric>::T tile)
 {
-	return GB(_m[tile].m3, 4, 4);
+	return GB(GetTile(tile)->m3, 4, 4);
 }
+/** @copydoc GetPresentSignals(TileIndexT<Tgeneric>::T) */
+static inline uint GetPresentSignals(TileIndex tile) { return GetPresentSignals<false>(tile); }
+/** @copydoc GetPresentSignals(TileIndexT<Tgeneric>::T) */
+static inline uint GetPresentSignals(GenericTileIndex tile) { return GetPresentSignals<true>(tile); }
 
 /**
  * Checks whether the given signals is present
@@ -411,11 +511,16 @@
  * Checks for the presence of signals (either way) on the given track on the
  * given rail tile.
  */
-static inline bool HasSignalOnTrack(TileIndex tile, Track track)
+template <bool Tgeneric>
+static inline bool HasSignalOnTrack(typename TileIndexT<Tgeneric>::T tile, Track track)
 {
 	assert(IsValidTrack(track));
 	return GetRailTileType(tile) == RAIL_TILE_SIGNALS && (GetPresentSignals(tile) & SignalOnTrack(track)) != 0;
 }
+/** @copydoc HasSignalOnTrack(TileIndexT<Tgeneric>::T,Track) */
+static inline bool HasSignalOnTrack(TileIndex tile, Track track) { return HasSignalOnTrack<false>(tile, track); }
+/** @copydoc HasSignalOnTrack(TileIndexT<Tgeneric>::T,Track) */
+static inline bool HasSignalOnTrack(GenericTileIndex tile, Track track) { return HasSignalOnTrack<true>(tile, track); }
 
 /**
  * Checks for the presence of signals along the given trackdir on the given
@@ -424,11 +529,16 @@
  * Along meaning if you are currently driving on the given trackdir, this is
  * the signal that is facing us (for which we stop when it's red).
  */
-static inline bool HasSignalOnTrackdir(TileIndex tile, Trackdir trackdir)
+template <bool Tgeneric>
+static inline bool HasSignalOnTrackdir(typename TileIndexT<Tgeneric>::T tile, Trackdir trackdir)
 {
-	assert (IsValidTrackdir(trackdir));
+	assert(IsValidTrackdir(trackdir));
 	return GetRailTileType(tile) == RAIL_TILE_SIGNALS && GetPresentSignals(tile) & SignalAlongTrackdir(trackdir);
 }
+/** @copydoc HasSignalOnTrackdir(TileIndexT<Tgeneric>::T,Trackdir) */
+static inline bool HasSignalOnTrackdir(TileIndex tile, Trackdir trackdir) { return HasSignalOnTrackdir<false>(tile, trackdir); }
+/** @copydoc HasSignalOnTrackdir(TileIndexT<Tgeneric>::T,Trackdir) */
+static inline bool HasSignalOnTrackdir(GenericTileIndex tile, Trackdir trackdir) { return HasSignalOnTrackdir<true>(tile, trackdir); }
 
 /**
  * Gets the state of the signal along the given trackdir.
@@ -480,7 +590,12 @@
 }
 
 
-RailType GetTileRailType(TileIndex tile);
+template <bool Tgeneric>
+RailType GetTileRailType(typename TileIndexT<Tgeneric>::T tile);
+/** @copydoc GetTileRailType(TileIndexT<Tgeneric>::T) */
+static inline RailType GetTileRailType(TileIndex tile) { return GetTileRailType<false>(tile); }
+/** @copydoc GetTileRailType(TileIndexT<Tgeneric>::T) */
+static inline RailType GetTileRailType(GenericTileIndex tile) { return GetTileRailType<true>(tile); }
 
 /** The ground 'under' the rail */
 enum RailGroundType {
@@ -503,12 +618,12 @@
 
 static inline void SetRailGroundType(TileIndex t, RailGroundType rgt)
 {
-	SB(_m[t].m4, 0, 4, rgt);
+	SB(GetTile(t)->m4, 0, 4, rgt);
 }
 
 static inline RailGroundType GetRailGroundType(TileIndex t)
 {
-	return (RailGroundType)GB(_m[t].m4, 0, 4);
+	return (RailGroundType)GB(GetTile(t)->m4, 0, 4);
 }
 
 static inline bool IsSnowRailGround(TileIndex t)
@@ -517,29 +632,38 @@
 }
 
 
-static inline void MakeRailNormal(TileIndex t, Owner o, TrackBits b, RailType r)
+template <bool Tgeneric>
+static inline void MakeRailNormal(typename TileIndexT<Tgeneric>::T t, Owner o, TrackBits b, RailType r)
 {
 	SetTileType(t, MP_RAILWAY);
 	SetTileOwner(t, o);
-	_m[t].m2 = 0;
-	_m[t].m3 = r;
-	_m[t].m4 = 0;
-	_m[t].m5 = RAIL_TILE_NORMAL << 6 | b;
-	SB(_m[t].m6, 2, 4, 0);
-	_me[t].m7 = 0;
+	GetTile(t)->m2 = 0;
+	GetTile(t)->m3 = r;
+	GetTile(t)->m4 = 0;
+	GetTile(t)->m5 = RAIL_TILE_NORMAL << 6 | b;
+	SB(GetTileEx(t)->m6, 2, 4, 0);
+	GetTileEx(t)->m7 = 0;
 }
+/** @copydoc MakeRailNormal(TileIndexT<Tgeneric>::T,Owner,TrackBits,RailType) */
+static inline void MakeRailNormal(TileIndex t, Owner o, TrackBits b, RailType r) { MakeRailNormal<false>(t, o, b, r); }
+/** @copydoc MakeRailNormal(TileIndexT<Tgeneric>::T,Owner,TrackBits,RailType) */
+static inline void MakeRailNormal(GenericTileIndex t, Owner o, TrackBits b, RailType r) { MakeRailNormal<true>(t, o, b, r); }
 
-
-static inline void MakeRailDepot(TileIndex t, Owner o, DepotID did, DiagDirection d, RailType r)
+template <bool Tgeneric>
+inline void MakeRailDepot(typename TileIndexT<Tgeneric>::T t, Owner o, DepotID did, DiagDirection d, RailType r)
 {
 	SetTileType(t, MP_RAILWAY);
 	SetTileOwner(t, o);
-	_m[t].m2 = did;
-	_m[t].m3 = r;
-	_m[t].m4 = 0;
-	_m[t].m5 = RAIL_TILE_DEPOT << 6 | d;
-	SB(_m[t].m6, 2, 4, 0);
-	_me[t].m7 = 0;
+	GetTile(t)->m2 = did;
+	GetTile(t)->m3 = r;
+	GetTile(t)->m4 = 0;
+	GetTile(t)->m5 = RAIL_TILE_DEPOT << 6 | d;
+	SB(GetTileEx(t)->m6, 2, 4, 0);
+	GetTileEx(t)->m7 = 0;
 }
+/** @copydoc MakeRailDepot(TileIndexT<Tgeneric>::T,Owner,DepotID,DiagDirection,RailType) */
+static inline void MakeRailDepot(TileIndex t, Owner o, DepotID did, DiagDirection d, RailType r) { MakeRailDepot<false>(t, o, did, d, r); }
+/** @copydoc MakeRailDepot(TileIndexT<Tgeneric>::T,Owner,DepotID,DiagDirection,RailType) */
+static inline void MakeRailDepot(GenericTileIndex t, Owner o, DepotID did, DiagDirection d, RailType r) { MakeRailDepot<true>(t, o, did, d, r); }
 
 #endif /* RAIL_MAP_H */
diff -urNad openttd-1.3.2/src/rev.cpp.in openttd-1.3.2-DC3.0RC3/src/rev.cpp.in
--- openttd-1.3.2/src/rev.cpp.in	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/rev.cpp.in	2013-11-22 05:49:07.000000000 +0100
@@ -37,7 +37,7 @@
  * norev000 is for non-releases that are made on systems without
  * subversion or sources that are not a checkout of subversion.
  */
-const char _openttd_revision[] = "!!VERSION!!";
+const char _openttd_revision[] = "!!VERSION!!-3.0RC3";
 
 /**
  * The text version of OpenTTD's build date.
diff -urNad openttd-1.3.2/src/road_cmd.cpp openttd-1.3.2-DC3.0RC3/src/road_cmd.cpp
--- openttd-1.3.2/src/road_cmd.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/road_cmd.cpp	2013-11-22 07:00:11.000000000 +0100
@@ -11,6 +11,7 @@
 
 #include "stdafx.h"
 #include "cmd_helper.h"
+#include "copypaste_cmd.h"
 #include "road_internal.h"
 #include "viewport_func.h"
 #include "command_func.h"
@@ -35,6 +36,8 @@
 #include "date_func.h"
 #include "genworld.h"
 #include "company_gui.h"
+#include "trafficlight_func.h"
+#include "clipboard_gui.h"
 
 #include "table/strings.h"
 
@@ -173,9 +176,10 @@
  * @param pieces roadbits to remove
  * @param rt roadtype to remove
  * @param crossing_check should we check if there is a tram track when we are removing road from crossing?
+ * @param trafficlights_check Should we check if there is a traffic light before removing road bits?
  * @param town_check should we check if the town allows removal?
  */
-static CommandCost RemoveRoad(TileIndex tile, DoCommandFlag flags, RoadBits pieces, RoadType rt, bool crossing_check, bool town_check = true)
+static CommandCost RemoveRoad(TileIndex tile, DoCommandFlag flags, RoadBits pieces, RoadType rt, bool crossing_check, bool trafficlights_check, bool town_check = true)
 {
 	RoadTypes rts = GetRoadTypes(tile);
 	/* The tile doesn't have the given road type */
@@ -299,6 +303,11 @@
 			/* Now set present what it will be after the remove */
 			present ^= pieces;
 
+			/* Check if traffic lights are present and if removing them would cause the tile to have less than three roadbits (of any kind!). */
+			if (trafficlights_check && HasTrafficLights(tile) && (CountBits(present | GetOtherRoadBits(tile, rt)) < 3)) {
+				return_cmd_error(STR_ERROR_MUST_REMOVE_TRAFFIC_LIGHTS_FIRST);
+			}
+
 			/* Check for invalid RoadBit combinations on slopes */
 			if (tileh != SLOPE_FLAT && present != ROAD_NONE &&
 					(present & _invalid_tileh_slopes_road[0][tileh & SLOPE_ELEVATED]) == present) {
@@ -399,7 +408,6 @@
 	}
 }
 
-
 /**
  * Calculate the costs for roads on slopes
  *  Aside modify the RoadBits to fit on the slopes
@@ -956,7 +964,7 @@
 
 		/* try to remove the halves. */
 		if (bits != 0) {
-			CommandCost ret = RemoveRoad(tile, flags & ~DC_EXEC, bits, rt, true);
+			CommandCost ret = RemoveRoad(tile, flags & ~DC_EXEC, bits, rt, true, true);
 			if (ret.Succeeded()) {
 				if (flags & DC_EXEC) {
 					money -= ret.GetCost();
@@ -964,7 +972,7 @@
 						_additional_cash_required = DoCommand(start_tile, end_tile, p2, flags & ~DC_EXEC, CMD_REMOVE_LONG_ROAD).GetCost();
 						return cost;
 					}
-					RemoveRoad(tile, flags, bits, rt, true, false);
+					RemoveRoad(tile, flags, bits, rt, true, true, false);
 				}
 				cost.AddCost(ret);
 				had_success = true;
@@ -1067,9 +1075,18 @@
 			/* Clear the road if only one piece is on the tile OR we are not using the DC_AUTO flag */
 			if ((HasExactlyOneBit(b) && GetRoadBits(tile, ROADTYPE_TRAM) == ROAD_NONE) || !(flags & DC_AUTO)) {
 				CommandCost ret(EXPENSES_CONSTRUCTION);
+
+				/* Remove traffic light if necessary. */
+				if (HasTrafficLights(tile)) {
+					CommandCost tl_ret = CmdRemoveTrafficLights(tile, flags, 0, 0, 0);
+					if (tl_ret.Failed()) return tl_ret;
+					ret.AddCost(tl_ret);
+				}
+
+				/* Remove road bits. */
 				RoadType rt;
 				FOR_EACH_SET_ROADTYPE(rt, GetRoadTypes(tile)) {
-					CommandCost tmp_ret = RemoveRoad(tile, flags, GetRoadBits(tile, rt), rt, true);
+					CommandCost tmp_ret = RemoveRoad(tile, flags, GetRoadBits(tile, rt), rt, true, false);
 					if (tmp_ret.Failed()) return tmp_ret;
 					ret.AddCost(tmp_ret);
 				}
@@ -1089,7 +1106,7 @@
 			RoadType rt = ROADTYPE_TRAM;
 			do {
 				if (HasBit(rts, rt)) {
-					CommandCost tmp_ret = RemoveRoad(tile, flags, GetCrossingRoadBits(tile), rt, false);
+					CommandCost tmp_ret = RemoveRoad(tile, flags, GetCrossingRoadBits(tile), rt, false, false);
 					if (tmp_ret.Failed()) return tmp_ret;
 					ret.AddCost(tmp_ret);
 				}
@@ -1212,7 +1229,7 @@
  * @param dy  the offset from the top of the BB of the tile
  * @param h   the height of the sprite to draw
  */
-static void DrawRoadDetail(SpriteID img, const TileInfo *ti, int dx, int dy, int h)
+void DrawRoadDetail(SpriteID img, TileInfo *ti, int dx, int dy, int h)
 {
 	int x = ti->x | dx;
 	int y = ti->y | dy;
@@ -1278,6 +1295,8 @@
 		}
 	}
 
+	if (_settings_game.construction.traffic_lights && HasTrafficLights(ti->tile) && _cur_dpi->zoom <= ZOOM_LVL_DETAIL) DrawTrafficLights(ti);
+
 	if (HasRoadWorks(ti->tile)) {
 		/* Road works */
 		DrawGroundSprite((road | tram) & ROAD_X ? SPR_EXCAVATION_X : SPR_EXCAVATION_Y, PAL_NONE);
@@ -1314,11 +1333,14 @@
 	switch (GetRoadTileType(ti->tile)) {
 		case ROAD_TILE_NORMAL:
 			DrawRoadBits(ti);
+			DrawOverlay(ti, MP_ROAD);
 			break;
 
 		case ROAD_TILE_CROSSING: {
 			if (ti->tileh != SLOPE_FLAT) DrawFoundation(ti, FOUNDATION_LEVELED);
 
+			DrawOverlay(ti, MP_ROAD);
+
 			PaletteID pal = PAL_NONE;
 			const RailtypeInfo *rti = GetRailTypeInfo(GetRailType(ti->tile));
 
@@ -1394,6 +1416,7 @@
 			}
 
 			DrawGroundSprite(dts->ground.sprite, PAL_NONE);
+			DrawOverlay(ti, MP_ROAD);
 			DrawOrigTileSeq(ti, dts, TO_BUILDINGS, palette);
 			break;
 		}
@@ -1466,6 +1489,19 @@
 	}
 }
 
+/**
+ * Animates the traffic lights on a tile.
+ * @param tile This tile.
+ * @pre The setting must be anabled.
+ * @pre The tile must have trafficlights.
+ */
+static void AnimateTile_Road(TileIndex tile)
+{
+	if (_settings_game.construction.traffic_lights && HasTrafficLights(tile)) {
+		if (_tick_counter % 16 == 0) MarkTileDirtyByTile(tile);
+	}
+}
+
 static const Roadside _town_road_types[][2] = {
 	{ ROADSIDE_GRASS,         ROADSIDE_GRASS },
 	{ ROADSIDE_PAVED,         ROADSIDE_PAVED },
@@ -1486,6 +1522,7 @@
 static void TileLoop_Road(TileIndex tile)
 {
 	switch (_settings_game.game_creation.landscape) {
+		case LT_TEMPERATE:
 		case LT_ARCTIC:
 			if (IsOnSnow(tile) != (GetTileZ(tile) > GetSnowLine())) {
 				ToggleSnow(tile);
@@ -1511,7 +1548,7 @@
 			grp = GetTownRadiusGroup(t, tile);
 
 			/* Show an animation to indicate road work */
-			if (t->road_build_months != 0 &&
+			if ((t->road_build_months != 0 || Chance16(_settings_game.economy.random_road_construction, 100)) &&
 					(DistanceManhattan(t->xy, tile) < 8 || grp != HZB_TOWN_EDGE) &&
 					IsNormalRoad(tile) && !HasAtMostOneBit(GetAllRoadBits(tile))) {
 				if (GetFoundationSlope(tile) == SLOPE_FLAT && EnsureNoVehicleOnGround(tile).Succeeded() && Chance16(1, 40)) {
@@ -1550,20 +1587,29 @@
 			SetRoadside(tile, cur_rs);
 			MarkTileDirtyByTile(tile);
 		}
-	} else if (IncreaseRoadWorksCounter(tile)) {
-		TerminateRoadWorks(tile);
+	} else {
+		/* In the first half of roadworks, generate traffic lights with a certain chance. */
+		if (_settings_game.construction.traffic_lights && _settings_game.construction.towns_build_traffic_lights &&
+				(GetRoadWorksCounter(tile) < 8) && (CountBits(GetRoadBits(tile, ROADTYPE_ROAD)) >= 3) &&
+				!HasTrafficLights(tile) && Chance16(1, 20)) {
+			CmdBuildTrafficLights(tile, DC_EXEC | DC_AUTO | DC_NO_WATER, 0, 0, 0);
+			MarkTileDirtyByTile(tile);
+		}
+		if (IncreaseRoadWorksCounter(tile)) {
+			TerminateRoadWorks(tile);
 
-		if (_settings_game.economy.mod_road_rebuild) {
-			/* Generate a nicer town surface */
-			const RoadBits old_rb = GetAnyRoadBits(tile, ROADTYPE_ROAD);
-			const RoadBits new_rb = CleanUpRoadBits(tile, old_rb);
+			if (_settings_game.economy.mod_road_rebuild) {
+				/* Generate a nicer town surface. */
+				const RoadBits old_rb = GetAnyRoadBits(tile, ROADTYPE_ROAD);
+				const RoadBits new_rb = CleanUpRoadBits(tile, old_rb);
 
-			if (old_rb != new_rb) {
-				RemoveRoad(tile, DC_EXEC | DC_AUTO | DC_NO_WATER, (old_rb ^ new_rb), ROADTYPE_ROAD, true);
+				if (old_rb != new_rb) {
+					RemoveRoad(tile, DC_EXEC | DC_AUTO | DC_NO_WATER, (old_rb ^ new_rb), ROADTYPE_ROAD, true, true);
+				}
 			}
-		}
 
-		MarkTileDirtyByTile(tile);
+			MarkTileDirtyByTile(tile);
+		}
 	}
 }
 
@@ -1598,7 +1644,7 @@
 static TrackStatus GetTileTrackStatus_Road(TileIndex tile, TransportType mode, uint sub_mode, DiagDirection side)
 {
 	TrackdirBits trackdirbits = TRACKDIR_BIT_NONE;
-	TrackdirBits red_signals = TRACKDIR_BIT_NONE; // crossing barred
+	TrackdirBits red_signals = TRACKDIR_BIT_NONE; // Crossing barred or red traffic light.
 	switch (mode) {
 		case TRANSPORT_RAIL:
 			if (IsLevelCrossing(tile)) trackdirbits = TrackBitsToTrackdirBits(GetCrossingRailBits(tile));
@@ -1617,6 +1663,8 @@
 
 					uint multiplier = drd_to_multiplier[rt == ROADTYPE_TRAM ? DRD_NONE : GetDisallowedRoadDirections(tile)];
 					if (!HasRoadWorks(tile)) trackdirbits = (TrackdirBits)(_road_trackbits[bits] * multiplier);
+					if (_settings_game.construction.traffic_lights && HasTrafficLights(tile))
+						red_signals = trackdirbits & GetTrafficLightDisallowedDirections(tile);
 					break;
 				}
 
@@ -1627,6 +1675,14 @@
 
 					trackdirbits = TrackBitsToTrackdirBits(AxisToTrackBits(axis));
 					if (IsCrossingBarred(tile)) red_signals = trackdirbits;
+					if (IsLevelCrossingTile(TileAddByDiagDir(tile, AxisToDiagDir(axis))) &&
+							IsCrossingBarred(TileAddByDiagDir(tile, AxisToDiagDir(axis)))) {
+						red_signals &= (TrackdirBits)0x0102; // magic value. I think TRACKBIT_X_SW and TRACKBIT_X_NE should be swapped
+					}
+					if (IsLevelCrossingTile(TileAddByDiagDir(tile, ReverseDiagDir(AxisToDiagDir(axis)))) &&
+							IsCrossingBarred(TileAddByDiagDir(tile, ReverseDiagDir(AxisToDiagDir(axis))))) {
+						red_signals &= (TrackdirBits)0x0201; // inverse of above magic value
+					}
 					break;
 				}
 
@@ -1686,11 +1742,16 @@
 
 		default: {
 			RoadTypes rts = GetRoadTypes(tile);
-			td->str = (HasBit(rts, ROADTYPE_ROAD) ? _road_tile_strings[GetRoadside(tile)] : STR_LAI_ROAD_DESCRIPTION_TRAMWAY);
+			if (HasTrafficLights(tile)) {
+				td->str = STR_LAI_ROAD_DESCRIPTION_ROAD_WITH_TRAFFIC_LIGHTS;
+			} else {
+				td->str = (HasBit(rts, ROADTYPE_ROAD) ? _road_tile_strings[GetRoadside(tile)] : STR_LAI_ROAD_DESCRIPTION_TRAMWAY);
+			}
 			if (HasBit(rts, ROADTYPE_ROAD)) road_owner = GetRoadOwner(tile, ROADTYPE_ROAD);
 			if (HasBit(rts, ROADTYPE_TRAM)) tram_owner = GetRoadOwner(tile, ROADTYPE_TRAM);
 			break;
 		}
+
 	}
 
 	/* Now we have to discover, if the tile has only one owner or many:
@@ -1837,6 +1898,176 @@
 	return DoCommand(tile, 0, 0, flags, CMD_LANDSCAPE_CLEAR);
 }
 
+static void CopyPastePlaceRoad(GenericTileIndex tile, RoadBits roadbits_road, DisallowedRoadDirections drd, RoadBits roadbits_tram)
+{
+	if (IsMainMapTile(tile)) {
+		/* road */
+		if (roadbits_road != ROAD_NONE) {
+			if (IsNormalRoadTile(tile) && HasTileRoadType(tile, ROADTYPE_ROAD) &&
+					IsRoadOwner(tile, ROADTYPE_ROAD, _current_company) &&
+					(GetRoadBits(tile, ROADTYPE_ROAD) == roadbits_road)) {
+				drd &= ~GetDisallowedRoadDirections(tile);
+				if (drd == DRD_NONE) return;
+			}
+			_current_pasting->DoCommand(AsMainMapTile(tile), roadbits_road | (ROADTYPE_ROAD << 4) | (drd << 6), 0, CMD_BUILD_ROAD | CMD_MSG(STR_ERROR_CAN_T_BUILD_ROAD_HERE));
+		}
+		/* tram */
+		if (roadbits_tram != ROAD_NONE) {
+			_current_pasting->DoCommand(AsMainMapTile(tile), roadbits_tram | (ROADTYPE_TRAM << 4), 0, CMD_BUILD_ROAD | CMD_MSG(STR_ERROR_CAN_T_BUILD_TRAMWAY_HERE));
+		}
+	} else {
+		RoadTypes rt = ROADTYPES_NONE;
+		if (roadbits_road != ROAD_NONE) rt |= ROADTYPES_ROAD;
+		if (roadbits_tram != ROAD_NONE) rt |= ROADTYPES_TRAM;
+		assert(rt != ROADTYPES_NONE);
+
+		MakeRoadNormal(tile, ROAD_NONE, rt, 0, OWNER_NONE, OWNER_NONE);
+		SetRoadBits(tile, roadbits_road, ROADTYPE_ROAD);
+		SetDisallowedRoadDirections(tile, drd);
+		SetRoadBits(tile, roadbits_tram, ROADTYPE_TRAM);
+	}
+}
+
+static void CopyPastePlaceRoadCrossing(GenericTileIndex tile, RoadTypes road_types, Axis road_axis, RailType railtype)
+{
+	if (IsMainMapTile(tile)) {
+		CopyPastePlaceRoad(tile, HasBit(road_types, ROADTYPE_ROAD) ? AxisToRoadBits(road_axis) : ROAD_NONE,
+				DRD_NONE, HasBit(road_types, ROADTYPE_TRAM) ? AxisToRoadBits(road_axis) : ROAD_NONE);
+		CopyPastePlaceTracks(tile, railtype, AxisToTrackBits(OtherAxis(road_axis)));
+	} else {
+		MakeRoadCrossing(tile, OWNER_NONE, OWNER_NONE, OWNER_NONE, road_axis, railtype, road_types, 0);
+	}
+}
+
+static void CopyPastePlaceRoadDepot(GenericTileIndex tile, RoadType rt, DiagDirection dir)
+{
+	if (IsMainMapTile(tile)) {
+		TileIndex t = AsMainMapTile(tile);
+		if (IsRoadDepotTile(t) && IsTileOwner(t, _current_company) &&
+				 GetRoadDepotDirection(t) == dir && GetRoadTypes(t) == RoadTypeToRoadTypes(rt)) {
+			_current_pasting->CollectError(t, STR_ERROR_ALREADY_BUILT, STR_ERROR_CAN_T_BUILD_ROAD_DEPOT);
+		} else {
+			_current_pasting->DoCommand(t, dir | (rt << 2), 0, CMD_BUILD_ROAD_DEPOT | CMD_MSG(rt + STR_ERROR_CAN_T_BUILD_ROAD_DEPOT));
+		}
+	} else {
+		MakeRoadDepot(tile, OWNER_NONE, 0, dir, rt);
+	}
+}
+
+static bool IsRoadCopyable(GenericTileIndex tile, RoadType rt, CompanyID company = _current_company)
+{
+	return HasTileRoadType(tile, rt) && (!IsMainMapTile(tile) || IsRoadOwner(tile, rt, company));
+}
+
+/**
+ * Test a given road tile if there is any contented to be copied from it.
+ * @param tile the tile to test
+ * @param mode copy-paste mode
+ * @param company the #Company to check ownership against to
+ * @param preview (out, may be NULL) information on how to higlight preview of the tile
+ * @return whether this tile needs to be copy-pasted
+ */
+bool TestRoadTileCopyability(GenericTileIndex tile, CopyPasteMode mode, CompanyID company = _current_company, TileContentPastePreview *preview = NULL)
+{
+	if (preview != NULL) MemSetT(preview, 0);
+
+	if (!(mode & (CPM_WITH_ROAD_TRANSPORT | CPM_WITH_RAIL_TRANSPORT))) return false;
+
+	switch (GetRoadTileType(tile)) {
+		case ROAD_TILE_NORMAL:
+			if (!(mode & CPM_WITH_ROAD_TRANSPORT)) return false;
+			if (!IsRoadCopyable(tile, ROADTYPE_ROAD, company) && !IsRoadCopyable(tile, ROADTYPE_TRAM, company)) return false;
+			if (preview != NULL) preview->highlight_tile_rect = true;
+			break;
+
+		case ROAD_TILE_CROSSING: {
+			bool road_ok = (mode & CPM_WITH_ROAD_TRANSPORT) && (IsRoadCopyable(tile, ROADTYPE_ROAD, company) || IsRoadCopyable(tile, ROADTYPE_TRAM, company));
+			bool rail_ok = (mode & CPM_WITH_RAIL_TRANSPORT) && (!IsMainMapTile(tile) || IsTileOwner(tile, company));
+			if (!road_ok && !rail_ok) return false;
+			if (preview != NULL) {
+				if (road_ok) preview->highlight_tile_rect = true;
+				if (rail_ok) preview->highlight_track_bits = GetCrossingRailBits(tile);
+			}
+			break;
+		}
+
+		case ROAD_TILE_DEPOT:
+			if (!(mode & CPM_WITH_ROAD_TRANSPORT)) return false;
+			if (IsMainMapTile(tile) && !IsTileOwner(tile, company)) return false;
+			if (preview != NULL) preview->highlight_tile_rect = true;
+			break;
+	}
+
+	return true;
+}
+
+void CopyPasteTile_Road(GenericTileIndex src_tile, GenericTileIndex dst_tile, const CopyPasteParams &copy_paste)
+{
+	if (!TestRoadTileCopyability(src_tile, copy_paste.mode)) return;
+
+	/* Terraform tile if needed */
+	if (IsMainMapTile(dst_tile) && (copy_paste.mode & CPM_TERRAFORM_MASK) == CPM_TERRAFORM_MINIMAL) {
+		CopyPasteHeights(GenericTileArea(src_tile, 1, 1), dst_tile, copy_paste.transformation, copy_paste.height_delta);
+		if (IsPastingInterrupted()) return;
+	}
+
+	switch (GetRoadTileType(src_tile)) {
+		case ROAD_TILE_NORMAL: {
+			RoadBits roadbits_road = IsRoadCopyable(src_tile, ROADTYPE_ROAD) ?
+					TransformRoadBits(GetRoadBits(src_tile, ROADTYPE_ROAD), copy_paste.transformation) : ROAD_NONE;
+			RoadBits roadbits_tram = IsRoadCopyable(src_tile, ROADTYPE_TRAM) ?
+					TransformRoadBits(GetRoadBits(src_tile, ROADTYPE_TRAM), copy_paste.transformation) : ROAD_NONE;
+
+			/* transform DisallowedRoadDirections */
+			DisallowedRoadDirections drd = GetDisallowedRoadDirections(src_tile);
+			if (copy_paste.transformation != DTR_IDENTITY && (drd == DRD_SOUTHBOUND || drd == DRD_NORTHBOUND)) {
+				/* investigate current direction */
+				DiagDirection dir = (GetRoadBits(src_tile, ROADTYPE_ROAD) & ROAD_X) ? DIAGDIR_SW : DIAGDIR_SE;
+				if (drd == DRD_NORTHBOUND) dir = ReverseDiagDir(dir);
+				/* transform */
+				dir = TransformDiagDir(dir, copy_paste.transformation);
+				/* convert result to DisallowedRoadDirections */
+				drd = (dir == DIAGDIR_SW || dir == DIAGDIR_SE) ? DRD_SOUTHBOUND : DRD_NORTHBOUND;
+			}
+
+			/* paste roads */
+			CopyPastePlaceRoad(dst_tile, roadbits_road, drd, roadbits_tram);
+			break;
+		}
+
+		case ROAD_TILE_CROSSING: {
+			Axis road_axis = TransformAxis(GetCrossingRoadAxis(src_tile), copy_paste.transformation);
+			RoadTypes road_types = ROADTYPES_NONE;
+			if (copy_paste.mode & CPM_WITH_ROAD_TRANSPORT) {
+				if (IsRoadCopyable(src_tile, ROADTYPE_ROAD)) SetBit(road_types, ROADTYPE_ROAD);
+				if (IsRoadCopyable(src_tile, ROADTYPE_TRAM)) SetBit(road_types, ROADTYPE_TRAM);
+			}
+
+			if ((copy_paste.mode & CPM_WITH_RAIL_TRANSPORT) && (!IsMainMapTile(src_tile) || IsTileOwner(src_tile, _current_company))) {
+				RailType railtype = (copy_paste.mode & CPM_CONVERT_RAILTYPE) ? copy_paste.railtype : GetRailType(src_tile);
+				if (road_types != ROADTYPES_NONE) {
+					CopyPastePlaceRoadCrossing(dst_tile, road_types, road_axis, railtype);
+				} else {
+					CopyPastePlaceTracks(dst_tile, railtype, AxisToTrackBits(OtherAxis(road_axis)));
+				}
+			} else if (road_types != ROADTYPES_NONE) {
+				CopyPastePlaceRoad(dst_tile, HasBit(road_types, ROADTYPE_ROAD) ? AxisToRoadBits(road_axis) : ROAD_NONE,
+						DRD_NONE, HasBit(road_types, ROADTYPE_TRAM) ? AxisToRoadBits(road_axis) : ROAD_NONE);
+			}
+			break;
+		}
+
+		case ROAD_TILE_DEPOT:
+			/* paste depot */
+			CopyPastePlaceRoadDepot(dst_tile, (RoadType)FIND_FIRST_BIT(GetRoadTypes(src_tile)),
+					TransformDiagDir(GetRoadDepotDirection(src_tile), copy_paste.transformation));
+			break;
+
+		default:
+			NOT_REACHED(); // corrupted tile data?
+	}
+}
+
 /** Tile callback functions for road tiles */
 extern const TileTypeProcs _tile_type_road_procs = {
 	DrawTile_Road,           // draw_tile_proc
@@ -1846,11 +2077,12 @@
 	GetTileDesc_Road,        // get_tile_desc_proc
 	GetTileTrackStatus_Road, // get_tile_track_status_proc
 	ClickTile_Road,          // click_tile_proc
-	NULL,                    // animate_tile_proc
+	AnimateTile_Road,        // animate_tile_proc
 	TileLoop_Road,           // tile_loop_proc
 	ChangeTileOwner_Road,    // change_tile_owner_proc
 	NULL,                    // add_produced_cargo_proc
 	VehicleEnter_Road,       // vehicle_enter_tile_proc
 	GetFoundation_Road,      // get_foundation_proc
 	TerraformTile_Road,      // terraform_tile_proc
+	CopyPasteTile_Road,      // copypaste_tile_proc
 };
diff -urNad openttd-1.3.2/src/road_cmd.h openttd-1.3.2-DC3.0RC3/src/road_cmd.h
--- openttd-1.3.2/src/road_cmd.h	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/road_cmd.h	2013-11-22 05:49:07.000000000 +0100
@@ -14,8 +14,11 @@
 
 #include "direction_type.h"
 #include "road_type.h"
+#include "tile_cmd.h"
+#include "gfx_type.h"
 
 void DrawRoadDepotSprite(int x, int y, DiagDirection dir, RoadType rt);
 void UpdateNearestTownForRoadTiles(bool invalidate);
+void DrawRoadDetail(SpriteID img, TileInfo *ti, int dx, int dy, int h);
 
 #endif /* ROAD_CMD_H */
diff -urNad openttd-1.3.2/src/road_func.h openttd-1.3.2-DC3.0RC3/src/road_func.h
--- openttd-1.3.2/src/road_func.h	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/road_func.h	2013-11-22 05:49:07.000000000 +0100
@@ -14,6 +14,7 @@
 
 #include "core/bitmath_func.hpp"
 #include "road_type.h"
+#include "direction_func.h"
 #include "economy_func.h"
 
 /**
@@ -77,6 +78,20 @@
 }
 
 /**
+ * Calculate rotated RoadBits
+ *
+ * Move the RoadBits clockwise to their new position.
+ *
+ * @param r The given RoadBits value
+ * @param rot The given rotation angle
+ * @return The rotated RoadBits
+ */
+static inline RoadBits RotateRoadBits(RoadBits r, DiagDirDiff rot)
+{
+	return (RoadBits)((r | (r << DIAGDIR_END)) >> rot) & ROAD_ALL;
+}
+
+/**
  * Calculate the mirrored RoadBits
  *
  * Simply move the bits to their new position.
@@ -86,24 +101,36 @@
  */
 static inline RoadBits MirrorRoadBits(RoadBits r)
 {
-	return (RoadBits)(GB(r, 0, 2) << 2 | GB(r, 2, 2));
+	return RotateRoadBits(r, DIAGDIRDIFF_REVERSE);
 }
 
 /**
- * Calculate rotated RoadBits
- *
- * Move the Roadbits clockwise until they are in their final position.
- *
- * @param r The given RoadBits value
- * @param rot The given Rotation angle
- * @return the rotated
+ * Transform RoadBits by given transformation.
+ * @param road_bits The RoadBits to transform.
+ * @param transformation Transformation to perform.
+ * @return The transformed RoadBits.
  */
-static inline RoadBits RotateRoadBits(RoadBits r, DiagDirDiff rot)
+static inline RoadBits TransformRoadBits(RoadBits road_bits, DirTransformation transformation)
 {
-	for (; rot > (DiagDirDiff)0; rot--) {
-		r = (RoadBits)(GB(r, 0, 1) << 3 | GB(r, 1, 3));
+	/* reflect agains X axis before rotating */
+	if (transformation & DTR_REFLECTION_BIT) {
+		/* firstly reflect against W-E axis by swapping odd and even bits (the numbers are bit positions)
+		 *
+		 * [ROAD_NW] [ROAD_NE]    0   3                            1   2      /N\
+		 * -------------------    -----  --reflect-against-W-E-->  -----     W-+-E
+		 * [ROAD_SW] [ROAD_SE]    1   2                            0   3      \S/
+		 *
+		 * bit 0 (ROAD_NW) swaps with bit 1 (ROAD_SW)
+		 * bit 2 (ROAD_SE) swaps with bit 3 (ROAD_NE) */
+		road_bits = SwapOddEvenBits(road_bits);
+		/* Now we have reflection agains W-E axis. To get reflection agains X axis we must rotate the
+		 * result left by 90 degree. To do that we can simply subtract 1 from the number of 90-degree
+		 * right rotations that we will be doing in the next step. We can safely overflow. */
+		transformation = (DirTransformation)(transformation - 1);
 	}
-	return r;
+
+	/* rotate */
+	return RotateRoadBits(road_bits, (DiagDirDiff)(transformation & DTR_ROTATION_MASK));
 }
 
 /**
diff -urNad openttd-1.3.2/src/road_gui.cpp openttd-1.3.2-DC3.0RC3/src/road_gui.cpp
--- openttd-1.3.2/src/road_gui.cpp	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/road_gui.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -67,6 +67,23 @@
 }
 
 /**
+ * Place trafficlights on a tile or returns an error.
+ * @param tile This tile.
+ */
+static void PlaceRoad_TrafficLights(TileIndex tile, Window *w)
+{
+	if (_remove_button_clicked) {
+		DoCommandP(tile, 0, 0, CMD_REMOVE_TRAFFICLIGHTS | CMD_MSG(STR_ERROR_CAN_T_REMOVE_TRAFFIC_LIGHTS_FROM), CcPlaySound1D);
+	} else {
+		if (!_settings_game.construction.traffic_lights) {
+			DoCommandP(tile, 0, 0, CMD_BUILD_TRAFFICLIGHTS | CMD_MSG(STR_ERROR_BUILDING_TRAFFIC_LIGHTS_DISABLED), CcPlaySound1D);
+		} else{
+			DoCommandP(tile, 0, 0, CMD_BUILD_TRAFFICLIGHTS | CMD_MSG(STR_ERROR_CAN_T_PLACE_TRAFFIC_LIGHTS), CcPlaySound1D);
+		}
+	}
+}
+
+/**
  * Callback to start placing a bridge.
  * @param tile Start tile of the bridge.
  */
@@ -301,6 +318,12 @@
 		}
 	}
 
+	/* Allow ctrl also for traffic lights. */
+	if (w->IsWidgetLowered(WID_ROT_TRAFFIC_LIGHT)) {
+		ToggleRoadButton_Remove(w);
+		return true;
+	}
+
 	return false;
 }
 
@@ -316,6 +339,11 @@
 				WID_ROT_ONE_WAY,
 				WIDGET_LIST_END);
 
+		this->SetWidgetsDisabledState(!_settings_game.construction.traffic_lights,
+				WID_ROT_TRAFFIC_LIGHT,
+				WIDGET_LIST_END);
+		if (!_settings_game.construction.traffic_lights && this->IsWidgetLowered(WID_ROT_TRAFFIC_LIGHT)) ResetObjectToPlace();
+
 		this->OnInvalidateData();
 		this->last_started_action = WIDGET_LIST_END;
 
@@ -365,6 +393,7 @@
 
 			case WID_ROT_BUS_STATION:
 			case WID_ROT_TRUCK_STATION:
+			case WID_ROT_TRAFFIC_LIGHT:
 				this->DisableWidget(WID_ROT_ONE_WAY);
 				this->SetWidgetDisabledState(WID_ROT_REMOVE, !this->IsWidgetLowered(clicked_widget));
 				break;
@@ -449,6 +478,11 @@
 				SetSelectionRed(false);
 				break;
 
+			case WID_ROT_TRAFFIC_LIGHT:
+				HandlePlacePushButton(this, WID_ROT_TRAFFIC_LIGHT, SPR_CURSOR_TRAFFIC_LIGHT, HT_RECT);
+				this->last_started_action = widget;
+				break;
+
 			case WID_ROT_BUILD_BRIDGE:
 				HandlePlacePushButton(this, WID_ROT_BUILD_BRIDGE, SPR_CURSOR_BRIDGE, HT_RECT);
 				this->last_started_action = widget;
@@ -523,6 +557,10 @@
 				PlaceRoad_TruckStation(tile);
 				break;
 
+			case WID_ROT_TRAFFIC_LIGHT:
+				PlaceRoad_TrafficLights(tile, this);
+				break;
+
 			case WID_ROT_BUILD_BRIDGE:
 				PlaceRoad_Bridge(tile, this);
 				break;
@@ -704,6 +742,8 @@
 		NWidget(WWT_PANEL, COLOUR_DARK_GREEN, -1), SetMinimalSize(0, 22), SetFill(1, 1), EndContainer(),
 		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_ROT_ONE_WAY),
 						SetFill(0, 1), SetMinimalSize(22, 22), SetDataTip(SPR_IMG_ROAD_ONE_WAY, STR_ROAD_TOOLBAR_TOOLTIP_TOGGLE_ONE_WAY_ROAD),
+		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_ROT_TRAFFIC_LIGHT),
+						SetFill(0, 1), SetMinimalSize(22, 22), SetDataTip(SPR_IMG_TRAFFIC_LIGHT, STR_ROAD_TOOLBAR_TOOLTIP_BUILD_TRAFFIC_LIGHT),
 		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_ROT_BUILD_BRIDGE),
 						SetFill(0, 1), SetMinimalSize(43, 22), SetDataTip(SPR_IMG_BRIDGE, STR_ROAD_TOOLBAR_TOOLTIP_BUILD_ROAD_BRIDGE),
 		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_ROT_BUILD_TUNNEL),
@@ -743,6 +783,8 @@
 						SetFill(0, 1), SetMinimalSize(22, 22), SetDataTip(SPR_IMG_TRUCK_BAY, STR_ROAD_TOOLBAR_TOOLTIP_BUILD_CARGO_TRAM_STATION),
 		NWidget(WWT_PANEL, COLOUR_DARK_GREEN, -1), SetMinimalSize(0, 22), SetFill(1, 1), EndContainer(),
 		NWidget(WWT_EMPTY, COLOUR_DARK_GREEN, WID_ROT_ONE_WAY), SetMinimalSize(0, 0),
+		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_ROT_TRAFFIC_LIGHT),
+						SetFill(0, 1), SetMinimalSize(22, 22), SetDataTip(SPR_IMG_TRAFFIC_LIGHT, STR_ROAD_TOOLBAR_TOOLTIP_BUILD_TRAFFIC_LIGHT),
 		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_ROT_BUILD_BRIDGE),
 						SetFill(0, 1), SetMinimalSize(43, 22), SetDataTip(SPR_IMG_BRIDGE, STR_ROAD_TOOLBAR_TOOLTIP_BUILD_TRAMWAY_BRIDGE),
 		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_ROT_BUILD_TUNNEL),
@@ -803,6 +845,8 @@
 		NWidget(WWT_PANEL, COLOUR_DARK_GREEN, -1), SetMinimalSize(0, 22), SetFill(1, 1), EndContainer(),
 		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_ROT_ONE_WAY),
 						SetFill(0, 1), SetMinimalSize(22, 22), SetDataTip(SPR_IMG_ROAD_ONE_WAY, STR_ROAD_TOOLBAR_TOOLTIP_TOGGLE_ONE_WAY_ROAD),
+		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_ROT_TRAFFIC_LIGHT),
+						SetFill(0, 1), SetMinimalSize(22, 22), SetDataTip(SPR_IMG_TRAFFIC_LIGHT, STR_ROAD_TOOLBAR_TOOLTIP_BUILD_TRAFFIC_LIGHT),
 		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_ROT_BUILD_BRIDGE),
 						SetFill(0, 1), SetMinimalSize(43, 22), SetDataTip(SPR_IMG_BRIDGE, STR_ROAD_TOOLBAR_TOOLTIP_BUILD_ROAD_BRIDGE),
 		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_ROT_BUILD_TUNNEL),
diff -urNad openttd-1.3.2/src/road_map.h openttd-1.3.2-DC3.0RC3/src/road_map.h
--- openttd-1.3.2/src/road_map.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/road_map.h	2013-11-22 05:49:07.000000000 +0100
@@ -32,11 +32,16 @@
  * @pre IsTileType(t, MP_ROAD)
  * @return The road tile type.
  */
-static inline RoadTileType GetRoadTileType(TileIndex t)
+template <bool Tgeneric>
+static inline RoadTileType GetRoadTileType(typename TileIndexT<Tgeneric>::T t)
 {
 	assert(IsTileType(t, MP_ROAD));
-	return (RoadTileType)GB(_m[t].m5, 6, 2);
+	return (RoadTileType)GB(GetTile(t)->m5, 6, 2);
 }
+/** @copydoc GetRoadTileType(TileIndexT<Tgeneric>::T) */
+static inline RoadTileType GetRoadTileType(TileIndex t) { return GetRoadTileType<false>(t); }
+/** @copydoc GetRoadTileType(TileIndexT<Tgeneric>::T) */
+static inline RoadTileType GetRoadTileType(GenericTileIndex t) { return GetRoadTileType<true>(t); }
 
 /**
  * Return whether a tile is a normal road.
@@ -44,20 +49,30 @@
  * @pre IsTileType(t, MP_ROAD)
  * @return True if normal road.
  */
-static inline bool IsNormalRoad(TileIndex t)
+template <bool Tgeneric>
+static inline bool IsNormalRoad(typename TileIndexT<Tgeneric>::T t)
 {
 	return GetRoadTileType(t) == ROAD_TILE_NORMAL;
 }
+/** @copydoc IsNormalRoad(TileIndexT<Tgeneric>::T) */
+static inline bool IsNormalRoad(TileIndex t) { return IsNormalRoad<false>(t); }
+/** @copydoc IsNormalRoad(TileIndexT<Tgeneric>::T) */
+static inline bool IsNormalRoad(GenericTileIndex t) { return IsNormalRoad<true>(t); }
 
 /**
  * Return whether a tile is a normal road tile.
  * @param t Tile to query.
  * @return True if normal road tile.
  */
-static inline bool IsNormalRoadTile(TileIndex t)
+template <bool Tgeneric>
+static inline bool IsNormalRoadTile(typename TileIndexT<Tgeneric>::T t)
 {
 	return IsTileType(t, MP_ROAD) && IsNormalRoad(t);
 }
+/** @copydoc IsNormalRoadTile(TileIndexT<Tgeneric>::T) */
+static inline bool IsNormalRoadTile(TileIndex t) { return IsNormalRoadTile<false>(t); }
+/** @copydoc IsNormalRoadTile(TileIndexT<Tgeneric>::T) */
+static inline bool IsNormalRoadTile(GenericTileIndex t) { return IsNormalRoadTile<true>(t); }
 
 /**
  * Return whether a tile is a level crossing.
@@ -65,20 +80,30 @@
  * @pre IsTileType(t, MP_ROAD)
  * @return True if level crossing.
  */
-static inline bool IsLevelCrossing(TileIndex t)
+template <bool Tgeneric>
+static inline bool IsLevelCrossing(typename TileIndexT<Tgeneric>::T t)
 {
 	return GetRoadTileType(t) == ROAD_TILE_CROSSING;
 }
+/** @copydoc IsLevelCrossing(TileIndexT<Tgeneric>::T) */
+static inline bool IsLevelCrossing(TileIndex t) { return IsLevelCrossing<false>(t); }
+/** @copydoc IsLevelCrossing(TileIndexT<Tgeneric>::T) */
+static inline bool IsLevelCrossing(GenericTileIndex t) { return IsLevelCrossing<true>(t); }
 
 /**
  * Return whether a tile is a level crossing tile.
  * @param t Tile to query.
  * @return True if level crossing tile.
  */
-static inline bool IsLevelCrossingTile(TileIndex t)
+template <bool Tgeneric>
+static inline bool IsLevelCrossingTile(typename TileIndexT<Tgeneric>::T t)
 {
 	return IsTileType(t, MP_ROAD) && IsLevelCrossing(t);
 }
+/** @copydoc IsLevelCrossingTile(TileIndexT<Tgeneric>::T) */
+static inline bool IsLevelCrossingTile(TileIndex t) { return IsLevelCrossingTile<false>(t); }
+/** @copydoc IsLevelCrossingTile(TileIndexT<Tgeneric>::T) */
+static inline bool IsLevelCrossingTile(GenericTileIndex t) { return IsLevelCrossingTile<true>(t); }
 
 /**
  * Return whether a tile is a road depot.
@@ -86,10 +111,15 @@
  * @pre IsTileType(t, MP_ROAD)
  * @return True if road depot.
  */
-static inline bool IsRoadDepot(TileIndex t)
+template <bool Tgeneric>
+static inline bool IsRoadDepot(typename TileIndexT<Tgeneric>::T t)
 {
 	return GetRoadTileType(t) == ROAD_TILE_DEPOT;
 }
+/** @copydoc IsRoadDepot(TileIndexT<Tgeneric>::T) */
+static inline bool IsRoadDepot(TileIndex t) { return IsRoadDepot<false>(t); }
+/** @copydoc IsRoadDepot(TileIndexT<Tgeneric>::T) */
+static inline bool IsRoadDepot(GenericTileIndex t) { return IsRoadDepot<true>(t); }
 
 /**
  * Return whether a tile is a road depot tile.
@@ -108,15 +138,20 @@
  * @pre IsNormalRoad(t)
  * @return The present road bits for the road type.
  */
-static inline RoadBits GetRoadBits(TileIndex t, RoadType rt)
+template <bool Tgeneric>
+static inline RoadBits GetRoadBits(typename TileIndexT<Tgeneric>::T t, RoadType rt)
 {
 	assert(IsNormalRoad(t));
 	switch (rt) {
 		default: NOT_REACHED();
-		case ROADTYPE_ROAD: return (RoadBits)GB(_m[t].m5, 0, 4);
-		case ROADTYPE_TRAM: return (RoadBits)GB(_m[t].m3, 0, 4);
+		case ROADTYPE_ROAD: return (RoadBits)GB(GetTile(t)->m5, 0, 4);
+		case ROADTYPE_TRAM: return (RoadBits)GB(GetTile(t)->m3, 0, 4);
 	}
 }
+/** @copydoc GetRoadBits(TileIndexT<Tgeneric>::T,RoadType) */
+static inline RoadBits GetRoadBits(TileIndex t, RoadType rt) { return GetRoadBits<false>(t, rt); }
+/** @copydoc GetRoadBits(TileIndexT<Tgeneric>::T,RoadType) */
+static inline RoadBits GetRoadBits(GenericTileIndex t, RoadType rt) { return GetRoadBits<true>(t, rt); }
 
 /**
  * Get all RoadBits set on a tile except from the given RoadType
@@ -148,36 +183,51 @@
  * @param rt Road type.
  * @pre IsNormalRoad(t)
  */
-static inline void SetRoadBits(TileIndex t, RoadBits r, RoadType rt)
+template <bool Tgeneric>
+static inline void SetRoadBits(typename TileIndexT<Tgeneric>::T t, RoadBits r, RoadType rt)
 {
 	assert(IsNormalRoad(t)); // XXX incomplete
 	switch (rt) {
 		default: NOT_REACHED();
-		case ROADTYPE_ROAD: SB(_m[t].m5, 0, 4, r); break;
-		case ROADTYPE_TRAM: SB(_m[t].m3, 0, 4, r); break;
+		case ROADTYPE_ROAD: SB(GetTile(t)->m5, 0, 4, r); break;
+		case ROADTYPE_TRAM: SB(GetTile(t)->m3, 0, 4, r); break;
 	}
 }
+/** @copydoc SetRoadBits(TileIndexT<Tgeneric>::T,RoadBits,RoadType) */
+static inline void SetRoadBits(TileIndex t, RoadBits r, RoadType rt) { SetRoadBits<false>(t, r, rt); }
+/** @copydoc SetRoadBits(TileIndexT<Tgeneric>::T,RoadBits,RoadType) */
+static inline void SetRoadBits(GenericTileIndex t, RoadBits r, RoadType rt) { SetRoadBits<true>(t, r, rt); }
 
 /**
  * Get the present road types of a tile.
  * @param t The tile to query.
  * @return Present road types.
  */
-static inline RoadTypes GetRoadTypes(TileIndex t)
+template <bool Tgeneric>
+static inline RoadTypes GetRoadTypes(typename TileIndexT<Tgeneric>::T t)
 {
-	return (RoadTypes)GB(_me[t].m7, 6, 2);
+	return (RoadTypes)GB(GetTileEx(t)->m7, 6, 2);
 }
+/** @copydoc GetRoadTypes(TileIndexT<Tgeneric>::T) */
+static inline RoadTypes GetRoadTypes(TileIndex t) { return GetRoadTypes<false>(t); }
+/** @copydoc GetRoadTypes(TileIndexT<Tgeneric>::T) */
+static inline RoadTypes GetRoadTypes(GenericTileIndex t) { return GetRoadTypes<true>(t); }
 
 /**
  * Set the present road types of a tile.
  * @param t  The tile to change.
  * @param rt The new road types.
  */
-static inline void SetRoadTypes(TileIndex t, RoadTypes rt)
+template <bool Tgeneric>
+static inline void SetRoadTypes(typename TileIndexT<Tgeneric>::T t, RoadTypes rt)
 {
 	assert(IsTileType(t, MP_ROAD) || IsTileType(t, MP_STATION) || IsTileType(t, MP_TUNNELBRIDGE));
-	SB(_me[t].m7, 6, 2, rt);
+	SB(GetTileEx(t)->m7, 6, 2, rt);
 }
+/** @copydoc SetRoadTypes(TileIndexT<Tgeneric>::T,RoadTypes) */
+static inline void SetRoadTypes(TileIndex t, RoadTypes rt) { SetRoadTypes<false>(t, rt); }
+/** @copydoc SetRoadTypes(TileIndexT<Tgeneric>::T,RoadTypes) */
+static inline void SetRoadTypes(GenericTileIndex t, RoadTypes rt) { SetRoadTypes<true>(t, rt); }
 
 /**
  * Check if a tile has a specific road type.
@@ -185,10 +235,15 @@
  * @param rt Road type to check.
  * @return True if the tile has the specified road type.
  */
-static inline bool HasTileRoadType(TileIndex t, RoadType rt)
+template <bool Tgeneric>
+static inline bool HasTileRoadType(typename TileIndexT<Tgeneric>::T t, RoadType rt)
 {
 	return HasBit(GetRoadTypes(t), rt);
 }
+/** @copydoc HasTileRoadType(TileIndexT<Tgeneric>::T,RoadType) */
+static inline bool HasTileRoadType(TileIndex t, RoadType rt) { return HasTileRoadType<false>(t, rt); }
+/** @copydoc HasTileRoadType(TileIndexT<Tgeneric>::T,RoadType) */
+static inline bool HasTileRoadType(GenericTileIndex t, RoadType rt) { return HasTileRoadType<true>(t, rt); }
 
 /**
  * Get the owner of a specific road type.
@@ -196,20 +251,25 @@
  * @param rt The road type to get the owner of.
  * @return Owner of the given road type.
  */
-static inline Owner GetRoadOwner(TileIndex t, RoadType rt)
+template <bool Tgeneric>
+static inline Owner GetRoadOwner(typename TileIndexT<Tgeneric>::T t, RoadType rt)
 {
 	assert(IsTileType(t, MP_ROAD) || IsTileType(t, MP_STATION) || IsTileType(t, MP_TUNNELBRIDGE));
 	switch (rt) {
 		default: NOT_REACHED();
-		case ROADTYPE_ROAD: return (Owner)GB(IsNormalRoadTile(t) ? _m[t].m1 : _me[t].m7, 0, 5);
+		case ROADTYPE_ROAD: return (Owner)GB(IsNormalRoadTile(t) ? GetTile(t)->m1 : GetTileEx(t)->m7, 0, 5);
 		case ROADTYPE_TRAM: {
 			/* Trams don't need OWNER_TOWN, and remapping OWNER_NONE
 			 * to OWNER_TOWN makes it use one bit less */
-			Owner o = (Owner)GB(_m[t].m3, 4, 4);
+			Owner o = (Owner)GB(GetTile(t)->m3, 4, 4);
 			return o == OWNER_TOWN ? OWNER_NONE : o;
 		}
 	}
 }
+/** @copydoc GetRoadOwner(TileIndexT<Tgeneric>::T,RoadType) */
+static inline Owner GetRoadOwner(TileIndex t, RoadType rt) { return GetRoadOwner<false>(t, rt); }
+/** @copydoc GetRoadOwner(TileIndexT<Tgeneric>::T,RoadType) */
+static inline Owner GetRoadOwner(GenericTileIndex t, RoadType rt) { return GetRoadOwner<true>(t, rt); }
 
 /**
  * Set the owner of a specific road type.
@@ -217,14 +277,19 @@
  * @param rt The road type to change the owner of.
  * @param o  New owner of the given road type.
  */
-static inline void SetRoadOwner(TileIndex t, RoadType rt, Owner o)
+template <bool Tgeneric>
+static inline void SetRoadOwner(typename TileIndexT<Tgeneric>::T t, RoadType rt, Owner o)
 {
 	switch (rt) {
 		default: NOT_REACHED();
-		case ROADTYPE_ROAD: SB(IsNormalRoadTile(t) ? _m[t].m1 : _me[t].m7, 0, 5, o); break;
-		case ROADTYPE_TRAM: SB(_m[t].m3, 4, 4, o == OWNER_NONE ? OWNER_TOWN : o); break;
+		case ROADTYPE_ROAD: SB(IsNormalRoadTile(t) ? GetTile(t)->m1 : GetTileEx(t)->m7, 0, 5, o); break;
+		case ROADTYPE_TRAM: SB(GetTile(t)->m3, 4, 4, o == OWNER_NONE ? OWNER_TOWN : o); break;
 	}
 }
+/** @copydoc SetRoadOwner(TileIndexT<Tgeneric>::T,RoadType,Owner) */
+static inline void SetRoadOwner(TileIndex t, RoadType rt, Owner o) { SetRoadOwner<false>(t, rt, o); }
+/** @copydoc SetRoadOwner(TileIndexT<Tgeneric>::T,RoadType,Owner) */
+static inline void SetRoadOwner(GenericTileIndex t, RoadType rt, Owner o) { SetRoadOwner<true>(t, rt, o); }
 
 /**
  * Check if a specific road type is owned by an owner.
@@ -234,11 +299,16 @@
  * @pre HasTileRoadType(t, rt)
  * @return True if the road type is owned by the given owner.
  */
-static inline bool IsRoadOwner(TileIndex t, RoadType rt, Owner o)
+template <bool Tgeneric>
+static inline bool IsRoadOwner(typename TileIndexT<Tgeneric>::T t, RoadType rt, Owner o)
 {
 	assert(HasTileRoadType(t, rt));
 	return (GetRoadOwner(t, rt) == o);
 }
+/** @copydoc IsRoadOwner(TileIndexT<Tgeneric>::T,RoadType,Owner) */
+static inline bool IsRoadOwner(TileIndex t, RoadType rt, Owner o) { return IsRoadOwner<false>(t, rt, o); }
+/** @copydoc IsRoadOwner(TileIndexT<Tgeneric>::T,RoadType,Owner) */
+static inline bool IsRoadOwner(GenericTileIndex t, RoadType rt, Owner o) { return IsRoadOwner<true>(t, rt, o); }
 
 /**
  * Checks if given tile has town owned road
@@ -251,6 +321,29 @@
 	return HasTileRoadType(t, ROADTYPE_ROAD) && IsRoadOwner(t, ROADTYPE_ROAD, OWNER_TOWN);
 }
 
+static inline void MakeTrafficLights(TileIndex t)
+{
+	assert(IsTileType(t, MP_ROAD));
+	assert(GetRoadTileType(t) == ROAD_TILE_NORMAL);
+	SetBit(GetTileEx(t)->m7, 4);
+}
+
+static inline void ClearTrafficLights(TileIndex t)
+{
+	assert(IsTileType(t, MP_ROAD));
+	assert(GetRoadTileType(t) == ROAD_TILE_NORMAL);
+	ClrBit(GetTileEx(t)->m7, 4);
+}
+
+/**
+ * Check if a tile has traffic lights returns true if tile has traffic lights.
+ * @param t The tile to check.
+ */
+static inline bool HasTrafficLights(TileIndex t)
+{
+	return (IsTileType(t, MP_ROAD) && (GetRoadTileType(t) == ROAD_TILE_NORMAL) && HasBit(GetTileEx(t)->m7, 4));
+}
+
 /** Which directions are disallowed ? */
 enum DisallowedRoadDirections {
 	DRD_NONE,       ///< None of the directions are disallowed
@@ -268,23 +361,33 @@
  * @param t the tile to get the directions from
  * @return the disallowed directions
  */
-static inline DisallowedRoadDirections GetDisallowedRoadDirections(TileIndex t)
+template <bool Tgeneric>
+static inline DisallowedRoadDirections GetDisallowedRoadDirections(typename TileIndexT<Tgeneric>::T t)
 {
 	assert(IsNormalRoad(t));
-	return (DisallowedRoadDirections)GB(_m[t].m5, 4, 2);
+	return (DisallowedRoadDirections)GB(GetTile(t)->m5, 4, 2);
 }
+/** @copydoc GetDisallowedRoadDirections(TileIndexT<Tgeneric>::T) */
+static inline DisallowedRoadDirections GetDisallowedRoadDirections(TileIndex t) { return GetDisallowedRoadDirections<false>(t); }
+/** @copydoc GetDisallowedRoadDirections(TileIndexT<Tgeneric>::T) */
+static inline DisallowedRoadDirections GetDisallowedRoadDirections(GenericTileIndex t) { return GetDisallowedRoadDirections<true>(t); }
 
 /**
  * Sets the disallowed directions
  * @param t   the tile to set the directions for
  * @param drd the disallowed directions
  */
-static inline void SetDisallowedRoadDirections(TileIndex t, DisallowedRoadDirections drd)
+template <bool Tgeneric>
+static inline void SetDisallowedRoadDirections(typename TileIndexT<Tgeneric>::T t, DisallowedRoadDirections drd)
 {
 	assert(IsNormalRoad(t));
 	assert(drd < DRD_END);
-	SB(_m[t].m5, 4, 2, drd);
+	SB(GetTile(t)->m5, 4, 2, drd);
 }
+/** @copydoc SetDisallowedRoadDirections(TileIndexT<Tgeneric>::T,DisallowedRoadDirections) */
+static inline void SetDisallowedRoadDirections(TileIndex t, DisallowedRoadDirections drd) { SetDisallowedRoadDirections<false>(t, drd); }
+/** @copydoc SetDisallowedRoadDirections(TileIndexT<Tgeneric>::T,DisallowedRoadDirections) */
+static inline void SetDisallowedRoadDirections(GenericTileIndex t, DisallowedRoadDirections drd) { SetDisallowedRoadDirections<true>(t, drd); }
 
 /**
  * Get the road axis of a level crossing.
@@ -292,11 +395,16 @@
  * @pre IsLevelCrossing(t)
  * @return The axis of the road.
  */
-static inline Axis GetCrossingRoadAxis(TileIndex t)
+template <bool Tgeneric>
+static inline Axis GetCrossingRoadAxis(typename TileIndexT<Tgeneric>::T t)
 {
 	assert(IsLevelCrossing(t));
-	return (Axis)GB(_m[t].m5, 0, 1);
+	return (Axis)GB(GetTile(t)->m5, 0, 1);
 }
+/** @copydoc GetCrossingRoadAxis(TileIndexT<Tgeneric>::T) */
+static inline Axis GetCrossingRoadAxis(TileIndex t) { return GetCrossingRoadAxis<false>(t); }
+/** @copydoc GetCrossingRoadAxis(TileIndexT<Tgeneric>::T) */
+static inline Axis GetCrossingRoadAxis(GenericTileIndex t) { return GetCrossingRoadAxis<true>(t); }
 
 /**
  * Get the rail axis of a level crossing.
@@ -304,21 +412,31 @@
  * @pre IsLevelCrossing(t)
  * @return The axis of the rail.
  */
-static inline Axis GetCrossingRailAxis(TileIndex t)
+template <bool Tgeneric>
+static inline Axis GetCrossingRailAxis(typename TileIndexT<Tgeneric>::T t)
 {
 	assert(IsLevelCrossing(t));
 	return OtherAxis((Axis)GetCrossingRoadAxis(t));
 }
+/** @copydoc GetCrossingRailAxis(TileIndexT<Tgeneric>::T) */
+static inline Axis GetCrossingRailAxis(TileIndex t) { return GetCrossingRailAxis<false>(t); }
+/** @copydoc GetCrossingRailAxis(TileIndexT<Tgeneric>::T) */
+static inline Axis GetCrossingRailAxis(GenericTileIndex t) { return GetCrossingRailAxis<true>(t); }
 
 /**
  * Get the road bits of a level crossing.
  * @param tile The tile to query.
  * @return The present road bits.
  */
-static inline RoadBits GetCrossingRoadBits(TileIndex tile)
+template <bool Tgeneric>
+static inline RoadBits GetCrossingRoadBits(typename TileIndexT<Tgeneric>::T tile)
 {
 	return GetCrossingRoadAxis(tile) == AXIS_X ? ROAD_X : ROAD_Y;
 }
+/** @copydoc GetCrossingRoadBits(TileIndexT<Tgeneric>::T) */
+static inline RoadBits GetCrossingRoadBits(TileIndex tile) { return GetCrossingRoadBits<false>(tile); }
+/** @copydoc GetCrossingRoadBits(TileIndexT<Tgeneric>::T) */
+static inline RoadBits GetCrossingRoadBits(GenericTileIndex tile) { return GetCrossingRoadBits<true>(tile); }
 
 /**
  * Get the rail track of a level crossing.
@@ -335,10 +453,15 @@
  * @param tile The tile to query.
  * @return The rail track bits.
  */
-static inline TrackBits GetCrossingRailBits(TileIndex tile)
+template <bool Tgeneric>
+static inline TrackBits GetCrossingRailBits(typename TileIndexT<Tgeneric>::T tile)
 {
 	return AxisToTrackBits(GetCrossingRailAxis(tile));
 }
+/** @copydoc GetCrossingRailBits(TileIndexT<Tgeneric>::T) */
+static inline TrackBits GetCrossingRailBits(TileIndex tile) { return GetCrossingRailBits<false>(tile); }
+/** @copydoc GetCrossingRailBits(TileIndexT<Tgeneric>::T) */
+static inline TrackBits GetCrossingRailBits(GenericTileIndex tile) { return GetCrossingRailBits<true>(tile); }
 
 
 /**
@@ -350,7 +473,7 @@
 static inline bool HasCrossingReservation(TileIndex t)
 {
 	assert(IsLevelCrossingTile(t));
-	return HasBit(_m[t].m5, 4);
+	return HasBit(GetTile(t)->m5, 4);
 }
 
 /**
@@ -363,7 +486,7 @@
 static inline void SetCrossingReservation(TileIndex t, bool b)
 {
 	assert(IsLevelCrossingTile(t));
-	SB(_m[t].m5, 4, 1, b ? 1 : 0);
+	SB(GetTile(t)->m5, 4, 1, b ? 1 : 0);
 }
 
 /**
@@ -386,7 +509,7 @@
 static inline bool IsCrossingBarred(TileIndex t)
 {
 	assert(IsLevelCrossing(t));
-	return HasBit(_m[t].m5, 5);
+	return HasBit(GetTile(t)->m5, 5);
 }
 
 /**
@@ -398,7 +521,7 @@
 static inline void SetCrossingBarred(TileIndex t, bool barred)
 {
 	assert(IsLevelCrossing(t));
-	SB(_m[t].m5, 5, 1, barred ? 1 : 0);
+	SB(GetTile(t)->m5, 5, 1, barred ? 1 : 0);
 }
 
 /**
@@ -428,7 +551,7 @@
  */
 static inline bool IsOnSnow(TileIndex t)
 {
-	return HasBit(_me[t].m7, 5);
+	return HasBit(GetTileEx(t)->m7, 5);
 }
 
 /** Toggle the snow/desert state of a road tile. */
@@ -439,7 +562,7 @@
  */
 static inline void ToggleSnow(TileIndex t)
 {
-	ToggleBit(_me[t].m7, 5);
+	ToggleBit(GetTileEx(t)->m7, 5);
 }
 
 
@@ -461,7 +584,7 @@
  */
 static inline Roadside GetRoadside(TileIndex tile)
 {
-	return (Roadside)GB(_m[tile].m6, 3, 3);
+	return (Roadside)GB(GetTileEx(tile)->m6, 3, 3);
 }
 
 /**
@@ -471,7 +594,7 @@
  */
 static inline void SetRoadside(TileIndex tile, Roadside s)
 {
-	SB(_m[tile].m6, 3, 3, s);
+	SB(GetTileEx(tile)->m6, 3, 3, s);
 }
 
 /**
@@ -491,9 +614,14 @@
  */
 static inline bool IncreaseRoadWorksCounter(TileIndex t)
 {
-	AB(_me[t].m7, 0, 4, 1);
+        AB(GetTileEx(t)->m7, 0, 4, 1);
 
-	return GB(_me[t].m7, 0, 4) == 15;
+       return GB(GetTileEx(t)->m7, 0, 4) == 1;
+}
+
+static inline byte GetRoadWorksCounter(TileIndex t)
+{
+	return GB(GetTile(t)->m3, 0, 4);
 }
 
 /**
@@ -522,7 +650,7 @@
 	assert(HasRoadWorks(t));
 	SetRoadside(t, (Roadside)(GetRoadside(t) - ROADSIDE_GRASS_ROAD_WORKS + ROADSIDE_GRASS));
 	/* Stop the counter */
-	SB(_me[t].m7, 0, 4, 0);
+	SB(GetTileEx(t)->m7, 0, 4, 0);
 }
 
 
@@ -531,11 +659,16 @@
  * @param t The tile to query.
  * @return Diagonal direction of the depot exit.
  */
-static inline DiagDirection GetRoadDepotDirection(TileIndex t)
+template <bool Tgeneric>
+static inline DiagDirection GetRoadDepotDirection(typename TileIndexT<Tgeneric>::T t)
 {
 	assert(IsRoadDepot(t));
-	return (DiagDirection)GB(_m[t].m5, 0, 2);
+	return (DiagDirection)GB(GetTile(t)->m5, 0, 2);
 }
+/** @copydoc GetRoadDepotDirection(TileIndexT<Tgeneric>::T) */
+static inline DiagDirection GetRoadDepotDirection(TileIndex t) { return GetRoadDepotDirection<false>(t); }
+/** @copydoc GetRoadDepotDirection(TileIndexT<Tgeneric>::T) */
+static inline DiagDirection GetRoadDepotDirection(GenericTileIndex t) { return GetRoadDepotDirection<true>(t); }
 
 
 RoadBits GetAnyRoadBits(TileIndex tile, RoadType rt, bool straight_tunnel_bridge_entrance = false);
@@ -550,18 +683,23 @@
  * @param road New owner of road.
  * @param tram New owner of tram tracks.
  */
-static inline void MakeRoadNormal(TileIndex t, RoadBits bits, RoadTypes rot, TownID town, Owner road, Owner tram)
+template <bool Tgeneric>
+static inline void MakeRoadNormal(typename TileIndexT<Tgeneric>::T t, RoadBits bits, RoadTypes rot, TownID town, Owner road, Owner tram)
 {
 	SetTileType(t, MP_ROAD);
 	SetTileOwner(t, road);
-	_m[t].m2 = town;
-	_m[t].m3 = (HasBit(rot, ROADTYPE_TRAM) ? bits : 0);
-	_m[t].m4 = 0;
-	_m[t].m5 = (HasBit(rot, ROADTYPE_ROAD) ? bits : 0) | ROAD_TILE_NORMAL << 6;
-	SB(_m[t].m6, 2, 4, 0);
-	_me[t].m7 = rot << 6;
+	GetTile(t)->m2 = town;
+	GetTile(t)->m3 = (HasBit(rot, ROADTYPE_TRAM) ? bits : 0);
+	GetTile(t)->m4 = 0;
+	GetTile(t)->m5 = (HasBit(rot, ROADTYPE_ROAD) ? bits : 0) | ROAD_TILE_NORMAL << 6;
+	SB(GetTileEx(t)->m6, 2, 4, 0);
+	GetTileEx(t)->m7 = rot << 6;
 	SetRoadOwner(t, ROADTYPE_TRAM, tram);
 }
+/** @copydoc MakeRoadNormal(TileIndexT<Tgeneric>::T,RoadBits,RoadTypes,TownID,Owner,Owner) */
+static inline void MakeRoadNormal(TileIndex t, RoadBits bits, RoadTypes rot, TownID town, Owner road, Owner tram) { MakeRoadNormal<false>(t, bits, rot, town, road, tram); }
+/** @copydoc MakeRoadNormal(TileIndexT<Tgeneric>::T,RoadBits,RoadTypes,TownID,Owner,Owner) */
+static inline void MakeRoadNormal(GenericTileIndex t, RoadBits bits, RoadTypes rot, TownID town, Owner road, Owner tram) { MakeRoadNormal<true>(t, bits, rot, town, road, tram); }
 
 /**
  * Make a level crossing.
@@ -574,18 +712,23 @@
  * @param rot     New present road types.
  * @param town    Town ID if the road is a town-owned road.
  */
-static inline void MakeRoadCrossing(TileIndex t, Owner road, Owner tram, Owner rail, Axis roaddir, RailType rat, RoadTypes rot, uint town)
+template <bool Tgeneric>
+static inline void MakeRoadCrossing(typename TileIndexT<Tgeneric>::T t, Owner road, Owner tram, Owner rail, Axis roaddir, RailType rat, RoadTypes rot, uint town)
 {
 	SetTileType(t, MP_ROAD);
 	SetTileOwner(t, rail);
-	_m[t].m2 = town;
-	_m[t].m3 = rat;
-	_m[t].m4 = 0;
-	_m[t].m5 = ROAD_TILE_CROSSING << 6 | roaddir;
-	SB(_m[t].m6, 2, 4, 0);
-	_me[t].m7 = rot << 6 | road;
+	GetTile(t)->m2 = town;
+	GetTile(t)->m3 = rat;
+	GetTile(t)->m4 = 0;
+	GetTile(t)->m5 = ROAD_TILE_CROSSING << 6 | roaddir;
+	SB(GetTileEx(t)->m6, 2, 4, 0);
+	GetTileEx(t)->m7 = rot << 6 | road;
 	SetRoadOwner(t, ROADTYPE_TRAM, tram);
 }
+/** @copydoc MakeRoadCrossing(TileIndexT<Tgeneric>::T,Owner,Owner,Owner,Axis,RailType,RoadTypes,uint) */
+static inline void MakeRoadCrossing(TileIndex t, Owner road, Owner tram, Owner rail, Axis roaddir, RailType rat, RoadTypes rot, uint town) { MakeRoadCrossing<false>(t, road, tram, rail, roaddir, rat, rot, town); }
+/** @copydoc MakeRoadCrossing(TileIndexT<Tgeneric>::T,Owner,Owner,Owner,Axis,RailType,RoadTypes,uint) */
+static inline void MakeRoadCrossing(GenericTileIndex t, Owner road, Owner tram, Owner rail, Axis roaddir, RailType rat, RoadTypes rot, uint town) { MakeRoadCrossing<true>(t, road, tram, rail, roaddir, rat, rot, town); }
 
 /**
  * Make a road depot.
@@ -595,17 +738,22 @@
  * @param dir   Direction of the depot exit.
  * @param rt    Road type of the depot.
  */
-static inline void MakeRoadDepot(TileIndex t, Owner owner, DepotID did, DiagDirection dir, RoadType rt)
+template <bool Tgeneric>
+static inline void MakeRoadDepot(typename TileIndexT<Tgeneric>::T t, Owner owner, DepotID did, DiagDirection dir, RoadType rt)
 {
 	SetTileType(t, MP_ROAD);
 	SetTileOwner(t, owner);
-	_m[t].m2 = did;
-	_m[t].m3 = 0;
-	_m[t].m4 = 0;
-	_m[t].m5 = ROAD_TILE_DEPOT << 6 | dir;
-	SB(_m[t].m6, 2, 4, 0);
-	_me[t].m7 = RoadTypeToRoadTypes(rt) << 6 | owner;
+	GetTile(t)->m2 = did;
+	GetTile(t)->m3 = 0;
+	GetTile(t)->m4 = 0;
+	GetTile(t)->m5 = ROAD_TILE_DEPOT << 6 | dir;
+	SB(GetTileEx(t)->m6, 2, 4, 0);
+	GetTileEx(t)->m7 = RoadTypeToRoadTypes(rt) << 6 | owner;
 	SetRoadOwner(t, ROADTYPE_TRAM, owner);
 }
+/** @copydoc MakeRoadDepot(TileIndexT<Tgeneric>::T,Owner,DepotID,DiagDirection,RoadType) */
+static inline void MakeRoadDepot(TileIndex t, Owner owner, DepotID did, DiagDirection dir, RoadType rt) { MakeRoadDepot<false>(t, owner, did, dir, rt); }
+/** @copydoc MakeRoadDepot(TileIndexT<Tgeneric>::T,Owner,DepotID,DiagDirection,RoadType) */
+static inline void MakeRoadDepot(GenericTileIndex t, Owner owner, DepotID did, DiagDirection dir, RoadType rt) { MakeRoadDepot<true>(t, owner, did, dir, rt); }
 
 #endif /* ROAD_MAP_H */
diff -urNad openttd-1.3.2/src/roadveh_cmd.cpp openttd-1.3.2-DC3.0RC3/src/roadveh_cmd.cpp
--- openttd-1.3.2/src/roadveh_cmd.cpp	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/roadveh_cmd.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -33,8 +33,10 @@
 #include "core/random_func.hpp"
 #include "company_base.h"
 #include "core/backup_type.hpp"
+#include "infrastructure_func.h"
 #include "newgrf.h"
 #include "zoom_func.h"
+#include "town.h"
 
 #include "table/strings.h"
 
@@ -216,6 +218,8 @@
 
 	v->gcache.cached_total_length = 0;
 
+	uint32 cargo_mask = 0;
+
 	for (RoadVehicle *u = v; u != NULL; u = u->Next()) {
 		/* Check the v->first cache. */
 		assert(u->First() == v);
@@ -237,12 +241,15 @@
 		/* Invalidate the vehicle colour map */
 		u->colourmap = PAL_NONE;
 
+		/* Update carried cargo. */
+		if (u->cargo_type != INVALID_CARGO && u->cargo_cap > 0) SetBit(cargo_mask, u->cargo_type);
 		/* Update cargo aging period. */
 		u->vcache.cached_cargo_age_period = GetVehicleProperty(u, PROP_ROADVEH_CARGO_AGE_PERIOD, EngInfo(u->engine_type)->cargo_age_period);
 	}
 
 	uint max_speed = GetVehicleProperty(v, PROP_ROADVEH_SPEED, 0);
 	v->vcache.cached_max_speed = (max_speed != 0) ? max_speed * 4 : RoadVehInfo(v->engine_type)->max_speed;
+	v->vcache.cached_cargo_mask = cargo_mask;
 }
 
 /**
@@ -365,7 +372,7 @@
 
 	if (!v->IsPrimaryVehicle()) return CMD_ERROR;
 
-	CommandCost ret = CheckOwnership(v->owner);
+	CommandCost ret = CheckVehicleControlAllowed(v);
 	if (ret.Failed()) return ret;
 
 	if ((v->vehstatus & VS_STOPPED) ||
@@ -437,18 +444,22 @@
 			if (this->state <= RVSB_TRACKDIR_MASK && IsReversingRoadTrackdir((Trackdir)this->state)) {
 				max_speed = this->vcache.cached_max_speed / 2;
 				break;
-			} else if ((u->direction & 1) == 0) {
+			} else if (((u->direction & 1) == 0) && ( _settings_game.vehicle.limit_vehicle_speed_in_curves )) {
 				max_speed = this->vcache.cached_max_speed * 3 / 4;
 			}
 		}
-
+		
 		/* Vehicle is on the middle part of a bridge. */
 		if (u->state == RVSB_WORMHOLE && !(u->vehstatus & VS_HIDDEN)) {
 			max_speed = min(max_speed, GetBridgeSpec(GetBridgeType(u->tile))->speed * 2);
 		}
 	}
-
+	if ( (this->limit_speed_pass) > 2 )
+	    {
+		max_speed = min(max_speed,this->limit_speed_pass);
+	    }
 	return min(max_speed, this->current_order.max_speed * 2);
+	;
 }
 
 /**
@@ -833,7 +844,7 @@
 	v->overtaking = RVSB_DRIVE_SIDE;
 }
 
-static void RoadZPosAffectSpeed(RoadVehicle *v, byte old_z)
+static void RoadZPosAffectSpeed(RoadVehicle *v, int old_z)
 {
 	if (old_z == v->z_pos || _settings_game.vehicle.roadveh_acceleration_model != AM_ORIGINAL) return;
 
@@ -875,14 +886,14 @@
 	TrackdirBits trackdirs = TrackStatusToTrackdirBits(ts);
 
 	if (IsTileType(tile, MP_ROAD)) {
-		if (IsRoadDepot(tile) && (!IsTileOwner(tile, v->owner) || GetRoadDepotDirection(tile) == enterdir || (GetRoadTypes(tile) & v->compatible_roadtypes) == 0)) {
+		if (IsRoadDepot(tile) && (!IsInfraTileUsageAllowed(VEH_ROAD, v->owner, tile) || GetRoadDepotDirection(tile) == enterdir || (GetRoadTypes(tile) & v->compatible_roadtypes) == 0)) {
 			/* Road depot owned by another company or with the wrong orientation */
 			trackdirs = TRACKDIR_BIT_NONE;
 		}
 	} else if (IsTileType(tile, MP_STATION) && IsStandardRoadStopTile(tile)) {
 		/* Standard road stop (drive-through stops are treated as normal road) */
 
-		if (!IsTileOwner(tile, v->owner) || GetRoadStopDir(tile) == enterdir || v->HasArticulatedPart()) {
+		if (!IsInfraTileUsageAllowed(VEH_ROAD, v->owner, tile) || GetRoadStopDir(tile) == enterdir || v->HasArticulatedPart()) {
 			/* different station owner or wrong orientation or the vehicle has articulated parts */
 			trackdirs = TRACKDIR_BIT_NONE;
 		} else {
@@ -1095,8 +1106,124 @@
 	return ret.Succeeded();
 }
 
+/* Calculate speed limit
+ *
+ * @pram v vehicle
+ * @pram t nearest town
+ *
+ * @note speed 100 = ~49km/h, ~31mph, ~(x/2-1)
+ *
+ * @return max speed which car can go at it's location
+ */
+uint16 CalcMaxRoadVehSpeed(RoadVehicle *v) {
+       //if (v->u.road.another_tile) {
+       if (v->another_tile) {
+               /* start - another tile */
+
+               /* not another tile anymore */
+               //v->u.road.another_tile = false;
+               v->another_tile = false;
+
+               bool in_town = false;
+               bool one_way = false;
+
+               HouseZonesBits grp = HZB_TOWN_EDGE;
+
+               if (_settings_game.vehicle.limit_vehicle_speed_in_towns) {
+                       Town *t;
+                       t = ClosestTownFromTile(v->tile, (uint)-1);
+                       grp = GetTownRadiusGroup(t, v->tile);
+
+                       if ( grp >= HZB_TOWN_OUTSKIRT) {
+                               in_town = true;
+                       }
+               }
+
+               if ( IsTileType(v->tile, MP_ROAD)
+                       && (IsNormalRoadTile(v->tile))
+                       && _settings_game.vehicle.max_veh_speed_in_towns_one_way)
+               {
+                       one_way = !(GetDisallowedRoadDirections(v->tile) == DRD_NONE);
+               }
+
+               if ( in_town && _settings_game.vehicle.limit_vehicle_speed_in_towns) {
+                       /* start - in city */
+
+                       if (one_way && _settings_game.vehicle.max_veh_speed_in_towns_one_way) {
+                               /* start - one-way road */
+                               /* check, that vehicle will don't go faster than it's max */
+                               if ( v->vcache.cached_max_speed >= (_settings_game.vehicle.max_veh_speed_in_towns_one_way * 2) ) {
+                                       v->limit_speed = (_settings_game.vehicle.max_veh_speed_in_towns_one_way * 2);
+
+                                       if(v->limit_speed) {
+                                               return v->limit_speed;
+                                       }
+                               }
+                       } else if (_settings_game.vehicle.max_veh_speed_in_towns_two_way) {
+                               /* start - two-way road */
+                               /* check, that vehicle will don't go faster than it's max */
+                               if ( v->vcache.cached_max_speed >= (_settings_game.vehicle.max_veh_speed_in_towns_two_way * 2) ) {
+                                       v->limit_speed = (_settings_game.vehicle.max_veh_speed_in_towns_two_way * 2);
+
+                                       if (v->limit_speed) {
+                                               return v->limit_speed;
+                                       }
+                               }
+                       }
+
+                       /* end - in city*/
+               } else {
+                       /* start - outside city */
+
+                       if (_settings_game.vehicle.limit_vehicle_speed_outside_towns) {
+                               /* one-way or two-way road */
+                               if (one_way && _settings_game.vehicle.max_veh_speed_out_towns_one_way) {
+                                       /* start - one-way road */
+                                       /* check, that vehicle will don't go faster than it's max */
+                                       if ( v->vcache.cached_max_speed >= (_settings_game.vehicle.max_veh_speed_out_towns_one_way * 2) ) {
+                                               v->limit_speed = (_settings_game.vehicle.max_veh_speed_out_towns_one_way * 2);
+
+                                               if (v->limit_speed) {
+                                                       return v->limit_speed;
+                                               }
+                                       }
+                               } else if ( _settings_game.vehicle.max_veh_speed_out_towns_two_way ) {
+                                       /* start - two-way road */
+                                       /* check, that vehicle will don't go faster than it's max */
+                                       if ( v->vcache.cached_max_speed >= (_settings_game.vehicle.max_veh_speed_out_towns_two_way * 2) ) {
+                                               v->limit_speed = (_settings_game.vehicle.max_veh_speed_out_towns_two_way * 2);
+
+                                               if (v->limit_speed) {
+                                                       return v->limit_speed;
+                                               }
+                                       }
+                               }
+                       }
+                       /* end - outside city */
+               }
+
+               /* end - another tile */
+
+               if (v->state == RVSB_WORMHOLE && _settings_game.vehicle.limit_vehicle_speed_tunnel_bridge) {
+                       /* start - tunnels and bridges */
+                       /* check, that vehicle will don't go faster than it's max */
+                       if ( v->vcache.cached_max_speed >= (_settings_game.vehicle.max_veh_speed_tunnel_bridge * 2) ) {
+                                       v->limit_speed = (_settings_game.vehicle.max_veh_speed_tunnel_bridge * 2);
+                                       if (v->limit_speed) {
+                                               return v->limit_speed;
+                                       }
+                       }
+               } else if (v->limit_speed && v->state != RVSB_WORMHOLE) {
+                       return v->limit_speed;
+               }
+       }
+       v->limit_speed = v->vcache.cached_max_speed;
+       return v->limit_speed;
+}
+
 static bool IndividualRoadVehicleController(RoadVehicle *v, const RoadVehicle *prev)
 {
+
 	if (v->overtaking != 0)  {
 		if (IsTileType(v->tile, MP_STATION)) {
 			/* Force us to be not overtaking! */
@@ -1140,7 +1267,7 @@
 		v->x_pos = gp.x;
 		v->y_pos = gp.y;
 		VehicleUpdatePosition(v);
-		if ((v->vehstatus & VS_HIDDEN) == 0) VehicleUpdateViewport(v, true);
+		if (v->IsDrawn()) VehicleUpdateViewport(v, true);
 		return true;
 	}
 
@@ -1232,6 +1359,12 @@
 		int x = TileX(tile) * TILE_SIZE + rdp[start_frame].x;
 		int y = TileY(tile) * TILE_SIZE + rdp[start_frame].y;
 
+		if (v->tile != v->last_tile) {
+			v->another_tile = true;
+			v->last_tile = v->tile;
+		}
+	v->limit_speed_pass = CalcMaxRoadVehSpeed(v);
+
 		Direction new_dir = RoadVehGetSlidingDirection(v, x, y);
 		if (v->IsFrontEngine()) {
 			Vehicle *u = RoadVehFindCloseTo(v, x, y, new_dir);
@@ -1287,6 +1420,9 @@
 			v->direction = new_dir;
 			if (_settings_game.vehicle.roadveh_acceleration_model == AM_ORIGINAL) v->cur_speed -= v->cur_speed >> 2;
 		}
+//egyik lenyeg
+		v->cur_speed = min(v->cur_speed, CalcMaxRoadVehSpeed(v));
+
 		v->x_pos = x;
 		v->y_pos = y;
 		VehicleUpdatePosition(v);
@@ -1389,12 +1525,11 @@
 			/* In case an RV is stopped in a road stop, why not try to load? */
 			if (v->cur_speed == 0 && IsInsideMM(v->state, RVSB_IN_DT_ROAD_STOP, RVSB_IN_DT_ROAD_STOP_END) &&
 					v->current_order.ShouldStopAtStation(v, GetStationIndex(v->tile)) &&
-					v->owner == GetTileOwner(v->tile) && !v->current_order.IsType(OT_LEAVESTATION) &&
+					IsInfraTileUsageAllowed(VEH_ROAD, v->owner, v->tile) && !v->current_order.IsType(OT_LEAVESTATION) &&
 					GetRoadStopType(v->tile) == (v->IsBus() ? ROADSTOP_BUS : ROADSTOP_TRUCK)) {
 				Station *st = Station::GetByTile(v->tile);
-				v->last_station_visited = st->index;
 				RoadVehArrivesAt(v, st);
-				v->BeginLoading();
+				v->BeginLoading(st->index);
 			}
 			return false;
 		}
@@ -1423,7 +1558,7 @@
 			_road_stop_stop_frame[v->state - RVSB_IN_ROAD_STOP + (_settings_game.vehicle.road_side << RVS_DRIVE_SIDE)] == v->frame) ||
 			(IsInsideMM(v->state, RVSB_IN_DT_ROAD_STOP, RVSB_IN_DT_ROAD_STOP_END) &&
 			v->current_order.ShouldStopAtStation(v, GetStationIndex(v->tile)) &&
-			v->owner == GetTileOwner(v->tile) &&
+			IsInfraTileUsageAllowed(VEH_ROAD, v->owner, v->tile) &&
 			GetRoadStopType(v->tile) == (v->IsBus() ? ROADSTOP_BUS : ROADSTOP_TRUCK) &&
 			v->frame == RVC_DRIVE_THROUGH_STOP_FRAME))) {
 
@@ -1453,13 +1588,13 @@
 			rs->SetEntranceBusy(false);
 			SetBit(v->state, RVS_ENTERED_STOP);
 
-			v->last_station_visited = st->index;
-
 			if (IsDriveThroughStopTile(v->tile) || (v->current_order.IsType(OT_GOTO_STATION) && v->current_order.GetDestination() == st->index)) {
 				RoadVehArrivesAt(v, st);
-				v->BeginLoading();
+				v->BeginLoading(st->index);
 				return false;
 			}
+
+			v->last_station_visited = st->index;
 		} else {
 			/* Vehicle is ready to leave a bay in a road stop */
 			if (rs->IsEntranceBusy()) {
@@ -1498,6 +1633,7 @@
 	return true;
 }
 
+
 static bool RoadVehController(RoadVehicle *v)
 {
 	/* decrease counters */
diff -urNad openttd-1.3.2/src/roadveh_gui.cpp openttd-1.3.2-DC3.0RC3/src/roadveh_gui.cpp
--- openttd-1.3.2/src/roadveh_gui.cpp	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/roadveh_gui.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -37,7 +37,8 @@
 	SetDParam(2, v->value);
 	DrawString(left, right, y + y_offset, STR_VEHICLE_INFO_BUILT_VALUE);
 
-	if (v->HasArticulatedPart()) {
+                CargoArray act_cargo;
+                CargoDestSummary dests[NUM_CARGO];
 		CargoArray max_cargo;
 		StringID subtype_text[NUM_CARGO];
 		char capacity[512];
@@ -87,33 +88,41 @@
 				SetDParam(2, u->cargo.Source());
 				str = STR_VEHICLE_DETAILS_CARGO_FROM;
 				feeder_share += u->cargo.FeederShare();
+                                act_cargo[u->cargo_type] += u->cargo.Count();
+                                AddVehicleCargoDestSummary(u, &dests[u->cargo_type]);
 			}
 			DrawString(left, right, y + 2 * FONT_HEIGHT_NORMAL + 1 + y_offset, str);
 
 			y_offset += FONT_HEIGHT_NORMAL + 1;
 		}
 
-		y_offset -= FONT_HEIGHT_NORMAL + 1;
-	} else {
-		SetDParam(0, v->cargo_type);
-		SetDParam(1, v->cargo_cap);
-		SetDParam(4, GetCargoSubtypeText(v));
-		DrawString(left, right, y + FONT_HEIGHT_NORMAL + y_offset, STR_VEHICLE_INFO_CAPACITY);
+        /* Draw Transfer credits text */
+        SetDParam(0, feeder_share);
+        DrawString(left, right, y + 2 * FONT_HEIGHT_NORMAL + 3 + y_offset, STR_VEHICLE_INFO_FEEDER_CARGO_VALUE);
+        y_offset += 2 * FONT_HEIGHT_NORMAL + 6;
 
-		str = STR_VEHICLE_DETAILS_CARGO_EMPTY;
-		if (!v->cargo.Empty()) {
-			SetDParam(0, v->cargo_type);
-			SetDParam(1, v->cargo.Count());
-			SetDParam(2, v->cargo.Source());
-			str = STR_VEHICLE_DETAILS_CARGO_FROM;
-			feeder_share += v->cargo.FeederShare();
-		}
-		DrawString(left, right, y + 2 * FONT_HEIGHT_NORMAL + 1 + y_offset, str);
-	}
 
-	/* Draw Transfer credits text */
-	SetDParam(0, feeder_share);
-	DrawString(left, right, y + 3 * FONT_HEIGHT_NORMAL + 3 + y_offset, STR_VEHICLE_INFO_FEEDER_CARGO_VALUE);
+                DrawString(left, right, y + FONT_HEIGHT_NORMAL + y_offset, STR_STATION_VIEW_WAITING_TO_BUTTON);
+
+                for (CargoID i = 0; i < NUM_CARGO; i++) {
+                        if (max_cargo[i] > 0) {
+                                SetDParam(0, i);            // {CARGO} #1
+                                SetDParam(1, act_cargo[i]); // {CARGO} #2
+                                SetDParam(2, i);            // {SHORTCARGO} #1
+                                SetDParam(3, max_cargo[i]); // {SHORTCARGO} #2
+                                SetDParam(4, _settings_game.vehicle.freight_trains);
+                                DrawString(left, right, y + 2 * FONT_HEIGHT_NORMAL + 1 + y_offset, STR_VEHICLE_DETAILS_TRAIN_TOTAL_CAPACITY);
+                                y_offset += FONT_HEIGHT_NORMAL + 1;
+                        }
+                        for (CargoDestSummary::const_iterator row = dests[i].begin(); row != dests[i].end(); ++row) {
+                                        SetDParam(0, i);          // {SHORTCARGO} #1
+                                        SetDParam(1, row->count); // {SHORTCARGO} #2
+                                        SetDParam(2, row->type == ST_INDUSTRY ? STR_INDUSTRY_NAME : (row->type == ST_TOWN ? STR_TOWN_NAME : STR_COMPANY_NAME)); // {STRING1}
+                                        SetDParam(3, row->dest);  // Parameter of {STRING1}
+                                        DrawString(left + 2 * WD_PAR_VSEP_WIDE, right, y + 2 * FONT_HEIGHT_NORMAL + 1 + y_offset, STR_VEHICLE_DETAILS_CARGO_TO);
+                                        y_offset += FONT_HEIGHT_NORMAL + 1;
+                        }
+                }
 }
 
 /**
diff -urNad openttd-1.3.2/src/roadveh.h openttd-1.3.2-DC3.0RC3/src/roadveh.h
--- openttd-1.3.2/src/roadveh.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/roadveh.h	2013-11-22 05:49:07.000000000 +0100
@@ -97,6 +97,12 @@
 	RoadType roadtype;
 	RoadTypes compatible_roadtypes;
 
+	/* used for limiting speed out/in cities */
+	TileIndex last_tile;     ///< Last tile where vehicle was
+	bool another_tile;       ///< Vehicle entered another tile?
+	uint16 limit_speed;      ///< Limitation of speed
+	uint16 limit_speed_pass; ///< Hack solution, sorry.
+
 	/** We don't want GCC to zero our struct! It already is zeroed and has an index! */
 	RoadVehicle() : GroundVehicleBase() {}
 	/** We want to 'destruct' the right class. */
diff -urNad openttd-1.3.2/src/saveload/aaa_template_replacement_sl.cpp openttd-1.3.2-DC3.0RC3/src/saveload/aaa_template_replacement_sl.cpp
--- openttd-1.3.2/src/saveload/aaa_template_replacement_sl.cpp	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/saveload/aaa_template_replacement_sl.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -0,0 +1,35 @@
+#include "../stdafx.h"
+
+#include "../aaa_template_vehicle.h"
+
+#include "saveload.h"
+
+static const SaveLoad _template_replacement_desc[] = {
+	SLE_VAR(TemplateReplacement, sel_template, SLE_UINT16),
+	SLE_VAR(TemplateReplacement, group, SLE_UINT16),
+	SLE_END()
+};
+
+static void Save_TMPL_RPLS()
+{
+	TemplateReplacement *tr;
+
+	FOR_ALL_TEMPLATE_REPLACEMENTS(tr) {
+		SlSetArrayIndex(tr->index);
+		SlObject(tr, _template_replacement_desc);
+	}
+}
+
+static void Load_TMPL_RPLS()
+{
+	int index;
+
+	while ((index = SlIterateArray()) != -1) {
+		TemplateReplacement *tr = new (index) TemplateReplacement();
+		SlObject(tr, _template_replacement_desc);
+	}
+}
+
+extern const ChunkHandler _template_replacement_chunk_handlers[] = {
+	{'TRPL', Save_TMPL_RPLS, Load_TMPL_RPLS, NULL, NULL, CH_ARRAY | CH_LAST},
+};
diff -urNad openttd-1.3.2/src/saveload/aaa_template_veh_sl.cpp openttd-1.3.2-DC3.0RC3/src/saveload/aaa_template_veh_sl.cpp
--- openttd-1.3.2/src/saveload/aaa_template_veh_sl.cpp	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/saveload/aaa_template_veh_sl.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -0,0 +1,100 @@
+#include "../stdafx.h"
+
+#include "../aaa_template_vehicle.h"
+
+#include "saveload.h"
+
+const SaveLoad* GTD() {
+
+	static const SaveLoad _template_veh_desc[] = {
+		SLE_REF(TemplateVehicle, next, 		REF_TEMPLATE_VEHICLE),
+
+		SLE_VAR(TemplateVehicle, reuse_depot_vehicles, SLE_UINT8),
+		SLE_VAR(TemplateVehicle, keep_remaining_vehicles, SLE_UINT8),
+		SLE_VAR(TemplateVehicle, refit_as_template, SLE_UINT8),
+
+		SLE_VAR(TemplateVehicle, owner, SLE_UINT8),
+		SLE_VAR(TemplateVehicle, owner_b, SLE_UINT8),
+
+		SLE_VAR(TemplateVehicle, engine_type, SLE_UINT16),
+		SLE_VAR(TemplateVehicle, cargo_type, SLE_UINT16),
+		SLE_VAR(TemplateVehicle, cargo_cap, SLE_UINT16),
+		SLE_VAR(TemplateVehicle, cargo_subtype, SLE_UINT8),
+
+		SLE_VAR(TemplateVehicle, subtype, SLE_UINT8),
+		SLE_VAR(TemplateVehicle, railtype, SLE_UINT8),
+
+		SLE_VAR(TemplateVehicle, index, SLE_UINT32),
+
+		SLE_VAR(TemplateVehicle, real_consist_length, SLE_UINT16),
+
+		SLE_VAR(TemplateVehicle, max_speed, SLE_UINT16),
+		SLE_VAR(TemplateVehicle, power, SLE_UINT32),
+		SLE_VAR(TemplateVehicle, weight, SLE_UINT32),
+		SLE_VAR(TemplateVehicle, max_te, SLE_UINT32),
+
+		SLE_VAR(TemplateVehicle, spritenum, SLE_UINT8),
+		SLE_VAR(TemplateVehicle, cur_image, SLE_UINT32),
+		SLE_VAR(TemplateVehicle, image_width, SLE_UINT32),
+		SLE_VAR(TemplateVehicle, sgroup, SLE_UINT32),
+
+		SLE_END()
+	};
+
+	static const SaveLoad * const _ret[] = {
+		_template_veh_desc,
+	};
+
+	return _ret[0];
+}
+
+static void Save_TMPLS()
+{
+	TemplateVehicle *tv;
+
+	FOR_ALL_TEMPLATES(tv) {
+		SlSetArrayIndex(tv->index);
+		SlObject(tv, GTD());
+	}
+}
+
+static void Load_TMPLS()
+{
+	int index;
+
+	while ((index = SlIterateArray()) != -1) {
+		TemplateVehicle *tv = new (index) TemplateVehicle(); //TODO:check with veh sl code
+		SlObject(tv, GTD());
+	}
+}
+
+static void Ptrs_TMPLS()
+{
+	TemplateVehicle *tv;
+	FOR_ALL_TEMPLATES(tv) {
+		SlObject(tv, GTD());
+	}
+}
+
+void AfterLoadTemplateVehicles()
+{
+	TemplateVehicle *tv;
+
+	FOR_ALL_TEMPLATES(tv) {
+		/* Reinstate the previous pointer */
+		if (tv->next != NULL) tv->next->previous = tv;
+		tv->first =NULL;
+	}
+	FOR_ALL_TEMPLATES(tv) {
+		/* Fill the first pointers */
+		if (tv->previous == NULL) {
+			for (TemplateVehicle *u = tv; u != NULL; u = u->Next()) {
+				u->first = tv;
+			}
+		}
+	}
+}
+
+extern const ChunkHandler _template_vehicle_chunk_handlers[] = {
+	{'TMPL', Save_TMPLS, Load_TMPLS, Ptrs_TMPLS, NULL, CH_ARRAY | CH_LAST},
+};
diff -urNad openttd-1.3.2/src/saveload/afterload.cpp openttd-1.3.2-DC3.0RC3/src/saveload/afterload.cpp
--- openttd-1.3.2/src/saveload/afterload.cpp	2013-07-27 17:09:36.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/saveload/afterload.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -49,9 +49,12 @@
 #include "../engine_func.h"
 #include "../rail_gui.h"
 #include "../core/backup_type.hpp"
+#include "../core/mem_func.hpp"
 #include "../smallmap_gui.h"
 #include "../news_func.h"
+#include "../cargodest_func.h"
 #include "../error.h"
+#include "../trafficlight_func.h"
 
 
 #include "saveload_internal.h"
@@ -120,7 +123,7 @@
 
 			case MP_TREES:
 				/* trees on shore */
-				has_water |= (GB(_m[neighbour].m2, 4, 2) == TREE_GROUND_SHORE);
+				has_water |= (GB(_main_map.m[neighbour].m2, 4, 2) == TREE_GROUND_SHORE);
 				break;
 
 			default: break;
@@ -146,13 +149,13 @@
 	for (TileIndex tile = 0; tile != MapSize(); tile++) {
 		switch (GetTileType(tile)) {
 			case MP_ROAD:
-				if (GB(_m[tile].m5, 4, 2) == ROAD_TILE_CROSSING && HasBit(_m[tile].m3, 7)) {
-					_m[tile].m3 = OWNER_TOWN;
+				if (GB(_main_map.m[tile].m5, 4, 2) == ROAD_TILE_CROSSING && HasBit(_main_map.m[tile].m3, 7)) {
+					_main_map.m[tile].m3 = OWNER_TOWN;
 				}
 				/* FALL THROUGH */
 
 			case MP_TUNNELBRIDGE:
-				if (_m[tile].m1 & 0x80) SetTileOwner(tile, OWNER_TOWN);
+				if (_main_map.m[tile].m1 & 0x80) SetTileOwner(tile, OWNER_TOWN);
 				break;
 
 			default: break;
@@ -254,6 +257,7 @@
 
 	Station::RecomputeIndustriesNearForAll();
 	RebuildSubsidisedSourceAndDestinationCache();
+	RebuildCargoLinkCounts();
 
 	/* Towns have a noise controlled number of airports system
 	 * So each airport's noise value must be added to the town->noise_reached value
@@ -487,6 +491,10 @@
 	/* The LFSR used in RunTileLoop iteration cannot have a zeroed state, make it non-zeroed. */
 	if (_cur_tileloop_tile == 0) _cur_tileloop_tile = 1;
 
+	if (IsSavegameVersionBefore(MORE_HEIGHTLEVEL_SAVEGAME_VERSION)) {
+		_settings_game.construction.max_heightlevel = 15;
+	}
+
 	if (IsSavegameVersionBefore(98)) GamelogOldver();
 
 	GamelogTestRevision();
@@ -526,8 +534,8 @@
 		}
 		for (TileIndex t = 0; t < map_size; t++) {
 			if (!IsTileType(t, MP_STATION)) continue;
-			if (_m[t].m5 > 7) continue; // is it a rail station tile?
-			st = Station::Get(_m[t].m2);
+			if (_main_map.m[t].m5 > 7) continue; // is it a rail station tile?
+			st = Station::Get(_main_map.m[t].m2);
 			assert(st->train_station.tile != 0);
 			int dx = TileX(t) - TileX(st->train_station.tile);
 			int dy = TileY(t) - TileY(st->train_station.tile);
@@ -689,6 +697,9 @@
 	/* Update all vehicles */
 	AfterLoadVehicles(true);
 
+	// MYGUI
+	AfterLoadTemplateVehicles();
+
 	/* Make sure there is an AI attached to an AI company */
 	{
 		Company *c;
@@ -739,7 +750,7 @@
 					break;
 
 				case MP_STATION: {
-					if (HasBit(_m[t].m6, 3)) SetBit(_m[t].m6, 2);
+					if (HasBit(_main_map.me[t].m6, 3)) SetBit(_main_map.me[t].m6, 2);
 					StationGfx gfx = GetStationGfx(t);
 					StationType st;
 					if (       IsInsideMM(gfx,   0,   8)) { // Rail station
@@ -777,7 +788,7 @@
 						ResetSignalHandlers();
 						return false;
 					}
-					SB(_m[t].m6, 3, 3, st);
+					SB(_main_map.me[t].m6, 3, 3, st);
 					break;
 				}
 			}
@@ -796,6 +807,9 @@
 				if (!Station::IsExpected(bst)) break;
 				Station *st = Station::From(bst);
 
+				/* Set up station catchment */
+				st->catchment.BeforeAddTile(t, st->GetCatchmentRadius());
+
 				switch (GetStationType(t)) {
 					case STATION_TRUCK:
 					case STATION_BUS:
@@ -858,13 +872,13 @@
 		for (TileIndex t = 0; t < map_size; t++) {
 			switch (GetTileType(t)) {
 				case MP_HOUSE:
-					_m[t].m4 = _m[t].m2;
+					_main_map.m[t].m4 = _main_map.m[t].m2;
 					SetTownIndex(t, CalcClosestTownFromTile(t)->index);
 					break;
 
 				case MP_ROAD:
-					_m[t].m4 |= (_m[t].m2 << 4);
-					if ((GB(_m[t].m5, 4, 2) == ROAD_TILE_CROSSING ? (Owner)_m[t].m3 : GetTileOwner(t)) == OWNER_TOWN) {
+					_main_map.m[t].m4 |= (_main_map.m[t].m2 << 4);
+					if ((GB(_main_map.m[t].m5, 4, 2) == ROAD_TILE_CROSSING ? (Owner)_main_map.m[t].m3 : GetTileOwner(t)) == OWNER_TOWN) {
 						SetTownIndex(t, CalcClosestTownFromTile(t)->index);
 					} else {
 						SetTownIndex(t, 0);
@@ -918,20 +932,20 @@
 					if (IsPlainRail(t)) {
 						/* Swap ground type and signal type for plain rail tiles, so the
 						 * ground type uses the same bits as for depots and waypoints. */
-						uint tmp = GB(_m[t].m4, 0, 4);
-						SB(_m[t].m4, 0, 4, GB(_m[t].m2, 0, 4));
-						SB(_m[t].m2, 0, 4, tmp);
-					} else if (HasBit(_m[t].m5, 2)) {
+						uint tmp = GB(_main_map.m[t].m4, 0, 4);
+						SB(_main_map.m[t].m4, 0, 4, GB(_main_map.m[t].m2, 0, 4));
+						SB(_main_map.m[t].m2, 0, 4, tmp);
+					} else if (HasBit(_main_map.m[t].m5, 2)) {
 						/* Split waypoint and depot rail type and remove the subtype. */
-						ClrBit(_m[t].m5, 2);
-						ClrBit(_m[t].m5, 6);
+						ClrBit(_main_map.m[t].m5, 2);
+						ClrBit(_main_map.m[t].m5, 6);
 					}
 					break;
 
 				case MP_ROAD:
 					/* Swap m3 and m4, so the track type for rail crossings is the
 					 * same as for normal rail. */
-					Swap(_m[t].m3, _m[t].m4);
+					Swap(_main_map.m[t].m3, _main_map.m[t].m4);
 					break;
 
 				default: break;
@@ -945,16 +959,16 @@
 		for (TileIndex t = 0; t < map_size; t++) {
 			switch (GetTileType(t)) {
 				case MP_ROAD:
-					SB(_m[t].m5, 6, 2, GB(_m[t].m5, 4, 2));
+					SB(_main_map.m[t].m5, 6, 2, GB(_main_map.m[t].m5, 4, 2));
 					switch (GetRoadTileType(t)) {
 						default: SlErrorCorrupt("Invalid road tile type");
 						case ROAD_TILE_NORMAL:
-							SB(_m[t].m4, 0, 4, GB(_m[t].m5, 0, 4));
-							SB(_m[t].m4, 4, 4, 0);
-							SB(_m[t].m6, 2, 4, 0);
+							SB(_main_map.m[t].m4, 0, 4, GB(_main_map.m[t].m5, 0, 4));
+							SB(_main_map.m[t].m4, 4, 4, 0);
+							SB(_main_map.me[t].m6, 2, 4, 0);
 							break;
 						case ROAD_TILE_CROSSING:
-							SB(_m[t].m4, 5, 2, GB(_m[t].m5, 2, 2));
+							SB(_main_map.m[t].m4, 5, 2, GB(_main_map.m[t].m5, 2, 2));
 							break;
 						case ROAD_TILE_DEPOT:    break;
 					}
@@ -967,8 +981,8 @@
 
 				case MP_TUNNELBRIDGE:
 					/* Middle part of "old" bridges */
-					if (old_bridge && IsBridge(t) && HasBit(_m[t].m5, 6)) break;
-					if (((old_bridge && IsBridge(t)) ? (TransportType)GB(_m[t].m5, 1, 2) : GetTunnelBridgeTransportType(t)) == TRANSPORT_ROAD) {
+					if (old_bridge && IsBridge(t) && HasBit(_main_map.m[t].m5, 6)) break;
+					if (((old_bridge && IsBridge(t)) ? (TransportType)GB(_main_map.m[t].m5, 1, 2) : GetTunnelBridgeTransportType(t)) == TRANSPORT_ROAD) {
 						SetRoadTypes(t, ROADTYPES_ROAD);
 					}
 					break;
@@ -985,24 +999,24 @@
 		for (TileIndex t = 0; t < map_size; t++) {
 			switch (GetTileType(t)) {
 				case MP_ROAD:
-					if (fix_roadtypes) SetRoadTypes(t, (RoadTypes)GB(_me[t].m7, 5, 3));
-					SB(_me[t].m7, 5, 1, GB(_m[t].m3, 7, 1)); // snow/desert
+					if (fix_roadtypes) SetRoadTypes(t, (RoadTypes)GB(_main_map.me[t].m7, 5, 3));
+					SB(_main_map.me[t].m7, 5, 1, GB(_main_map.m[t].m3, 7, 1)); // snow/desert
 					switch (GetRoadTileType(t)) {
 						default: SlErrorCorrupt("Invalid road tile type");
 						case ROAD_TILE_NORMAL:
-							SB(_me[t].m7, 0, 4, GB(_m[t].m3, 0, 4)); // road works
-							SB(_m[t].m6, 3, 3, GB(_m[t].m3, 4, 3));  // ground
-							SB(_m[t].m3, 0, 4, GB(_m[t].m4, 4, 4));  // tram bits
-							SB(_m[t].m3, 4, 4, GB(_m[t].m5, 0, 4));  // tram owner
-							SB(_m[t].m5, 0, 4, GB(_m[t].m4, 0, 4));  // road bits
+							SB(_main_map.me[t].m7, 0, 4, GB(_main_map.m[t].m3, 0, 4)); // road works
+							SB(_main_map.me[t].m6, 3, 3, GB(_main_map.m[t].m3, 4, 3));  // ground
+							SB(_main_map.m[t].m3, 0, 4, GB(_main_map.m[t].m4, 4, 4));  // tram bits
+							SB(_main_map.m[t].m3, 4, 4, GB(_main_map.m[t].m5, 0, 4));  // tram owner
+							SB(_main_map.m[t].m5, 0, 4, GB(_main_map.m[t].m4, 0, 4));  // road bits
 							break;
 
 						case ROAD_TILE_CROSSING:
-							SB(_me[t].m7, 0, 5, GB(_m[t].m4, 0, 5)); // road owner
-							SB(_m[t].m6, 3, 3, GB(_m[t].m3, 4, 3));  // ground
-							SB(_m[t].m3, 4, 4, GB(_m[t].m5, 0, 4));  // tram owner
-							SB(_m[t].m5, 0, 1, GB(_m[t].m4, 6, 1));  // road axis
-							SB(_m[t].m5, 5, 1, GB(_m[t].m4, 5, 1));  // crossing state
+							SB(_main_map.me[t].m7, 0, 5, GB(_main_map.m[t].m4, 0, 5)); // road owner
+							SB(_main_map.me[t].m6, 3, 3, GB(_main_map.m[t].m3, 4, 3));  // ground
+							SB(_main_map.m[t].m3, 4, 4, GB(_main_map.m[t].m5, 0, 4));  // tram owner
+							SB(_main_map.m[t].m5, 0, 1, GB(_main_map.m[t].m4, 6, 1));  // road axis
+							SB(_main_map.m[t].m5, 5, 1, GB(_main_map.m[t].m4, 5, 1));  // crossing state
 							break;
 
 						case ROAD_TILE_DEPOT:
@@ -1012,32 +1026,32 @@
 						const Town *town = CalcClosestTownFromTile(t);
 						if (town != NULL) SetTownIndex(t, town->index);
 					}
-					_m[t].m4 = 0;
+					_main_map.m[t].m4 = 0;
 					break;
 
 				case MP_STATION:
 					if (!IsRoadStop(t)) break;
 
-					if (fix_roadtypes) SetRoadTypes(t, (RoadTypes)GB(_m[t].m3, 0, 3));
-					SB(_me[t].m7, 0, 5, HasBit(_m[t].m6, 2) ? OWNER_TOWN : GetTileOwner(t));
-					SB(_m[t].m3, 4, 4, _m[t].m1);
-					_m[t].m4 = 0;
+					if (fix_roadtypes) SetRoadTypes(t, (RoadTypes)GB(_main_map.m[t].m3, 0, 3));
+					SB(_main_map.me[t].m7, 0, 5, HasBit(_main_map.me[t].m6, 2) ? OWNER_TOWN : GetTileOwner(t));
+					SB(_main_map.m[t].m3, 4, 4, _main_map.m[t].m1);
+					_main_map.m[t].m4 = 0;
 					break;
 
 				case MP_TUNNELBRIDGE:
-					if (old_bridge && IsBridge(t) && HasBit(_m[t].m5, 6)) break;
-					if (((old_bridge && IsBridge(t)) ? (TransportType)GB(_m[t].m5, 1, 2) : GetTunnelBridgeTransportType(t)) == TRANSPORT_ROAD) {
-						if (fix_roadtypes) SetRoadTypes(t, (RoadTypes)GB(_m[t].m3, 0, 3));
+					if (old_bridge && IsBridge(t) && HasBit(_main_map.m[t].m5, 6)) break;
+					if (((old_bridge && IsBridge(t)) ? (TransportType)GB(_main_map.m[t].m5, 1, 2) : GetTunnelBridgeTransportType(t)) == TRANSPORT_ROAD) {
+						if (fix_roadtypes) SetRoadTypes(t, (RoadTypes)GB(_main_map.m[t].m3, 0, 3));
 
 						Owner o = GetTileOwner(t);
-						SB(_me[t].m7, 0, 5, o); // road owner
-						SB(_m[t].m3, 4, 4, o == OWNER_NONE ? OWNER_TOWN : o); // tram owner
+						SB(_main_map.me[t].m7, 0, 5, o); // road owner
+						SB(_main_map.m[t].m3, 4, 4, o == OWNER_NONE ? OWNER_TOWN : o); // tram owner
 					}
-					SB(_m[t].m6, 2, 4, GB(_m[t].m2, 4, 4)); // bridge type
-					SB(_me[t].m7, 5, 1, GB(_m[t].m4, 7, 1)); // snow/desert
+					SB(_main_map.me[t].m6, 2, 4, GB(_main_map.m[t].m2, 4, 4)); // bridge type
+					SB(_main_map.me[t].m7, 5, 1, GB(_main_map.m[t].m4, 7, 1)); // snow/desert
 
-					_m[t].m2 = 0;
-					_m[t].m4 = 0;
+					_main_map.m[t].m2 = 0;
+					_main_map.m[t].m4 = 0;
 					break;
 
 				default: break;
@@ -1051,11 +1065,11 @@
 		for (TileIndex t = 0; t < map_size; t++) {
 			if (MayHaveBridgeAbove(t)) ClearBridgeMiddle(t);
 			if (IsBridgeTile(t)) {
-				if (HasBit(_m[t].m5, 6)) { // middle part
-					Axis axis = (Axis)GB(_m[t].m5, 0, 1);
+				if (HasBit(_main_map.m[t].m5, 6)) { // middle part
+					Axis axis = (Axis)GB(_main_map.m[t].m5, 0, 1);
 
-					if (HasBit(_m[t].m5, 5)) { // transport route under bridge?
-						if (GB(_m[t].m5, 3, 2) == TRANSPORT_RAIL) {
+					if (HasBit(_main_map.m[t].m5, 5)) { // transport route under bridge?
+						if (GB(_main_map.m[t].m5, 3, 2) == TRANSPORT_RAIL) {
 							MakeRailNormal(
 								t,
 								GetTileOwner(t),
@@ -1074,7 +1088,7 @@
 							);
 						}
 					} else {
-						if (GB(_m[t].m5, 3, 2) == 0) {
+						if (GB(_main_map.m[t].m5, 3, 2) == 0) {
 							MakeClear(t, CLEAR_GRASS, 3);
 						} else {
 							if (GetTileSlope(t) != SLOPE_FLAT) {
@@ -1090,12 +1104,12 @@
 					}
 					SetBridgeMiddle(t, axis);
 				} else { // ramp
-					Axis axis = (Axis)GB(_m[t].m5, 0, 1);
-					uint north_south = GB(_m[t].m5, 5, 1);
+					Axis axis = (Axis)GB(_main_map.m[t].m5, 0, 1);
+					uint north_south = GB(_main_map.m[t].m5, 5, 1);
 					DiagDirection dir = ReverseDiagDir(XYNSToDiagDir(axis, north_south));
-					TransportType type = (TransportType)GB(_m[t].m5, 1, 2);
+					TransportType type = (TransportType)GB(_main_map.m[t].m5, 1, 2);
 
-					_m[t].m5 = 1 << 7 | type << 2 | dir;
+					_main_map.m[t].m5 = 1 << 7 | type << 2 | dir;
 				}
 			}
 		}
@@ -1197,23 +1211,23 @@
 				case MP_RAILWAY:
 					if (HasSignals(t)) {
 						/* convert PBS signals to combo-signals */
-						if (HasBit(_m[t].m2, 2)) SetSignalType(t, TRACK_X, SIGTYPE_COMBO);
+						if (HasBit(_main_map.m[t].m2, 2)) SetSignalType(t, TRACK_X, SIGTYPE_COMBO);
 
 						/* move the signal variant back */
-						SetSignalVariant(t, TRACK_X, HasBit(_m[t].m2, 3) ? SIG_SEMAPHORE : SIG_ELECTRIC);
-						ClrBit(_m[t].m2, 3);
+						SetSignalVariant(t, TRACK_X, HasBit(_main_map.m[t].m2, 3) ? SIG_SEMAPHORE : SIG_ELECTRIC);
+						ClrBit(_main_map.m[t].m2, 3);
 					}
 
 					/* Clear PBS reservation on track */
 					if (!IsRailDepotTile(t)) {
-						SB(_m[t].m4, 4, 4, 0);
+						SB(_main_map.m[t].m4, 4, 4, 0);
 					} else {
-						ClrBit(_m[t].m3, 6);
+						ClrBit(_main_map.m[t].m3, 6);
 					}
 					break;
 
 				case MP_STATION: // Clear PBS reservation on station
-					ClrBit(_m[t].m3, 6);
+					ClrBit(_main_map.m[t].m3, 6);
 					break;
 
 				default: break;
@@ -1322,31 +1336,31 @@
 	if (IsSavegameVersionBefore(53)) {
 		for (TileIndex t = 0; t < map_size; t++) {
 			if (IsTileType(t, MP_HOUSE)) {
-				if (GB(_m[t].m3, 6, 2) != TOWN_HOUSE_COMPLETED) {
+				if (GB(_main_map.m[t].m3, 6, 2) != TOWN_HOUSE_COMPLETED) {
 					/* Move the construction stage from m3[7..6] to m5[5..4].
 					 * The construction counter does not have to move. */
-					SB(_m[t].m5, 3, 2, GB(_m[t].m3, 6, 2));
-					SB(_m[t].m3, 6, 2, 0);
+					SB(_main_map.m[t].m5, 3, 2, GB(_main_map.m[t].m3, 6, 2));
+					SB(_main_map.m[t].m3, 6, 2, 0);
 
 					/* The "house is completed" bit is now in m6[2]. */
 					SetHouseCompleted(t, false);
 				} else {
 					/* The "lift has destination" bit has been moved from
 					 * m5[7] to m7[0]. */
-					SB(_me[t].m7, 0, 1, HasBit(_m[t].m5, 7));
-					ClrBit(_m[t].m5, 7);
+					SB(_main_map.me[t].m7, 0, 1, HasBit(_main_map.m[t].m5, 7));
+					ClrBit(_main_map.m[t].m5, 7);
 
 					/* The "lift is moving" bit has been removed, as it does
 					 * the same job as the "lift has destination" bit. */
-					ClrBit(_m[t].m1, 7);
+					ClrBit(_main_map.m[t].m1, 7);
 
 					/* The position of the lift goes from m1[7..0] to m6[7..2],
 					 * making m1 totally free, now. The lift position does not
 					 * have to be a full byte since the maximum value is 36. */
-					SetLiftPosition(t, GB(_m[t].m1, 0, 6 ));
+					SetLiftPosition(t, GB(_main_map.m[t].m1, 0, 6 ));
 
-					_m[t].m1 = 0;
-					_m[t].m3 = 0;
+					_main_map.m[t].m1 = 0;
+					_main_map.m[t].m3 = 0;
 					SetHouseCompleted(t, true);
 				}
 			}
@@ -1361,19 +1375,19 @@
 			if (IsTileType(t, MP_INDUSTRY)) {
 				switch (GetIndustryGfx(t)) {
 					case GFX_POWERPLANT_SPARKS:
-						_m[t].m3 = GB(_m[t].m1, 2, 5);
+						_main_map.m[t].m3 = GB(_main_map.m[t].m1, 2, 5);
 						break;
 
 					case GFX_OILWELL_ANIMATED_1:
 					case GFX_OILWELL_ANIMATED_2:
 					case GFX_OILWELL_ANIMATED_3:
-						_m[t].m3 = GB(_m[t].m1, 0, 2);
+						_main_map.m[t].m3 = GB(_main_map.m[t].m1, 0, 2);
 						break;
 
 					case GFX_COAL_MINE_TOWER_ANIMATED:
 					case GFX_COPPER_MINE_TOWER_ANIMATED:
 					case GFX_GOLD_MINE_TOWER_ANIMATED:
-						 _m[t].m3 = _m[t].m1;
+						 _main_map.m[t].m3 = _main_map.m[t].m1;
 						 break;
 
 					default: // No animation states to change
@@ -1422,7 +1436,7 @@
 	if (IsSavegameVersionBefore(52)) {
 		for (TileIndex t = 0; t < map_size; t++) {
 			if (IsStatueTile(t)) {
-				_m[t].m2 = CalcClosestTownFromTile(t)->index;
+				_main_map.m[t].m2 = CalcClosestTownFromTile(t)->index;
 			}
 		}
 	}
@@ -1483,10 +1497,10 @@
 		/* copy the signal type/variant and move signal states bits */
 		for (TileIndex t = 0; t < map_size; t++) {
 			if (IsTileType(t, MP_RAILWAY) && HasSignals(t)) {
-				SetSignalStates(t, GB(_m[t].m2, 4, 4));
+				SetSignalStates(t, GB(_main_map.m[t].m2, 4, 4));
 				SetSignalVariant(t, INVALID_TRACK, GetSignalVariant(t, TRACK_X));
 				SetSignalType(t, INVALID_TRACK, GetSignalType(t, TRACK_X));
-				ClrBit(_m[t].m2, 7);
+				ClrBit(_main_map.m[t].m2, 7);
 			}
 		}
 	}
@@ -1529,7 +1543,7 @@
 	if (IsSavegameVersionBefore(83)) {
 		for (TileIndex t = 0; t < map_size; t++) {
 			if (IsShipDepotTile(t)) {
-				_m[t].m4 = (TileHeight(t) == 0) ? OWNER_WATER : OWNER_NONE;
+				_main_map.m[t].m4 = (TileHeight(t) == 0) ? OWNER_WATER : OWNER_NONE;
 			}
 		}
 	}
@@ -1565,8 +1579,8 @@
 	if (IsSavegameVersionBefore(81)) {
 		for (TileIndex t = 0; t < map_size; t++) {
 			if (GetTileType(t) == MP_TREES) {
-				TreeGround groundType = (TreeGround)GB(_m[t].m2, 4, 2);
-				if (groundType != TREE_GROUND_SNOW_DESERT) SB(_m[t].m2, 6, 2, 3);
+				TreeGround groundType = (TreeGround)GB(_main_map.m[t].m2, 4, 2);
+				if (groundType != TREE_GROUND_SNOW_DESERT) SB(_main_map.m[t].m2, 6, 2, 3);
 			}
 		}
 	}
@@ -1633,8 +1647,8 @@
 						case STATION_OILRIG:
 						case STATION_DOCK:
 						case STATION_BUOY:
-							SetWaterClass(t, (WaterClass)GB(_m[t].m3, 0, 2));
-							SB(_m[t].m3, 0, 2, 0);
+							SetWaterClass(t, (WaterClass)GB(_main_map.m[t].m3, 0, 2));
+							SB(_main_map.m[t].m3, 0, 2, 0);
 							break;
 
 						default:
@@ -1644,8 +1658,8 @@
 					break;
 
 				case MP_WATER:
-					SetWaterClass(t, (WaterClass)GB(_m[t].m3, 0, 2));
-					SB(_m[t].m3, 0, 2, 0);
+					SetWaterClass(t, (WaterClass)GB(_main_map.m[t].m3, 0, 2));
+					SB(_main_map.m[t].m3, 0, 2, 0);
 					break;
 
 				case MP_OBJECT:
@@ -1672,7 +1686,7 @@
 							MakeCanal(t, o, Random());
 						}
 					} else if (IsShipDepot(t)) {
-						Owner o = (Owner)_m[t].m4; // Original water owner
+						Owner o = (Owner)_main_map.m[t].m4; // Original water owner
 						SetWaterClass(t, o == OWNER_WATER ? WATER_CLASS_SEA : WATER_CLASS_CANAL);
 					}
 				}
@@ -1761,8 +1775,8 @@
 		/* Increase HouseAnimationFrame from 5 to 7 bits */
 		for (TileIndex t = 0; t < map_size; t++) {
 			if (IsTileType(t, MP_HOUSE) && GetHouseType(t) >= NEW_HOUSE_OFFSET) {
-				SB(_m[t].m6, 2, 6, GB(_m[t].m6, 3, 5));
-				SB(_m[t].m3, 5, 1, 0);
+				SB(_main_map.me[t].m6, 2, 6, GB(_main_map.me[t].m6, 3, 5));
+				SB(_main_map.m[t].m3, 5, 1, 0);
 			}
 		}
 	}
@@ -1795,7 +1809,7 @@
 
 			/* Replace "house construction year" with "house age" */
 			if (IsTileType(t, MP_HOUSE) && IsHouseCompleted(t)) {
-				_m[t].m5 = Clamp(_cur_year - (_m[t].m5 + ORIGINAL_BASE_YEAR), 0, 0xFF);
+				_main_map.m[t].m5 = Clamp(_cur_year - (_main_map.m[t].m5 + ORIGINAL_BASE_YEAR), 0, 0xFF);
 			}
 		}
 	}
@@ -1809,10 +1823,10 @@
 				case MP_RAILWAY:
 					if (HasSignals(t)) {
 						/* move the signal variant */
-						SetSignalVariant(t, TRACK_UPPER, HasBit(_m[t].m2, 2) ? SIG_SEMAPHORE : SIG_ELECTRIC);
-						SetSignalVariant(t, TRACK_LOWER, HasBit(_m[t].m2, 6) ? SIG_SEMAPHORE : SIG_ELECTRIC);
-						ClrBit(_m[t].m2, 2);
-						ClrBit(_m[t].m2, 6);
+						SetSignalVariant(t, TRACK_UPPER, HasBit(_main_map.m[t].m2, 2) ? SIG_SEMAPHORE : SIG_ELECTRIC);
+						SetSignalVariant(t, TRACK_LOWER, HasBit(_main_map.m[t].m2, 6) ? SIG_SEMAPHORE : SIG_ELECTRIC);
+						ClrBit(_main_map.m[t].m2, 2);
+						ClrBit(_main_map.m[t].m2, 6);
 					}
 
 					/* Clear PBS reservation on track */
@@ -1904,11 +1918,11 @@
 		for (TileIndex t = 0; t < map_size; t++) {
 			/* Check for HQ bit being set, instead of using map accessor,
 			 * since we've already changed it code-wise */
-			if (IsTileType(t, MP_OBJECT) && HasBit(_m[t].m5, 7)) {
+			if (IsTileType(t, MP_OBJECT) && HasBit(_main_map.m[t].m5, 7)) {
 				/* Move size and part identification of HQ out of the m5 attribute,
 				 * on new locations */
-				_m[t].m3 = GB(_m[t].m5, 0, 5);
-				_m[t].m5 = OBJECT_HQ;
+				_main_map.m[t].m3 = GB(_main_map.m[t].m5, 0, 5);
+				_main_map.m[t].m5 = OBJECT_HQ;
 			}
 		}
 	}
@@ -1918,12 +1932,12 @@
 
 			/* Reordering/generalisation of the object bits. */
 			ObjectType type = GetObjectType(t);
-			SB(_m[t].m6, 2, 4, type == OBJECT_HQ ? GB(_m[t].m3, 2, 3) : 0);
-			_m[t].m3 = type == OBJECT_HQ ? GB(_m[t].m3, 1, 1) | GB(_m[t].m3, 0, 1) << 4 : 0;
+			SB(_main_map.me[t].m6, 2, 4, type == OBJECT_HQ ? GB(_main_map.m[t].m3, 2, 3) : 0);
+			_main_map.m[t].m3 = type == OBJECT_HQ ? GB(_main_map.m[t].m3, 1, 1) | GB(_main_map.m[t].m3, 0, 1) << 4 : 0;
 
 			/* Make sure those bits are clear as well! */
-			_m[t].m4 = 0;
-			_me[t].m7 = 0;
+			_main_map.m[t].m4 = 0;
+			_main_map.me[t].m7 = 0;
 		}
 	}
 
@@ -1936,11 +1950,11 @@
 				/* No towns, so remove all objects! */
 				DoClearSquare(t);
 			} else {
-				uint offset = _m[t].m3;
+				uint offset = _main_map.m[t].m3;
 
 				/* Also move the animation state. */
-				_m[t].m3 = GB(_m[t].m6, 2, 4);
-				SB(_m[t].m6, 2, 4, 0);
+				_main_map.m[t].m3 = GB(_main_map.me[t].m6, 2, 4);
+				SB(_main_map.me[t].m6, 2, 4, 0);
 
 				if (offset == 0) {
 					/* No offset, so make the object. */
@@ -1958,14 +1972,14 @@
 					o->location.w    = size;
 					o->location.h    = size;
 					o->build_date    = _date;
-					o->town          = type == OBJECT_STATUE ? Town::Get(_m[t].m2) : CalcClosestTownFromTile(t, UINT_MAX);
-					_m[t].m2 = o->index;
+					o->town          = type == OBJECT_STATUE ? Town::Get(_main_map.m[t].m2) : CalcClosestTownFromTile(t, UINT_MAX);
+					_main_map.m[t].m2 = o->index;
 					Object::IncTypeCount(type);
 				} else {
 					/* We're at an offset, so get the ID from our "root". */
 					TileIndex northern_tile = t - TileXY(GB(offset, 0, 4), GB(offset, 4, 4));
 					assert(IsTileType(northern_tile, MP_OBJECT));
-					_m[t].m2 = _m[northern_tile].m2;
+					_main_map.m[t].m2 = _main_map.m[northern_tile].m2;
 				}
 			}
 		}
@@ -2185,8 +2199,8 @@
 	if (IsSavegameVersionBefore(128)) {
 		const Depot *d;
 		FOR_ALL_DEPOTS(d) {
-			_m[d->xy].m2 = d->index;
-			if (IsTileType(d->xy, MP_WATER)) _m[GetOtherShipDepotTile(d->xy)].m2 = d->index;
+			_main_map.m[d->xy].m2 = d->index;
+			if (IsTileType(d->xy, MP_WATER)) _main_map.m[GetOtherShipDepotTile(d->xy)].m2 = d->index;
 		}
 	}
 
@@ -2208,16 +2222,16 @@
 			if (IsTileType(t, MP_CLEAR)) {
 				if (GetRawClearGround(t) == CLEAR_SNOW) {
 					SetClearGroundDensity(t, CLEAR_GRASS, GetClearDensity(t));
-					SetBit(_m[t].m3, 4);
+					SetBit(_main_map.m[t].m3, 4);
 				} else {
-					ClrBit(_m[t].m3, 4);
+					ClrBit(_main_map.m[t].m3, 4);
 				}
 			}
 			if (IsTileType(t, MP_TREES)) {
-				uint density = GB(_m[t].m2, 6, 2);
-				uint ground = GB(_m[t].m2, 4, 2);
-				uint counter = GB(_m[t].m2, 0, 4);
-				_m[t].m2 = ground << 6 | density << 4 | counter;
+				uint density = GB(_main_map.m[t].m2, 6, 2);
+				uint ground = GB(_main_map.m[t].m2, 4, 2);
+				uint counter = GB(_main_map.m[t].m2, 0, 4);
+				_main_map.m[t].m2 = ground << 6 | density << 4 | counter;
 			}
 		}
 	}
@@ -2302,6 +2316,22 @@
 		FOR_ALL_DEPOTS(d) d->build_date = _date;
 	}
 
+	if (IsSavegameVersionBefore(200)) {
+		Company *c;
+		FOR_ALL_COMPANIES(c) {
+			/* yearly_expenses has 3*15 entries now, saveload code gave us 3*13.
+			 * Move the old data to the right place in the new array and clear the new data.
+			 * The move has to be done in reverse order (first 2, then 1). */
+			MemMoveT(&c->yearly_expenses[3][0], &c->yearly_expenses[2][9], 13);
+			MemMoveT(&c->yearly_expenses[2][0], &c->yearly_expenses[1][11], 13);
+			MemMoveT(&c->yearly_expenses[1][0], &c->yearly_expenses[0][13], 13);
+			/* Clear the old location of just-moved data, so sharing income/expenses is set to 0 */
+			MemSetT(&c->yearly_expenses[0][13], 0, 3);
+			MemSetT(&c->yearly_expenses[1][13], 0, 3);
+			MemSetT(&c->yearly_expenses[2][13], 0, 3);
+		}
+	}
+
 	/* In old versions it was possible to remove an airport while a plane was
 	 * taking off or landing. This gives all kind of problems when building
 	 * another airport in the same station so we don't allow that anymore.
@@ -2317,7 +2347,7 @@
 				UpdateAircraftCache(v);
 				AircraftNextAirportPos_and_Order(v);
 				/* get aircraft back on running altitude */
-				if ((v->vehstatus & VS_CRASHED) == 0) SetAircraftPosition(v, v->x_pos, v->y_pos, GetAircraftFlyingAltitude(v));
+				if ((v->vehstatus & VS_CRASHED) == 0) SetAircraftPosition(v, v->x_pos, v->y_pos, GetAircraftMaxAltitude(v->x_pos, v->y_pos, 0));
 			}
 		}
 	}
@@ -2328,23 +2358,23 @@
 			switch (GetTileType(t)) {
 				case MP_HOUSE:
 					if (GetHouseType(t) >= NEW_HOUSE_OFFSET) {
-						uint per_proc = _me[t].m7;
-						_me[t].m7 = GB(_m[t].m6, 2, 6) | (GB(_m[t].m3, 5, 1) << 6);
-						SB(_m[t].m3, 5, 1, 0);
-						SB(_m[t].m6, 2, 6, min(per_proc, 63));
+						uint per_proc = _main_map.me[t].m7;
+						_main_map.me[t].m7 = GB(_main_map.me[t].m6, 2, 6) | (GB(_main_map.m[t].m3, 5, 1) << 6);
+						SB(_main_map.m[t].m3, 5, 1, 0);
+						SB(_main_map.me[t].m6, 2, 6, min(per_proc, 63));
 					}
 					break;
 
 				case MP_INDUSTRY: {
-					uint rand = _me[t].m7;
-					_me[t].m7 = _m[t].m3;
-					_m[t].m3 = rand;
+					uint rand = _main_map.me[t].m7;
+					_main_map.me[t].m7 = _main_map.m[t].m3;
+					_main_map.m[t].m3 = rand;
 					break;
 				}
 
 				case MP_OBJECT:
-					_me[t].m7 = _m[t].m3;
-					_m[t].m3 = 0;
+					_main_map.me[t].m7 = _main_map.m[t].m3;
+					_main_map.m[t].m3 = 0;
 					break;
 
 				default:
@@ -2669,16 +2699,16 @@
 		for (TileIndex t = 0; t < map_size; t++) {
 			if (!IsTileType(t, MP_CLEAR) && !IsTileType(t, MP_TREES)) continue;
 			if (IsTileType(t, MP_CLEAR) && IsClearGround(t, CLEAR_FIELDS)) continue;
-			uint fence = GB(_m[t].m4, 5, 3);
+			uint fence = GB(_main_map.m[t].m4, 5, 3);
 			if (fence != 0 && IsTileType(TILE_ADDXY(t, 1, 0), MP_CLEAR) && IsClearGround(TILE_ADDXY(t, 1, 0), CLEAR_FIELDS)) {
 				SetFenceNE(TILE_ADDXY(t, 1, 0), fence);
 			}
-			fence = GB(_m[t].m4, 2, 3);
+			fence = GB(_main_map.m[t].m4, 2, 3);
 			if (fence != 0 && IsTileType(TILE_ADDXY(t, 0, 1), MP_CLEAR) && IsClearGround(TILE_ADDXY(t, 0, 1), CLEAR_FIELDS)) {
 				SetFenceNW(TILE_ADDXY(t, 0, 1), fence);
 			}
-			SB(_m[t].m4, 2, 3, 0);
-			SB(_m[t].m4, 5, 3, 0);
+			SB(_main_map.m[t].m4, 2, 3, 0);
+			SB(_main_map.m[t].m4, 5, 3, 0);
 		}
 	}
 
@@ -2780,6 +2810,50 @@
 		}
 	}
 
+	if (IsSavegameVersionBefore(TL_SV)) {
+		/* Savegames before this version can not have trafficlights already.
+		 * Sometimes they are added randomly when loading old savegames.
+		 * Unfortunately also in the wrong places -> not on crossings.
+		 *
+		 * Iterate over the whole map and remove any trafficlights found. */
+		for (TileIndex tile = 0; tile < MapSize(); tile++) {
+			if (HasTrafficLights(tile)) ClearTrafficLights(tile);
+		}
+	}
+
+	if (IsSavegameVersionBefore(181)) {
+		/* Update cargo acceptance map of towns. */
+		for (TileIndex t = 0; t < map_size; t++) {
+			if (!IsTileType(t, MP_HOUSE)) continue;
+			Town::Get(GetTownIndex(t))->cargo_accepted.Add(t);
+		}
+
+		Town *town;
+		FOR_ALL_TOWNS(town) {
+			UpdateTownCargoes(town);
+		}
+
+		/* Update cargo acceptance of industries. */
+		Industry *ind;
+		FOR_ALL_INDUSTRIES(ind) {
+			UpdateIndustryAcceptance(ind);
+			ind->average_production[0] = ind->last_month_production[0];
+			ind->average_production[1] = ind->last_month_production[1];
+		}
+
+		UpdateCargoLinks();
+
+		Vehicle *v;
+		FOR_ALL_VEHICLES(v) {
+			/* Set the current order index from the order list. */
+			Order *o = v->GetOrder(v->cur_implicit_order_index);
+			if (o != NULL) v->current_order.index = o->index;
+
+			/* Pre-fill route links from orders. */
+			if (v->IsFrontEngine()) PrefillRouteLinks(v);
+		}
+	}
+
 	/* Road stops is 'only' updating some caches */
 	AfterLoadRoadStops();
 	AfterLoadLabelMaps();
diff -urNad openttd-1.3.2/src/saveload/cargodest_sl.cpp openttd-1.3.2-DC3.0RC3/src/saveload/cargodest_sl.cpp
--- openttd-1.3.2/src/saveload/cargodest_sl.cpp	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/saveload/cargodest_sl.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -0,0 +1,181 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file cargodest_sl.cpp Code handling saving and loading of cargo destinations. */
+
+#include "../stdafx.h"
+#include "../cargodest_base.h"
+#include "../town.h"
+#include "../industry.h"
+#include "saveload.h"
+
+static uint32 _cargolink_uint;
+static const SaveLoadGlobVarList _cargolink_uint_desc[] = {
+	SLEG_VAR(_cargolink_uint, SLE_UINT32),
+	SLEG_END()
+};
+
+static const SaveLoad _cargolink_desc[] = {
+	SLE_VAR(CargoLink, amount.old_max, SLE_UINT32),
+	SLE_VAR(CargoLink, amount.new_max, SLE_UINT32),
+	SLE_VAR(CargoLink, amount.old_act, SLE_UINT32),
+	SLE_VAR(CargoLink, amount.new_act, SLE_UINT32),
+	SLE_VAR(CargoLink, weight,         SLE_UINT32),
+	SLE_VAR(CargoLink, weight_mod,     SLE_UINT8),
+	SLE_END()
+};
+
+void CargoSourceSink::SaveCargoSourceSink()
+{
+	if (IsSavegameVersionBefore(181)) return;
+
+	static const SaveLoad _cargosourcesink_desc[] = {
+		SLE_ARR(CargoSourceSink, cargo_links_weight, SLE_UINT32, NUM_CARGO),
+		SLE_END()
+	};
+	SlObject(this, _cargosourcesink_desc);
+
+	for (uint cid = 0; cid < lengthof(this->cargo_links); cid++) {
+		_cargolink_uint = this->cargo_links[cid].Length();
+		SlObject(NULL, _cargolink_uint_desc);
+		for (CargoLink *l = this->cargo_links[cid].Begin(); l != this->cargo_links[cid].End(); l++) {
+			SourceID dest = INVALID_SOURCE;
+			SourceTypeByte type;
+			type = ST_TOWN;
+
+			if (l->dest != NULL) {
+				type = l->dest->GetType();
+				dest = l->dest->GetID();
+			}
+
+			/* Pack type and destination index into temp variable. */
+			assert_compile(sizeof(SourceID) <= 3);
+			_cargolink_uint = type | (dest << 8);
+
+			SlGlobList(_cargolink_uint_desc);
+			SlObject(l, _cargolink_desc);
+		}
+	}
+}
+
+void CargoSourceSink::LoadCargoSourceSink()
+{
+	if (IsSavegameVersionBefore(181)) return;
+
+	static const SaveLoad _cargosourcesink_desc[] = {
+		SLE_ARR(CargoSourceSink, cargo_links_weight, SLE_UINT32, NUM_CARGO),
+		SLE_END()
+	};
+	SlObject(this, _cargosourcesink_desc);
+
+	for (uint cid = 0; cid < lengthof(this->cargo_links); cid++) {
+		/* Remove links created by constructors. */
+		this->cargo_links[cid].Clear();
+		/* Read vector length and allocate storage. */
+		SlObject(NULL, _cargolink_uint_desc);
+		this->cargo_links[cid].Append(_cargolink_uint);
+
+		for (CargoLink *l = this->cargo_links[cid].Begin(); l != this->cargo_links[cid].End(); l++) {
+			/* Read packed type and dest and store in dest pointer. */
+			SlGlobList(_cargolink_uint_desc);
+			*(size_t*)&l->dest = _cargolink_uint;
+
+			SlObject(l, _cargolink_desc);
+		}
+	}
+}
+
+void CargoSourceSink::PtrsCargoSourceSink()
+{
+	if (IsSavegameVersionBefore(181)) return;
+
+	for (uint cid = 0; cid < lengthof(this->cargo_links); cid++) {
+		for (CargoLink *l = this->cargo_links[cid].Begin(); l != this->cargo_links[cid].End(); l++) {
+			/* Extract type and destination index. */
+			SourceType type = (SourceType)((size_t)l->dest & 0xFF);
+			SourceID dest = (SourceID)((size_t)l->dest >> 8);
+
+			/* Resolve index. */
+			l->dest = NULL;
+			if (dest != INVALID_SOURCE) {
+				switch (type) {
+					case ST_TOWN:
+						if (!Town::IsValidID(dest)) SlErrorCorrupt("Invalid cargo link destination");
+						l->dest = Town::Get(dest);
+						break;
+
+					case ST_INDUSTRY:
+						if (!Industry::IsValidID(dest)) SlErrorCorrupt("Invalid cargo link destination");
+						l->dest = Industry::Get(dest);
+						break;
+
+					default:
+						SlErrorCorrupt("Invalid cargo link destination type");
+				}
+			}
+		}
+	}
+}
+
+/**
+ * Wrapper function to get the RouteLinks's internal structure while
+ * some of the variables itself are private.
+ * @return The SaveLoad description for RouteLinks.
+ */
+const SaveLoad *GetRouteLinkDescription()
+{
+	static const SaveLoad _routelink_desc[] = {
+		SLE_VAR(RouteLink, dest,         SLE_UINT16),
+		SLE_VAR(RouteLink, prev_order,   SLE_UINT16),
+		SLE_VAR(RouteLink, next_order,   SLE_UINT16),
+		SLE_VAR(RouteLink, owner,        SLE_UINT8),
+		SLE_VAR(RouteLink, vtype,        SLE_UINT8),
+		SLE_VAR(RouteLink, travel_time,  SLE_UINT32),
+		SLE_VAR(RouteLink, wait_time,    SLE_UINT16),
+
+		SLE_END()
+	};
+	return _routelink_desc;
+}
+
+/** Save the RouteLink chunk. */
+static void Save_RTLN()
+{
+	RouteLink *link;
+
+	FOR_ALL_ROUTELINKS(link) {
+		SlSetArrayIndex(link->index);
+		SlObject(link, GetRouteLinkDescription());
+	}
+}
+
+/** Load the RouteLink chunk. */
+static void Load_RTLN()
+{
+	int index;
+
+	while ((index = SlIterateArray()) != -1) {
+		RouteLink *link = new (index) RouteLink();
+		SlObject(link, GetRouteLinkDescription());
+	}
+}
+
+/** Resolve references after loading the RouteLink chunk. */
+static void Ptrs_RTLN()
+{
+	RouteLink *link;
+
+	FOR_ALL_ROUTELINKS(link) {
+		SlObject(link, GetRouteLinkDescription());
+	}
+}
+
+extern const ChunkHandler _routelink_chunk_handlers[] = {
+	{ 'RTLN', Save_RTLN, Load_RTLN, Ptrs_RTLN, NULL, CH_ARRAY | CH_LAST},
+};
diff -urNad openttd-1.3.2/src/saveload/cargopacket_sl.cpp openttd-1.3.2-DC3.0RC3/src/saveload/cargopacket_sl.cpp
--- openttd-1.3.2/src/saveload/cargopacket_sl.cpp	2013-07-27 17:09:36.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/saveload/cargopacket_sl.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -95,6 +95,12 @@
 		     SLE_VAR(CargoPacket, feeder_share,    SLE_INT64),
 		 SLE_CONDVAR(CargoPacket, source_type,     SLE_UINT8,  125, SL_MAX_VERSION),
 		 SLE_CONDVAR(CargoPacket, source_id,       SLE_UINT16, 125, SL_MAX_VERSION),
+		 SLE_CONDVAR(CargoPacket, dest_xy,         SLE_UINT32, 181, SL_MAX_VERSION),
+		 SLE_CONDVAR(CargoPacket, dest_id,         SLE_UINT16, 181, SL_MAX_VERSION),
+		 SLE_CONDVAR(CargoPacket, dest_type,       SLE_UINT8,  181, SL_MAX_VERSION),
+		 SLE_CONDVAR(CargoPacket, flags,           SLE_UINT8,  181, SL_MAX_VERSION),
+		 SLE_CONDVAR(CargoPacket, next_order,      SLE_UINT16, 181, SL_MAX_VERSION),
+		 SLE_CONDVAR(CargoPacket, next_station,    SLE_UINT16, 181, SL_MAX_VERSION),
 
 		/* Used to be paid_for, but that got changed. */
 		SLE_CONDNULL(1, 0, 120),
diff -urNad openttd-1.3.2/src/saveload/company_sl.cpp openttd-1.3.2-DC3.0RC3/src/saveload/company_sl.cpp
--- openttd-1.3.2/src/saveload/company_sl.cpp	2013-07-27 17:09:36.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/saveload/company_sl.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -281,7 +281,8 @@
 
 	/* yearly expenses was changed to 64-bit in savegame version 2. */
 	SLE_CONDARR(CompanyProperties, yearly_expenses,       SLE_FILE_I32 | SLE_VAR_I64, 3 * 13, 0, 1),
-	SLE_CONDARR(CompanyProperties, yearly_expenses,       SLE_INT64, 3 * 13,                  2, SL_MAX_VERSION),
+	SLE_CONDARR(CompanyProperties, yearly_expenses,       SLE_INT64, 3 * 13,                  2, 180),
+	SLE_CONDARR(CompanyProperties, yearly_expenses,       SLE_INT64, 3 * 16,                181, SL_MAX_VERSION),
 
 	SLE_CONDVAR(CompanyProperties, is_ai,                 SLE_BOOL,                    2, SL_MAX_VERSION),
 	SLE_CONDNULL(1, 107, 111), ///< is_noai
diff -urNad openttd-1.3.2/src/saveload/economy_sl.cpp openttd-1.3.2-DC3.0RC3/src/saveload/economy_sl.cpp
--- openttd-1.3.2/src/saveload/economy_sl.cpp	2013-07-27 17:09:36.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/saveload/economy_sl.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -46,6 +46,7 @@
 	    SLE_VAR(Economy, infl_amount,                   SLE_UINT8),
 	    SLE_VAR(Economy, infl_amount_pr,                SLE_UINT8),
 	SLE_CONDVAR(Economy, industry_daily_change_counter, SLE_UINT32,                102, SL_MAX_VERSION),
+	SLE_CONDVAR(Economy, industry_helper,               SLE_INT64,				   181, SL_MAX_VERSION),
 	    SLE_END()
 };
 
@@ -67,6 +68,8 @@
 	SLE_VAR(CargoPayment, route_profit,  SLE_INT64),
 	SLE_VAR(CargoPayment, visual_profit, SLE_INT64),
 
+	SLE_CONDVAR(CargoPayment, transfer_profit, SLE_INT64, 181, SL_MAX_VERSION),
+
 	SLE_END()
 };
 
diff -urNad openttd-1.3.2/src/saveload/industry_sl.cpp openttd-1.3.2-DC3.0RC3/src/saveload/industry_sl.cpp
--- openttd-1.3.2/src/saveload/industry_sl.cpp	2013-07-27 17:09:36.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/saveload/industry_sl.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -30,12 +30,14 @@
 	    SLE_ARR(Industry, production_rate,            SLE_UINT8,  2),
 	SLE_CONDNULL( 3, 0, 60),       ///< used to be industry's accepts_cargo
 	SLE_CONDARR(Industry, accepts_cargo,              SLE_UINT8,  3,              78, SL_MAX_VERSION),
+	SLE_CONDVAR(Industry, produced_accepted_mask,     SLE_UINT32,                181, SL_MAX_VERSION),
 	    SLE_VAR(Industry, prod_level,                 SLE_UINT8),
 	    SLE_ARR(Industry, this_month_production,      SLE_UINT16, 2),
 	    SLE_ARR(Industry, this_month_transported,     SLE_UINT16, 2),
 	    SLE_ARR(Industry, last_month_pct_transported, SLE_UINT8,  2),
 	    SLE_ARR(Industry, last_month_production,      SLE_UINT16, 2),
 	    SLE_ARR(Industry, last_month_transported,     SLE_UINT16, 2),
+	SLE_CONDARR(Industry, average_production,         SLE_UINT16, 2,             181, SL_MAX_VERSION),
 
 	    SLE_VAR(Industry, counter,                    SLE_UINT16),
 
@@ -63,6 +65,12 @@
 	SLE_END()
 };
 
+static void RealSave_INDY(Industry *ind)
+{
+	SlObject(ind, _industry_desc);
+	ind->SaveCargoSourceSink();
+}
+
 static void Save_INDY()
 {
 	Industry *ind;
@@ -70,7 +78,7 @@
 	/* Write the industries */
 	FOR_ALL_INDUSTRIES(ind) {
 		SlSetArrayIndex(ind->index);
-		SlObject(ind, _industry_desc);
+		SlAutolength((AutolengthProc *)RealSave_INDY, ind);
 	}
 }
 
@@ -93,6 +101,7 @@
 	while ((index = SlIterateArray()) != -1) {
 		Industry *i = new (index) Industry();
 		SlObject(i, _industry_desc);
+		i->LoadCargoSourceSink();
 
 		/* Before savegame version 161, persistent storages were not stored in a pool. */
 		if (IsSavegameVersionBefore(161) && !IsSavegameVersionBefore(76)) {
@@ -121,6 +130,7 @@
 
 	FOR_ALL_INDUSTRIES(i) {
 		SlObject(i, _industry_desc);
+		i->PtrsCargoSourceSink();
 	}
 }
 
diff -urNad openttd-1.3.2/src/saveload/map_sl.cpp openttd-1.3.2-DC3.0RC3/src/saveload/map_sl.cpp
--- openttd-1.3.2/src/saveload/map_sl.cpp	2013-07-27 17:09:36.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/saveload/map_sl.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -54,8 +54,15 @@
 
 	for (TileIndex i = 0; i != size;) {
 		SlArray(buf, MAP_SL_BUF_SIZE, SLE_UINT8);
-		for (uint j = 0; j != MAP_SL_BUF_SIZE; j++) _m[i++].type_height = buf[j];
+		for (uint j = 0; j != MAP_SL_BUF_SIZE; j++) _main_map.m[i++].type = buf[j];
 	}
+
+       if (IsSavegameVersionBefore(MORE_HEIGHTLEVEL_SAVEGAME_VERSION)) {
+               // In old savegame versions, the heightlevel was coded in bits 0..3 of the type field
+               for (TileIndex tile = 0; tile != size; tile++) {
+                       _main_map.m[tile].height = GB(_main_map.m[tile].type, 0, 4);
+               }
+        }
 }
 
 static void Save_MAPT()
@@ -65,11 +72,34 @@
 
 	SlSetLength(size);
 	for (TileIndex i = 0; i != size;) {
-		for (uint j = 0; j != MAP_SL_BUF_SIZE; j++) buf[j] = _m[i++].type_height;
+		for (uint j = 0; j != MAP_SL_BUF_SIZE; j++) buf[j] = _main_map.m[i++].type;
 		SlArray(buf, MAP_SL_BUF_SIZE, SLE_UINT8);
 	}
 }
 
+static void Load_MAPH()
+{
+       SmallStackSafeStackAlloc<byte, MAP_SL_BUF_SIZE> buf;
+       TileIndex size = MapSize();
+
+       for (TileIndex i = 0; i != size;) {
+               SlArray(buf, MAP_SL_BUF_SIZE, SLE_UINT8);
+               for (uint j = 0; j != MAP_SL_BUF_SIZE; j++) _main_map.m[i++].height = buf[j];
+       }
+}
+
+static void Save_MAPH()
+{
+       SmallStackSafeStackAlloc<byte, MAP_SL_BUF_SIZE> buf;
+       TileIndex size = MapSize();
+
+       SlSetLength(size);
+       for (TileIndex i = 0; i != size;) {
+               for (uint j = 0; j != MAP_SL_BUF_SIZE; j++) buf[j] = _main_map.m[i++].height;
+                SlArray(buf, MAP_SL_BUF_SIZE, SLE_UINT8);
+        }
+}
+
 static void Load_MAP1()
 {
 	SmallStackSafeStackAlloc<byte, MAP_SL_BUF_SIZE> buf;
@@ -77,7 +107,7 @@
 
 	for (TileIndex i = 0; i != size;) {
 		SlArray(buf, MAP_SL_BUF_SIZE, SLE_UINT8);
-		for (uint j = 0; j != MAP_SL_BUF_SIZE; j++) _m[i++].m1 = buf[j];
+		for (uint j = 0; j != MAP_SL_BUF_SIZE; j++) _main_map.m[i++].m1 = buf[j];
 	}
 }
 
@@ -88,7 +118,7 @@
 
 	SlSetLength(size);
 	for (TileIndex i = 0; i != size;) {
-		for (uint j = 0; j != MAP_SL_BUF_SIZE; j++) buf[j] = _m[i++].m1;
+		for (uint j = 0; j != MAP_SL_BUF_SIZE; j++) buf[j] = _main_map.m[i++].m1;
 		SlArray(buf, MAP_SL_BUF_SIZE, SLE_UINT8);
 	}
 }
@@ -103,7 +133,7 @@
 			/* In those versions the m2 was 8 bits */
 			IsSavegameVersionBefore(5) ? SLE_FILE_U8 | SLE_VAR_U16 : SLE_UINT16
 		);
-		for (uint j = 0; j != MAP_SL_BUF_SIZE; j++) _m[i++].m2 = buf[j];
+		for (uint j = 0; j != MAP_SL_BUF_SIZE; j++) _main_map.m[i++].m2 = buf[j];
 	}
 }
 
@@ -114,7 +144,7 @@
 
 	SlSetLength(size * sizeof(uint16));
 	for (TileIndex i = 0; i != size;) {
-		for (uint j = 0; j != MAP_SL_BUF_SIZE; j++) buf[j] = _m[i++].m2;
+		for (uint j = 0; j != MAP_SL_BUF_SIZE; j++) buf[j] = _main_map.m[i++].m2;
 		SlArray(buf, MAP_SL_BUF_SIZE, SLE_UINT16);
 	}
 }
@@ -126,7 +156,7 @@
 
 	for (TileIndex i = 0; i != size;) {
 		SlArray(buf, MAP_SL_BUF_SIZE, SLE_UINT8);
-		for (uint j = 0; j != MAP_SL_BUF_SIZE; j++) _m[i++].m3 = buf[j];
+		for (uint j = 0; j != MAP_SL_BUF_SIZE; j++) _main_map.m[i++].m3 = buf[j];
 	}
 }
 
@@ -137,7 +167,7 @@
 
 	SlSetLength(size);
 	for (TileIndex i = 0; i != size;) {
-		for (uint j = 0; j != MAP_SL_BUF_SIZE; j++) buf[j] = _m[i++].m3;
+		for (uint j = 0; j != MAP_SL_BUF_SIZE; j++) buf[j] = _main_map.m[i++].m3;
 		SlArray(buf, MAP_SL_BUF_SIZE, SLE_UINT8);
 	}
 }
@@ -149,7 +179,7 @@
 
 	for (TileIndex i = 0; i != size;) {
 		SlArray(buf, MAP_SL_BUF_SIZE, SLE_UINT8);
-		for (uint j = 0; j != MAP_SL_BUF_SIZE; j++) _m[i++].m4 = buf[j];
+		for (uint j = 0; j != MAP_SL_BUF_SIZE; j++) _main_map.m[i++].m4 = buf[j];
 	}
 }
 
@@ -160,7 +190,7 @@
 
 	SlSetLength(size);
 	for (TileIndex i = 0; i != size;) {
-		for (uint j = 0; j != MAP_SL_BUF_SIZE; j++) buf[j] = _m[i++].m4;
+		for (uint j = 0; j != MAP_SL_BUF_SIZE; j++) buf[j] = _main_map.m[i++].m4;
 		SlArray(buf, MAP_SL_BUF_SIZE, SLE_UINT8);
 	}
 }
@@ -172,7 +202,7 @@
 
 	for (TileIndex i = 0; i != size;) {
 		SlArray(buf, MAP_SL_BUF_SIZE, SLE_UINT8);
-		for (uint j = 0; j != MAP_SL_BUF_SIZE; j++) _m[i++].m5 = buf[j];
+		for (uint j = 0; j != MAP_SL_BUF_SIZE; j++) _main_map.m[i++].m5 = buf[j];
 	}
 }
 
@@ -183,7 +213,7 @@
 
 	SlSetLength(size);
 	for (TileIndex i = 0; i != size;) {
-		for (uint j = 0; j != MAP_SL_BUF_SIZE; j++) buf[j] = _m[i++].m5;
+		for (uint j = 0; j != MAP_SL_BUF_SIZE; j++) buf[j] = _main_map.m[i++].m5;
 		SlArray(buf, MAP_SL_BUF_SIZE, SLE_UINT8);
 	}
 }
@@ -198,16 +228,16 @@
 			/* 1024, otherwise we overflow on 64x64 maps! */
 			SlArray(buf, 1024, SLE_UINT8);
 			for (uint j = 0; j != 1024; j++) {
-				_m[i++].m6 = GB(buf[j], 0, 2);
-				_m[i++].m6 = GB(buf[j], 2, 2);
-				_m[i++].m6 = GB(buf[j], 4, 2);
-				_m[i++].m6 = GB(buf[j], 6, 2);
+				_main_map.me[i++].m6 = GB(buf[j], 0, 2);
+				_main_map.me[i++].m6 = GB(buf[j], 2, 2);
+				_main_map.me[i++].m6 = GB(buf[j], 4, 2);
+				_main_map.me[i++].m6 = GB(buf[j], 6, 2);
 			}
 		}
 	} else {
 		for (TileIndex i = 0; i != size;) {
 			SlArray(buf, MAP_SL_BUF_SIZE, SLE_UINT8);
-			for (uint j = 0; j != MAP_SL_BUF_SIZE; j++) _m[i++].m6 = buf[j];
+			for (uint j = 0; j != MAP_SL_BUF_SIZE; j++) _main_map.me[i++].m6 = buf[j];
 		}
 	}
 }
@@ -219,7 +249,7 @@
 
 	SlSetLength(size);
 	for (TileIndex i = 0; i != size;) {
-		for (uint j = 0; j != MAP_SL_BUF_SIZE; j++) buf[j] = _m[i++].m6;
+		for (uint j = 0; j != MAP_SL_BUF_SIZE; j++) buf[j] = _main_map.me[i++].m6;
 		SlArray(buf, MAP_SL_BUF_SIZE, SLE_UINT8);
 	}
 }
@@ -231,7 +261,7 @@
 
 	for (TileIndex i = 0; i != size;) {
 		SlArray(buf, MAP_SL_BUF_SIZE, SLE_UINT8);
-		for (uint j = 0; j != MAP_SL_BUF_SIZE; j++) _me[i++].m7 = buf[j];
+		for (uint j = 0; j != MAP_SL_BUF_SIZE; j++) _main_map.me[i++].m7 = buf[j];
 	}
 }
 
@@ -242,7 +272,7 @@
 
 	SlSetLength(size);
 	for (TileIndex i = 0; i != size;) {
-		for (uint j = 0; j != MAP_SL_BUF_SIZE; j++) buf[j] = _me[i++].m7;
+		for (uint j = 0; j != MAP_SL_BUF_SIZE; j++) buf[j] = _main_map.me[i++].m7;
 		SlArray(buf, MAP_SL_BUF_SIZE, SLE_UINT8);
 	}
 }
@@ -250,6 +280,7 @@
 extern const ChunkHandler _map_chunk_handlers[] = {
 	{ 'MAPS', Save_MAPS, Load_MAPS, NULL, Check_MAPS, CH_RIFF },
 	{ 'MAPT', Save_MAPT, Load_MAPT, NULL, NULL,       CH_RIFF },
+	{ 'MAPH', Save_MAPH, Load_MAPH, NULL, NULL,       CH_RIFF },
 	{ 'MAPO', Save_MAP1, Load_MAP1, NULL, NULL,       CH_RIFF },
 	{ 'MAP2', Save_MAP2, Load_MAP2, NULL, NULL,       CH_RIFF },
 	{ 'M3LO', Save_MAP3, Load_MAP3, NULL, NULL,       CH_RIFF },
diff -urNad openttd-1.3.2/src/saveload/misc_sl.cpp openttd-1.3.2-DC3.0RC3/src/saveload/misc_sl.cpp
--- openttd-1.3.2/src/saveload/misc_sl.cpp	2013-07-27 17:09:36.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/saveload/misc_sl.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -73,6 +73,7 @@
 	SLEG_CONDVAR(_date,                   SLE_INT32,                  31, SL_MAX_VERSION),
 	    SLEG_VAR(_date_fract,             SLE_UINT16),
 	    SLEG_VAR(_tick_counter,           SLE_UINT16),
+       SLEG_CONDVAR(_tick_skip_counter,      SLE_UINT8,                 200, SL_MAX_VERSION),
 	SLE_CONDNULL(2, 0, 156), // _vehicle_id_ctr_day
 	SLEG_CONDVAR(_age_cargo_skip_counter, SLE_UINT8,                   0, 161),
 	SLE_CONDNULL(1, 0, 45),
@@ -98,6 +99,7 @@
 	SLEG_CONDVAR(_load_check_data.current_date,  SLE_INT32,                  31, SL_MAX_VERSION),
 	    SLE_NULL(2),                       // _date_fract
 	    SLE_NULL(2),                       // _tick_counter
+        SLEG_CONDVAR(_tick_skip_counter,      SLE_UINT8,                 200, SL_MAX_VERSION),
 	SLE_CONDNULL(2, 0, 156),               // _vehicle_id_ctr_day
 	SLE_CONDNULL(1, 0, 161),               // _age_cargo_skip_counter
 	SLE_CONDNULL(1, 0, 45),
diff -urNad openttd-1.3.2/src/saveload/oldloader_sl.cpp openttd-1.3.2-DC3.0RC3/src/saveload/oldloader_sl.cpp
--- openttd-1.3.2/src/saveload/oldloader_sl.cpp	2013-07-27 17:09:36.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/saveload/oldloader_sl.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -44,55 +44,55 @@
 {
 	/* TTO/TTD/TTDP savegames could have buoys at tile 0
 	 * (without assigned station struct) */
-	MemSetT(&_m[0], 0);
+	MemSetT(&_main_map.m[0], 0);
 	SetTileType(0, MP_WATER);
 	SetTileOwner(0, OWNER_WATER);
 }
 
 static void FixTTDMapArray()
 {
-	/* _old_map3 is moved to _m::m3 and _m::m4 */
+	/* _old_map3 is moved to m3 and m4 */
 	for (TileIndex t = 0; t < OLD_MAP_SIZE; t++) {
-		_m[t].m3 = _old_map3[t * 2];
-		_m[t].m4 = _old_map3[t * 2 + 1];
+		_main_map.m[t].m3 = _old_map3[t * 2];
+		_main_map.m[t].m4 = _old_map3[t * 2 + 1];
 	}
 
 	for (TileIndex t = 0; t < OLD_MAP_SIZE; t++) {
 		switch (GetTileType(t)) {
 			case MP_STATION:
-				_m[t].m4 = 0; // We do not understand this TTDP station mapping (yet)
-				switch (_m[t].m5) {
+				_main_map.m[t].m4 = 0; // We do not understand this TTDP station mapping (yet)
+				switch (_main_map.m[t].m5) {
 					/* We have drive through stops at a totally different place */
-					case 0x53: case 0x54: _m[t].m5 += 170 - 0x53; break; // Bus drive through
-					case 0x57: case 0x58: _m[t].m5 += 168 - 0x57; break; // Truck drive through
-					case 0x55: case 0x56: _m[t].m5 += 170 - 0x55; break; // Bus tram stop
-					case 0x59: case 0x5A: _m[t].m5 += 168 - 0x59; break; // Truck tram stop
+					case 0x53: case 0x54: _main_map.m[t].m5 += 170 - 0x53; break; // Bus drive through
+					case 0x57: case 0x58: _main_map.m[t].m5 += 168 - 0x57; break; // Truck drive through
+					case 0x55: case 0x56: _main_map.m[t].m5 += 170 - 0x55; break; // Bus tram stop
+					case 0x59: case 0x5A: _main_map.m[t].m5 += 168 - 0x59; break; // Truck tram stop
 					default: break;
 				}
 				break;
 
 			case MP_RAILWAY:
 				/* We save presignals different from TTDPatch, convert them */
-				if (GB(_m[t].m5, 6, 2) == 1) { // RAIL_TILE_SIGNALS
+				if (GB(_main_map.m[t].m5, 6, 2) == 1) { // RAIL_TILE_SIGNALS
 					/* This byte is always zero in TTD for this type of tile */
-					if (_m[t].m4) { // Convert the presignals to our own format
-						_m[t].m4 = (_m[t].m4 >> 1) & 7;
+					if (_main_map.m[t].m4) { // Convert the presignals to our own format
+						_main_map.m[t].m4 = (_main_map.m[t].m4 >> 1) & 7;
 					}
 				}
 				/* TTDPatch stores PBS things in L6 and all elsewhere; so we'll just
 				 * clear it for ourselves and let OTTD's rebuild PBS itself */
-				_m[t].m4 &= 0xF; // Only keep the lower four bits; upper four is PBS
+				_main_map.m[t].m4 &= 0xF; // Only keep the lower four bits; upper four is PBS
 				break;
 
 			case MP_WATER:
 				/* if water class == 3, make river there */
-				if (GB(_m[t].m3, 0, 2) == 3) {
+				if (GB(_main_map.m[t].m3, 0, 2) == 3) {
 					SetTileType(t, MP_WATER);
 					SetTileOwner(t, OWNER_WATER);
-					_m[t].m2 = 0;
-					_m[t].m3 = 2; // WATER_CLASS_RIVER
-					_m[t].m4 = Random();
-					_m[t].m5 = 0;
+					_main_map.m[t].m2 = 0;
+					_main_map.m[t].m3 = 2; // WATER_CLASS_RIVER
+					_main_map.m[t].m4 = Random();
+					_main_map.m[t].m5 = 0;
 				}
 				break;
 
@@ -196,7 +196,7 @@
 			RoadVehicle *rv = RoadVehicle::From(v);
 			if (rv->state != RVSB_IN_DEPOT && rv->state != RVSB_WORMHOLE) {
 				ClrBit(rv->state, 2);
-				if (IsTileType(rv->tile, MP_STATION) && _m[rv->tile].m5 >= 168) {
+				if (IsTileType(rv->tile, MP_STATION) && _main_map.m[rv->tile].m5 >= 168) {
 					/* Update the vehicle's road state to show we're in a drive through road stop. */
 					SetBit(rv->state, RVS_IN_DT_ROAD_STOP);
 				}
@@ -226,9 +226,9 @@
 		if (tt == 11) {
 			/* TTO has a different way of storing monorail.
 			 * Instead of using bits in m3 it uses a different tile type. */
-			_m[t].m3 = 1; // rail type = monorail (in TTD)
+			_main_map.m[t].m3 = 1; // rail type = monorail (in TTD)
 			SetTileType(t, MP_RAILWAY);
-			_m[t].m2 = 1; // set monorail ground to RAIL_GROUND_GRASS
+			_main_map.m[t].m2 = 1; // set monorail ground to RAIL_GROUND_GRASS
 			tt = MP_RAILWAY;
 		}
 
@@ -237,18 +237,18 @@
 				break;
 
 			case MP_RAILWAY:
-				switch (GB(_m[t].m5, 6, 2)) {
+				switch (GB(_main_map.m[t].m5, 6, 2)) {
 					case 0: // RAIL_TILE_NORMAL
 						break;
 					case 1: // RAIL_TILE_SIGNALS
-						_m[t].m4 = (~_m[t].m5 & 1) << 2;        // signal variant (present only in OTTD)
-						SB(_m[t].m2, 6, 2, GB(_m[t].m5, 3, 2)); // signal status
-						_m[t].m3 |= 0xC0;                       // both signals are present
-						_m[t].m5 = HasBit(_m[t].m5, 5) ? 2 : 1; // track direction (only X or Y)
-						_m[t].m5 |= 0x40;                       // RAIL_TILE_SIGNALS
+						_main_map.m[t].m4 = (~_main_map.m[t].m5 & 1) << 2;        // signal variant (present only in OTTD)
+						SB(_main_map.m[t].m2, 6, 2, GB(_main_map.m[t].m5, 3, 2)); // signal status
+						_main_map.m[t].m3 |= 0xC0;                                // both signals are present
+						_main_map.m[t].m5 = HasBit(_main_map.m[t].m5, 5) ? 2 : 1; // track direction (only X or Y)
+						_main_map.m[t].m5 |= 0x40;                                // RAIL_TILE_SIGNALS
 						break;
 					case 3: // RAIL_TILE_DEPOT
-						_m[t].m2 = 0;
+						_main_map.m[t].m2 = 0;
 						break;
 					default:
 						return false;
@@ -256,12 +256,12 @@
 				break;
 
 			case MP_ROAD: // road (depot) or level crossing
-				switch (GB(_m[t].m5, 4, 4)) {
+				switch (GB(_main_map.m[t].m5, 4, 4)) {
 					case 0: // ROAD_TILE_NORMAL
-						if (_m[t].m2 == 4) _m[t].m2 = 5; // 'small trees' -> ROADSIDE_TREES
+						if (_main_map.m[t].m2 == 4) _main_map.m[t].m2 = 5; // 'small trees' -> ROADSIDE_TREES
 						break;
 					case 1: // ROAD_TILE_CROSSING (there aren't monorail crossings in TTO)
-						_m[t].m3 = _m[t].m1; // set owner of road = owner of rail
+						_main_map.m[t].m3 = _main_map.m[t].m1; // set owner of road = owner of rail
 						break;
 					case 2: // ROAD_TILE_DEPOT
 						break;
@@ -271,69 +271,69 @@
 				break;
 
 			case MP_HOUSE:
-				_m[t].m3 = _m[t].m2 & 0xC0;    // construction stage
-				_m[t].m2 &= 0x3F;              // building type
-				if (_m[t].m2 >= 5) _m[t].m2++; // skip "large office block on snow"
+				_main_map.m[t].m3 = _main_map.m[t].m2 & 0xC0;    // construction stage
+				_main_map.m[t].m2 &= 0x3F;                       // building type
+				if (_main_map.m[t].m2 >= 5) _main_map.m[t].m2++; // skip "large office block on snow"
 				break;
 
 			case MP_TREES:
-				_m[t].m3 = GB(_m[t].m5, 3, 3); // type of trees
-				_m[t].m5 &= 0xC7;              // number of trees and growth status
+				_main_map.m[t].m3 = GB(_main_map.m[t].m5, 3, 3); // type of trees
+				_main_map.m[t].m5 &= 0xC7;                       // number of trees and growth status
 				break;
 
 			case MP_STATION:
-				_m[t].m3 = (_m[t].m5 >= 0x08 && _m[t].m5 <= 0x0F) ? 1 : 0; // monorail -> 1, others 0 (rail, road, airport, dock)
-				if (_m[t].m5 >= 8) _m[t].m5 -= 8; // shift for monorail
-				if (_m[t].m5 >= 0x42) _m[t].m5++; // skip heliport
+				_main_map.m[t].m3 = (_main_map.m[t].m5 >= 0x08 && _main_map.m[t].m5 <= 0x0F) ? 1 : 0; // monorail -> 1, others 0 (rail, road, airport, dock)
+				if (_main_map.m[t].m5 >= 8) _main_map.m[t].m5 -= 8; // shift for monorail
+				if (_main_map.m[t].m5 >= 0x42) _main_map.m[t].m5++; // skip heliport
 				break;
 
 			case MP_WATER:
-				_m[t].m3 = _m[t].m2 = 0;
+				_main_map.m[t].m3 = _main_map.m[t].m2 = 0;
 				break;
 
 			case MP_VOID:
-				_m[t].m2 = _m[t].m3 = _m[t].m5 = 0;
+				_main_map.m[t].m2 = _main_map.m[t].m3 = _main_map.m[t].m5 = 0;
 				break;
 
 			case MP_INDUSTRY:
-				_m[t].m3 = 0;
-				switch (_m[t].m5) {
+				_main_map.m[t].m3 = 0;
+				switch (_main_map.m[t].m5) {
 					case 0x24: // farm silo
-						_m[t].m5 = 0x25;
+						_main_map.m[t].m5 = 0x25;
 						break;
 					case 0x25: case 0x27: // farm
 					case 0x28: case 0x29: case 0x2A: case 0x2B: // factory
-						_m[t].m5--;
+						_main_map.m[t].m5--;
 						break;
 					default:
-						if (_m[t].m5 >= 0x2C) _m[t].m5 += 3; // iron ore mine, steel mill or bank
+						if (_main_map.m[t].m5 >= 0x2C) _main_map.m[t].m5 += 3; // iron ore mine, steel mill or bank
 						break;
 				}
 				break;
 
 			case MP_TUNNELBRIDGE:
-				if (HasBit(_m[t].m5, 7)) { // bridge
-					byte m5 = _m[t].m5;
-					_m[t].m5 = m5 & 0xE1; // copy bits 7..5, 1
-					if (GB(m5, 1, 2) == 1) _m[t].m5 |= 0x02; // road bridge
-					if (GB(m5, 1, 2) == 3) _m[t].m2 |= 0xA0; // monorail bridge -> tubular, steel bridge
+				if (HasBit(_main_map.m[t].m5, 7)) { // bridge
+					byte m5 = _main_map.m[t].m5;
+					_main_map.m[t].m5 = m5 & 0xE1; // copy bits 7..5, 1
+					if (GB(m5, 1, 2) == 1) _main_map.m[t].m5 |= 0x02; // road bridge
+					if (GB(m5, 1, 2) == 3) _main_map.m[t].m2 |= 0xA0; // monorail bridge -> tubular, steel bridge
 					if (!HasBit(m5, 6)) { // bridge head
-						_m[t].m3 = (GB(m5, 1, 2) == 3) ? 1 : 0; // track subtype (1 for monorail, 0 for others)
+						_main_map.m[t].m3 = (GB(m5, 1, 2) == 3) ? 1 : 0; // track subtype (1 for monorail, 0 for others)
 					} else { // middle bridge part
-						_m[t].m3 = HasBit(m5, 2) ? 0x10 : 0;  // track subtype on bridge
-						if (GB(m5, 3, 2) == 3) _m[t].m3 |= 1; // track subtype under bridge
-						if (GB(m5, 3, 2) == 1) _m[t].m5 |= 0x08; // set for road/water under (0 for rail/clear)
+						_main_map.m[t].m3 = HasBit(m5, 2) ? 0x10 : 0;     // track subtype on bridge
+						if (GB(m5, 3, 2) == 3) _main_map.m[t].m3 |= 1;    // track subtype under bridge
+						if (GB(m5, 3, 2) == 1) _main_map.m[t].m5 |= 0x08; // set for road/water under (0 for rail/clear)
 					}
 				} else { // tunnel entrance/exit
-					_m[t].m2 = 0;
-					_m[t].m3 = HasBit(_m[t].m5, 3); // monorail
-					_m[t].m5 &= HasBit(_m[t].m5, 3) ? 0x03 : 0x07 ; // direction, transport type (== 0 for rail)
+					_main_map.m[t].m2 = 0;
+					_main_map.m[t].m3 = HasBit(_main_map.m[t].m5, 3); // monorail
+					_main_map.m[t].m5 &= HasBit(_main_map.m[t].m5, 3) ? 0x03 : 0x07 ; // direction, transport type (== 0 for rail)
 				}
 				break;
 
 			case MP_OBJECT:
-				_m[t].m2 = 0;
-				_m[t].m3 = 0;
+				_main_map.m[t].m2 = 0;
+				_main_map.m[t].m3 = 0;
 				break;
 
 			default:
@@ -1472,15 +1472,15 @@
 static bool LoadOldMapPart1(LoadgameState *ls, int num)
 {
 	if (_savegame_type == SGT_TTO) {
-		MemSetT(_m, 0, OLD_MAP_SIZE);
-		MemSetT(_me, 0, OLD_MAP_SIZE);
+		MemSetT(_main_map.m, 0, OLD_MAP_SIZE);
+		MemSetT(_main_map.me, 0, OLD_MAP_SIZE);
 	}
 
 	for (uint i = 0; i < OLD_MAP_SIZE; i++) {
-		_m[i].m1 = ReadByte(ls);
+		_main_map.m[i].m1 = ReadByte(ls);
 	}
 	for (uint i = 0; i < OLD_MAP_SIZE; i++) {
-		_m[i].m2 = ReadByte(ls);
+		_main_map.m[i].m2 = ReadByte(ls);
 	}
 
 	if (_savegame_type != SGT_TTO) {
@@ -1490,10 +1490,10 @@
 		}
 		for (uint i = 0; i < OLD_MAP_SIZE / 4; i++) {
 			byte b = ReadByte(ls);
-			_m[i * 4 + 0].m6 = GB(b, 0, 2);
-			_m[i * 4 + 1].m6 = GB(b, 2, 2);
-			_m[i * 4 + 2].m6 = GB(b, 4, 2);
-			_m[i * 4 + 3].m6 = GB(b, 6, 2);
+			_main_map.me[i * 4 + 0].m6 = GB(b, 0, 2);
+			_main_map.me[i * 4 + 1].m6 = GB(b, 2, 2);
+			_main_map.me[i * 4 + 2].m6 = GB(b, 4, 2);
+			_main_map.me[i * 4 + 3].m6 = GB(b, 6, 2);
 		}
 	}
 
@@ -1505,10 +1505,11 @@
 	uint i;
 
 	for (i = 0; i < OLD_MAP_SIZE; i++) {
-		_m[i].type_height = ReadByte(ls);
+               _main_map.m[i].type = ReadByte(ls);
+               _main_map.m[i].height = GB(_main_map.m[i].type, 0, 4);
 	}
 	for (i = 0; i < OLD_MAP_SIZE; i++) {
-		_m[i].m5 = ReadByte(ls);
+		_main_map.m[i].m5 = ReadByte(ls);
 	}
 
 	return true;
diff -urNad openttd-1.3.2/src/saveload/order_sl.cpp openttd-1.3.2-DC3.0RC3/src/saveload/order_sl.cpp
--- openttd-1.3.2/src/saveload/order_sl.cpp	2013-07-27 17:09:36.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/saveload/order_sl.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -111,6 +111,7 @@
 		 SLE_CONDVAR(Order, wait_time,      SLE_UINT16,  67, SL_MAX_VERSION),
 		 SLE_CONDVAR(Order, travel_time,    SLE_UINT16,  67, SL_MAX_VERSION),
 		 SLE_CONDVAR(Order, max_speed,      SLE_UINT16, 172, SL_MAX_VERSION),
+		 SLE_CONDVAR(Order, jump_counter,   SLE_INT8,   SL_CONDORDERS, SL_MAX_VERSION),
 
 		/* Leftover from the minor savegame version stuff
 		 * We will never use those free bytes, but we have to keep this line to allow loading of old savegames */
@@ -203,7 +204,14 @@
 const SaveLoad *GetOrderListDescription()
 {
 	static const SaveLoad _orderlist_desc[] = {
-		SLE_REF(OrderList, first,              REF_ORDER),
+		SLE_REF(    OrderList, first,               REF_ORDER),
+		SLE_CONDVAR(OrderList, current_sep_mode,    SLE_UINT, SL_TTSEP_VER, SL_MAX_VERSION),
+		SLE_CONDVAR(OrderList, num_sep_vehicles,    SLE_UINT, SL_TTSEP_VER, SL_MAX_VERSION),
+		SLE_CONDVAR(OrderList, separation_counter,  SLE_UINT, SL_TTSEP_VER, SL_MAX_VERSION),
+		SLE_CONDVAR(OrderList, separation_counter,  SLE_UINT, SL_TTSEP_VER, SL_MAX_VERSION),
+		SLE_CONDVAR(OrderList, is_separation_valid, SLE_BOOL, SL_TTSEP_VER, SL_MAX_VERSION),
+		SLE_CONDVAR(OrderList, current_separation,  SLE_INT,  SL_TTSEP_VER, SL_MAX_VERSION),
+		SLE_CONDVAR(OrderList, last_timetable_init, SLE_INT,  SL_TTSEP_VER, SL_MAX_VERSION),
 		SLE_END()
 	};
 
diff -urNad openttd-1.3.2/src/saveload/saveload.cpp openttd-1.3.2-DC3.0RC3/src/saveload/saveload.cpp
--- openttd-1.3.2/src/saveload/saveload.cpp	2013-07-27 17:09:36.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/saveload/saveload.cpp	2013-11-22 06:14:22.000000000 +0100
@@ -41,6 +41,9 @@
 #include "../string_func.h"
 #include "../fios.h"
 #include "../error.h"
+#include "../cargodest_base.h"
+
+#include "../aaa_template_vehicle.h" //MYGUI
 
 #include "table/strings.h"
 
@@ -245,7 +248,7 @@
  *  179   24810
  *  180   24998   1.3.x
  */
-extern const uint16 SAVEGAME_VERSION = 180; ///< Current savegame version of OpenTTD.
+extern const uint16 SAVEGAME_VERSION = 201; ///< Current savegame version of OpenTTD.
 
 SavegameType _savegame_type; ///< type of savegame we are loading
 
@@ -426,7 +429,10 @@
 extern const ChunkHandler _labelmaps_chunk_handlers[];
 extern const ChunkHandler _airport_chunk_handlers[];
 extern const ChunkHandler _object_chunk_handlers[];
+extern const ChunkHandler _routelink_chunk_handlers[];
 extern const ChunkHandler _persistent_storage_chunk_handlers[];
+extern const ChunkHandler _template_replacement_chunk_handlers[]; //MYGUI
+extern const ChunkHandler _template_vehicle_chunk_handlers[]; //MYGUI
 
 /** Array of all chunks in a savegame, \c NULL terminated. */
 static const ChunkHandler * const _chunk_handlers[] = {
@@ -460,7 +466,10 @@
 	_labelmaps_chunk_handlers,
 	_airport_chunk_handlers,
 	_object_chunk_handlers,
+	_routelink_chunk_handlers,
 	_persistent_storage_chunk_handlers,
+	_template_replacement_chunk_handlers,			// MYGUI
+	_template_vehicle_chunk_handlers,				// MYGUI
 	NULL,
 };
 
@@ -1207,6 +1216,7 @@
 	switch (rt) {
 		case REF_VEHICLE_OLD: // Old vehicles we save as new ones
 		case REF_VEHICLE:   return ((const  Vehicle*)obj)->index + 1;
+		case REF_TEMPLATE_VEHICLE: return ((const TemplateVehicle*)obj)->index + 1;	// MYGUI
 		case REF_STATION:   return ((const  Station*)obj)->index + 1;
 		case REF_TOWN:      return ((const     Town*)obj)->index + 1;
 		case REF_ORDER:     return ((const    Order*)obj)->index + 1;
@@ -1214,6 +1224,7 @@
 		case REF_ENGINE_RENEWS: return ((const       EngineRenew*)obj)->index + 1;
 		case REF_CARGO_PACKET:  return ((const       CargoPacket*)obj)->index + 1;
 		case REF_ORDERLIST:     return ((const         OrderList*)obj)->index + 1;
+		case REF_ROUTE_LINK:    return ((const         RouteLink*)obj)->index + 1;
 		case REF_STORAGE:       return ((const PersistentStorage*)obj)->index + 1;
 		default: NOT_REACHED();
 	}
@@ -1264,6 +1275,10 @@
 			if (Vehicle::IsValidID(index)) return Vehicle::Get(index);
 			SlErrorCorrupt("Referencing invalid Vehicle");
 
+		case REF_TEMPLATE_VEHICLE:						// MYGUI
+			if (TemplateVehicle::IsValidID(index)) return TemplateVehicle::Get(index);
+			SlErrorCorrupt("Referencing invalid TemplateVehicle");
+
 		case REF_STATION:
 			if (Station::IsValidID(index)) return Station::Get(index);
 			SlErrorCorrupt("Referencing invalid Station");
@@ -1284,6 +1299,10 @@
 			if (CargoPacket::IsValidID(index)) return CargoPacket::Get(index);
 			SlErrorCorrupt("Referencing invalid CargoPacket");
 
+		case REF_ROUTE_LINK:
+			if (RouteLink::IsValidID(index)) return RouteLink::Get(index);
+			SlErrorCorrupt("Referencing invalid RouteLink");
+
 		case REF_STORAGE:
 			if (PersistentStorage::IsValidID(index)) return PersistentStorage::Get(index);
 			SlErrorCorrupt("Referencing invalid PersistentStorage");
diff -urNad openttd-1.3.2/src/saveload/saveload.h openttd-1.3.2-DC3.0RC3/src/saveload/saveload.h
--- openttd-1.3.2/src/saveload/saveload.h	2013-07-27 17:09:36.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/saveload/saveload.h	2013-11-22 06:14:09.000000000 +0100
@@ -15,6 +15,8 @@
 #include "../fileio_type.h"
 #include "../strings_type.h"
 
+#define SL_TTSEP_VER 200
+
 /** Save or load result codes. */
 enum SaveOrLoadResult {
 	SL_OK     = 0, ///< completed successfully
@@ -82,11 +84,20 @@
 	REF_ENGINE_RENEWS = 6, ///< Load/save a reference to an engine renewal (autoreplace).
 	REF_CARGO_PACKET  = 7, ///< Load/save a reference to a cargo packet.
 	REF_ORDERLIST     = 8, ///< Load/save a reference to an orderlist.
-	REF_STORAGE       = 9, ///< Load/save a reference to a persistent storage.
+	REF_ROUTE_LINK    = 9, ///< Load/save a reference to a route link.
+	REF_STORAGE       = 10, ///< Load/save a reference to a persistent storage.
+	REF_TEMPLATE_VEHICLE = 11, ///< Load/save a reference to a template vehicle
 };
 
+/* Current savegame version. */
+static const uint TL_SV = 200;
+
 /** Highest possible savegame version. */
 #define SL_MAX_VERSION 255
+#define SL_IBC         200
+#define SL_TRIP        190
+#define SL_CONDORDERS  200
+#define MORE_HEIGHTLEVEL_SAVEGAME_VERSION 201
 
 /** Flags of a chunk. */
 enum ChunkType {
diff -urNad openttd-1.3.2/src/saveload/saveload_internal.h openttd-1.3.2-DC3.0RC3/src/saveload/saveload_internal.h
--- openttd-1.3.2/src/saveload/saveload_internal.h	2013-07-27 17:09:36.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/saveload/saveload_internal.h	2013-11-22 05:49:07.000000000 +0100
@@ -28,6 +28,7 @@
 
 void AfterLoadVehicles(bool part_of_load);
 void FixupTrainLengths();
+void AfterLoadTemplateVehicles(); //MYGUI
 void AfterLoadStations();
 void AfterLoadRoadStops();
 void AfterLoadLabelMaps();
diff -urNad openttd-1.3.2/src/saveload/station_sl.cpp openttd-1.3.2-DC3.0RC3/src/saveload/station_sl.cpp
--- openttd-1.3.2/src/saveload/station_sl.cpp	2013-07-27 17:09:36.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/saveload/station_sl.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -93,7 +93,7 @@
 			TILE_AREA_LOOP(t, train_st) {
 				if (!IsTileType(t, MP_STATION) || GetStationIndex(t) != index) continue;
 
-				SB(_m[t].m6, 3, 3, STATION_WAYPOINT);
+				SB(_main_map.me[t].m6, 3, 3, STATION_WAYPOINT);
 				wp->rect.BeforeAddTile(t, StationRect::ADD_FORCE);
 			}
 
@@ -258,7 +258,10 @@
 		SLEG_CONDVAR(            _cargo_feeder_share, SLE_FILE_U32 | SLE_VAR_I64, 14, 64),
 		SLEG_CONDVAR(            _cargo_feeder_share, SLE_INT64,                  65, 67),
 		 SLE_CONDVAR(GoodsEntry, amount_fract,        SLE_UINT8,                 150, SL_MAX_VERSION),
+		 SLE_CONDVAR(GoodsEntry, cargo_counter,       SLE_UINT16,                181, SL_MAX_VERSION),
 		 SLE_CONDLST(GoodsEntry, cargo.packets,       REF_CARGO_PACKET,           68, SL_MAX_VERSION),
+		 SLE_CONDVAR(GoodsEntry, cargo.next_start,    SLE_UINT32,                181, SL_MAX_VERSION),
+		 SLE_CONDLST(GoodsEntry, routes,              REF_ROUTE_LINK,            181, SL_MAX_VERSION),
 
 		SLE_END()
 	};
@@ -362,7 +365,9 @@
 	  SLE_CONDVAR(Station, airport.h,                  SLE_FILE_U8 | SLE_VAR_U16, 140, SL_MAX_VERSION),
 	      SLE_VAR(Station, airport.type,               SLE_UINT8),
 	  SLE_CONDVAR(Station, airport.layout,             SLE_UINT8,                 145, SL_MAX_VERSION),
+	  SLE_CONDVAR(Station, airport.num_circle,         SLE_UINT8,                 181, SL_MAX_VERSION),
 	      SLE_VAR(Station, airport.flags,              SLE_UINT64),
+	  SLE_CONDVAR(Station, airport.flags2,             SLE_UINT64,                181, SL_MAX_VERSION),
 	  SLE_CONDVAR(Station, airport.rotation,           SLE_UINT8,                 145, SL_MAX_VERSION),
 	 SLEG_CONDARR(_old_st_persistent_storage.storage,  SLE_UINT32, 16,            145, 160),
 	  SLE_CONDREF(Station, airport.psa,                REF_STORAGE,               161, SL_MAX_VERSION),
diff -urNad openttd-1.3.2/src/saveload/town_sl.cpp openttd-1.3.2-DC3.0RC3/src/saveload/town_sl.cpp
--- openttd-1.3.2/src/saveload/town_sl.cpp	2013-07-27 17:09:36.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/saveload/town_sl.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -249,6 +249,8 @@
 		SlObject(&t->received[i], _town_received_desc);
 	}
 
+	t->SaveCargoSourceSink();
+
 	if (IsSavegameVersionBefore(166)) return;
 
 	SlObject(&t->cargo_accepted, GetTileMatrixDesc());
@@ -287,6 +289,8 @@
 			SlErrorCorrupt("Invalid town name generator");
 		}
 
+		t->LoadCargoSourceSink();
+
 		if (IsSavegameVersionBefore(166)) continue;
 
 		SlObject(&t->cargo_accepted, GetTileMatrixDesc());
@@ -298,16 +302,26 @@
 			/* Rebuild total cargo acceptance. */
 			UpdateTownCargoTotal(t);
 		}
+
+		/* Cache the aligned tile index of the centre tile. */
+		uint town_x = (TileX(t->xy) / AcceptanceMatrix::GRID) * AcceptanceMatrix::GRID;
+		uint town_y = (TileY(t->xy) / AcceptanceMatrix::GRID) * AcceptanceMatrix::GRID;
+		t->xy_aligned= TileXY(town_x, town_y);
 	}
 }
 
 /** Fix pointers when loading town data. */
 static void Ptrs_TOWN()
 {
+	Town *t;
+
+	FOR_ALL_TOWNS(t) {
+		t->PtrsCargoSourceSink();
+	}
+
 	/* Don't run when savegame version lower than 161. */
 	if (IsSavegameVersionBefore(161)) return;
 
-	Town *t;
 	FOR_ALL_TOWNS(t) {
 		SlObject(t, _town_desc);
 	}
diff -urNad openttd-1.3.2/src/saveload/vehicle_sl.cpp openttd-1.3.2-DC3.0RC3/src/saveload/vehicle_sl.cpp
--- openttd-1.3.2/src/saveload/vehicle_sl.cpp	2013-07-27 17:09:36.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/saveload/vehicle_sl.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -197,7 +197,7 @@
 			if (a->subtype == AIR_HELICOPTER) a->Next()->Next()->cur_speed = 32;
 
 			/* set new position x,y,z */
-			SetAircraftPosition(a, gp.x, gp.y, GetAircraftFlyingAltitude(a));
+			SetAircraftPosition(a, gp.x, gp.y, GetAircraftMaxAltitude(a->x_pos, a->y_pos, 0));
 		}
 	}
 }
@@ -352,7 +352,7 @@
 			}
 		}
 
-		if (IsSavegameVersionBefore(180)) {
+		if (IsSavegameVersionBefore(181)) {
 			/* Set service interval flags */
 			FOR_ALL_VEHICLES(v) {
 				if (!v->IsPrimaryVehicle()) continue;
@@ -604,6 +604,8 @@
 		     SLE_VAR(Vehicle, vehstatus,             SLE_UINT8),
 		 SLE_CONDVAR(Vehicle, last_station_visited,  SLE_FILE_U8  | SLE_VAR_U16,   0,   4),
 		 SLE_CONDVAR(Vehicle, last_station_visited,  SLE_UINT16,                   5, SL_MAX_VERSION),
+		 SLE_CONDVAR(Vehicle, last_station_loaded,   SLE_UINT16,                 181, SL_MAX_VERSION),
+		 SLE_CONDVAR(Vehicle, last_order_id,         SLE_UINT16,                 181, SL_MAX_VERSION),
 
 		     SLE_VAR(Vehicle, cargo_type,            SLE_UINT8),
 		 SLE_CONDVAR(Vehicle, cargo_subtype,         SLE_UINT8,                   35, SL_MAX_VERSION),
@@ -616,6 +618,7 @@
 		 SLE_CONDLST(Vehicle, cargo.packets,         REF_CARGO_PACKET,            68, SL_MAX_VERSION),
 		 SLE_CONDVAR(Vehicle, cargo_age_counter,     SLE_UINT16,                 162, SL_MAX_VERSION),
 
+		 SLE_CONDVAR(Vehicle, travel_time,           SLE_UINT32,                 181, SL_MAX_VERSION),
 		     SLE_VAR(Vehicle, day_counter,           SLE_UINT8),
 		     SLE_VAR(Vehicle, tick_counter,          SLE_UINT8),
 		 SLE_CONDVAR(Vehicle, running_ticks,         SLE_UINT8,                   88, SL_MAX_VERSION),
@@ -635,6 +638,7 @@
 		 SLE_CONDVAR(Vehicle, current_order.type,    SLE_UINT8,                    5, SL_MAX_VERSION),
 		 SLE_CONDVAR(Vehicle, current_order.flags,   SLE_UINT8,                    5, SL_MAX_VERSION),
 		 SLE_CONDVAR(Vehicle, current_order.dest,    SLE_UINT16,                   5, SL_MAX_VERSION),
+		 SLE_CONDVAR(Vehicle, current_order.index,   SLE_UINT16,                 181, SL_MAX_VERSION),
 
 		/* Refit in current order */
 		 SLE_CONDVAR(Vehicle, current_order.refit_cargo,   SLE_UINT8,             36, SL_MAX_VERSION),
@@ -696,6 +700,27 @@
 
 		SLE_CONDNULL(10,                                                           2, 143), // old reserved space
 
+		// Trip History Arrays
+		SLE_CONDVAR(Vehicle, trip_history.t[0].profit,     SLE_INT64,     SL_TRIP, SL_MAX_VERSION),
+		SLE_CONDVAR(Vehicle, trip_history.t[1].profit,     SLE_INT64,     SL_TRIP, SL_MAX_VERSION),
+		SLE_CONDVAR(Vehicle, trip_history.t[2].profit,     SLE_INT64,     SL_TRIP, SL_MAX_VERSION),
+		SLE_CONDVAR(Vehicle, trip_history.t[3].profit,     SLE_INT64,     SL_TRIP, SL_MAX_VERSION),
+		SLE_CONDVAR(Vehicle, trip_history.t[4].profit,     SLE_INT64,     SL_TRIP, SL_MAX_VERSION),
+		SLE_CONDVAR(Vehicle, trip_history.t[5].profit,     SLE_INT64,     SL_TRIP, SL_MAX_VERSION),
+		SLE_CONDVAR(Vehicle, trip_history.t[6].profit,     SLE_INT64,     SL_TRIP, SL_MAX_VERSION),
+		SLE_CONDVAR(Vehicle, trip_history.t[7].profit,     SLE_INT64,     SL_TRIP, SL_MAX_VERSION),
+		SLE_CONDVAR(Vehicle, trip_history.t[8].profit,     SLE_INT64,     SL_TRIP, SL_MAX_VERSION),
+		SLE_CONDVAR(Vehicle, trip_history.t[9].profit,     SLE_INT64,     SL_TRIP, SL_MAX_VERSION),
+		SLE_CONDVAR(Vehicle, trip_history.t[0].date,       SLE_INT64,     SL_TRIP, SL_MAX_VERSION),
+		SLE_CONDVAR(Vehicle, trip_history.t[1].date,       SLE_INT64,     SL_TRIP, SL_MAX_VERSION),
+		SLE_CONDVAR(Vehicle, trip_history.t[2].date,       SLE_INT64,     SL_TRIP, SL_MAX_VERSION),
+		SLE_CONDVAR(Vehicle, trip_history.t[3].date,       SLE_INT64,     SL_TRIP, SL_MAX_VERSION),
+		SLE_CONDVAR(Vehicle, trip_history.t[4].date,       SLE_INT64,     SL_TRIP, SL_MAX_VERSION),
+		SLE_CONDVAR(Vehicle, trip_history.t[5].date,       SLE_INT64,     SL_TRIP, SL_MAX_VERSION),
+		SLE_CONDVAR(Vehicle, trip_history.t[6].date,       SLE_INT64,     SL_TRIP, SL_MAX_VERSION),
+		SLE_CONDVAR(Vehicle, trip_history.t[7].date,       SLE_INT64,     SL_TRIP, SL_MAX_VERSION),
+		SLE_CONDVAR(Vehicle, trip_history.t[8].date,       SLE_INT64,     SL_TRIP, SL_MAX_VERSION),
+		SLE_CONDVAR(Vehicle, trip_history.t[9].date,       SLE_INT64,     SL_TRIP, SL_MAX_VERSION),
 		     SLE_END()
 	};
 
@@ -766,6 +791,9 @@
 		 SLE_CONDVAR(Aircraft, last_direction,        SLE_UINT8,                    2, SL_MAX_VERSION),
 		 SLE_CONDVAR(Aircraft, number_consecutive_turns, SLE_UINT8,                 2, SL_MAX_VERSION),
 
+		 SLE_CONDVAR(Aircraft, in_max_height_correction, SLE_BOOL,     MORE_HEIGHTLEVEL_SAVEGAME_VERSION, SL_MAX_VERSION),
+		 SLE_CONDVAR(Aircraft, in_min_height_correction, SLE_BOOL,     MORE_HEIGHTLEVEL_SAVEGAME_VERSION, SL_MAX_VERSION),
+
 		 SLE_CONDVAR(Aircraft, turn_counter,          SLE_UINT8,                  136, SL_MAX_VERSION),
 		 SLE_CONDVAR(Aircraft, flags,                 SLE_UINT8,                  167, SL_MAX_VERSION),
 
@@ -836,6 +864,8 @@
 
 		     SLE_VAR(DisasterVehicle, image_override,            SLE_UINT16),
 		     SLE_VAR(DisasterVehicle, big_ufo_destroyer_target,  SLE_UINT16),
+		 SLE_CONDVAR(DisasterVehicle, in_max_height_correction, SLE_UINT8,     MORE_HEIGHTLEVEL_SAVEGAME_VERSION, SL_MAX_VERSION),
+		 SLE_CONDVAR(DisasterVehicle, in_min_height_correction, SLE_UINT8,     MORE_HEIGHTLEVEL_SAVEGAME_VERSION, SL_MAX_VERSION),
 
 		SLE_CONDNULL(16,                                                           2, 143), // old reserved space
 
diff -urNad openttd-1.3.2/src/saveload/waypoint_sl.cpp openttd-1.3.2-DC3.0RC3/src/saveload/waypoint_sl.cpp
--- openttd-1.3.2/src/saveload/waypoint_sl.cpp	2013-07-27 17:09:36.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/saveload/waypoint_sl.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -73,10 +73,10 @@
 			if (wp->delete_ctr != 0) continue; // The waypoint was deleted
 
 			/* Waypoint indices were not added to the map prior to this. */
-			_m[wp->xy].m2 = (StationID)wp->index;
+			_main_map.m[wp->xy].m2 = (StationID)wp->index;
 
-			if (HasBit(_m[wp->xy].m3, 4)) {
-				wp->spec = StationClass::Get(STAT_CLASS_WAYP)->GetSpec(_m[wp->xy].m4 + 1);
+			if (HasBit(_main_map.m[wp->xy].m3, 4)) {
+				wp->spec = StationClass::Get(STAT_CLASS_WAYP)->GetSpec(_main_map.m[wp->xy].m4 + 1);
 			}
 		}
 	} else {
@@ -109,12 +109,12 @@
 		new_wp->string_id = STR_SV_STNAME_WAYPOINT;
 
 		TileIndex t = wp->xy;
-		if (IsTileType(t, MP_RAILWAY) && GetRailTileType(t) == 2 /* RAIL_TILE_WAYPOINT */ && _m[t].m2 == wp->index) {
+		if (IsTileType(t, MP_RAILWAY) && GetRailTileType(t) == 2 /* RAIL_TILE_WAYPOINT */ && _main_map.m[t].m2 == wp->index) {
 			/* The tile might've been reserved! */
-			bool reserved = !IsSavegameVersionBefore(100) && HasBit(_m[t].m5, 4);
+			bool reserved = !IsSavegameVersionBefore(100) && HasBit(_main_map.m[t].m5, 4);
 
 			/* The tile really has our waypoint, so reassign the map array */
-			MakeRailWaypoint(t, GetTileOwner(t), new_wp->index, (Axis)GB(_m[t].m5, 0, 1), 0, GetRailType(t));
+			MakeRailWaypoint(t, GetTileOwner(t), new_wp->index, (Axis)GB(_main_map.m[t].m5, 0, 1), 0, GetRailType(t));
 			new_wp->facilities |= FACIL_TRAIN;
 			new_wp->owner = GetTileOwner(t);
 
diff -urNad openttd-1.3.2/src/script/api/ai/ai_airport.hpp.sq openttd-1.3.2-DC3.0RC3/src/script/api/ai/ai_airport.hpp.sq
--- openttd-1.3.2/src/script/api/ai/ai_airport.hpp.sq	2013-07-27 17:09:35.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/script/api/ai/ai_airport.hpp.sq	2013-11-22 05:49:07.000000000 +0100
@@ -30,6 +30,8 @@
 	SQAIAirport.DefSQConst(engine, ScriptAirport::AT_HELIPORT,      "AT_HELIPORT");
 	SQAIAirport.DefSQConst(engine, ScriptAirport::AT_HELISTATION,   "AT_HELISTATION");
 	SQAIAirport.DefSQConst(engine, ScriptAirport::AT_HELIDEPOT,     "AT_HELIDEPOT");
+	SQAIAirport.DefSQConst(engine, ScriptAirport::AT_INTERCONTINENTAL2, "AT_INTERCONTINENTAL2");
+	SQAIAirport.DefSQConst(engine, ScriptAirport::AT_CIRCLE,        "AT_CIRCLE");
 	SQAIAirport.DefSQConst(engine, ScriptAirport::AT_INVALID,       "AT_INVALID");
 	SQAIAirport.DefSQConst(engine, ScriptAirport::PT_HELICOPTER,    "PT_HELICOPTER");
 	SQAIAirport.DefSQConst(engine, ScriptAirport::PT_SMALL_PLANE,   "PT_SMALL_PLANE");
diff -urNad openttd-1.3.2/src/script/api/game/game_airport.hpp.sq openttd-1.3.2-DC3.0RC3/src/script/api/game/game_airport.hpp.sq
--- openttd-1.3.2/src/script/api/game/game_airport.hpp.sq	2013-07-27 17:09:34.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/script/api/game/game_airport.hpp.sq	2013-11-22 05:49:07.000000000 +0100
@@ -30,6 +30,8 @@
 	SQGSAirport.DefSQConst(engine, ScriptAirport::AT_HELIPORT,      "AT_HELIPORT");
 	SQGSAirport.DefSQConst(engine, ScriptAirport::AT_HELISTATION,   "AT_HELISTATION");
 	SQGSAirport.DefSQConst(engine, ScriptAirport::AT_HELIDEPOT,     "AT_HELIDEPOT");
+	SQGSAirport.DefSQConst(engine, ScriptAirport::AT_INTERCONTINENTAL2, "AT_INTERCONTINENTAL2");
+	SQGSAirport.DefSQConst(engine, ScriptAirport::AT_CIRCLE,        "AT_CIRCLE");
 	SQGSAirport.DefSQConst(engine, ScriptAirport::AT_INVALID,       "AT_INVALID");
 	SQGSAirport.DefSQConst(engine, ScriptAirport::PT_HELICOPTER,    "PT_HELICOPTER");
 	SQGSAirport.DefSQConst(engine, ScriptAirport::PT_SMALL_PLANE,   "PT_SMALL_PLANE");
diff -urNad openttd-1.3.2/src/script/api/game/game_window.hpp.sq openttd-1.3.2-DC3.0RC3/src/script/api/game/game_window.hpp.sq
--- openttd-1.3.2/src/script/api/game/game_window.hpp.sq	2013-07-27 17:09:34.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/script/api/game/game_window.hpp.sq	2013-11-22 05:49:07.000000000 +0100
@@ -244,6 +244,27 @@
 	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_BV_BUILD_SEL,                          "WID_BV_BUILD_SEL");
 	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_BV_RENAME,                             "WID_BV_RENAME");
 	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_C_PANEL,                               "WID_C_PANEL");
+	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_CT_COPY,                               "WID_CT_COPY");
+	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_CT_PASTE,                              "WID_CT_PASTE");
+	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_CT_PASTE_FLAG_BUTTON_BEGIN,            "WID_CT_PASTE_FLAG_BUTTON_BEGIN");
+	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_CT_WITH_RAIL,                          "WID_CT_WITH_RAIL");
+	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_CT_WITH_ROAD,                          "WID_CT_WITH_ROAD");
+	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_CT_WITH_WATER,                         "WID_CT_WITH_WATER");
+	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_CT_WITH_AIR,                           "WID_CT_WITH_AIR");
+	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_CT_MIRROR_SIGNALS,                     "WID_CT_MIRROR_SIGNALS");
+	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_CT_UPGRADE_BRIDGES,                    "WID_CT_UPGRADE_BRIDGES");
+	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_CT_PASTE_FLAG_BUTTON_END,              "WID_CT_PASTE_FLAG_BUTTON_END");
+	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_CT_CONVERT_RAILTYPE,                   "WID_CT_CONVERT_RAILTYPE");
+	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_CT_TERRAFORM,                          "WID_CT_TERRAFORM");
+	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_CT_TRANSFORMATION,                     "WID_CT_TRANSFORMATION");
+	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_CT_ROTATE_LEFT,                        "WID_CT_ROTATE_LEFT");
+	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_CT_ROTATE_RIGHT,                       "WID_CT_ROTATE_RIGHT");
+	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_CT_REFLECT_NE_SW,                      "WID_CT_REFLECT_NE_SW");
+	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_CT_REFLECT_NW_SE,                      "WID_CT_REFLECT_NW_SE");
+	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_CT_HEIGHT_DIFF_GLYPH,                  "WID_CT_HEIGHT_DIFF_GLYPH");
+	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_CT_HEIGHT_DIFF,                        "WID_CT_HEIGHT_DIFF");
+	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_CT_HEIGHT_DIFF_INCREASE,               "WID_CT_HEIGHT_DIFF_INCREASE");
+	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_CT_HEIGHT_DIFF_DECREASE,               "WID_CT_HEIGHT_DIFF_DECREASE");
 	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_C_CAPTION,                             "WID_C_CAPTION");
 	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_C_FACE,                                "WID_C_FACE");
 	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_C_FACE_TITLE,                          "WID_C_FACE_TITLE");
@@ -1073,6 +1094,7 @@
 	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_TT_LOWER_LAND,                         "WID_TT_LOWER_LAND");
 	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_TT_RAISE_LAND,                         "WID_TT_RAISE_LAND");
 	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_TT_LEVEL_LAND,                         "WID_TT_LEVEL_LAND");
+	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_TT_CLIPBOARD,                          "WID_TT_CLIPBOARD");
 	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_TT_DEMOLISH,                           "WID_TT_DEMOLISH");
 	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_TT_BUY_LAND,                           "WID_TT_BUY_LAND");
 	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_TT_PLANT_TREES,                        "WID_TT_PLANT_TREES");
diff -urNad openttd-1.3.2/src/script/api/script_airport.hpp openttd-1.3.2-DC3.0RC3/src/script/api/script_airport.hpp
--- openttd-1.3.2/src/script/api/script_airport.hpp	2013-07-27 17:09:35.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/script/api/script_airport.hpp	2013-11-22 05:49:07.000000000 +0100
@@ -35,6 +35,8 @@
 		AT_HELIPORT      = ::AT_HELIPORT,      ///< The heliport.
 		AT_HELISTATION   = ::AT_HELISTATION,   ///< The helistation.
 		AT_HELIDEPOT     = ::AT_HELIDEPOT,     ///< The helidepot.
+		AT_INTERCONTINENTAL2   = ::AT_INTERCONTINENTAL2, ///< The intercontinental 2 airport.
+		AT_CIRCLE        = ::AT_CIRCLE,        ///< The circle airport.
 		AT_INVALID       = ::AT_INVALID,       ///< Invalid airport.
 	};
 
diff -urNad openttd-1.3.2/src/script/api/script_window.hpp openttd-1.3.2-DC3.0RC3/src/script/api/script_window.hpp
--- openttd-1.3.2/src/script/api/script_window.hpp	2013-07-27 17:09:35.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/script/api/script_window.hpp	2013-11-22 05:49:07.000000000 +0100
@@ -23,6 +23,7 @@
 #include "../../widgets/bridge_widget.h"
 #include "../../widgets/build_vehicle_widget.h"
 #include "../../widgets/cheat_widget.h"
+#include "../../widgets/clipboard_widget.h"
 #include "../../widgets/company_widget.h"
 #include "../../widgets/console_widget.h"
 #include "../../widgets/date_widget.h"
@@ -969,6 +970,42 @@
 		WID_C_PANEL                                  = ::WID_C_PANEL,                                  ///< Panel where all cheats are shown in.
 	};
 
+	/* automatically generated from ../../widgets/clipboard_widget.h */
+	/** Widgets of the #ClipboardToolbarWindow class. */
+	enum ClipboardToolbarWidgets {
+		WID_CT_CLIPBOARD_1                           = ::WID_CT_CLIPBOARD_1,                           ///< Button to switch to clipboard #1
+		WID_CT_CLIPBOARD_2                           = ::WID_CT_CLIPBOARD_2,                           ///< Button to switch to clipboard #2
+		WID_CT_CLIPBOARD_3                           = ::WID_CT_CLIPBOARD_3,                           ///< Button to switch to clipboard #3
+		WID_CT_CLIPBOARD_4                           = ::WID_CT_CLIPBOARD_4,                           ///< Button to switch to clipboard #4
+
+		WID_CT_COPY                                  = ::WID_CT_COPY,                                  ///< Copy button (single player)
+		WID_CT_PASTE                                 = ::WID_CT_PASTE,                                 ///< Paste button (single player)
+
+		WID_CT_PASTE_FLAG_BUTTON_BEGIN               = ::WID_CT_PASTE_FLAG_BUTTON_BEGIN,               ///< First button to toggle copy-paste flag
+		WID_CT_WITH_RAIL                             = ::WID_CT_WITH_RAIL,                             ///< Toggle rails button
+		WID_CT_WITH_ROAD                             = ::WID_CT_WITH_ROAD,                             ///< Toggle roads button
+		WID_CT_WITH_WATER                            = ::WID_CT_WITH_WATER,                            ///< Toggle water button
+		WID_CT_WITH_AIR                              = ::WID_CT_WITH_AIR,                              ///< Toggle air button
+		WID_CT_MIRROR_SIGNALS                        = ::WID_CT_MIRROR_SIGNALS,                        ///< Toggle signal mirrorig button
+		WID_CT_UPGRADE_BRIDGES                       = ::WID_CT_UPGRADE_BRIDGES,                       ///< Toggle bridge upgrading button
+		WID_CT_PASTE_FLAG_BUTTON_END                 = ::WID_CT_PASTE_FLAG_BUTTON_END,                 ///< Past-the-last button to toggle copy-paste flag
+
+		WID_CT_CONVERT_RAILTYPE                      = ::WID_CT_CONVERT_RAILTYPE,                      ///< Button to select railtype to convert to
+
+		WID_CT_TERRAFORM                             = ::WID_CT_TERRAFORM,                             ///< Button to select terraforming mode
+
+		WID_CT_TRANSFORMATION                        = ::WID_CT_TRANSFORMATION,                        ///< Button to show/reset clipboard transformation
+		WID_CT_ROTATE_LEFT                           = ::WID_CT_ROTATE_LEFT,                           ///< Rotate left button
+		WID_CT_ROTATE_RIGHT                          = ::WID_CT_ROTATE_RIGHT,                          ///< Rotate right button
+		WID_CT_REFLECT_NE_SW                         = ::WID_CT_REFLECT_NE_SW,                         ///< Reflect against NE-SW axis button
+		WID_CT_REFLECT_NW_SE                         = ::WID_CT_REFLECT_NW_SE,                         ///< Reflect against NW-SE axis button
+
+		WID_CT_HEIGHT_DIFF_GLYPH                     = ::WID_CT_HEIGHT_DIFF_GLYPH,                     ///< Image in front of buttons to increase/decrease height level
+		WID_CT_HEIGHT_DIFF                           = ::WID_CT_HEIGHT_DIFF,                           ///< Panel with buttons to increase/decrease height level
+		WID_CT_HEIGHT_DIFF_INCREASE                  = ::WID_CT_HEIGHT_DIFF_INCREASE,                  ///< Button to increase height level
+		WID_CT_HEIGHT_DIFF_DECREASE                  = ::WID_CT_HEIGHT_DIFF_DECREASE,                  ///< Button to decrease height level
+	};
+
 	/* automatically generated from ../../widgets/company_widget.h */
 	/** Widgets of the #CompanyWindow class. */
 	enum CompanyWidgets {
@@ -2228,6 +2265,7 @@
 		WID_TT_LOWER_LAND                            = ::WID_TT_LOWER_LAND,                            ///< Lower land button.
 		WID_TT_RAISE_LAND                            = ::WID_TT_RAISE_LAND,                            ///< Raise land button.
 		WID_TT_LEVEL_LAND                            = ::WID_TT_LEVEL_LAND,                            ///< Level land button.
+		WID_TT_CLIPBOARD                             = ::WID_TT_CLIPBOARD,                             ///< Button to open the clipboard toolbar
 		WID_TT_DEMOLISH                              = ::WID_TT_DEMOLISH,                              ///< Demolish aka dynamite button.
 		WID_TT_BUY_LAND                              = ::WID_TT_BUY_LAND,                              ///< Buy land button.
 		WID_TT_PLANT_TREES                           = ::WID_TT_PLANT_TREES,                           ///< Plant trees button (note: opens separate window, no place-push-button).
diff -urNad openttd-1.3.2/src/script/api/template/template_window.hpp.sq openttd-1.3.2-DC3.0RC3/src/script/api/template/template_window.hpp.sq
--- openttd-1.3.2/src/script/api/template/template_window.hpp.sq	2013-07-27 17:09:35.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/script/api/template/template_window.hpp.sq	2013-11-22 05:49:07.000000000 +0100
@@ -47,6 +47,8 @@
 	template <> inline int Return<ScriptWindow::BuildVehicleWidgets>(HSQUIRRELVM vm, ScriptWindow::BuildVehicleWidgets res) { sq_pushinteger(vm, (int32)res); return 1; }
 	template <> inline ScriptWindow::CheatWidgets GetParam(ForceType<ScriptWindow::CheatWidgets>, HSQUIRRELVM vm, int index, SQAutoFreePointers *ptr) { SQInteger tmp; sq_getinteger(vm, index, &tmp); return (ScriptWindow::CheatWidgets)tmp; }
 	template <> inline int Return<ScriptWindow::CheatWidgets>(HSQUIRRELVM vm, ScriptWindow::CheatWidgets res) { sq_pushinteger(vm, (int32)res); return 1; }
+	template <> inline ScriptWindow::ClipboardToolbarWidgets GetParam(ForceType<ScriptWindow::ClipboardToolbarWidgets>, HSQUIRRELVM vm, int index, SQAutoFreePointers *ptr) { SQInteger tmp; sq_getinteger(vm, index, &tmp); return (ScriptWindow::ClipboardToolbarWidgets)tmp; }
+	template <> inline int Return<ScriptWindow::ClipboardToolbarWidgets>(HSQUIRRELVM vm, ScriptWindow::ClipboardToolbarWidgets res) { sq_pushinteger(vm, (int32)res); return 1; }
 	template <> inline ScriptWindow::CompanyWidgets GetParam(ForceType<ScriptWindow::CompanyWidgets>, HSQUIRRELVM vm, int index, SQAutoFreePointers *ptr) { SQInteger tmp; sq_getinteger(vm, index, &tmp); return (ScriptWindow::CompanyWidgets)tmp; }
 	template <> inline int Return<ScriptWindow::CompanyWidgets>(HSQUIRRELVM vm, ScriptWindow::CompanyWidgets res) { sq_pushinteger(vm, (int32)res); return 1; }
 	template <> inline ScriptWindow::CompanyFinancesWidgets GetParam(ForceType<ScriptWindow::CompanyFinancesWidgets>, HSQUIRRELVM vm, int index, SQAutoFreePointers *ptr) { SQInteger tmp; sq_getinteger(vm, index, &tmp); return (ScriptWindow::CompanyFinancesWidgets)tmp; }
diff -urNad openttd-1.3.2/src/settings.cpp openttd-1.3.2-DC3.0RC3/src/settings.cpp
--- openttd-1.3.2/src/settings.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/settings.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -54,6 +54,7 @@
 #include "base_media_base.h"
 #include "gamelog.h"
 #include "settings_func.h"
+#include "economy_func.h"
 #include "ini_type.h"
 #include "ai/ai_config.hpp"
 #include "ai/ai.hpp"
@@ -64,9 +65,13 @@
 #include "roadveh.h"
 #include "fios.h"
 #include "strings_func.h"
+#include "industry.h"
+#include "cargodest_func.h"
+#include "trafficlight_func.h"
 
 #include "void_map.h"
 #include "station_base.h"
+#include "infrastructure_func.h"
 
 #include "table/strings.h"
 #include "table/settings.h"
@@ -760,6 +765,20 @@
 
 /* Begin - Callback Functions for the various settings. */
 
+static bool AfterChangeOfMaxHeightlevel(int32 p1)
+{
+	for (uint x = 0; x < MapMaxX(); x++) {
+		for (uint y = 0; y < MapMaxY(); y++) {
+			TileIndex tile = TileXY(x, y);
+			if ((int32)TileHeight(tile) > p1) {
+				ShowErrorMessage(STR_CONFIG_SETTING_TOO_HIGH_MOUNTAIN, INVALID_STRING_ID, WL_ERROR);
+				return false;
+			}
+		}
+	}
+	return true;
+}
+
 /** Reposition the main toolbar as the setting changed. */
 static bool v_PositionMainToolbar(int32 p1)
 {
@@ -803,12 +822,40 @@
 	return true;
 }
 
+/**
+ * Check, if we dont have bigger balance factor than day length factor.
+ */
+static bool CheckDayLengthBalance(int32 p1)
+{
+	EconomySettings *es;
+
+	if (_game_mode == GM_MENU) {
+		es = &_settings_newgame.economy;
+	} else {
+		es = &_settings_game.economy;
+	}
+
+	if (es->day_length_factor < es->day_length_balance_factor) {
+		es->day_length_balance_factor = es->day_length_factor;
+	}
+
+	return true;
+}
+
+static bool InvalidateIndustryWindow(int32 p1)
+{
+	InvalidateWindowData(WC_INDUSTRY_DIRECTORY, 0, 1);
+	return true;
+}
+
 static bool InvalidateDetailsWindow(int32 p1)
 {
 	SetWindowClassesDirty(WC_VEHICLE_DETAILS);
 	return true;
 }
 
+
+
 static bool StationSpreadChanged(int32 p1)
 {
 	InvalidateWindowData(WC_SELECT_STATION, 0);
@@ -1033,6 +1080,27 @@
 	return true;
 }
 
+/**
+ * Updates everything affected by day length.
+ */
+static bool UpdateAllCosts(int32 p1)
+{
+	if (_game_mode != GM_MENU) {
+		InvalidateIndustryWindow(p1);
+
+		SetWindowClassesDirty(WC_BUILD_VEHICLE);
+		SetWindowClassesDirty(WC_REPLACE_VEHICLE);
+
+		InvalidateBuildIndustryWindow(p1);
+		InvalidateDetailsWindow(p1);
+	}
+
+	InitializeGraphPerformance();
+	CheckDayLengthBalance(p1);
+
+	return true;
+}
+
 static bool InvalidateVehTimetableWindow(int32 p1)
 {
 	InvalidateWindowClassesData(WC_VEHICLE_TIMETABLE, VIWD_MODIFY_ORDERS);
@@ -1170,6 +1238,21 @@
 	return LookupOneOfMany("normal|hilly|desert|candy", value);
 }
 
+/**
+ * What to do when traffic light Setting was changed.
+ * @param p1 unused
+ * @return always 0
+ */
+static bool TLSettingChanged(int32 p1)
+{
+	/* Road building gui changed. */
+	MarkWholeScreenDirty();
+
+	/* If traffic lights got disabled, clear them all. */
+	if (!_settings_game.construction.traffic_lights) ClearAllTrafficLights();
+	return true;
+}
+
 static bool CheckFreeformEdges(int32 p1)
 {
 	if (_game_mode == GM_MENU) return true;
@@ -1253,6 +1336,64 @@
 	return true;
 }
 
+bool CargodestModeChanged(int32 p1)
+{
+	/* Clear route links and destinations for cargoes that aren't routed anymore. */
+	Station *st;
+	FOR_ALL_STATIONS(st) {
+		for (CargoID cid = 0; cid < NUM_CARGO; cid++) {
+			if (CargoHasDestinations(cid)) continue;
+
+			/* Clear route links. */
+			for (RouteLinkList::iterator i = st->goods[cid].routes.begin(); i != st->goods[cid].routes.end(); ++i) {
+				delete *i;
+			}
+			st->goods[cid].routes.clear();
+
+			/* Remove destinations from cargo packets. */
+			for (StationCargoList::Iterator i = st->goods[cid].cargo.packets.begin(); i != st->goods[cid].cargo.packets.end(); ++i) {
+				(*i)->dest_id = INVALID_SOURCE;
+				(*i)->next_order = INVALID_ORDER;
+				(*i)->next_station = INVALID_STATION;
+			}
+			st->goods[cid].cargo.InvalidateCache();
+		}
+	}
+
+	Vehicle *v;
+	FOR_ALL_VEHICLES(v) {
+		if (v->IsFrontEngine()) PrefillRouteLinks(v);
+		if (CargoHasDestinations(v->cargo_type)) continue;
+		/* Remove destination from all cargoes that aren't routed anymore. */
+		for (VehicleCargoList::Iterator i = v->cargo.packets.begin(); i != v->cargo.packets.end(); ++i) {
+			(*i)->dest_id = INVALID_SOURCE;
+			(*i)->next_order = INVALID_ORDER;
+			(*i)->next_station = INVALID_STATION;
+		}
+		v->cargo.InvalidateCache();
+	}
+
+	/* Clear all links for cargoes that aren't routed anymore. */
+	CargoSourceSink *css;
+	FOR_ALL_TOWNS(css) {
+		for (CargoID cid = 0; cid < NUM_CARGO; cid++) {
+			if (!CargoHasDestinations(cid)) css->cargo_links[cid].Clear();
+		}
+	}
+	FOR_ALL_INDUSTRIES(css) {
+		for (CargoID cid = 0; cid < NUM_CARGO; cid++) {
+			if (!CargoHasDestinations(cid)) css->cargo_links[cid].Clear();
+		}
+	}
+
+	/* Recount incoming cargo links. */
+	RebuildCargoLinkCounts();
+
+	/* Update remaining links. */
+	UpdateCargoLinks();
+
+	return true;
+}
 
 #ifdef ENABLE_NETWORK
 
@@ -1289,6 +1430,27 @@
 
 #endif /* ENABLE_NETWORK */
 
+static bool CheckSharingRail(int32 p1)
+{
+	if (!CheckSharingChangePossible(VEH_TRAIN)) return false;
+	UpdateAllBlockSignals();
+	return true;
+}
+ 
+static bool CheckSharingRoad(int32 p1)
+{
+	return CheckSharingChangePossible(VEH_ROAD);
+}
+
+static bool CheckSharingWater(int32 p1)
+{
+	return CheckSharingChangePossible(VEH_SHIP);
+}
+
+static bool CheckSharingAir(int32 p1)
+{
+	return CheckSharingChangePossible(VEH_AIRCRAFT);
+}
 
 /* End - Callback Functions */
 
diff -urNad openttd-1.3.2/src/settings_gui.cpp openttd-1.3.2-DC3.0RC3/src/settings_gui.cpp
--- openttd-1.3.2/src/settings_gui.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/settings_gui.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -1431,6 +1431,9 @@
 	SettingEntry("gui.zoom_min"),
 	SettingEntry("gui.zoom_max"),
 	SettingEntry("gui.graph_line_thickness"),
+	SettingEntry("gui.forecast_display"),
+        SettingEntry("gui.show_vehicle_route_stopovers"),
+        SettingEntry("gui.show_vehicle_route_path"),
 };
 /** Display options sub-page */
 static SettingsPage _settings_ui_display_page = {_settings_ui_display, lengthof(_settings_ui_display)};
@@ -1459,44 +1462,68 @@
 static SettingsPage _settings_ui_interaction_page = {_settings_ui_interaction, lengthof(_settings_ui_interaction)};
 
 static SettingEntry _settings_ui_sound[] = {
-	SettingEntry("sound.click_beep"),
-	SettingEntry("sound.confirm"),
-	SettingEntry("sound.news_ticker"),
-	SettingEntry("sound.news_full"),
-	SettingEntry("sound.new_year"),
-	SettingEntry("sound.disaster"),
-	SettingEntry("sound.vehicle"),
-	SettingEntry("sound.ambient"),
+       SettingEntry("sound.click_beep"),
+       SettingEntry("sound.confirm"),
+       SettingEntry("sound.news_ticker"),
+       SettingEntry("sound.news_full"),
+       SettingEntry("sound.new_year"),
+       SettingEntry("sound.disaster"),
+       SettingEntry("sound.vehicle"),
+       SettingEntry("sound.ambient"),
+       SettingEntry("sound.cashtill"),
 };
 /** Sound effects sub-page */
 static SettingsPage _settings_ui_sound_page = {_settings_ui_sound, lengthof(_settings_ui_sound)};
 
 static SettingEntry _settings_ui_news[] = {
-	SettingEntry("news_display.arrival_player"),
-	SettingEntry("news_display.arrival_other"),
-	SettingEntry("news_display.accident"),
-	SettingEntry("news_display.company_info"),
-	SettingEntry("news_display.open"),
-	SettingEntry("news_display.close"),
-	SettingEntry("news_display.economy"),
-	SettingEntry("news_display.production_player"),
-	SettingEntry("news_display.production_other"),
-	SettingEntry("news_display.production_nobody"),
-	SettingEntry("news_display.advice"),
-	SettingEntry("news_display.new_vehicles"),
-	SettingEntry("news_display.acceptance"),
-	SettingEntry("news_display.subsidies"),
-	SettingEntry("news_display.general"),
-	SettingEntry("gui.coloured_news_year"),
+       SettingEntry("news_display.arrival_player"),
+       SettingEntry("news_display.arrival_other"),
+       SettingEntry("news_display.accident"),
+       SettingEntry("news_display.company_info"),
+       SettingEntry("news_display.open"),
+       SettingEntry("news_display.close"),
+       SettingEntry("news_display.economy"),
+       SettingEntry("news_display.production_player"),
+       SettingEntry("news_display.production_other"),
+       SettingEntry("news_display.production_nobody"),
+       SettingEntry("news_display.advice"),
+       SettingEntry("news_display.new_vehicles"),
+       SettingEntry("news_display.acceptance"),
+       SettingEntry("news_display.subsidies"),
+       SettingEntry("news_display.general"),
+       SettingEntry("gui.coloured_news_year"),
 };
 /** News sub-page */
 static SettingsPage _settings_ui_news_page = {_settings_ui_news, lengthof(_settings_ui_news)};
 
+
+static SettingEntry _settings_ui_departureboards[] = {
+	SettingEntry("gui.max_departures"),
+	SettingEntry("gui.max_departure_time"),
+	SettingEntry("gui.departure_calc_frequency"),
+	SettingEntry("gui.departure_show_vehicle"),
+	SettingEntry("gui.departure_show_group"),
+	SettingEntry("gui.departure_show_company"),
+	SettingEntry("gui.departure_show_vehicle_type"),
+	SettingEntry("gui.departure_show_vehicle_color"),
+	SettingEntry("gui.departure_larger_font"),
+	SettingEntry("gui.departure_destination_type"),
+	SettingEntry("gui.departure_show_both"),
+	SettingEntry("gui.departure_only_passengers"),
+	SettingEntry("gui.departure_smart_terminus"),
+	SettingEntry("gui.departure_conditionals"),
+	SettingEntry("gui.departure_show_all_stops"),
+	SettingEntry("gui.departure_merge_identical"),
+};
+/** Departureboards sub-page */
+static SettingsPage _settings_ui_departureboards_page = {_settings_ui_departureboards, lengthof(_settings_ui_departureboards)};
+
 static SettingEntry _settings_ui[] = {
 	SettingEntry(&_settings_ui_display_page, STR_CONFIG_SETTING_DISPLAY_OPTIONS),
 	SettingEntry(&_settings_ui_interaction_page, STR_CONFIG_SETTING_INTERACTION),
 	SettingEntry(&_settings_ui_sound_page, STR_CONFIG_SETTING_SOUND),
 	SettingEntry(&_settings_ui_news_page, STR_CONFIG_SETTING_NEWS),
+	SettingEntry(&_settings_ui_departureboards_page, STR_CONFIG_SETTING_DEPARTUREBOARDS),
 	SettingEntry("gui.show_finances"),
 	SettingEntry("gui.errmsg_duration"),
 	SettingEntry("gui.hover_delay"),
@@ -1506,6 +1533,11 @@
 	SettingEntry("gui.pause_on_newgame"),
 	SettingEntry("gui.advanced_vehicle_list"),
 	SettingEntry("gui.timetable_in_ticks"),
+	SettingEntry("gui.time_in_minutes"),
+	SettingEntry("gui.timetable_start_text_entry"),
+	SettingEntry("gui.ticks_per_minute"),
+	SettingEntry("gui.date_with_time"),
+	SettingEntry("gui.clock_offset"),
 	SettingEntry("gui.timetable_arrival_departure"),
 	SettingEntry("gui.quick_goto"),
 	SettingEntry("gui.default_rail_type"),
@@ -1526,17 +1558,37 @@
 /** Signals subpage */
 static SettingsPage _settings_construction_signals_page = {_settings_construction_signals, lengthof(_settings_construction_signals)};
 
+static SettingEntry _settings_construction_trafficlights[] = {
+	SettingEntry("construction.traffic_lights"),
+	SettingEntry("construction.towns_build_traffic_lights"),
+	SettingEntry("construction.allow_building_tls_in_towns"),
+	SettingEntry("construction.traffic_lights_green_phase"),
+	SettingEntry("construction.max_tlc_size"),
+	SettingEntry("construction.max_tlc_distance"),
+};
+
+/** Traffic lights subpage */
+static SettingsPage _settings_construction_trafficlights_page = {_settings_construction_trafficlights, lengthof(_settings_construction_trafficlights)};
+
 static SettingEntry _settings_construction[] = {
 	SettingEntry(&_settings_construction_signals_page, STR_CONFIG_SETTING_CONSTRUCTION_SIGNALS),
+	SettingEntry(&_settings_construction_trafficlights_page, STR_CONFIG_SETTING_CONSTRUCTION_TRAFFIC_LIGHTS),
+        SettingEntry("construction.max_heightlevel"),
 	SettingEntry("construction.build_on_slopes"),
 	SettingEntry("construction.autoslope"),
+	SettingEntry("construction.enable_land_buying"),
+	SettingEntry("construction.enable_restrictive_land_buying"),
+	SettingEntry("construction.drag_drop_land_buying_limit"),
 	SettingEntry("construction.extra_dynamite"),
 	SettingEntry("construction.max_bridge_length"),
 	SettingEntry("construction.max_tunnel_length"),
 	SettingEntry("station.never_expire_airports"),
 	SettingEntry("construction.freeform_edges"),
+	SettingEntry("construction.snow_in_temperate"),
 	SettingEntry("construction.extra_tree_placement"),
+        SettingEntry("construction.tree_growth_rate"),
 	SettingEntry("construction.command_pause_level"),
+	SettingEntry("construction.clipboard_capacity"),
 };
 /** Construction sub-page */
 static SettingsPage _settings_construction_page = {_settings_construction, lengthof(_settings_construction)};
@@ -1558,6 +1610,7 @@
 	SettingEntry("station.modified_catchment"),
 	SettingEntry("construction.road_stop_on_town_road"),
 	SettingEntry("construction.road_stop_on_competitor_road"),
+	SettingEntry("station.advanced_control"),
 };
 /** Stations sub-page */
 static SettingsPage _settings_stations_page = {_settings_stations, lengthof(_settings_stations)};
@@ -1576,6 +1629,8 @@
 	SettingEntry("economy.town_growth_rate"),
 	SettingEntry("economy.larger_towns"),
 	SettingEntry("economy.initial_city_size"),
+	SettingEntry("economy.town_construction_cost"),
+	SettingEntry("economy.random_road_construction"),
 };
 /** Towns sub-page */
 static SettingsPage _settings_economy_towns_page = {_settings_economy_towns, lengthof(_settings_economy_towns)};
@@ -1590,17 +1645,38 @@
 static SettingsPage _settings_economy_industries_page = {_settings_economy_industries, lengthof(_settings_economy_industries)};
 
 
+static SettingEntry _settings_economy_day_length[] = {
+	SettingEntry("economy.day_length_factor"),
+	SettingEntry("economy.slow_down_production"),
+	SettingEntry("economy.town_cargo_factor"),
+	SettingEntry("economy.day_length_balance_type"),
+	SettingEntry("economy.day_length_balance_factor"),
+	SettingEntry("economy.include_prop_main_to_run"),
+	SettingEntry("economy.include_loan_int_to_run"),
+	SettingEntry("economy.slow_down_veh_rel_drop_down"),
+	SettingEntry("economy.slow_down_town_growth"),
+//	SettingEntry("economy.show_orig_productions"),
+};
+/** Day length sub-page */
+static SettingsPage _settings_economy_day_length_page = {_settings_economy_day_length, lengthof(_settings_economy_day_length)};
+
 static SettingEntry _settings_economy[] = {
 	SettingEntry(&_settings_economy_towns_page, STR_CONFIG_SETTING_ECONOMY_TOWNS),
 	SettingEntry(&_settings_economy_industries_page, STR_CONFIG_SETTING_ECONOMY_INDUSTRIES),
+	SettingEntry(&_settings_economy_day_length_page, STR_CONFIG_SETTING_ECONOMY_DAY_LENGTH),
 	SettingEntry("economy.inflation"),
 	SettingEntry("difficulty.initial_interest"),
 	SettingEntry("difficulty.max_loan"),
 	SettingEntry("difficulty.subsidy_multiplier"),
 	SettingEntry("difficulty.economy"),
+	SettingEntry("economy.lost_cargo"),
+	SettingEntry("economy.yearly_tax"),
 	SettingEntry("economy.smooth_economy"),
 	SettingEntry("economy.feeder_payment_share"),
 	SettingEntry("economy.infrastructure_maintenance"),
+	SettingEntry("economy.cargodest.mode_pax_mail"),
+	SettingEntry("economy.cargodest.mode_town_cargo"),
+	SettingEntry("economy.cargodest.mode_others"),
 	SettingEntry("difficulty.vehicle_costs"),
 	SettingEntry("difficulty.construction_cost"),
 	SettingEntry("difficulty.disasters"),
@@ -1621,8 +1697,23 @@
 /** Computer players sub-page */
 static SettingsPage _settings_ai_npc_page = {_settings_ai_npc, lengthof(_settings_ai_npc)};
 
+static SettingEntry _settings_sharing[] = {
+	SettingEntry("economy.infrastructure_sharing[0]"),
+	SettingEntry("economy.infrastructure_sharing[1]"),
+	SettingEntry("economy.infrastructure_sharing[2]"),
+	SettingEntry("economy.infrastructure_sharing[3]"),
+	SettingEntry("economy.sharing_fee[0]"),
+	SettingEntry("economy.sharing_fee[1]"),
+	SettingEntry("economy.sharing_fee[2]"),
+	SettingEntry("economy.sharing_fee[3]"),
+	SettingEntry("economy.sharing_payment_in_debt"),
+};
+/** Infrastructure sharing sub-page */
+static SettingsPage _settings_sharing_page = {_settings_sharing, lengthof(_settings_sharing)};
+
 static SettingEntry _settings_ai[] = {
 	SettingEntry(&_settings_ai_npc_page, STR_CONFIG_SETTING_AI_NPC),
+	SettingEntry(&_settings_sharing_page, STR_CONFIG_SETTING_SHARING),
 	SettingEntry("economy.give_money"),
 	SettingEntry("economy.allow_shares"),
 };
@@ -1674,11 +1765,28 @@
 /** Trains sub-page */
 static SettingsPage _settings_vehicles_trains_page = {_settings_vehicles_trains, lengthof(_settings_vehicles_trains)};
 
+static SettingEntry _settings_vehicles_speedlimit[] = {
+       SettingEntry("vehicle.limit_vehicle_speed_in_towns"),
+       SettingEntry("vehicle.max_veh_speed_in_towns_two_way"),
+       SettingEntry("vehicle.max_veh_speed_in_towns_one_way"),
+       SettingEntry("vehicle.limit_vehicle_speed_outside_towns"),
+       SettingEntry("vehicle.max_veh_speed_out_towns_two_way"),
+       SettingEntry("vehicle.max_veh_speed_out_towns_one_way"),
+//       SettingEntry("vehicle.limit_vehicle_speed_tunnel_bridge"),
+//       SettingEntry("vehicle.max_veh_speed_tunnel_bridge"),
+       SettingEntry("vehicle.limit_vehicle_speed_in_curves"),
+};
+
+/** Speed limits subpage */
+static SettingsPage _settings_vehicles_speedlimit_page = {_settings_vehicles_speedlimit, lengthof(_settings_vehicles_speedlimit)};
+
 static SettingEntry _settings_vehicles[] = {
 	SettingEntry(&_settings_vehicles_routing_page, STR_CONFIG_SETTING_VEHICLES_ROUTING),
 	SettingEntry(&_settings_vehicles_autorenew_page, STR_CONFIG_SETTING_VEHICLES_AUTORENEW),
 	SettingEntry(&_settings_vehicles_servicing_page, STR_CONFIG_SETTING_VEHICLES_SERVICING),
 	SettingEntry(&_settings_vehicles_trains_page, STR_CONFIG_SETTING_VEHICLES_TRAINS),
+        SettingEntry(&_settings_vehicles_speedlimit_page, STR_CONFIG_SETTING_VEHICLES_SPEEDLIMIT),
+	SettingEntry("gui.specific_group_name"),
 	SettingEntry("gui.new_nonstop"),
 	SettingEntry("gui.order_review_system"),
 	SettingEntry("gui.vehicle_income_warn"),
@@ -1690,11 +1798,15 @@
 	SettingEntry("vehicle.max_ships"),
 	SettingEntry("vehicle.plane_speed"),
 	SettingEntry("vehicle.plane_crashes"),
+	SettingEntry("order.automatic_timetable_separation"),
 	SettingEntry("vehicle.dynamic_engines"),
 	SettingEntry("vehicle.roadveh_acceleration_model"),
 	SettingEntry("vehicle.roadveh_slope_steepness"),
 	SettingEntry("vehicle.smoke_amount"),
+	SettingEntry("vehicle.repair_cost"),
 };
+
+
 /** Vehicles sub-page */
 static SettingsPage _settings_vehicles_page = {_settings_vehicles, lengthof(_settings_vehicles)};
 
diff -urNad openttd-1.3.2/src/settings_type.h openttd-1.3.2-DC3.0RC3/src/settings_type.h
--- openttd-1.3.2/src/settings_type.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/settings_type.h	2013-11-22 05:49:07.000000000 +0100
@@ -76,6 +76,7 @@
 	uint8  order_review_system;              ///< perform order reviews on vehicles
 	bool   vehicle_income_warn;              ///< if a vehicle isn't generating income, show a warning
 	bool   show_finances;                    ///< show finances at end of year
+	uint8  specific_group_name;              ///< use station or town names for specific group names
 	bool   sg_new_nonstop;                   ///< ttdpatch compatible nonstop handling read from pre v93 savegames
 	bool   new_nonstop;                      ///< ttdpatch compatible nonstop handling
 	uint8  stop_location;                    ///< what is the default stop location of trains?
@@ -106,15 +107,39 @@
 	uint8  date_format_in_default_names;     ///< should the default savegame/screenshot name use long dates (31th Dec 2008), short dates (31-12-2008) or ISO dates (2008-12-31)
 	byte   max_num_autosaves;                ///< controls how many autosavegames are made before the game starts to overwrite (names them 0 to max_num_autosaves - 1)
 	bool   population_in_label;              ///< show the population of a town in his label?
+	bool   forecast_display;                 ///< show the supply and demand forecasting on station building
 	uint8  right_mouse_btn_emulation;        ///< should we emulate right mouse clicking?
 	uint8  scrollwheel_scrolling;            ///< scrolling using the scroll wheel?
 	uint8  scrollwheel_multiplier;           ///< how much 'wheel' per incoming event from the OS?
+	bool   show_vehicle_route_stopovers;     ///< when a window related to a specific vehicle is focused, show the stopovers on map
+	uint32 show_vehicle_route_path;          ///< show a vehicle's path when its orders/timetable window is focused
 	bool   timetable_arrival_departure;      ///< show arrivals and departures in vehicle timetables
+	uint8  max_departures;                   ///< maximum number of departures to show per station
+	uint16 max_departure_time;               ///< maximum time in advance to show departures
+	uint16 departure_calc_frequency;         ///< how often to calculate departures (in ticks)
+	bool   departure_show_vehicle;           ///< whether to show vehicle names with departures
+	bool   departure_show_group;             ///< whether to show group names with departures
+	bool   departure_show_company;           ///< whether to show company names with departures
+	bool   departure_show_vehicle_type;      ///< whether to show vehicle type icons with departures
+	bool   departure_show_vehicle_color;     ///< whether to show vehicle type icons in silver instead of orange
+	bool   departure_larger_font;            ///< whether to show the calling at list in a larger font
+	bool   departure_destination_type;       ///< whether to show destination types for ports and airports
+	bool   departure_show_both;              ///< whether to show departure and arrival times on the same line
+	bool   departure_only_passengers;        ///< whether to only show passenger services
+	bool   departure_smart_terminus;         ///< whether to only show passenger services
+	uint8  departure_conditionals;           ///< how to handle conditional orders
+	bool   departure_show_all_stops;         ///< whether to show stops regardless of loading/unloading done at them
+	bool   departure_merge_identical;        ///< whether to merge identical departures
 	bool   left_mouse_btn_scrolling;         ///< left mouse button scroll
 	bool   pause_on_newgame;                 ///< whether to start new games paused or not
 	bool   enable_signal_gui;                ///< show the signal GUI when the signal button is pressed
 	Year   coloured_news_year;               ///< when does newspaper become coloured?
 	bool   timetable_in_ticks;               ///< whether to show the timetable in ticks rather than days
+	bool   time_in_minutes;                  ///< whether to use the hh:mm conversion when printing dates
+	bool   timetable_start_text_entry;       ///< whether to enter timetable start times as text (hhmm format)
+	uint8  ticks_per_minute;                 ///< how many ticks per minute
+	uint8  date_with_time;                   ///< whether to show the month and year with the time
+	uint16 clock_offset;                     ///< clock offset in minutes
 	bool   quick_goto;                       ///< Allow quick access to 'goto button' in vehicle orders window
 	bool   auto_euro;                        ///< automatically switch to euro in 2002
 	byte   drag_signals_density;             ///< many signals density
@@ -172,6 +197,7 @@
 	bool   disaster;                         ///< Play disaster and accident sounds.
 	bool   vehicle;                          ///< Play vehicle sound effects.
 	bool   ambient;                          ///< Play ambient, industry and town sounds.
+	bool   cashtill;                          ///< Play ambient, industry and town sounds.
 };
 
 /** Settings related to music. */
@@ -267,8 +293,8 @@
 	uint8  map_y;                            ///< Y size of map
 	byte   land_generator;                   ///< the landscape generator
 	byte   oil_refinery_limit;               ///< distance oil refineries allowed from map edge
-	byte   snow_line_height;                 ///< a number 0-15 that configured snow line height
-	byte   tgen_smoothness;                  ///< how rough is the terrain from 0-3
+	byte   snow_line_height;                 ///< a number 0-255 that configured snow line height
+	byte   tgen_smoothness;                  ///< how rough is the terrain from 0-6
 	byte   tree_placer;                      ///< the tree placer algorithm
 	byte   heightmap_rotation;               ///< rotation director for the heightmap
 	byte   se_flat_world_height;             ///< land height a flat world gets in SE
@@ -285,8 +311,12 @@
 
 /** Settings related to construction in-game */
 struct ConstructionSettings {
+	uint8  max_heightlevel;                  ///< maximal allowed heightlevel
 	bool   build_on_slopes;                  ///< allow building on slopes
 	bool   autoslope;                        ///< allow terraforming under things
+	bool   enable_land_buying;               ///< allow any land buying.
+	bool   enable_restrictive_land_buying;   ///< enable restriction on drag and drop land buying.
+	uint8  drag_drop_land_buying_limit;      ///< allow the use of dragging and dropping to buy land.
 	uint16 max_bridge_length;                ///< maximum length of bridges
 	uint16 max_tunnel_length;                ///< maximum length of tunnels
 	byte   train_signal_side;                ///< show signals on left / driving / right side
@@ -296,8 +326,11 @@
 	uint8  raw_industry_construction;        ///< type of (raw) industry construction (none, "normal", prospecting)
 	uint8  industry_platform;                ///< the amount of flat land around an industry
 	bool   freeform_edges;                   ///< allow terraforming the tiles at the map edges
+	bool   snow_in_temperate;                ///< enable snow in temperate
 	uint8  extra_tree_placement;             ///< (dis)allow building extra trees in-game
+        uint8  tree_growth_rate;                 ///< tree growth rate
 	uint8  command_pause_level;              ///< level/amount of commands that can't be executed while paused
+	uint8  clipboard_capacity;              ///< maximum copy/paste area size (width/height)
 
 	uint32 terraform_per_64k_frames;         ///< how many tile heights may, over a long period, be terraformed per 65536 frames?
 	uint16 terraform_frame_burst;            ///< how many tile heights may, over a short period, be terraformed?
@@ -305,6 +338,13 @@
 	uint16 clear_frame_burst;                ///< how many tiles may, over a short period, be cleared?
 	uint32 tree_per_64k_frames;              ///< how many trees may, over a long period, be planted per 65536 frames?
 	uint16 tree_frame_burst;                 ///< how many trees may, over a short period, be planted?
+
+	bool traffic_lights;                     ///< Whether traffic lights are enabled.
+	bool towns_build_traffic_lights;         ///< Whether towns build traffic lights during road construction.
+	bool allow_building_tls_in_towns;        ///< Whether the players are allowed to build traffic lights on town owned roads.
+	uint8 traffic_lights_green_phase;        ///< How long traffic lights' green phase lasts.
+	uint8 max_tlc_size;                      ///< Maximum size for traffic light consists.
+	uint8 max_tlc_distance;                  ///< Maximum distance between traffic lights for synchronising them.
 };
 
 /** Settings related to the AI. */
@@ -352,6 +392,8 @@
 	uint32 npf_road_curve_penalty;           ///< the penalty for curves
 	uint32 npf_crossing_penalty;             ///< the penalty for level crossings
 	uint32 npf_road_drive_through_penalty;   ///< the penalty for going through a drive-through road stop
+	uint32 npf_road_two_way_penalty;         ///< The penalty for two-way road
+	uint32 npf_road_trafficlight_penalty;    ///< Penalty for junctions with traffic lights.
 	uint32 npf_road_dt_occupied_penalty;     ///< the penalty multiplied by the fill percentage of a drive-through road stop
 	uint32 npf_road_bay_occupied_penalty;    ///< the penalty multiplied by the fill percentage of a road bay
 };
@@ -368,6 +410,8 @@
 	uint32 road_curve_penalty;               ///< penalty for curves
 	uint32 road_crossing_penalty;            ///< penalty for level crossing
 	uint32 road_stop_penalty;                ///< penalty for going through a drive-through road stop
+	uint32 road_two_way_penalty;             ///< penalty for two way road
+	uint32 road_trafficlight_penalty;        ///< Penalty for junctions with traffic lights.	
 	uint32 road_stop_occupied_penalty;       ///< penalty multiplied by the fill percentage of a drive-through road stop
 	uint32 road_stop_bay_occupied_penalty;   ///< penalty multiplied by the fill percentage of a road bay
 	bool   rail_firstred_twoway_eol;         ///< treat first red two-way signal as dead end
@@ -394,6 +438,14 @@
 	uint32 rail_longer_platform_per_tile_penalty;  ///< penalty for longer  station platform than train (per tile)
 	uint32 rail_shorter_platform_penalty;          ///< penalty for shorter station platform than train
 	uint32 rail_shorter_platform_per_tile_penalty; ///< penalty for shorter station platform than train (per tile)
+
+	uint32 route_transfer_cost;              ///< penalty for transferring to a different vehicle
+	uint32 route_max_transfers;              ///< maximum number of allowed transfers
+	uint16 route_distance_factor;            ///< factor for the link length
+	uint16 route_travel_time_factor;         ///< factor * CYapfCostRouteLinkT::PENALTY_DIVISOR (=16) for the link travel time
+	uint16 route_station_last_veh_factor;    ///< factor * CYapfCostRouteLinkT::PENALTY_DIVISOR (=16) for the time since the last vehicle arrived at a station
+	uint16 route_station_waiting_factor;     ///< factor * CYapfCostRouteLinkT::PENALTY_DIVISOR (=16) for the waiting cargo at a station
+	byte   route_mode_cost_factor[4];        ///< vehicle type dependent factor for the link length
 };
 
 /** Settings related to all pathfinders. */
@@ -425,6 +477,7 @@
 	bool   gradual_loading;                  ///< load vehicles gradually
 	bool   selectgoods;                      ///< only send the goods to station if a train has been there
 	bool   no_servicing_if_no_breakdowns;    ///< don't send vehicles to depot when breakdowns are disabled
+	bool   automatic_timetable_separation;   ///< Enable automatic separation of vehicles in the timetable.
 	bool   serviceathelipad;                 ///< service helicopters at helipads automatically (no need to send to depot)
 };
 
@@ -448,7 +501,44 @@
 	bool   never_expire_vehicles;            ///< never expire vehicles
 	byte   extend_vehicle_life;              ///< extend vehicle life by this many years
 	byte   road_side;                        ///< the side of the road vehicles drive on
+       bool limit_vehicle_speed_in_towns;       ///< limit vehicle speed in towns
+       uint16 max_veh_speed_in_towns_two_way;   ///< max speed of vehicle in towns on two-way road
+       uint16 max_veh_speed_in_towns_one_way;   ///< max speed of vehicle in towns on one-way road
+       bool limit_vehicle_speed_outside_towns;  ///< limit vehicle speed outside towns
+       uint16 max_veh_speed_out_towns_two_way;  ///< max speed of vehicle outside towns on two-way road
+       uint16 max_veh_speed_out_towns_one_way;  ///< max speed of vehicle outside towns on one-way road
+       bool limit_vehicle_speed_tunnel_bridge;  ///< limit vehicle speed on bridge and in tunnel
+       uint16 max_veh_speed_tunnel_bridge;      ///< max speed of vehicle on bridge and in tunnel
+       bool limit_vehicle_speed_in_curves;      ///< limit vehicle speed in curves
 	uint8  plane_crashes;                    ///< number of plane crashes, 0 = none, 1 = reduced, 2 = normal
+	bool   repair_cost;
+};
+
+/** Settings related to cargo destinations. */
+struct CargodestSettings {
+	uint8  mode_pax_mail;                    ///< routing mode for cargoes with TE_PASSENGERS or TE_MAIL
+	uint8  mode_town_cargo;                  ///< routing mode for cargoes with other town effects
+	uint8  mode_others;                      ///< routing mode for all other cargoes
+	uint8  base_town_links[2];               ///< minimum number of town demand links for (0=#BASE_TOWN_LINKS) all cargoes except (1=#BASE_TOWN_LINKS_SYMM) symmetric cargoes
+	uint8  base_ind_links[3];                ///< minimum number of industry demand links for (0=#BASE_IND_LINKS) all cargoes except (1=#BASE_IND_LINKS_TOWN) town cargoes and (2=#BASE_IND_LINKS_SYMM) symmetric cargoes
+	uint8  city_town_links;                  ///< additional number of links for cities
+	uint8  town_chances_town[4];             ///< chances a link from a town to a town has a specific destination class (@see FindTownDestination)
+	uint8  town_chances_city[4];             ///< chances a link from a city to a town has a specific destination class (@see FindTownDestination)
+	uint8  ind_chances[3];                   ///< chances a link to an industry has a specific destination class (@see FindIndustryDestination)
+	uint8  random_dest_chance;               ///< percentage for traffic with random destination
+	uint32 big_town_pop[2];                  ///< (0=#BIG_TOWN_POP_MAIL) mail, (1=#BIG_TOWN_POP_PAX) passenger amount to count as a big town
+	uint16 pop_scale_town[4];                ///< population/cargo amount scale divisor for (0=#SCALE_TOWN) all cargoes (1=#SCALE_TOWN_BIG) for big towns except (2=#SCALE_TOWN_PAX) passengers (3=#SCALE_TOWN_BIG_PAX) for big towns
+	uint16 cargo_scale_ind[2];               ///< cargo amount scale divisor for (0=#CARGO_SCALE_IND) all cargoes except (1=#CARGO_SCALE_IND_TOWN) town cargoes
+	uint16 min_weight_town[2];               ///< minimum link weight for (0=MIN_WEIGHT_TOWN) all cargoes except (1=MIN_WEIGHT_TOWN_PAX) passengers
+	uint16 min_weight_ind;                   ///< minimum link weight for industry links
+	uint16 weight_scale_town[4];             ///< weight scale divisor for (0=#SCALE_TOWN) all cargoes (1=#SCALE_TOWN_BIG) for big towns except (2=#SCALE_TOWN_PAX) passengers (3=#SCALE_TOWN_BIG_PAX) for big towns
+	uint16 weight_scale_ind[2];              ///< weight scale divisor for (0=#WEIGHT_SCALE_IND_PROD) produced cargo (1=#WEIGHT_SCALE_IND_PILE) stockpiled cargo
+	uint32 town_nearby_dist;                 ///< squared distance (on a 256x256 map) inside which a town is considered nearby
+	uint32 ind_nearby_dist;                  ///< squared distance (on a 256x256 map) inside which an industry is considered nearby
+	uint16 max_route_age;                    ///< maximum days since the last vehicle traveled a link until link expiration
+	uint16 route_recalc_delay;               ///< delay in ticks between recalculating the next hop of cargo packets
+	uint16 route_recalc_chunk;               ///< maximum amount of cargo packets to recalculate in one step
+	uint16 max_route_penalty[2];             ///< maximum penalty factor based on distance, (1) base value, (2) random additional span
 };
 
 /** Settings related to the economy. */
@@ -464,6 +554,7 @@
 	bool   fund_roads;                       ///< allow funding local road reconstruction
 	bool   give_money;                       ///< allow giving other companies money
 	bool   mod_road_rebuild;                 ///< roadworks remove unnecessary RoadBits
+    bool   town_construction_cost;           ///< Increase construction costs the closer you get to a town/city center
 	bool   multiple_industry_per_town;       ///< allow many industries of the same type per town
 	uint8  town_growth_rate;                 ///< town growth rate
 	uint8  larger_towns;                     ///< the number of cities to build. These start off larger and grow twice as fast
@@ -473,8 +564,25 @@
 	TownFoundingByte found_town;             ///< town founding, @see TownFounding
 	bool   station_noise_level;              ///< build new airports when the town noise level is still within accepted limits
 	uint16 town_noise_population[3];         ///< population to base decision on noise evaluation (@see town_council_tolerance)
+	bool   infrastructure_sharing[4];        ///< enable infrastructure sharing for rail/road/water/air
+	uint   sharing_fee[4];                   ///< fees for infrastructure sharing for rail/road/water/air
+	bool   sharing_payment_in_debt;          ///< allow fee payment for companies with more loan than money (switch off to prevent MP exploits)
+	uint8 random_road_construction;          ///< Chance for towns to start random road construction
 	bool   allow_town_level_crossings;       ///< towns are allowed to build level crossings
+	int8   town_cargo_factor;                ///< power-of-two multiplier for town (passenger, mail) generation. May be negative.
+	bool   lost_cargo;                       ///< lost cargo generates lost money
 	bool   infrastructure_maintenance;       ///< enable monthly maintenance fee for owner infrastructure
+       uint8  day_length_factor;                ///< factor which the day length is multiplied (74 default ticks * setting)
+       uint8  day_length_balance_type;          ///< way of balancing day length
+       uint8  day_length_balance_factor;        ///< factor which parts of economy is modified
+       bool   include_prop_main_to_run;         ///< property maintenance will be multiplied with balance type running costs, not just all costs
+       bool   include_loan_int_to_run;          ///< loan interests will be multiplied with balance type running costs, not just all costs
+       bool   slow_down_veh_rel_drop_down;      ///< vehicles reliability will drop down per game year same apart day length
+       bool   slow_down_town_growth;            ///< towns will grow the same per each game year apart day length
+       bool   slow_down_production;             ///< towns will grow the same per each game year apart day length
+       bool   show_orig_productions;            ///< industry will show original production
+	bool   yearly_tax;                       ///< Whether to be taxes for companies
+	CargodestSettings cargodest;             ///< settings related to cargo destinations
 };
 
 /** Settings related to stations. */
@@ -484,6 +592,7 @@
 	bool   distant_join_stations;            ///< allow to join non-adjacent stations
 	bool   never_expire_airports;            ///< never expire airports
 	byte   station_spread;                   ///< amount a station may spread
+	bool   advanced_control;
 };
 
 /** Default settings for vehicles. */
diff -urNad openttd-1.3.2/src/ship_cmd.cpp openttd-1.3.2-DC3.0RC3/src/ship_cmd.cpp
--- openttd-1.3.2/src/ship_cmd.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/ship_cmd.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -31,6 +31,8 @@
 #include "pathfinder/opf/opf_ship.h"
 #include "engine_base.h"
 #include "company_base.h"
+#include "infrastructure_func.h"
+#include "cargotype.h"
 #include "tunnelbridge_map.h"
 #include "zoom_func.h"
 
@@ -132,7 +134,7 @@
 
 	FOR_ALL_DEPOTS(depot) {
 		TileIndex tile = depot->xy;
-		if (IsShipDepotTile(tile) && IsTileOwner(tile, v->owner)) {
+		if (IsShipDepotTile(tile) && IsInfraTileUsageAllowed(VEH_SHIP, v->owner, tile)) {
 			uint dist = DistanceManhattan(tile, v->tile);
 			if (dist < best_dist) {
 				best_dist = dist;
@@ -181,6 +183,7 @@
 void Ship::UpdateCache()
 {
 	const ShipVehicleInfo *svi = ShipVehInfo(this->engine_type);
+	this->vcache.cached_cargo_mask = (this->cargo_type != INVALID_CARGO && this->cargo_cap > 0) ? 1 << this->cargo_type : 0;
 
 	/* Get speed fraction for the current water type. Aqueducts are always canals. */
 	bool is_ocean = GetEffectiveWaterClass(this->tile) == WATER_CLASS_SEA;
@@ -496,6 +499,24 @@
 	}
 };
 
+/* Used to find DiagDirection from tile to next tile if track is followed */
+static const DiagDirection _diagdir_to_next_tile[6][4] = {
+	{ DIAGDIR_NE, DIAGDIR_SE, DIAGDIR_SW, DIAGDIR_NW },
+	{ DIAGDIR_NE, DIAGDIR_SE, DIAGDIR_SW, DIAGDIR_NW },
+	{ DIAGDIR_SE, DIAGDIR_NE, DIAGDIR_NW, DIAGDIR_SW },
+	{ DIAGDIR_SE, DIAGDIR_NW, DIAGDIR_NE, DIAGDIR_SW },
+	{ DIAGDIR_NW, DIAGDIR_SW, DIAGDIR_SE, DIAGDIR_NE },
+	{ DIAGDIR_SW, DIAGDIR_NW, DIAGDIR_SE, DIAGDIR_NE }
+};
+
+/** Helper function for collision avoidance. */
+static Vehicle *FindShipOnTile(Vehicle *v, void *data)
+{
+	if (v->type != VEH_SHIP || v->vehstatus & VS_STOPPED) return NULL;
+
+	return v;
+}
+
 static void ShipController(Ship *v)
 {
 	uint32 r;
@@ -558,14 +579,13 @@
 									return;
 								}
 							} else if (v->current_order.IsType(OT_GOTO_STATION)) {
-								v->last_station_visited = v->current_order.GetDestination();
-
 								/* Process station in the orderlist. */
 								Station *st = Station::Get(v->current_order.GetDestination());
 								if (st->facilities & FACIL_DOCK) { // ugly, ugly workaround for problem with ships able to drop off cargo at wrong stations
 									ShipArrivesAt(v, st);
-									v->BeginLoading();
+									v->BeginLoading(st->index);
 								} else { // leave stations without docks right aways
+									v->last_station_visited = v->current_order.GetDestination();
 									v->current_order.MakeLeaveStation();
 									v->IncrementRealOrderIndex();
 								}
@@ -588,6 +608,25 @@
 			track = ChooseShipTrack(v, gp.new_tile, diagdir, tracks);
 			if (track == INVALID_TRACK) goto reverse_direction;
 
+			/* Try to avoid collision and keep distance between each other. */
+			if (_settings_game.pf.forbid_90_deg && DistanceManhattan(v->dest_tile, gp.new_tile) > 3) {
+				if (HasVehicleOnPos(gp.new_tile, NULL, &FindShipOnTile) ||
+						HasVehicleOnPos(TileAddByDiagDir(gp.new_tile, _diagdir_to_next_tile[track][diagdir]), NULL, &FindShipOnTile)) {
+
+					v->cur_speed /= 4; // Go quarter speed.
+
+					Track old = track;
+					switch (tracks) {
+						default: break;
+						case TRACK_BIT_3WAY_NE: track == TRACK_RIGHT ? track = TRACK_X : track = TRACK_UPPER; break;
+						case TRACK_BIT_3WAY_SE: track == TRACK_LOWER ? track = TRACK_Y : track = TRACK_RIGHT; break;
+						case TRACK_BIT_3WAY_SW: track == TRACK_LEFT  ? track = TRACK_X : track = TRACK_LOWER; break;
+						case TRACK_BIT_3WAY_NW: track == TRACK_UPPER ? track = TRACK_Y : track = TRACK_LEFT;  break;
+					}
+					if (!IsWaterTile(gp.new_tile) || !IsWaterTile(TileAddByDiagDir(gp.new_tile, _diagdir_to_next_tile[track][diagdir]))) track = old; // Don't bump in coast, don't get stuck.
+				}
+			}
+
 			b = _ship_subcoord[diagdir][track];
 
 			gp.x = (gp.x & ~0xF) | b[0];
diff -urNad openttd-1.3.2/src/ship_gui.cpp openttd-1.3.2-DC3.0RC3/src/ship_gui.cpp
--- openttd-1.3.2/src/ship_gui.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/ship_gui.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -59,6 +59,10 @@
  */
 void DrawShipDetails(const Vehicle *v, int left, int right, int y)
 {
+        CargoArray act_cargo;
+        CargoDestSummary dests[NUM_CARGO];
+        CargoArray max_cargo;
+
 	SetDParam(0, v->engine_type);
 	SetDParam(1, v->build_year);
 	SetDParam(2, v->value);
@@ -75,10 +79,36 @@
 		SetDParam(1, v->cargo.Count());
 		SetDParam(2, v->cargo.Source());
 		str = STR_VEHICLE_DETAILS_CARGO_FROM;
+                act_cargo[v->cargo_type] += v->cargo.Count();
+                AddVehicleCargoDestSummary(v, &dests[v->cargo_type]);
 	}
 	DrawString(left, right, y + 2 * FONT_HEIGHT_NORMAL + 1, str);
 
 	/* Draw Transfer credits text */
 	SetDParam(0, v->cargo.FeederShare());
 	DrawString(left, right, y + 3 * FONT_HEIGHT_NORMAL + 3, STR_VEHICLE_INFO_FEEDER_CARGO_VALUE);
+
+        int y_offset = y - 2 * FONT_HEIGHT_NORMAL;
+        max_cargo[v->cargo_type] += v->cargo_cap;
+       DrawString(left, right, y + FONT_HEIGHT_NORMAL + y_offset, STR_STATION_VIEW_WAITING_TO_BUTTON);
+
+                for (CargoID i = 0; i < NUM_CARGO; i++) {
+                        if (max_cargo[i] > 0) {
+                                SetDParam(0, i);            // {CARGO} #1
+                                SetDParam(1, act_cargo[i]); // {CARGO} #2
+                                SetDParam(2, i);            // {SHORTCARGO} #1
+                                SetDParam(3, max_cargo[i]); // {SHORTCARGO} #2
+//                                SetDParam(4, _settings_game.vehicle.freight_trains);
+                                DrawString(left, right, y + 2 * FONT_HEIGHT_NORMAL + 1 + y_offset, STR_VEHICLE_DETAILS_TRAIN_TOTAL_CAPACITY);
+                               y_offset += FONT_HEIGHT_NORMAL + 1;
+                        }
+                        for (CargoDestSummary::const_iterator row = dests[i].begin(); row != dests[i].end(); ++row) {
+                                        SetDParam(0, i);          // {SHORTCARGO} #1
+                                        SetDParam(1, row->count); // {SHORTCARGO} #2
+                                        SetDParam(2, row->type == ST_INDUSTRY ? STR_INDUSTRY_NAME : (row->type == ST_TOWN ? STR_TOWN_NAME : STR_COMPANY_NAME)); // {STRING1}
+                                        SetDParam(3, row->dest);  // Parameter of {STRING1}
+                                        DrawString(left + 2 * WD_PAR_VSEP_WIDE, right, y + 2 * FONT_HEIGHT_NORMAL + 1 + y_offset, STR_VEHICLE_DETAILS_CARGO_TO);
+                                       y_offset += FONT_HEIGHT_NORMAL + 1;
+                        }
+                }
 }
diff -urNad openttd-1.3.2/src/signal.cpp openttd-1.3.2-DC3.0RC3/src/signal.cpp
--- openttd-1.3.2/src/signal.cpp	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/signal.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -17,6 +17,7 @@
 #include "viewport_func.h"
 #include "train.h"
 #include "company_base.h"
+#include "infrastructure_func.h"
 
 
 /** these are the maximums used for updating signal blocks */
@@ -277,7 +278,7 @@
 
 		switch (GetTileType(tile)) {
 			case MP_RAILWAY: {
-				if (GetTileOwner(tile) != owner) continue; // do not propagate signals on others' tiles (remove for tracksharing)
+				if (!IsOneSignalBlock(owner, GetTileOwner(tile))) continue;
 
 				if (IsRailDepot(tile)) {
 					if (enterdir == INVALID_DIAGDIR) { // from 'inside' - train just entered or left the depot
@@ -351,7 +352,7 @@
 
 			case MP_STATION:
 				if (!HasStationRail(tile)) continue;
-				if (GetTileOwner(tile) != owner) continue;
+				if (!IsOneSignalBlock(owner, GetTileOwner(tile))) continue;
 				if (DiagDirToAxis(enterdir) != GetRailStationAxis(tile)) continue; // different axis
 				if (IsStationTileBlocked(tile)) continue; // 'eye-candy' station tile
 
@@ -361,7 +362,7 @@
 
 			case MP_ROAD:
 				if (!IsLevelCrossing(tile)) continue;
-				if (GetTileOwner(tile) != owner) continue;
+				if (!IsOneSignalBlock(owner, GetTileOwner(tile))) continue;
 				if (DiagDirToAxis(enterdir) == GetCrossingRoadAxis(tile)) continue; // different axis
 
 				if (!(flags & SF_TRAIN) && HasVehicleOnPos(tile, NULL, &TrainOnTileEnum)) flags |= SF_TRAIN;
@@ -369,7 +370,7 @@
 				break;
 
 			case MP_TUNNELBRIDGE: {
-				if (GetTileOwner(tile) != owner) continue;
+				if (!IsOneSignalBlock(owner, GetTileOwner(tile))) continue;
 				if (GetTunnelBridgeTransportType(tile) != TRANSPORT_RAIL) continue;
 				DiagDirection dir = GetTunnelBridgeDirection(tile);
 
@@ -583,8 +584,9 @@
 		DIAGDIR_SW, DIAGDIR_NW, DIAGDIR_NW, DIAGDIR_SW, DIAGDIR_NW, DIAGDIR_NE
 	};
 
-	/* do not allow signal updates for two companies in one run */
-	assert(_globset.IsEmpty() || owner == _last_owner);
+	/* do not allow signal updates for two companies in one run,
+	 * if these companies are not part of the same signal block */
+	assert(_globset.IsEmpty() || IsOneSignalBlock(owner, _last_owner));
 
 	_last_owner = owner;
 
@@ -608,8 +610,9 @@
  */
 void AddSideToSignalBuffer(TileIndex tile, DiagDirection side, Owner owner)
 {
-	/* do not allow signal updates for two companies in one run */
-	assert(_globset.IsEmpty() || owner == _last_owner);
+	/* do not allow signal updates for two companies in one run,
+	 * if these companies are not part of the same signal block */
+	assert(_globset.IsEmpty() || IsOneSignalBlock(owner, _last_owner));
 
 	_last_owner = owner;
 
diff -urNad openttd-1.3.2/src/slope_func.h openttd-1.3.2-DC3.0RC3/src/slope_func.h
--- openttd-1.3.2/src/slope_func.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/slope_func.h	2013-11-22 05:49:07.000000000 +0100
@@ -189,6 +189,48 @@
 }
 
 /**
+ * Transform a Corner.
+ * @param c The Corner to transform.
+ * @param transformation Transformation to perform.
+ * @return The transformed Corner.
+ */
+static inline Corner TransformCorner(Corner c, DirTransformation transformation)
+{
+	if (transformation & DTR_REFLECTION_BIT) c = (Corner)(1 - c); // reflect against X-axis (let overflow)
+	return (Corner)((uint)(c + transformation) % CORNER_END); // rotate and cut off overflowing bits
+}
+
+/**
+ * Transform a Slope.
+ * @param s The Slope to transform.
+ * @param transformation Transformation to perform.
+ * @return The transformed Slope.
+ */
+static inline Slope TransformSlope(Slope s, DirTransformation transformation)
+{
+	assert((s & ~(SLOPE_ELEVATED | SLOPE_STEEP)) == 0);
+
+	Slope steep_bit = s & SLOPE_STEEP; // store the "steep" bit
+	s &= SLOPE_ELEVATED; // only "corner" bits need to be transformed
+
+	/* reflect agains X axis before rotating */
+	if (transformation & DTR_REFLECTION_BIT) {
+		/* reflect by swapping odd and even bits (the numbers are bit positions):
+		 *   [N]          3/                              2/
+		 * [W] [E]       0/2 --reflect-against-x-axis--> 1/3
+		 *   [S]         /1                              /0
+		 *  SLOPE_W (bit 0) needs to be swapped with SLOPE_S (bit 1)
+		 *  SLOPE_E (bit 2) needs to be swapped with SLOPE_N (bit 3) */
+		s = SwapOddEvenBits(s);
+	}
+
+	/* rotate */
+	s = (Slope)((s | (s << 4)) >> (transformation & DTR_ROTATION_MASK)) & SLOPE_ELEVATED;
+
+	return s | steep_bit;
+}
+
+/**
  * Tests if a specific slope has exactly three corners raised.
  *
  * @param s The #Slope
diff -urNad openttd-1.3.2/src/smallmap_gui.cpp openttd-1.3.2-DC3.0RC3/src/smallmap_gui.cpp
--- openttd-1.3.2/src/smallmap_gui.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/smallmap_gui.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -26,6 +26,10 @@
 #include "sound_func.h"
 #include "window_func.h"
 #include "company_base.h"
+#include "station_base.h"
+#include "company_func.h"
+#include "cargotype.h"
+#include "core/smallmap_type.hpp"
 
 #include "widgets/smallmap_widget.h"
 
@@ -33,6 +37,7 @@
 
 static int _smallmap_industry_count; ///< Number of used industries
 static int _smallmap_company_count;  ///< Number of entries in the owner legend.
+static int _smallmap_cargo_count;    ///< Number of entries in the cargo legend.
 
 static const int NUM_NO_COMPANY_ENTRIES = 4; ///< Number of entries in the owner legend that are not companies.
 
@@ -44,25 +49,28 @@
 static const uint8 PC_WATER           = 0xCA; ///< Dark blue palette colour for water.
 
 /** Macro for ordinary entry of LegendAndColour */
-#define MK(a, b) {a, b, INVALID_INDUSTRYTYPE, 0, INVALID_COMPANY, true, false, false}
+#define MK(a, b) {a, b, INVALID_INDUSTRYTYPE, 0, INVALID_COMPANY, INVALID_CARGO, true, false, false}
 
 /** Macro for a height legend entry with configurable colour. */
-#define MC(height)  {0, STR_TINY_BLACK_HEIGHT, INVALID_INDUSTRYTYPE, height, INVALID_COMPANY, true, false, false}
+#define MC(height)  {0, STR_TINY_BLACK_HEIGHT, INVALID_INDUSTRYTYPE, height, INVALID_COMPANY, INVALID_CARGO, true, false, false}
+
+/** Macro for a height legend entry break marker with configurable colour. */
+#define MCS(height)  {0, STR_TINY_BLACK_HEIGHT, INVALID_INDUSTRYTYPE, height, INVALID_COMPANY, true, false, true}
 
 /** Macro for non-company owned property entry of LegendAndColour */
-#define MO(a, b) {a, b, INVALID_INDUSTRYTYPE, 0, INVALID_COMPANY, true, false, false}
+#define MO(a, b) {a, b, INVALID_INDUSTRYTYPE, 0, INVALID_COMPANY, INVALID_CARGO, true, false, false}
 
 /** Macro used for forcing a rebuild of the owner legend the first time it is used. */
-#define MOEND() {0, 0, INVALID_INDUSTRYTYPE, 0, OWNER_NONE, true, true, false}
+#define MOEND() {0, 0, INVALID_INDUSTRYTYPE, 0, OWNER_NONE, INVALID_CARGO, true, true, false}
 
 /** Macro for end of list marker in arrays of LegendAndColour */
-#define MKEND() {0, STR_NULL, INVALID_INDUSTRYTYPE, 0, INVALID_COMPANY, true, true, false}
+#define MKEND() {0, STR_NULL, INVALID_INDUSTRYTYPE, 0, INVALID_COMPANY, INVALID_CARGO, true, true, false}
 
 /**
  * Macro for break marker in arrays of LegendAndColour.
  * It will have valid data, though
  */
-#define MS(a, b) {a, b, INVALID_INDUSTRYTYPE, 0, INVALID_COMPANY, true, false, true}
+#define MS(a, b) {a, b, INVALID_INDUSTRYTYPE, 0, INVALID_COMPANY, INVALID_CARGO, true, false, true}
 
 /** Structure for holding relevant data for legends in small map */
 struct LegendAndColour {
@@ -71,6 +79,7 @@
 	IndustryType type;         ///< Type of industry. Only valid for industry entries.
 	uint8 height;              ///< Height in tiles. Only valid for height legend entries.
 	CompanyID company;         ///< Company to display. Only valid for company entries of the owner legend.
+	CargoID cid;               ///< Cargo type to display. Only valid for entries of the cargo legend.
 	bool show_on_map;          ///< For filtering industries, if \c true, industry is shown on the map in colour.
 	bool end;                  ///< This is the end of the list.
 	bool col_break;            ///< Perform a column break and go further at the next column.
@@ -80,16 +89,30 @@
 static LegendAndColour _legend_land_contours[] = {
 	/* The colours for the following values are set at BuildLandLegend() based on each colour scheme. */
 	MC(0),
-	MC(4),
-	MC(8),
-	MC(12),
-	MC(14),
+	MC(16),
+	MC(32),
+	MC(48),
+	MC(64),
+	MC(80),
 
-	MS(PC_BLACK,           STR_SMALLMAP_LEGENDA_ROADS),
-	MK(PC_GREY,            STR_SMALLMAP_LEGENDA_RAILROADS),
-	MK(PC_LIGHT_BLUE,      STR_SMALLMAP_LEGENDA_STATIONS_AIRPORTS_DOCKS),
-	MK(PC_DARK_RED,        STR_SMALLMAP_LEGENDA_BUILDINGS_INDUSTRIES),
-	MK(PC_WHITE,           STR_SMALLMAP_LEGENDA_VEHICLES),
+	MCS(96),
+	MC(112),
+	MC(128),
+	MC(144),
+	MC(160),
+	MC(176),
+
+	MCS(192),
+	MC(208),
+	MC(224),
+	MC(240),
+	MC(255),
+
+	MS(0xD7, STR_SMALLMAP_LEGENDA_ROADS),
+	MK(0x0A, STR_SMALLMAP_LEGENDA_RAILROADS),
+	MK(0x98, STR_SMALLMAP_LEGENDA_STATIONS_AIRPORTS_DOCKS),
+	MK(0xB5, STR_SMALLMAP_LEGENDA_BUILDINGS_INDUSTRIES),
+	MK(0x0F, STR_SMALLMAP_LEGENDA_VEHICLES),
 	MKEND()
 };
 
@@ -144,6 +167,7 @@
 
 #undef MK
 #undef MC
+#undef MCS
 #undef MS
 #undef MO
 #undef MOEND
@@ -156,6 +180,10 @@
 static LegendAndColour _legend_from_industries[NUM_INDUSTRYTYPES + 1];
 /** For connecting industry type to position in industries list(small map legend) */
 static uint _industry_to_list_pos[NUM_INDUSTRYTYPES];
+/** Legend text for the cargo types in the route link legend. */
+static LegendAndColour _legend_from_cargoes[NUM_CARGO + 1];
+/** For connecting cargo type to position in route link legend. */
+static uint _cargotype_to_list_pos[NUM_CARGO];
 /** Show heightmap in industry and owner mode of smallmap window. */
 static bool _smallmap_show_heightmap = false;
 /** Highlight a specific industry type */
@@ -196,10 +224,38 @@
 	_smallmap_industry_count = j;
 }
 
+/** Fills the array for the route link legend. */
+void BuildCargoTypesLegend()
+{
+	uint j = 0;
+
+	/* Add all standard cargo types. */
+	const CargoSpec *cs;
+	FOR_ALL_SORTED_STANDARD_CARGOSPECS(cs) {
+		_legend_from_cargoes[j].legend = cs->name;
+		_legend_from_cargoes[j].colour = cs->legend_colour;
+		_legend_from_cargoes[j].cid = cs->Index();
+		_legend_from_cargoes[j].show_on_map = true;
+		_legend_from_cargoes[j].col_break = false;
+		_legend_from_cargoes[j].end = false;
+
+		/* Store widget number for this cargo type. */
+		_cargotype_to_list_pos[cs->Index()] = j;
+		j++;
+	}
+
+	/* Terminate list. */
+	_legend_from_cargoes[j].end = true;
+
+	/* Store number of enabled cargoes. */
+	_smallmap_cargo_count = j;
+}
+
 static const LegendAndColour * const _legend_table[] = {
 	_legend_land_contours,
 	_legend_vehicles,
 	_legend_from_industries,
+	_legend_from_cargoes,
 	_legend_routes,
 	_legend_vegetation,
 	_legend_land_owners,
@@ -223,64 +279,784 @@
 
 /** Height map colours for the green colour scheme, ordered by height. */
 static const uint32 _green_map_heights[] = {
-	MKCOLOUR_XXXX(0x5A),
-	MKCOLOUR_XYXY(0x5A, 0x5B),
-	MKCOLOUR_XXXX(0x5B),
-	MKCOLOUR_XYXY(0x5B, 0x5C),
-	MKCOLOUR_XXXX(0x5C),
-	MKCOLOUR_XYXY(0x5C, 0x5D),
-	MKCOLOUR_XXXX(0x5D),
-	MKCOLOUR_XYXY(0x5D, 0x5E),
-	MKCOLOUR_XXXX(0x5E),
-	MKCOLOUR_XYXY(0x5E, 0x5F),
-	MKCOLOUR_XXXX(0x5F),
-	MKCOLOUR_XYXY(0x5F, 0x1F),
-	MKCOLOUR_XXXX(0x1F),
-	MKCOLOUR_XYXY(0x1F, 0x27),
-	MKCOLOUR_XXXX(0x27),
-	MKCOLOUR_XXXX(0x27),
+	MKCOLOUR(0x59595958), // height 0
+	MKCOLOUR(0x59595958), // height 1
+	MKCOLOUR(0x59595958), // height 2
+	MKCOLOUR(0X59595959), // height 3
+	MKCOLOUR(0X59595959), // height 4
+	MKCOLOUR(0X5959595A), // height 5
+	MKCOLOUR(0X5959595A), // height 6
+	MKCOLOUR(0X59595A59), // height 7
+	MKCOLOUR(0X59595A59), // height 8
+	MKCOLOUR(0X59595A5A), // height 9
+	MKCOLOUR(0X59595A5A), // height 10
+	MKCOLOUR(0X595A5959), // height 11
+	MKCOLOUR(0X595A5959), // height 12
+	MKCOLOUR(0X595A595A), // height 13
+	MKCOLOUR(0X595A595A), // height 14
+	MKCOLOUR(0X595A5A59), // height 15
+	MKCOLOUR(0X595A5A59), // height 16
+	MKCOLOUR(0X595A5A5A), // height 17
+	MKCOLOUR(0X595A5A5A), // height 18
+	MKCOLOUR(0X5A595959), // height 19
+	MKCOLOUR(0X5A595959), // height 20
+	MKCOLOUR(0X5A59595A), // height 21
+	MKCOLOUR(0X5A59595A), // height 22
+	MKCOLOUR(0X5A595A59), // height 23
+	MKCOLOUR(0X5A595A59), // height 24
+	MKCOLOUR(0X5A595A5A), // height 25
+	MKCOLOUR(0X5A595A5A), // height 26
+	MKCOLOUR(0X5A5A5959), // height 27
+	MKCOLOUR(0X5A5A5959), // height 28
+	MKCOLOUR(0X5A5A595A), // height 29
+	MKCOLOUR(0X5A5A595A), // height 30
+	MKCOLOUR(0X5A5A5A59), // height 31
+	MKCOLOUR(0X5A5A5A59), // height 32
+	MKCOLOUR(0x5A5A5A5A), // height 33
+	MKCOLOUR(0x5A5A5A5A), // height 34
+	MKCOLOUR(0x5A5A5A5B), // height 35
+	MKCOLOUR(0x5A5A5A5B), // height 36
+	MKCOLOUR(0x5A5A5B5A), // height 37
+	MKCOLOUR(0x5A5A5B5A), // height 38
+	MKCOLOUR(0x5A5A5B5B), // height 39
+	MKCOLOUR(0x5A5A5B5B), // height 40
+	MKCOLOUR(0x5A5B5A5A), // height 41
+	MKCOLOUR(0x5A5B5A5A), // height 42
+	MKCOLOUR(0x5A5B5A5B), // height 43
+	MKCOLOUR(0x5A5B5A5B), // height 44
+	MKCOLOUR(0x5A5B5B5A), // height 45
+	MKCOLOUR(0x5A5B5B5A), // height 46
+	MKCOLOUR(0x5A5B5B5B), // height 47
+	MKCOLOUR(0x5A5B5B5B), // height 48
+	MKCOLOUR(0x5B5A5A5A), // height 49
+	MKCOLOUR(0x5B5A5A5A), // height 50
+	MKCOLOUR(0x5B5A5A5B), // height 51
+	MKCOLOUR(0x5B5A5A5B), // height 52
+	MKCOLOUR(0x5B5A5B5A), // height 53
+	MKCOLOUR(0x5B5A5B5A), // height 54
+	MKCOLOUR(0x5B5A5B5B), // height 55
+	MKCOLOUR(0x5B5A5B5B), // height 56
+	MKCOLOUR(0x5B5B5A5A), // height 57
+	MKCOLOUR(0x5B5B5A5A), // height 58
+	MKCOLOUR(0x5B5B5A5B), // height 59
+	MKCOLOUR(0x5B5B5A5B), // height 60
+	MKCOLOUR(0x5B5B5B5B), // height 61
+	MKCOLOUR(0x5B5B5B5B), // height 62
+	MKCOLOUR(0x5B5B5B5C), // height 63
+	MKCOLOUR(0x5B5B5B5C), // height 64
+	MKCOLOUR(0x5B5B5C5B), // height 65
+	MKCOLOUR(0x5B5B5C5B), // height 66
+	MKCOLOUR(0x5B5B5C5C), // height 67
+	MKCOLOUR(0x5B5B5C5C), // height 68
+	MKCOLOUR(0x5B5C5B5B), // height 69
+	MKCOLOUR(0x5B5C5B5B), // height 70
+	MKCOLOUR(0x5B5C5B5C), // height 71
+	MKCOLOUR(0x5B5C5B5C), // height 72
+	MKCOLOUR(0x5B5C5C5B), // height 73
+	MKCOLOUR(0x5B5C5C5B), // height 74
+	MKCOLOUR(0x5B5C5C5C), // height 75
+	MKCOLOUR(0x5B5C5C5C), // height 76
+	MKCOLOUR(0x5C5B5B5B), // height 77
+	MKCOLOUR(0x5C5B5B5B), // height 78
+	MKCOLOUR(0x5C5B5B5C), // height 79
+	MKCOLOUR(0x5C5B5B5C), // height 80
+	MKCOLOUR(0x5C5B5C5B), // height 81
+	MKCOLOUR(0x5C5B5C5B), // height 82
+	MKCOLOUR(0x5C5B5C5C), // height 83
+	MKCOLOUR(0x5C5B5C5C), // height 84
+	MKCOLOUR(0x5C5C5B5B), // height 85
+	MKCOLOUR(0x5C5C5B5B), // height 86
+	MKCOLOUR(0x5C5C5B5C), // height 87
+	MKCOLOUR(0x5C5C5B5C), // height 88
+	MKCOLOUR(0x5C5C5C5C), // height 89
+	MKCOLOUR(0x5C5C5C5C), // height 90
+	MKCOLOUR(0x5C5C5C5D), // height 91
+	MKCOLOUR(0x5C5C5C5D), // height 92
+	MKCOLOUR(0x5C5C5D5C), // height 93
+	MKCOLOUR(0x5C5C5D5C), // height 94
+	MKCOLOUR(0x5C5C5D5D), // height 95
+	MKCOLOUR(0x5C5C5D5D), // height 96
+	MKCOLOUR(0x5C5D5C5C), // height 97
+	MKCOLOUR(0x5C5D5C5C), // height 98
+	MKCOLOUR(0x5C5D5C5D), // height 99
+	MKCOLOUR(0x5C5D5C5D), // height 100
+	MKCOLOUR(0x5C5D5D5C), // height 101
+	MKCOLOUR(0x5C5D5D5C), // height 102
+	MKCOLOUR(0x5C5D5D5D), // height 103
+	MKCOLOUR(0x5C5D5D5D), // height 104
+	MKCOLOUR(0x5D5C5C5C), // height 105
+	MKCOLOUR(0x5D5C5C5C), // height 106
+	MKCOLOUR(0x5D5C5C5D), // height 107
+	MKCOLOUR(0x5D5C5C5D), // height 108
+	MKCOLOUR(0x5D5C5D5C), // height 109
+	MKCOLOUR(0x5D5C5D5C), // height 110
+	MKCOLOUR(0x5D5C5D5D), // height 111
+	MKCOLOUR(0x5D5C5D5D), // height 112
+	MKCOLOUR(0x5D5D5C5C), // height 113
+	MKCOLOUR(0x5D5D5C5C), // height 114
+	MKCOLOUR(0x5D5D5C5D), // height 115
+	MKCOLOUR(0x5D5D5C5D), // height 116
+	MKCOLOUR(0x5D5D5D5D), // height 117
+	MKCOLOUR(0x5D5D5D5D), // height 118
+	MKCOLOUR(0x5D5D5D5E), // height 119
+	MKCOLOUR(0x5D5D5D5E), // height 120
+	MKCOLOUR(0x5D5D5E5D), // height 121
+	MKCOLOUR(0x5D5D5E5D), // height 122
+	MKCOLOUR(0x5D5D5E5E), // height 123
+	MKCOLOUR(0x5D5D5E5E), // height 124
+	MKCOLOUR(0x5D5E5D5D), // height 125
+	MKCOLOUR(0x5D5E5D5D), // height 126
+	MKCOLOUR(0x5D5E5D5E), // height 127
+	MKCOLOUR(0x5D5E5D5E), // height 128
+	MKCOLOUR(0x5D5E5E5D), // height 129
+	MKCOLOUR(0x5D5E5E5D), // height 130
+	MKCOLOUR(0x5D5E5E5E), // height 131
+	MKCOLOUR(0x5D5E5E5E), // height 132
+	MKCOLOUR(0x5E5D5D5D), // height 133
+	MKCOLOUR(0x5E5D5D5D), // height 134
+	MKCOLOUR(0x5E5D5D5E), // height 135
+	MKCOLOUR(0x5E5D5D5E), // height 136
+	MKCOLOUR(0x5E5D5E5D), // height 137
+	MKCOLOUR(0x5E5D5E5D), // height 138
+	MKCOLOUR(0x5E5D5E5E), // height 139
+	MKCOLOUR(0x5E5D5E5E), // height 140
+	MKCOLOUR(0x5E5D5D5D), // height 141
+	MKCOLOUR(0x5E5D5D5D), // height 142
+	MKCOLOUR(0x5E5D5D5E), // height 143
+	MKCOLOUR(0x5E5D5D5E), // height 144
+	MKCOLOUR(0x5E5E5E5E), // height 145
+	MKCOLOUR(0x5E5E5E5E), // height 146
+	MKCOLOUR(0x5E5E5E5F), // height 147
+	MKCOLOUR(0x5E5E5E5F), // height 148
+	MKCOLOUR(0x5E5E5F5E), // height 149
+	MKCOLOUR(0x5E5E5F5E), // height 150
+	MKCOLOUR(0x5E5E5F5F), // height 151
+	MKCOLOUR(0x5E5E5F5F), // height 152
+	MKCOLOUR(0x5E5F5E5E), // height 153
+	MKCOLOUR(0x5E5F5E5E), // height 154
+	MKCOLOUR(0x5E5F5E5F), // height 155
+	MKCOLOUR(0x5E5F5E5F), // height 156
+	MKCOLOUR(0x5E5F5F5E), // height 157
+	MKCOLOUR(0x5E5F5F5E), // height 158
+	MKCOLOUR(0x5E5F5F5F), // height 159
+	MKCOLOUR(0x5E5F5F5F), // height 160
+	MKCOLOUR(0x5F5E5E5E), // height 161
+	MKCOLOUR(0x5F5E5E5E), // height 162
+	MKCOLOUR(0x5F5E5E5F), // height 163
+	MKCOLOUR(0x5F5E5E5F), // height 164
+	MKCOLOUR(0x5F5E5F5E), // height 165
+	MKCOLOUR(0x5F5E5F5E), // height 166
+	MKCOLOUR(0x5F5E5F5F), // height 167
+	MKCOLOUR(0x5F5E5F5F), // height 168
+	MKCOLOUR(0x5F5F5E5E), // height 169
+	MKCOLOUR(0x5F5F5E5E), // height 170
+	MKCOLOUR(0x5F5F5E5F), // height 171
+	MKCOLOUR(0x5F5F5E5F), // height 172
+	MKCOLOUR(0x5F5F5F5F), // height 173
+	MKCOLOUR(0x5F5F5F5F), // height 174
+	MKCOLOUR(0x5F5F5F1F), // height 175
+	MKCOLOUR(0x5F5F5F1F), // height 176
+	MKCOLOUR(0x5F5F1F5F), // height 177
+	MKCOLOUR(0x5F5F1F5F), // height 178
+	MKCOLOUR(0x5F5F1F1F), // height 179
+	MKCOLOUR(0x5F5F1F1F), // height 180
+	MKCOLOUR(0x5F1F5F1F), // height 181
+	MKCOLOUR(0x5F1F5F1F), // height 182
+	MKCOLOUR(0x5F1F1F1F), // height 183
+	MKCOLOUR(0x5F1F1F1F), // height 184
+	MKCOLOUR(0x1F5F5F5F), // height 185
+	MKCOLOUR(0x1F5F5F5F), // height 186
+	MKCOLOUR(0x1F5F5F1F), // height 187
+	MKCOLOUR(0x1F5F5F1F), // height 188
+	MKCOLOUR(0x1F5F1F5F), // height 189
+	MKCOLOUR(0x1F5F1F5F), // height 190
+	MKCOLOUR(0x1F5F1F1F), // height 191
+	MKCOLOUR(0x1F5F1F1F), // height 192
+	MKCOLOUR(0x1F1F5F5F), // height 193
+	MKCOLOUR(0x1F1F5F5F), // height 194
+	MKCOLOUR(0x1F1F5F1F), // height 195
+	MKCOLOUR(0x1F1F5F1F), // height 196
+	MKCOLOUR(0x1F1F1F5F), // height 197
+	MKCOLOUR(0x1F1F1F5F), // height 198
+	MKCOLOUR(0x1F1F1F1F), // height 199
+	MKCOLOUR(0x1F1F1F1F), // height 200
+	MKCOLOUR(0x1F1F1F27), // height 201
+	MKCOLOUR(0x1F1F1F27), // height 202
+	MKCOLOUR(0x1F1F271F), // height 203
+	MKCOLOUR(0x1F1F271F), // height 204
+	MKCOLOUR(0x1F1F2727), // height 205
+	MKCOLOUR(0x1F1F2727), // height 206
+	MKCOLOUR(0x1F271F1F), // height 207
+	MKCOLOUR(0x1F271F1F), // height 208
+	MKCOLOUR(0x1F271F27), // height 209
+	MKCOLOUR(0x1F271F27), // height 210
+	MKCOLOUR(0x1F272727), // height 211
+	MKCOLOUR(0x1F272727), // height 212
+	MKCOLOUR(0x271F1F1F), // height 213
+	MKCOLOUR(0x271F1F1F), // height 214
+	MKCOLOUR(0x271F1F27), // height 215
+	MKCOLOUR(0x271F1F27), // height 216
+	MKCOLOUR(0x271F271F), // height 217
+	MKCOLOUR(0x271F271F), // height 218
+	MKCOLOUR(0x271F2727), // height 219
+	MKCOLOUR(0x271F2727), // height 220
+	MKCOLOUR(0x27271F1F), // height 221
+	MKCOLOUR(0x27271F1F), // height 222
+	MKCOLOUR(0x27271F27), // height 223
+	MKCOLOUR(0x27271F27), // height 224
+	MKCOLOUR(0x2727271F), // height 225
+	MKCOLOUR(0x2727271F), // height 226
+	MKCOLOUR(0x27272727), // height 227
+	MKCOLOUR(0x27272727), // height 228
+	MKCOLOUR(0x27272727), // height 229
+	MKCOLOUR(0x27272727), // height 230
+	MKCOLOUR(0x1F27AF27), // height 231
+	MKCOLOUR(0x1F27AF27), // height 232
+	MKCOLOUR(0x1F274FAF), // height 233
+	MKCOLOUR(0x1F274FAF), // height 234
+	MKCOLOUR(0x4F274FAF), // height 235
+	MKCOLOUR(0x4F274FAF), // height 236
+	MKCOLOUR(0x4FAF1FAF), // height 237
+	MKCOLOUR(0x4FAF1FAF), // height 238
+	MKCOLOUR(0x4F2727AF), // height 239
+	MKCOLOUR(0x4F2727AF), // height 240
+	MKCOLOUR(0x4F27AF27), // height 241
+	MKCOLOUR(0x4F27AF27), // height 242
+	MKCOLOUR(0x4F27AFAF), // height 243
+	MKCOLOUR(0x4F27AFAF), // height 244
+	MKCOLOUR(0x4FAF2727), // height 245
+	MKCOLOUR(0x4FAF2727), // height 246
+	MKCOLOUR(0x4FAF27AF), // height 247
+	MKCOLOUR(0x4FAF27AF), // height 248
+	MKCOLOUR(0x4FAFAF27), // height 249
+	MKCOLOUR(0x4FAFAF27), // height 250
+	MKCOLOUR(0x4FAFAFAF), // height 251
+	MKCOLOUR(0x4FAFAFAF), // height 252
+	MKCOLOUR(0x4FAFAFCF), // height 253
+	MKCOLOUR(0x4FAFAFCF), // height 254
+	MKCOLOUR(0x4FAFCFAF), // height 255
 };
 assert_compile(lengthof(_green_map_heights) == MAX_TILE_HEIGHT + 1);
 
 /** Height map colours for the dark green colour scheme, ordered by height. */
 static const uint32 _dark_green_map_heights[] = {
-	MKCOLOUR_XXXX(0x60),
-	MKCOLOUR_XYXY(0x60, 0x61),
-	MKCOLOUR_XXXX(0x61),
-	MKCOLOUR_XYXY(0x61, 0x62),
-	MKCOLOUR_XXXX(0x62),
-	MKCOLOUR_XYXY(0x62, 0x63),
-	MKCOLOUR_XXXX(0x63),
-	MKCOLOUR_XYXY(0x63, 0x64),
-	MKCOLOUR_XXXX(0x64),
-	MKCOLOUR_XYXY(0x64, 0x65),
-	MKCOLOUR_XXXX(0x65),
-	MKCOLOUR_XYXY(0x65, 0x66),
-	MKCOLOUR_XXXX(0x66),
-	MKCOLOUR_XYXY(0x66, 0x67),
-	MKCOLOUR_XXXX(0x67),
-	MKCOLOUR_XXXX(0x67),
+	MKCOLOUR(0x60606060), // height 0
+	MKCOLOUR(0x60606060), // height 1
+	MKCOLOUR(0x60606060),
+	MKCOLOUR(0x60606061), // height 3
+	MKCOLOUR(0x60606061),
+	MKCOLOUR(0x60606160), // height 5
+	MKCOLOUR(0x60606160),
+	MKCOLOUR(0x60606161), // height 7
+	MKCOLOUR(0x60606161),
+	MKCOLOUR(0x60616060), // height 9
+	MKCOLOUR(0x60616060),
+	MKCOLOUR(0x60616061), // height 11
+	MKCOLOUR(0x60616061),
+	MKCOLOUR(0x60616160), // height 13
+	MKCOLOUR(0x60616160),
+	MKCOLOUR(0x60616161), // height 15
+	MKCOLOUR(0x60616161),
+	MKCOLOUR(0x61606060), // height 17
+	MKCOLOUR(0x61606060),
+	MKCOLOUR(0x61606061), // height 19
+	MKCOLOUR(0x61606061),
+	MKCOLOUR(0x61606160), // height 21
+	MKCOLOUR(0x61606160),
+	MKCOLOUR(0x61606161), // height 23
+	MKCOLOUR(0x61606161),
+	MKCOLOUR(0x61616060), // height 25
+	MKCOLOUR(0x61616060),
+	MKCOLOUR(0x61616061), // height 27
+	MKCOLOUR(0x61616061),
+	MKCOLOUR(0x61616160), // height 29
+	MKCOLOUR(0x61616160),
+	MKCOLOUR(0x61616161), // height 31
+	MKCOLOUR(0x61616161),
+	MKCOLOUR(0x61616162), // height 33
+	MKCOLOUR(0x61616162),
+	MKCOLOUR(0x61616261), // height 35
+	MKCOLOUR(0x61616261),
+	MKCOLOUR(0x61616262), // height 37
+	MKCOLOUR(0x61616262),
+	MKCOLOUR(0x61626161), // height 39
+	MKCOLOUR(0x61626161),
+	MKCOLOUR(0x61626162), // height 41
+	MKCOLOUR(0x61626162),
+	MKCOLOUR(0x61626261), // height 43
+	MKCOLOUR(0x61626261),
+	MKCOLOUR(0x61626262), // height 45
+	MKCOLOUR(0x61626262),
+	MKCOLOUR(0x62616161), // height 47
+	MKCOLOUR(0x62616161),
+	MKCOLOUR(0x62616162), // height 49
+	MKCOLOUR(0x62616162),
+	MKCOLOUR(0x62616261), // height 51
+	MKCOLOUR(0x62616261),
+	MKCOLOUR(0x62616262), // height 53
+	MKCOLOUR(0x62616262),
+	MKCOLOUR(0x62626161), // height 55
+	MKCOLOUR(0x62626161),
+	MKCOLOUR(0x62626162), // height 57
+	MKCOLOUR(0x62626162),
+	MKCOLOUR(0x62626261), // height 59
+	MKCOLOUR(0x62626261),
+	MKCOLOUR(0x62626262), // height 61
+	MKCOLOUR(0x62626262),
+	MKCOLOUR(0x62626263), // height 63
+	MKCOLOUR(0x62626263),
+	MKCOLOUR(0x62626362), // height 65
+	MKCOLOUR(0x62626362),
+	MKCOLOUR(0x62626363), // height 67
+	MKCOLOUR(0x62626363),
+	MKCOLOUR(0x62636262), // height 69
+	MKCOLOUR(0x62636262),
+	MKCOLOUR(0x62636263), // height 71
+	MKCOLOUR(0x62636263),
+	MKCOLOUR(0x62636362), // height 73
+	MKCOLOUR(0x62636362),
+	MKCOLOUR(0x62636363), // height 75
+	MKCOLOUR(0x62636363),
+	MKCOLOUR(0x63626262), // height 77
+	MKCOLOUR(0x63626262),
+	MKCOLOUR(0x63626263), // height 79
+	MKCOLOUR(0x63626263),
+	MKCOLOUR(0x63626362), // height 81
+	MKCOLOUR(0x63626362),
+	MKCOLOUR(0x63626363), // height 83
+	MKCOLOUR(0x63626363),
+	MKCOLOUR(0x63636262), // height 85
+	MKCOLOUR(0x63636262),
+	MKCOLOUR(0x63636263), // height 87
+	MKCOLOUR(0x63636263),
+	MKCOLOUR(0x63636362), // height 89
+	MKCOLOUR(0x63636362),
+	MKCOLOUR(0x63636363), // height 91
+	MKCOLOUR(0x63636363),
+	MKCOLOUR(0x63636364), // height 93
+	MKCOLOUR(0x63636364),
+	MKCOLOUR(0x63636463), // height 95
+	MKCOLOUR(0x63636463),
+	MKCOLOUR(0x63636464), // height 97
+	MKCOLOUR(0x63636464),
+	MKCOLOUR(0x63646363), // height 99
+	MKCOLOUR(0x63646363),
+	MKCOLOUR(0x63646364), // height 101
+	MKCOLOUR(0x63646364),
+	MKCOLOUR(0x63646463), // height 103
+	MKCOLOUR(0x63646463),
+	MKCOLOUR(0x63646464), // height 105
+	MKCOLOUR(0x63646464),
+	MKCOLOUR(0x64636363), // height 107
+	MKCOLOUR(0x64636363),
+	MKCOLOUR(0x64636364), // height 109
+	MKCOLOUR(0x64636364),
+	MKCOLOUR(0x64636463), // height 111
+	MKCOLOUR(0x64636463),
+	MKCOLOUR(0x64636464), // height 113
+	MKCOLOUR(0x64636464),
+	MKCOLOUR(0x64646363), // height 115
+	MKCOLOUR(0x64646363),
+	MKCOLOUR(0x64646364), // height 117
+	MKCOLOUR(0x64646364),
+	MKCOLOUR(0x64646463), // height 119
+	MKCOLOUR(0x64646463),
+	MKCOLOUR(0x64646464), // height 121
+	MKCOLOUR(0x64646464),
+	MKCOLOUR(0x64646465), // height 123
+	MKCOLOUR(0x64646465),
+	MKCOLOUR(0x64646564), // height 125
+	MKCOLOUR(0x64646564),
+	MKCOLOUR(0x64646565), // height 127
+	MKCOLOUR(0x64646565),
+	MKCOLOUR(0x64656464), // height 129
+	MKCOLOUR(0x64656464),
+	MKCOLOUR(0x64656465), // height 131
+	MKCOLOUR(0x64656465),
+	MKCOLOUR(0x64656564), // height 133
+	MKCOLOUR(0x64656564),
+	MKCOLOUR(0x64656565), // height 135
+	MKCOLOUR(0x64656565),
+	MKCOLOUR(0x65646464), // height 137
+	MKCOLOUR(0x65646464),
+	MKCOLOUR(0x65646465), // height 139
+	MKCOLOUR(0x65646465),
+	MKCOLOUR(0x65646564), // height 141
+	MKCOLOUR(0x65646564),
+	MKCOLOUR(0x65646565), // height 143
+	MKCOLOUR(0x65646565),
+	MKCOLOUR(0x65656464), // height 145
+	MKCOLOUR(0x65656464),
+	MKCOLOUR(0x65656465), // height 147
+	MKCOLOUR(0x65656465),
+	MKCOLOUR(0x65656564), // height 149
+	MKCOLOUR(0x65656564),
+	MKCOLOUR(0x65656565), // height 151
+	MKCOLOUR(0x65656565),
+	MKCOLOUR(0x65656566), // height 153
+	MKCOLOUR(0x65656566),
+	MKCOLOUR(0x65656665), // height 155
+	MKCOLOUR(0x65656665),
+	MKCOLOUR(0x65656666), // height 157
+	MKCOLOUR(0x65656666),
+	MKCOLOUR(0x65666565), // height 159
+	MKCOLOUR(0x65666565),
+	MKCOLOUR(0x65666566), // height 161
+	MKCOLOUR(0x65666566),
+	MKCOLOUR(0x65666665), // height 163
+	MKCOLOUR(0x65666665),
+	MKCOLOUR(0x65666666), // height 165
+	MKCOLOUR(0x65666666),
+	MKCOLOUR(0x66656565), // height 167
+	MKCOLOUR(0x66656565),
+	MKCOLOUR(0x66656566), // height 169
+	MKCOLOUR(0x66656566),
+	MKCOLOUR(0x66656665), // height 171
+	MKCOLOUR(0x66656665),
+	MKCOLOUR(0x66656666), // height 173
+	MKCOLOUR(0x66656666),
+	MKCOLOUR(0x66666565), // height 175
+	MKCOLOUR(0x66666565),
+	MKCOLOUR(0x66666566), // height 177
+	MKCOLOUR(0x66666566),
+	MKCOLOUR(0x66666665), // height 179
+	MKCOLOUR(0x66666665),
+	MKCOLOUR(0x66666666), // height 181
+	MKCOLOUR(0x66666666),
+	MKCOLOUR(0x66666667), // height 183
+	MKCOLOUR(0x66666667),
+	MKCOLOUR(0x66666766), // height 185
+	MKCOLOUR(0x66666766),
+	MKCOLOUR(0x66666767), // height 187
+	MKCOLOUR(0x66666767),
+	MKCOLOUR(0x66676666), // height 189
+	MKCOLOUR(0x66676666),
+	MKCOLOUR(0x66676667), // height 191
+	MKCOLOUR(0x66676667),
+	MKCOLOUR(0x66676766), // height 193
+	MKCOLOUR(0x66676766),
+	MKCOLOUR(0x66676767), // height 195
+	MKCOLOUR(0x66676767),
+	MKCOLOUR(0x67676767), // height 197
+	MKCOLOUR(0x67676767),
+	MKCOLOUR(0x67676767), // height 199
+	MKCOLOUR(0x67676767),
+	MKCOLOUR(0x67676767), // height 201
+	MKCOLOUR(0x67676767),
+	MKCOLOUR(0x67676767), // height 203
+	MKCOLOUR(0x67676767),
+	MKCOLOUR(0x67676767), // height 205
+	MKCOLOUR(0x67676767),
+	MKCOLOUR(0x67676767), // height 207
+	MKCOLOUR(0x67676767),
+	MKCOLOUR(0x67676767), // height 209
+	MKCOLOUR(0x67676767),
+	MKCOLOUR(0x67676767), // height 211
+	MKCOLOUR(0x67676767),
+	MKCOLOUR(0x67676767), // height 213
+	MKCOLOUR(0x67676767),
+	MKCOLOUR(0x67676767), // height 215
+	MKCOLOUR(0x67676767),
+	MKCOLOUR(0x67676767), // height 217
+	MKCOLOUR(0x67676767),
+	MKCOLOUR(0x67676767), // height 219
+	MKCOLOUR(0x67676767),
+	MKCOLOUR(0x67676767), // height 221
+	MKCOLOUR(0x67676767),
+	MKCOLOUR(0x67676767), // height 223
+	MKCOLOUR(0x67676767),
+	MKCOLOUR(0x67676767), // height 225
+	MKCOLOUR(0x67676767),
+	MKCOLOUR(0x67676767), // height 227
+	MKCOLOUR(0x67676767),
+	MKCOLOUR(0x67676767), // height 229
+	MKCOLOUR(0x67676767),
+	MKCOLOUR(0x1F27AF27), // height 231
+	MKCOLOUR(0x1F27AF27), // height 232
+	MKCOLOUR(0x1F274FAF), // height 233
+	MKCOLOUR(0x1F274FAF), // height 234
+	MKCOLOUR(0x4F274FAF), // height 235
+	MKCOLOUR(0x4F274FAF), // height 236
+	MKCOLOUR(0x4FAF1FAF), // height 237
+	MKCOLOUR(0x4FAF1FAF), // height 238
+	MKCOLOUR(0x4F2727AF), // height 239
+	MKCOLOUR(0x4F2727AF), // height 240
+	MKCOLOUR(0x4F27AF27), // height 241
+	MKCOLOUR(0x4F27AF27), // height 242
+	MKCOLOUR(0x4F27AFAF), // height 243
+	MKCOLOUR(0x4F27AFAF), // height 244
+	MKCOLOUR(0x4FAF2727), // height 245
+	MKCOLOUR(0x4FAF2727), // height 246
+	MKCOLOUR(0x4FAF27AF), // height 247
+	MKCOLOUR(0x4FAF27AF), // height 248
+	MKCOLOUR(0x4FAFAF27), // height 249
+	MKCOLOUR(0x4FAFAF27), // height 250
+	MKCOLOUR(0x4FAFAFAF), // height 251
+	MKCOLOUR(0x4FAFAFAF), // height 252
+	MKCOLOUR(0x4FAFAFCF), // height 253
+	MKCOLOUR(0x4FAFAFCF), // height 254
+	MKCOLOUR(0x4FAFCFAF), // height 255
 };
 assert_compile(lengthof(_dark_green_map_heights) == MAX_TILE_HEIGHT + 1);
 
 /** Height map colours for the violet colour scheme, ordered by height. */
 static const uint32 _violet_map_heights[] = {
-	MKCOLOUR_XXXX(0x80),
-	MKCOLOUR_XYXY(0x80, 0x81),
-	MKCOLOUR_XXXX(0x81),
-	MKCOLOUR_XYXY(0x81, 0x82),
-	MKCOLOUR_XXXX(0x82),
-	MKCOLOUR_XYXY(0x82, 0x83),
-	MKCOLOUR_XXXX(0x83),
-	MKCOLOUR_XYXY(0x83, 0x84),
-	MKCOLOUR_XXXX(0x84),
-	MKCOLOUR_XYXY(0x84, 0x85),
-	MKCOLOUR_XXXX(0x85),
-	MKCOLOUR_XYXY(0x85, 0x86),
-	MKCOLOUR_XXXX(0x86),
-	MKCOLOUR_XYXY(0x86, 0x87),
-	MKCOLOUR_XXXX(0x87),
-	MKCOLOUR_XXXX(0x87),
+	MKCOLOUR(0x80808080), // height 0
+	MKCOLOUR(0x80808080), // height 1
+	MKCOLOUR(0x80808080),
+	MKCOLOUR(0x80808081), // height 3
+	MKCOLOUR(0x80808081),
+	MKCOLOUR(0x80808180), // height 5
+	MKCOLOUR(0x80808180),
+	MKCOLOUR(0x80808181), // height 7
+	MKCOLOUR(0x80808181),
+	MKCOLOUR(0x80818080), // height 9
+	MKCOLOUR(0x80818080),
+	MKCOLOUR(0x80818081), // height 11
+	MKCOLOUR(0x80818081),
+	MKCOLOUR(0x80818180), // height 13
+	MKCOLOUR(0x80818180),
+	MKCOLOUR(0x80818181), // height 15
+	MKCOLOUR(0x80818181),
+	MKCOLOUR(0x81808080), // height 17
+	MKCOLOUR(0x81808080),
+	MKCOLOUR(0x81808081), // height 19
+	MKCOLOUR(0x81808081),
+	MKCOLOUR(0x81808180), // height 21
+	MKCOLOUR(0x81808180),
+	MKCOLOUR(0x81808181), // height 23
+	MKCOLOUR(0x81808181),
+	MKCOLOUR(0x81818080), // height 25
+	MKCOLOUR(0x81818080),
+	MKCOLOUR(0x81818081), // height 27
+	MKCOLOUR(0x81818081),
+	MKCOLOUR(0x81818180), // height 29
+	MKCOLOUR(0x81818180),
+	MKCOLOUR(0x81818181), // height 31
+	MKCOLOUR(0x81818181),
+	MKCOLOUR(0x81818182), // height 33
+	MKCOLOUR(0x81818182),
+	MKCOLOUR(0x81818281), // height 35
+	MKCOLOUR(0x81818281),
+	MKCOLOUR(0x81818282), // height 37
+	MKCOLOUR(0x81818282),
+	MKCOLOUR(0x81828181), // height 39
+	MKCOLOUR(0x81828181),
+	MKCOLOUR(0x81828182), // height 41
+	MKCOLOUR(0x81828182),
+	MKCOLOUR(0x81828281), // height 43
+	MKCOLOUR(0x81828281),
+	MKCOLOUR(0x81828282), // height 45
+	MKCOLOUR(0x81828282),
+	MKCOLOUR(0x82818181), // height 47
+	MKCOLOUR(0x82818181),
+	MKCOLOUR(0x82818182), // height 49
+	MKCOLOUR(0x82818182),
+	MKCOLOUR(0x82818281), // height 51
+	MKCOLOUR(0x82818281),
+	MKCOLOUR(0x82818282), // height 53
+	MKCOLOUR(0x82818282),
+	MKCOLOUR(0x82828181), // height 55
+	MKCOLOUR(0x82828181),
+	MKCOLOUR(0x82828182), // height 57
+	MKCOLOUR(0x82828182),
+	MKCOLOUR(0x82828281), // height 59
+	MKCOLOUR(0x82828281),
+	MKCOLOUR(0x82828282), // height 61
+	MKCOLOUR(0x82828282),
+	MKCOLOUR(0x82828283), // height 63
+	MKCOLOUR(0x82828283),
+	MKCOLOUR(0x82828382), // height 65
+	MKCOLOUR(0x82828382),
+	MKCOLOUR(0x82828383), // height 67
+	MKCOLOUR(0x82828383),
+	MKCOLOUR(0x82838282), // height 69
+	MKCOLOUR(0x82838282),
+	MKCOLOUR(0x82838283), // height 71
+	MKCOLOUR(0x82838283),
+	MKCOLOUR(0x82838382), // height 73
+	MKCOLOUR(0x82838382),
+	MKCOLOUR(0x82838383), // height 75
+	MKCOLOUR(0x82838383),
+	MKCOLOUR(0x83828282), // height 77
+	MKCOLOUR(0x83828282),
+	MKCOLOUR(0x83828283), // height 79
+	MKCOLOUR(0x83828283),
+	MKCOLOUR(0x83828382), // height 81
+	MKCOLOUR(0x83828382),
+	MKCOLOUR(0x83828383), // height 83
+	MKCOLOUR(0x83828383),
+	MKCOLOUR(0x83838282), // height 85
+	MKCOLOUR(0x83838282),
+	MKCOLOUR(0x83838283), // height 87
+	MKCOLOUR(0x83838283),
+	MKCOLOUR(0x83838382), // height 89
+	MKCOLOUR(0x83838382),
+	MKCOLOUR(0x83838383), // height 91
+	MKCOLOUR(0x83838383),
+	MKCOLOUR(0x83838384), // height 93
+	MKCOLOUR(0x83838384),
+	MKCOLOUR(0x83838483), // height 95
+	MKCOLOUR(0x83838483),
+	MKCOLOUR(0x83838484), // height 97
+	MKCOLOUR(0x83838484),
+	MKCOLOUR(0x83848383), // height 99
+	MKCOLOUR(0x83848383),
+	MKCOLOUR(0x83848384), // height 101
+	MKCOLOUR(0x83848384),
+	MKCOLOUR(0x83848483), // height 103
+	MKCOLOUR(0x83848483),
+	MKCOLOUR(0x83848484), // height 105
+	MKCOLOUR(0x83848484),
+	MKCOLOUR(0x84838383), // height 107
+	MKCOLOUR(0x84838383),
+	MKCOLOUR(0x84838384), // height 109
+	MKCOLOUR(0x84838384),
+	MKCOLOUR(0x84838483), // height 111
+	MKCOLOUR(0x84838483),
+	MKCOLOUR(0x84838484), // height 113
+	MKCOLOUR(0x84838484),
+	MKCOLOUR(0x84848383), // height 115
+	MKCOLOUR(0x84848383),
+	MKCOLOUR(0x84848384), // height 117
+	MKCOLOUR(0x84848384),
+	MKCOLOUR(0x84848483), // height 119
+	MKCOLOUR(0x84848483),
+	MKCOLOUR(0x84848484), // height 121
+	MKCOLOUR(0x84848484),
+	MKCOLOUR(0x84848485), // height 123
+	MKCOLOUR(0x84848485),
+	MKCOLOUR(0x84848584), // height 125
+	MKCOLOUR(0x84848584),
+	MKCOLOUR(0x84848585), // height 127
+	MKCOLOUR(0x84848585),
+	MKCOLOUR(0x84858484), // height 129
+	MKCOLOUR(0x84858484),
+	MKCOLOUR(0x84858485), // height 131
+	MKCOLOUR(0x84858485),
+	MKCOLOUR(0x84858584), // height 133
+	MKCOLOUR(0x84858584),
+	MKCOLOUR(0x84858585), // height 135
+	MKCOLOUR(0x84858585),
+	MKCOLOUR(0x85848484), // height 137
+	MKCOLOUR(0x85848484),
+	MKCOLOUR(0x85848485), // height 139
+	MKCOLOUR(0x85848485),
+	MKCOLOUR(0x85848584), // height 141
+	MKCOLOUR(0x85848584),
+	MKCOLOUR(0x85848585), // height 143
+	MKCOLOUR(0x85848585),
+	MKCOLOUR(0x85858484), // height 145
+	MKCOLOUR(0x85858484),
+	MKCOLOUR(0x85858485), // height 147
+	MKCOLOUR(0x85858485),
+	MKCOLOUR(0x85858584), // height 149
+	MKCOLOUR(0x85858584),
+	MKCOLOUR(0x85858585), // height 151
+	MKCOLOUR(0x85858585),
+	MKCOLOUR(0x85858586), // height 153
+	MKCOLOUR(0x85858586),
+	MKCOLOUR(0x85858685), // height 155
+	MKCOLOUR(0x85858685),
+	MKCOLOUR(0x85858686), // height 157
+	MKCOLOUR(0x85858686),
+	MKCOLOUR(0x85868585), // height 159
+	MKCOLOUR(0x85868585),
+	MKCOLOUR(0x85868586), // height 161
+	MKCOLOUR(0x85868586),
+	MKCOLOUR(0x85868685), // height 163
+	MKCOLOUR(0x85868685),
+	MKCOLOUR(0x85868686), // height 165
+	MKCOLOUR(0x85868686),
+	MKCOLOUR(0x85868585), // height 167
+	MKCOLOUR(0x85868585),
+	MKCOLOUR(0x85868586), // height 169
+	MKCOLOUR(0x85868586),
+	MKCOLOUR(0x85868685), // height 171
+	MKCOLOUR(0x85868685),
+	MKCOLOUR(0x85868686), // height 173
+	MKCOLOUR(0x85868686),
+	MKCOLOUR(0x86868585), // height 175
+	MKCOLOUR(0x86868585),
+	MKCOLOUR(0x86868586), // height 177
+	MKCOLOUR(0x86868586),
+	MKCOLOUR(0x86868685), // height 179
+	MKCOLOUR(0x86868685),
+	MKCOLOUR(0x86868686), // height 181
+	MKCOLOUR(0x86868686),
+	MKCOLOUR(0x86868687), // height 183
+	MKCOLOUR(0x86868687),
+	MKCOLOUR(0x86868786), // height 185
+	MKCOLOUR(0x86868786),
+	MKCOLOUR(0x86868787), // height 187
+	MKCOLOUR(0x86868787),
+	MKCOLOUR(0x86878686), // height 189
+	MKCOLOUR(0x86878686),
+	MKCOLOUR(0x86878687), // height 191
+	MKCOLOUR(0x86878687),
+	MKCOLOUR(0x86878786), // height 193
+	MKCOLOUR(0x86878786),
+	MKCOLOUR(0x86878787), // height 195
+	MKCOLOUR(0x86878787),
+	MKCOLOUR(0x87868686), // height 197
+	MKCOLOUR(0x87868686),
+	MKCOLOUR(0x87868687), // height 199
+	MKCOLOUR(0x87868687),
+	MKCOLOUR(0x87868786), // height 201
+	MKCOLOUR(0x87868786),
+	MKCOLOUR(0x87868787), // height 203
+	MKCOLOUR(0x87868787),
+	MKCOLOUR(0x87878686), // height 205
+	MKCOLOUR(0x87878686),
+	MKCOLOUR(0x87878687), // height 207
+	MKCOLOUR(0x87878687),
+	MKCOLOUR(0x87878786), // height 209
+	MKCOLOUR(0x87878786),
+	MKCOLOUR(0x87878787), // height 211
+	MKCOLOUR(0x87878787),
+	MKCOLOUR(0x87878787), // height 213
+	MKCOLOUR(0x87878787),
+	MKCOLOUR(0x87878787), // height 215
+	MKCOLOUR(0x87878787),
+	MKCOLOUR(0x87878787), // height 217
+	MKCOLOUR(0x87878787),
+	MKCOLOUR(0x87878787), // height 219
+	MKCOLOUR(0x87878787),
+	MKCOLOUR(0x87878787), // height 221
+	MKCOLOUR(0x87878787),
+	MKCOLOUR(0x87878787), // height 223
+	MKCOLOUR(0x87878787),
+	MKCOLOUR(0x87878787), // height 225
+	MKCOLOUR(0x87878787),
+	MKCOLOUR(0x87878787), // height 227
+	MKCOLOUR(0x87878787),
+	MKCOLOUR(0x87878787), // height 229
+	MKCOLOUR(0x87878787),
+	MKCOLOUR(0x1F27AF27), // height 231
+	MKCOLOUR(0x1F27AF27), // height 232
+	MKCOLOUR(0x1F274FAF), // height 233
+	MKCOLOUR(0x1F274FAF), // height 234
+	MKCOLOUR(0x4F274FAF), // height 235
+	MKCOLOUR(0x4F274FAF), // height 236
+	MKCOLOUR(0x4FAF1FAF), // height 237
+	MKCOLOUR(0x4FAF1FAF), // height 238
+	MKCOLOUR(0x4F2727AF), // height 239
+	MKCOLOUR(0x4F2727AF), // height 240
+	MKCOLOUR(0x4F27AF27), // height 241
+	MKCOLOUR(0x4F27AF27), // height 242
+	MKCOLOUR(0x4F27AFAF), // height 243
+	MKCOLOUR(0x4F27AFAF), // height 244
+	MKCOLOUR(0x4FAF2727), // height 245
+	MKCOLOUR(0x4FAF2727), // height 246
+	MKCOLOUR(0x4FAF27AF), // height 247
+	MKCOLOUR(0x4FAF27AF), // height 248
+	MKCOLOUR(0x4FAFAF27), // height 249
+	MKCOLOUR(0x4FAFAF27), // height 250
+	MKCOLOUR(0x4FAFAFAF), // height 251
+	MKCOLOUR(0x4FAFAFAF), // height 252
+	MKCOLOUR(0x4FAFAFCF), // height 253
+	MKCOLOUR(0x4FAFAFCF), // height 254
+	MKCOLOUR(0x4FAFCFAF), // height 255
 };
 assert_compile(lengthof(_violet_map_heights) == MAX_TILE_HEIGHT + 1);
 
@@ -464,9 +1240,10 @@
  *
  * @param tile The tile of which we would like to get the colour.
  * @param t    Effective tile type of the tile (see #GetEffectiveTileType).
+ * @param show_height Whether to show the height of plain tiles.
  * @return The colour of tile  in the small map in mode "Routes"
  */
-static inline uint32 GetSmallMapRoutesPixels(TileIndex tile, TileType t)
+static inline uint32 GetSmallMapRoutesPixels(TileIndex tile, TileType t, bool show_height = false)
 {
 	if (t == MP_STATION) {
 		switch (GetStationType(tile)) {
@@ -489,7 +1266,7 @@
 
 	/* Ground colour */
 	const SmallMapColourScheme *cs = &_heightmap_schemes[_settings_client.gui.smallmap_land_colour];
-	return ApplyMask(cs->default_colour, &_smallmap_contours_andor[t]);
+	return ApplyMask(show_height ? cs->height_colours[TileHeight(tile)] : cs->default_colour, &_smallmap_contours_andor[t]);
 }
 
 
@@ -576,6 +1353,7 @@
 		SMT_CONTOUR,
 		SMT_VEHICLES,
 		SMT_INDUSTRY,
+		SMT_ROUTE_LINKS,
 		SMT_ROUTES,
 		SMT_VEGETATION,
 		SMT_OWNER,
@@ -774,6 +1552,9 @@
 			case SMT_INDUSTRY:
 				return GetSmallMapIndustriesPixels(tile, et);
 
+			case SMT_ROUTE_LINKS:
+				return GetSmallMapRoutesPixels(tile, et, _smallmap_show_heightmap);
+
 			case SMT_ROUTES:
 				return GetSmallMapRoutesPixels(tile, et);
 
@@ -901,6 +1682,110 @@
 	}
 
 	/**
+	 * Adds the route links to the smallmap.
+	 */
+	void DrawRouteLinks() const
+	{
+		/* Iterate all shown cargo types. */
+		for (int i = 0; i < _smallmap_cargo_count; i++) {
+			if (_legend_from_cargoes[i].show_on_map) {
+				CargoID cid = _legend_from_cargoes[i].cid;
+
+				/* Iterate all stations. */
+				const Station *st;
+				FOR_ALL_STATIONS(st) {
+					Point src_pt = this->RemapTile(TileX(st->xy), TileY(st->xy));
+					src_pt.x -= this->subscroll;
+
+					/* Collect waiting cargo per destination station. */
+					std::map<StationID, uint> links;
+					for (RouteLinkList::const_iterator l = st->goods[cid].routes.begin(); l != st->goods[cid].routes.end(); ++l) {
+						if (IsInteractiveCompany((*l)->GetOwner())) links[(*l)->GetDestination()] += st->goods[cid].cargo.CountForNextHop((*l)->GetOriginOrderId());
+					}
+
+					/* Add cargo count on back-links. */
+					for (std::map<StationID, uint>::iterator itr = links.begin(); itr != links.end(); ++itr) {
+						/* Get destination location. */
+						const Station *dest = Station::Get(itr->first);
+						Point dest_pt = this->RemapTile(TileX(dest->xy), TileY(dest->xy));
+						dest_pt.x -= this->subscroll;
+
+						/* Get total count including back-links. */
+						uint count = itr->second;
+						for (RouteLinkList::const_iterator j = dest->goods[cid].routes.begin(); j != dest->goods[cid].routes.end(); ++j) {
+							if ((*j)->GetDestination() == st->index && IsInteractiveCompany((*j)->GetOwner())) count += dest->goods[cid].cargo.CountForNextHop((*j)->GetOriginOrderId());
+						}
+
+						/* Calculate line size from waiting cargo. */
+						int size = 1;
+						if (count >= 400) size++;
+						if (count >= 800) size++;
+						if (count >= 1600) size++;
+						if (count >= 3200) size++;
+
+						/* Draw black border and cargo coloured line. */
+						GfxDrawLine(src_pt.x, src_pt.y, dest_pt.x, dest_pt.y, PC_BLACK, size + 2);
+						GfxDrawLine(src_pt.x, src_pt.y, dest_pt.x, dest_pt.y, _legend_from_cargoes[i].colour, size);
+					}
+				}
+			}
+		}
+
+		/* Draw station rect. */
+		const Station *st;
+		FOR_ALL_STATIONS(st) {
+			/* Count total cargo and check for links for all shown cargo types. */
+			uint total = 0;
+			bool show = false;
+			for (CargoID cid = 0; cid < NUM_CARGO; cid++) {
+				if (_legend_from_cargoes[_cargotype_to_list_pos[cid]].show_on_map) {
+					total += st->goods[cid].cargo.Count();
+					show |= !st->goods[cid].routes.empty();
+				}
+			}
+
+			if (!show) continue;
+
+			/* Get rect size from total cargo count. */
+			int d = 1;
+			if (total >= 200) d++;
+			if (total >= 400) d++;
+			if (total >= 800) d++;
+			if (total >= 1600) d++;
+			if (total >= 3200) d++;
+			if (total >= 6400) d++;
+
+			/* Get top-left corner of the rect. */
+			Point dest_pt = this->RemapTile(TileX(st->xy), TileY(st->xy));
+			dest_pt.x -= this->subscroll + d/2;
+			dest_pt.y -= d/2;
+
+			/* Draw black border and company-colour inset. */
+			byte colour = _colour_gradient[Company::IsValidID(st->owner) ? Company::Get(st->owner)->colour : (byte)COLOUR_GREY][6];
+			GfxFillRect(dest_pt.x - 1, dest_pt.y - 1, dest_pt.x + d + 1, dest_pt.y + d + 1, PC_BLACK); // Draw black frame
+			GfxFillRect(dest_pt.x, dest_pt.y, dest_pt.x + d, dest_pt.y + d, colour); // Draw colour insert
+		}
+	}
+
+	Point GetSmallMapCoordIncludingHeight(Point viewport_coord) const
+	{
+		/* First find out which tile would be there if we ignore height */
+		Point pt = InverseRemapCoords(viewport_coord.x, viewport_coord.y);
+		Point pt_without_height = {pt.x / TILE_SIZE, pt.y / TILE_SIZE};
+
+		/* Problem: There are mountains.  So the tile actually displayed at the given position
+		 * might be the high mountain of 30 tiles south.
+		 * Unfortunately, there is no closed formula for finding such a tile.
+		 * We call GetRowAtTile originally implemented for the viewport code, which performs
+		 * a interval search.  For details, see its documentation. */
+		int row_without_height = pt_without_height.x + pt_without_height.y;
+		int row_with_height = GetRowAtTile(viewport_coord.y, pt_without_height);
+		int row_offset = row_with_height - row_without_height;
+		Point pt_with_height = {pt_without_height.x + row_offset / 2, pt_without_height.y + row_offset / 2};
+		return pt_with_height;
+	}
+
+	/**
 	 * Draws vertical part of map indicator
 	 * @param x X coord of left/right border of main viewport
 	 * @param y Y coord of top border of main viewport
@@ -932,19 +1817,23 @@
 		/* Find main viewport. */
 		const ViewPort *vp = FindWindowById(WC_MAIN_WINDOW, 0)->viewport;
 
-		Point tile = InverseRemapCoords(vp->virtual_left, vp->virtual_top);
-		Point tl = this->RemapTile(tile.x >> 4, tile.y >> 4);
-		tl.x -= this->subscroll;
+		Point upper_left_viewport_coord = {vp->virtual_left, vp->virtual_top};
+		Point upper_left_small_map_coord = GetSmallMapCoordIncludingHeight(upper_left_viewport_coord);
+		Point upper_left = this->RemapTile(upper_left_small_map_coord.x, upper_left_small_map_coord.y);
+		/* why do we do this? in my tests subscroll was zero */
+		upper_left.x -= this->subscroll;
 
-		tile = InverseRemapCoords(vp->virtual_left + vp->virtual_width, vp->virtual_top + vp->virtual_height);
-		Point br = this->RemapTile(tile.x >> 4, tile.y >> 4);
-		br.x -= this->subscroll;
+		Point lower_right_viewport_coord = {vp->virtual_left + vp->virtual_width, vp->virtual_top + vp->virtual_height};
+		Point lower_right_smallmap_coord = GetSmallMapCoordIncludingHeight(lower_right_viewport_coord);
+		Point lower_right = this->RemapTile(lower_right_smallmap_coord.x, lower_right_smallmap_coord.y);
+		/* why do we do this? in my tests subscroll was zero */
+		lower_right.x -= this->subscroll;
 
-		SmallMapWindow::DrawVertMapIndicator(tl.x, tl.y, br.y);
-		SmallMapWindow::DrawVertMapIndicator(br.x, tl.y, br.y);
+		SmallMapWindow::DrawVertMapIndicator(upper_left.x, upper_left.y, lower_right.y);
+		SmallMapWindow::DrawVertMapIndicator(lower_right.x, upper_left.y, lower_right.y);
 
-		SmallMapWindow::DrawHorizMapIndicator(tl.x, br.x, tl.y);
-		SmallMapWindow::DrawHorizMapIndicator(tl.x, br.x, br.y);
+		SmallMapWindow::DrawHorizMapIndicator(upper_left.x, lower_right.x, upper_left.y);
+		SmallMapWindow::DrawHorizMapIndicator(upper_left.x, lower_right.x, lower_right.y);
 	}
 
 	/**
@@ -1007,6 +1896,9 @@
 		/* Draw vehicles */
 		if (this->map_type == SMT_CONTOUR || this->map_type == SMT_VEHICLES) this->DrawVehicles(dpi, blitter);
 
+		/* Draw route links. */
+		if (this->map_type == SMT_ROUTE_LINKS) this->DrawRouteLinks();
+
 		/* Draw town names */
 		if (this->show_towns) this->DrawTowns(dpi);
 
@@ -1040,6 +1932,13 @@
 				plane = 0;
 				break;
 
+			case SMT_ROUTE_LINKS:
+				legend_tooltip = STR_SMALLMAP_TOOLTIP_ROUTELINK_SELECTION;
+				enable_all_tooltip = STR_SMALLMAP_TOOLTIP_ENABLE_ALL_ROUTELINKS;
+				disable_all_tooltip = STR_SMALLMAP_TOOLTIP_DISABLE_ALL_ROUTELINKS;
+				plane = 0;
+				break;
+
 			default:
 				legend_tooltip = STR_NULL;
 				enable_all_tooltip = STR_NULL;
@@ -1140,6 +2039,9 @@
 					} else {
 						str = tbl->legend;
 					}
+				} else if (i == SMT_ROUTE_LINKS) {
+					SetDParam(0, tbl->legend);
+					str = STR_SMALLMAP_CARGO;
 				} else {
 					if (tbl->col_break) {
 						this->min_number_of_fixed_rows = max(this->min_number_of_fixed_rows, height);
@@ -1187,7 +2089,7 @@
 
 			case WID_SM_LEGEND: {
 				uint columns = this->GetNumberColumnsLegend(r.right - r.left + 1);
-				uint number_of_rows = max((this->map_type == SMT_INDUSTRY || this->map_type == SMT_OWNER) ? CeilDiv(max(_smallmap_company_count, _smallmap_industry_count), columns) : 0, this->min_number_of_fixed_rows);
+				uint number_of_rows = max((this->map_type == SMT_INDUSTRY || this->map_type == SMT_OWNER || this->map_type == SMT_ROUTE_LINKS) ? CeilDiv(max(_smallmap_company_count, max(_smallmap_industry_count, _smallmap_cargo_count)), columns) : 0, this->min_number_of_fixed_rows);
 				bool rtl = _current_text_dir == TD_RTL;
 				uint y_org = r.top + WD_FRAMERECT_TOP;
 				uint x = rtl ? r.right - this->column_width - WD_FRAMERECT_RIGHT : r.left + WD_FRAMERECT_LEFT;
@@ -1201,7 +2103,7 @@
 				uint blob_right = rtl ? this->column_width - 1 : LEGEND_BLOB_WIDTH;
 
 				for (const LegendAndColour *tbl = _legend_table[this->map_type]; !tbl->end; ++tbl) {
-					if (tbl->col_break || ((this->map_type == SMT_INDUSTRY || this->map_type == SMT_OWNER) && i++ >= number_of_rows)) {
+					if (tbl->col_break || ((this->map_type == SMT_INDUSTRY || this->map_type == SMT_OWNER || this->map_type == SMT_ROUTE_LINKS) && i++ >= number_of_rows)) {
 						/* Column break needed, continue at top, COLUMN_WIDTH pixels
 						 * (one "row") to the right. */
 						x += rtl ? -(int)this->column_width : this->column_width;
@@ -1227,6 +2129,16 @@
 							DrawString(x + text_left, x + text_right, y, STR_SMALLMAP_INDUSTRY, TC_BLACK);
 							GfxFillRect(x + blob_left, y + 1, x + blob_right, y + row_height - 1, PC_BLACK); // Outer border of the legend colour
 						}
+					} else if (this->map_type == SMT_ROUTE_LINKS) {
+						/* Cargo name needs formatting for tiny font. */
+						SetDParam(0, tbl->legend);
+						if (!tbl->show_on_map) {
+							/* Draw only the string and not the border of the legend colour. */
+							DrawString(x + text_left, x + text_right, y, STR_SMALLMAP_CARGO, TC_GREY);
+						} else {
+							DrawString(x + text_left, x + text_right, y, STR_SMALLMAP_CARGO, TC_BLACK);
+							GfxFillRect(x + blob_left, y + 1, x + blob_right, y + row_height - 1, PC_BLACK); // Outer border of the legend colour
+						}
 					} else if (this->map_type == SMT_OWNER && tbl->company != INVALID_COMPANY) {
 						SetDParam(0, tbl->company);
 						if (!tbl->show_on_map) {
@@ -1277,7 +2189,7 @@
 		const NWidgetBase *wi = this->GetWidget<NWidgetBase>(WID_SM_LEGEND);
 		uint line = (pt.y - wi->pos_y - WD_FRAMERECT_TOP) / FONT_HEIGHT_SMALL;
 		uint columns = this->GetNumberColumnsLegend(wi->current_x);
-		uint number_of_rows = max(CeilDiv(max(_smallmap_company_count, _smallmap_industry_count), columns), this->min_number_of_fixed_rows);
+		uint number_of_rows = max(CeilDiv(max(_smallmap_company_count, max(_smallmap_industry_count, _smallmap_cargo_count)), columns), this->min_number_of_fixed_rows);
 		if (line >= number_of_rows) return -1;
 
 		bool rtl = _current_text_dir == TD_RTL;
@@ -1329,6 +2241,18 @@
 				pt = RemapCoords(this->scroll_x + pt.x * TILE_SIZE + this->zoom * (TILE_SIZE - sub * TILE_SIZE / 4),
 						this->scroll_y + pt.y * TILE_SIZE + sub * this->zoom * TILE_SIZE / 4, 0);
 
+				/* correct y coordinate according to the height level at the chosen tile
+				 * - so far we assumed height zero.  Calculations here according to
+				 * TranslateXYToTileCoord in viewport.cpp */
+				Point pt_scaled = {pt.x / (int)(4 * TILE_SIZE), pt.y / (int)(2 * TILE_SIZE)};
+				Point tile_coord = {pt_scaled.y - pt_scaled.x, pt_scaled.y + pt_scaled.x};
+
+				if (tile_coord.x >= 0 && tile_coord.y >= 0
+				 && tile_coord.x < (int)MapMaxX() && tile_coord.y < (int)MapMaxY()) {
+					int clicked_tile_height = TileHeight(TileXY(tile_coord.x, tile_coord.y));
+					pt.y -= clicked_tile_height * TILE_HEIGHT;
+				}
+
 				w->viewport->follow_vehicle = INVALID_VEHICLE;
 				w->viewport->dest_scrollpos_x = pt.x - (w->viewport->virtual_width  >> 1);
 				w->viewport->dest_scrollpos_y = pt.y - (w->viewport->virtual_height >> 1);
@@ -1349,6 +2273,7 @@
 			case WID_SM_CONTOUR:    // Show land contours
 			case WID_SM_VEHICLES:   // Show vehicles
 			case WID_SM_INDUSTRIES: // Show industries
+			case WID_SM_ROUTE_LINKS:// Show route links
 			case WID_SM_ROUTES:     // Show transport routes
 			case WID_SM_VEGETATION: // Show vegetation
 			case WID_SM_OWNERS:     // Show land owners
@@ -1371,7 +2296,7 @@
 				break;
 
 			case WID_SM_LEGEND: // Legend
-				if (this->map_type == SMT_INDUSTRY || this->map_type == SMT_OWNER) {
+				if (this->map_type == SMT_INDUSTRY || this->map_type == SMT_OWNER || this->map_type == SMT_ROUTE_LINKS) {
 					/* If industry type small map*/
 					if (this->map_type == SMT_INDUSTRY) {
 						/* If click on industries label, find right industry type and enable/disable it. */
@@ -1422,6 +2347,30 @@
 								_legend_land_owners[company_pos].show_on_map = !_legend_land_owners[company_pos].show_on_map;
 							}
 						}
+					} else if (this->map_type == SMT_ROUTE_LINKS) {
+						/* If click on cargo label, find right cargo type and enable/disable it. */
+						int cargo_pos = GetPositionOnLegend(pt);
+						if (cargo_pos < _smallmap_cargo_count) {
+							if (_ctrl_pressed) {
+								/* Disable all, except the clicked one */
+								bool changes = false;
+								for (int i = 0; i != _smallmap_cargo_count; i++) {
+									bool new_state = i == cargo_pos;
+									if (_legend_from_cargoes[i].show_on_map != new_state) {
+										changes = true;
+										_legend_from_cargoes[i].show_on_map = new_state;
+									}
+								}
+								if (!changes) {
+									/* Nothing changed? Then show all (again). */
+									for (int i = 0; i != _smallmap_cargo_count; i++) {
+										_legend_from_cargoes[i].show_on_map = true;
+									}
+								}
+							} else {
+								_legend_from_cargoes[cargo_pos].show_on_map = !_legend_from_cargoes[cargo_pos].show_on_map;
+							}
+						}
 					}
 					this->SetDirty();
 				}
@@ -1436,6 +2385,10 @@
 					for (int i = NUM_NO_COMPANY_ENTRIES; i != _smallmap_company_count; i++) {
 						_legend_land_owners[i].show_on_map = true;
 					}
+				} else if (this->map_type == SMT_ROUTE_LINKS) {
+					for (int i = 0; i != _smallmap_cargo_count; i++) {
+						_legend_from_cargoes[i].show_on_map = true;
+					}
 				}
 				this->SetDirty();
 				break;
@@ -1445,10 +2398,14 @@
 					for (int i = 0; i != _smallmap_industry_count; i++) {
 						_legend_from_industries[i].show_on_map = false;
 					}
-				} else {
+				} else if (this->map_type == SMT_OWNER) {
 					for (int i = NUM_NO_COMPANY_ENTRIES; i != _smallmap_company_count; i++) {
 						_legend_land_owners[i].show_on_map = false;
 					}
+				} else if (this->map_type == SMT_ROUTE_LINKS) {
+					for (int i = 0; i != _smallmap_cargo_count; i++) {
+						_legend_from_cargoes[i].show_on_map = false;
+					}
 				}
 				this->SetDirty();
 				break;
@@ -1574,12 +2531,19 @@
 
 	void SmallMapCenterOnCurrentPos()
 	{
+		/* Goal: Given the viewport coordinates of the middle of the map window, find
+		 * out which tile is displayed there. */
+
+		/* First find out which tile would be there if we ignore height */
 		const ViewPort *vp = FindWindowById(WC_MAIN_WINDOW, 0)->viewport;
-		Point pt = InverseRemapCoords(vp->virtual_left + vp->virtual_width  / 2, vp->virtual_top  + vp->virtual_height / 2);
+		Point viewport_center = {vp->virtual_left + vp->virtual_width  / 2, vp->virtual_top  + vp->virtual_height / 2};
+		Point pt_with_height = GetSmallMapCoordIncludingHeight(viewport_center);
 
+		/* And finally scroll to that position. */
 		int sub;
 		const NWidgetBase *wid = this->GetWidget<NWidgetBase>(WID_SM_MAP);
-		Point sxy = this->ComputeScroll(pt.x / TILE_SIZE, pt.y / TILE_SIZE, max(0, (int)wid->current_x / 2 - 2), wid->current_y / 2, &sub);
+		Point sxy = this->ComputeScroll(pt_with_height.x, pt_with_height.y,
+				max(0, (int)wid->current_x / 2 - 2), wid->current_y / 2, &sub);
 		this->SetNewScroll(sxy.x, sxy.y, sub);
 		this->SetDirty();
 	}
@@ -1686,6 +2650,8 @@
 							SetDataTip(SPR_IMG_SHOW_VEHICLES, STR_SMALLMAP_TOOLTIP_SHOW_VEHICLES_ON_MAP), SetFill(1, 1),
 					NWidget(WWT_IMGBTN, COLOUR_BROWN, WID_SM_INDUSTRIES),
 							SetDataTip(SPR_IMG_INDUSTRY, STR_SMALLMAP_TOOLTIP_SHOW_INDUSTRIES_ON_MAP), SetFill(1, 1),
+					NWidget(WWT_IMGBTN, COLOUR_BROWN, WID_SM_ROUTE_LINKS),
+							SetDataTip(SPR_IMG_SHOW_ROUTES, STR_SMALLMAP_TOOLTIP_SHOW_ROUTE_LINKS_ON_MAP), SetFill(1, 1),
 				EndContainer(),
 				/* Bottom button row. */
 				NWidget(NWID_HORIZONTAL, NC_EQUALSIZE),
diff -urNad openttd-1.3.2/src/smallmap_gui.h openttd-1.3.2-DC3.0RC3/src/smallmap_gui.h
--- openttd-1.3.2/src/smallmap_gui.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/smallmap_gui.h	2013-11-22 05:49:07.000000000 +0100
@@ -13,6 +13,7 @@
 #define SMALLMAP_GUI_H
 
 void BuildIndustriesLegend();
+void BuildCargoTypesLegend();
 void ShowSmallMap();
 void BuildLandLegend();
 void BuildOwnerLegend();
diff -urNad openttd-1.3.2/src/station_base.h openttd-1.3.2-DC3.0RC3/src/station_base.h
--- openttd-1.3.2/src/station_base.h	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/station_base.h	2013-11-22 05:49:07.000000000 +0100
@@ -17,12 +17,19 @@
 #include "cargopacket.h"
 #include "industry_type.h"
 #include "newgrf_storage.h"
+#include "cargodest_type.h"
+#include "core/smallvec_type.hpp"
+#include <map>
+#include <set>
 
 typedef Pool<BaseStation, StationID, 32, 64000> StationPool;
 extern StationPool _station_pool;
 
 static const byte INITIAL_STATION_RATING = 175;
 
+/** List of RouteLinks. */
+typedef std::list<RouteLink *> RouteLinkList;
+
 /**
  * Stores station stats for a single cargo.
  */
@@ -74,7 +81,8 @@
 		time_since_pickup(255),
 		rating(INITIAL_STATION_RATING),
 		last_speed(0),
-		last_age(255)
+		last_age(255),
+		cargo_counter(0)
 	{}
 
 	byte acceptance_pickup; ///< Status of this cargo, see #GoodsEntryStatus.
@@ -106,7 +114,9 @@
 	byte last_age;
 
 	byte amount_fract;      ///< Fractional part of the amount in the cargo list
+	uint16 cargo_counter;   ///< Update timer for the packets' next hop
 	StationCargoList cargo; ///< The cargo packets of cargo waiting in this station
+	RouteLinkList routes;   ///< List of originating route links
 
 	/**
 	 * Reports whether a vehicle has ever tried to load the cargo at this station.
@@ -116,11 +126,32 @@
 	bool HasVehicleEverTriedLoading() const { return this->last_speed != 0; }
 };
 
+enum CatchmentType {
+	ACCEPTANCE = 0,
+	PRODUCTION = 1,
+	INDUSTRY = 2
+};
+
+struct StationCatchment {
+	std::map<TileIndex, std::set<TileIndex> > catchmentTiles;
+public:
+	StationCatchment();
+	void MakeEmpty();
+	bool IsTileInCatchment(TileIndex tile) const;
+	bool IsEmpty() const;
+	void BeforeAddTile(TileIndex tile, uint catchmentRadius);
+	void BeforeAddRect(TileIndex tile, int w, int h, uint catchmentRadius);
+	void AfterRemoveTile(TileIndex tile, uint catchmentRadius);
+	void AfterRemoveRect(TileIndex tile, int w, int h, uint catchmentRadius);
+};
+
 /** All airport-related information. Only valid if tile != INVALID_TILE. */
 struct Airport : public TileArea {
 	Airport() : TileArea(INVALID_TILE, 0, 0) {}
 
 	uint64 flags;       ///< stores which blocks on the airport are taken. was 16 bit earlier on, then 32
+        uint64 flags2;      ///< additional stores which blocks on the airport are taken.
+        byte num_circle;    ///< stores how many aircrafts are in circle area of airport
 	byte type;          ///< Type of this airport, @see AirportTypes
 	byte layout;        ///< Airport layout number.
 	Direction rotation; ///< How this airport is rotated.
@@ -236,6 +267,12 @@
 		return num;
 	}
 
+	/** Get the number of hangars on this airport. */
+	inline byte GetMaxCircle(TileIndex tile) const
+	{
+		return this->GetSpec()->max_circle;
+	}
+
 private:
 	/**
 	 * Retrieve hangar information of a hangar at a given tile.
@@ -289,11 +326,14 @@
 
 	IndustryVector industries_near; ///< Cached list of industries near the station that can accept cargo, @see DeliverGoodsToIndustry()
 
+	StationCatchment catchment;
+
 	Station(TileIndex tile = INVALID_TILE);
 	~Station();
 
 	void AddFacility(StationFacility new_facility_bit, TileIndex facil_xy);
-
+	void ChangeAcceptance(CargoID cargo_type, bool waiting);
+	
 	void MarkTilesDirty(bool cargo_change) const;
 
 	void UpdateVirtCoord();
@@ -304,6 +344,11 @@
 	static void RecomputeIndustriesNearForAll();
 
 	uint GetCatchmentRadius() const;
+
+	bool IsTileInCatchmentArea(const TileInfo* ti, CatchmentType type) const;
+
+	void MarkAcceptanceTilesDirty() const;
+
 	Rect GetCatchmentRect() const;
 
 	/* virtual */ inline bool TileBelongsToRailStation(TileIndex tile) const
diff -urNad openttd-1.3.2/src/station_cmd.cpp openttd-1.3.2-DC3.0RC3/src/station_cmd.cpp
--- openttd-1.3.2/src/station_cmd.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/station_cmd.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -13,6 +13,9 @@
 #include "aircraft.h"
 #include "bridge_map.h"
 #include "cmd_helper.h"
+#include "copypaste_cmd.h"
+#include "clipboard_func.h"
+#include "clipboard_gui.h"
 #include "viewport_func.h"
 #include "command_func.h"
 #include "town.h"
@@ -42,17 +45,25 @@
 #include "waypoint_base.h"
 #include "waypoint_func.h"
 #include "pbs.h"
+#include "overlay_cmd.h"
 #include "debug.h"
 #include "core/random_func.hpp"
 #include "company_base.h"
 #include "table/airporttile_ids.h"
 #include "newgrf_airporttiles.h"
 #include "order_backup.h"
+#include "cargodest_func.h"
 #include "newgrf_house.h"
 #include "company_gui.h"
 #include "widgets/station_widget.h"
+#include "tilearea_func.h"
 
 #include "table/strings.h"
+#include "newgrf_townname.h"
+
+#include <deque>
+
+static StationGfx _station_gfx_to_paste = 0;
 
 /**
  * Check whether the given tile is a hangar.
@@ -78,15 +89,16 @@
 }
 
 /**
- * Look for a station around the given tile area.
+ * Find all stations around the given tile area.
  * @param ta the area to search over
- * @param closest_station the closest station found so far
- * @param st to 'return' the found station
- * @return Succeeded command (if zero or one station found) or failed command (for two or more stations found).
+ * @param stations vector to fill in with the list of stations
+ * @param max_num_items maximal number of items to find (no limit if the value is negative)
  */
 template <class T>
-CommandCost GetStationAround(TileArea ta, StationID closest_station, T **st)
+void GetStationsAround(TileArea ta, SmallVector<T*, 4> *stations, int max_num_items = -1)
 {
+	if (max_num_items >= 0 && (int)stations->Length() >= max_num_items) return;
+
 	ta.tile -= TileDiffXY(1, 1);
 	ta.w    += 2;
 	ta.h    += 2;
@@ -94,18 +106,13 @@
 	/* check around to see if there's any stations there */
 	TILE_AREA_LOOP(tile_cur, ta) {
 		if (IsTileType(tile_cur, MP_STATION)) {
-			StationID t = GetStationIndex(tile_cur);
-			if (!T::IsValidID(t)) continue;
-
-			if (closest_station == INVALID_STATION) {
-				closest_station = t;
-			} else if (closest_station != t) {
-				return_cmd_error(STR_ERROR_ADJOINS_MORE_THAN_ONE_EXISTING);
+			T *st = T::GetByTile(tile_cur);
+			if (st != NULL) {
+				stations->Include(st);
+				if ((int)stations->Length() == max_num_items) break;
 			}
 		}
 	}
-	*st = (closest_station == INVALID_STATION) ? NULL : T::Get(closest_station);
-	return CommandCost();
 }
 
 /**
@@ -118,15 +125,18 @@
 /**
  * Counts the numbers of tiles matching a specific type in the area around
  * @param tile the center tile of the 'count area'
+ * @param width the x size of area around
+ * @param height the y size of area around
+ * @param rad the radius to count around area
  * @param cmp the comparator/matcher (@see CMSAMatcher)
  * @return the number of matching tiles around
  */
-static int CountMapSquareAround(TileIndex tile, CMSAMatcher cmp)
+static int CountMapSquareAround(TileIndex tile, int width, int height, int rad, CMSAMatcher cmp)
 {
 	int num = 0;
 
-	for (int dx = -3; dx <= 3; dx++) {
-		for (int dy = -3; dy <= 3; dy++) {
+	for (int dx = -rad; dx <= (width-1) + rad; dx++) {
+		for (int dy = -rad; dy <= (height-1) + rad; dy++) {
 			TileIndex t = TileAddWrap(tile, dx, dy);
 			if (t != INVALID_TILE && cmp(t)) num++;
 		}
@@ -182,6 +192,11 @@
 	return IsTileType(tile, MP_TREES);
 }
 
+static bool CMSAIndustry(TileIndex tile)
+{
+	return IsTileType(tile, MP_INDUSTRY);
+}
+
 #define M(x) ((x) - STR_SV_STNAME)
 
 enum StationNaming {
@@ -223,7 +238,9 @@
 	return !sni->indtypes[indtype];
 }
 
-static StringID GenerateStationName(Station *st, TileIndex tile, StationNaming name_class)
+static bool IsUniqueStationName(const char*);
+
+static StringID GenerateStationName(Station *st, TileIndex tile, int width, int height, StationNaming name_class)
 {
 	static const uint32 _gen_station_name_bits[] = {
 		0,                                       // STATIONNAMING_RAIL
@@ -276,10 +293,57 @@
 	/* check default names */
 	uint32 tmp = free_names & _gen_station_name_bits[name_class];
 	if (tmp != 0) return STR_SV_STNAME + FindFirstBit(tmp);
+	
+	/* check industry >>variable names<< */
+	for (int dx = -3; dx <= (width-1) + 3; dx++) {
+		for (int dy = -3; dy <= (height-1) + 3; dy++) {
+			if (CMSAIndustry(TILE_MASK(tile + TileDiffXY(dx, dy)))) {
+				char buf[512];
+
+				// Get town name (code mostly stolen from FormatString)
+				const Industry *ind = Industry::GetByTile(tile + TileDiffXY(dx, dy));
+				const Town *ind_t = ind->town;
+				int64 temp[1];
+
+				temp[0] = ind_t->townnameparts;
+				StringParameters tmp_params(temp);
+				uint32 grfid = ind_t->townnamegrfid;
+
+				if (ind_t->name != NULL) {
+					strecpy(buf, ind_t->name, lastof(buf));
+				} else if (grfid == 0) {
+					/* Original town name */
+					GetStringWithArgs(buf, ind_t->townnametype, &tmp_params, lastof(buf));
+				} else {
+					/* Newgrf town name */
+					if (GetGRFTownName(grfid) != NULL) {
+						/* The grf is loaded */
+						GRFTownNameGenerate(buf, ind_t->townnamegrfid, ind_t->townnametype, ind_t->townnameparts, lastof(buf));
+					} else {
+						/* Fallback to english original */
+						GetStringWithArgs(buf, SPECSTR_TOWNNAME_ENGLISH, &tmp_params, lastof(buf));
+					}
+				}
+				// End of get town name
+
+				// Add space :P
+				strcat(buf, " ");
+
+				// Add industry name
+				GetString(buf+strlen(buf), (GetIndustrySpec(ind->type))->name, lastof(buf));
+
+				if (IsUniqueStationName(buf)) {
+					free(st->name);
+					st->name = strdup(buf);
+					return true;
+				}
+			}
+		}
+	}
 
 	/* check mine? */
 	if (HasBit(free_names, M(STR_SV_STNAME_MINES))) {
-		if (CountMapSquareAround(tile, CMSAMine) >= 2) {
+		if (CountMapSquareAround(tile, width, height, 3, CMSAMine) >= 2) {
 			return STR_SV_STNAME_MINES;
 		}
 	}
@@ -294,14 +358,14 @@
 	/* Check lakeside */
 	if (HasBit(free_names, M(STR_SV_STNAME_LAKESIDE)) &&
 			DistanceFromEdge(tile) < 20 &&
-			CountMapSquareAround(tile, CMSAWater) >= 5) {
+			CountMapSquareAround(tile, width, height, 3, CMSAWater) >= 5) {
 		return STR_SV_STNAME_LAKESIDE;
 	}
 
 	/* Check woods */
 	if (HasBit(free_names, M(STR_SV_STNAME_WOODS)) && (
-				CountMapSquareAround(tile, CMSATree) >= 8 ||
-				CountMapSquareAround(tile, IsTileForestIndustry) >= 2)
+				CountMapSquareAround(tile, width, height, 3, CMSATree) >= 8 ||
+				CountMapSquareAround(tile, width, height, 3, IsTileForestIndustry) >= 2)
 			) {
 		return _settings_game.game_creation.landscape == LT_TROPIC ? STR_SV_STNAME_FOREST : STR_SV_STNAME_WOODS;
 	}
@@ -536,6 +600,126 @@
 }
 
 /**
+ * Get the rate of cargo being produced around the tile (in a rectangle).
+ * @param tile Northtile of area
+ * @param w X extent of the area
+ * @param h Y extent of the area
+ * @param rad Search radius in addition to the given area
+ */
+CargoArray GetProductionRateAroundTiles(TileIndex tile, int w, int h, int rad)
+{
+	CargoArray production_rate;
+
+	int x = TileX(tile);
+	int y = TileY(tile);
+
+	/* expand the region by rad tiles on each side
+	 * while making sure that we remain inside the board. */
+	int x2 = min(x + w + rad, MapSizeX());
+	int x1 = max(x - rad, 0);
+
+	int y2 = min(y + h + rad, MapSizeY());
+	int y1 = max(y - rad, 0);
+
+	assert(x1 < x2);
+	assert(y1 < y2);
+	assert(w > 0);
+	assert(h > 0);
+
+	TileArea ta(TileXY(x1, y1), TileXY(x2 - 1, y2 - 1));
+
+	/* Loop over all tiles to get the produced cargo of
+	 * everything except industries */
+	TILE_AREA_LOOP(tile, ta) {
+		if (GetTileType(tile) == MP_HOUSE) {
+			if (!IsHouseCompleted(tile)) continue;
+
+			const HouseSpec *hs = HouseSpec::Get(GetHouseType(tile));
+			
+			/* Use expected values to calculate supply forecasting since there is a random factor
+			 * in the equation.
+			 * E[x] = x1p1 + x2p2 + ... + xkpk
+			 * random number ranges from 0 to 255. However, all the ones above population are dropped.
+			 * All probabilities p1...pk are the same ( = 1 / 256 )
+			 * Thus, E[x] = (1 + 2 + ... + pop - 1) / 256
+			 */
+			uint sum = 0;
+			for (uint i = 1; i < hs->population; i++) {
+				sum += i;
+			}
+			/* Bitshift to the right by 8 is from the above equation and 3 is 
+			 * to divide by 8. For details, look at TileLoop_Town() in town_cmd.cpp */
+			uint amt = (sum >> 11) + 1;
+			if (EconomyIsInRecession()) amt = (amt + 1) >> 1;
+			production_rate[CT_PASSENGERS] += amt;
+
+			sum = 0;
+			for (uint i = 1; i < hs->mail_generation; i++) {
+				sum += i;
+			}
+			amt = (sum >> 11) + 1;
+			if (EconomyIsInRecession()) amt = (amt + 1) >> 1;
+			production_rate[CT_MAIL] += amt;
+		}
+	}
+
+	/* Loop over the industries. They produce cargo for
+	 * anything that is within 'rad' from their bounding
+	 * box. As such if you have e.g. a oil well the tile
+	 * area loop might not hit an industry tile while
+	 * the industry would produce cargo for the station.
+	 */
+	const Industry *i;
+	FOR_ALL_INDUSTRIES(i) {
+		if (!ta.Intersects(i->location)) continue;
+
+		for (uint j = 0; j < lengthof(i->produced_cargo); j++) {
+			CargoID cargo = i->produced_cargo[j];
+
+			if (cargo != CT_INVALID) production_rate[cargo] += i->last_month_production[j];
+		}
+	}
+
+	return production_rate;
+}
+
+/**
+ * Get the acceptance rate of cargoes around the tile.
+ * @param tile Center of the search area
+ * @param w X extent of area
+ * @param h Y extent of area
+ * @param rad Search radius in addition to given area
+ * @param always_accepted bitmask of cargo accepted by houses and headquarters; can be NULL
+ */
+CargoArray GetAcceptanceRateAroundTiles(TileIndex tile, int w, int h, int rad)
+{
+	CargoArray acceptance_rate;
+
+	int x = TileX(tile);
+	int y = TileY(tile);
+
+	/* expand the region by rad tiles on each side
+	 * while making sure that we remain inside the board. */
+	int x2 = min(x + w + rad, MapSizeX());
+	int y2 = min(y + h + rad, MapSizeY());
+	int x1 = max(x - rad, 0);
+	int y1 = max(y - rad, 0);
+
+	assert(x1 < x2);
+	assert(y1 < y2);
+	assert(w > 0);
+	assert(h > 0);
+
+	for (int yc = y1; yc != y2; yc++) {
+		for (int xc = x1; xc != x2; xc++) {
+			TileIndex tile = TileXY(xc, yc);
+			AddAcceptedCargo(tile, acceptance_rate, NULL);
+		}
+	}
+
+	return acceptance_rate;
+}
+/**
  * Update the acceptance for a station.
  * @param st Station to update
  * @param show_msg controls whether to display a message that acceptance was changed.
@@ -616,6 +800,36 @@
 
 	/* redraw the station view since acceptance changed */
 	SetWindowWidgetDirty(WC_STATION_VIEW, st->index, WID_SV_ACCEPT_RATING_LIST);
+	if (Overlays::Instance()->HasStation(st)) st->MarkAcceptanceTilesDirty();
+}
+
+/*
+ * Remove or add cargo type from cargolist of this station.
+ * @param tile unused
+ * @param flags Operation to perform
+ * @param p1 StationID
+ * @param p2 CargoID and flag of from what widget command comes. 00FF - cargo mask, FF00 - flag mask
+ * @param text unused
+ * @return The cost in case of success, or an error code if it failed.
+ */
+
+CommandCost CmdChangeStationAcceptance(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
+{
+	if (!Station::IsValidID(p1)) return CMD_ERROR;
+	Station *st = Station::Get(p1);
+
+	CommandCost ret = CheckOwnership(st->owner);
+	if (ret.Failed()) return ret;
+	
+	/* Determine in what widget click happen: WID_SV_WAITING have mask 0100, WID_SV_ACCEPT_RATING_LIST in other case */
+	bool waiting; 
+	waiting = (p2 & 0x0100) ? true : false;
+	p2 &= 0x00FF; 
+	
+	if (flags & DC_EXEC) {
+		st->ChangeAcceptance(p2, waiting);
+	}
+	return CommandCost();
 }
 
 static void UpdateStationSignCoord(BaseStation *st)
@@ -658,7 +872,7 @@
 			*st = new Station(area.tile);
 
 			(*st)->town = ClosestTownFromTile(area.tile, UINT_MAX);
-			(*st)->string_id = GenerateStationName(*st, area.tile, name_class);
+			(*st)->string_id = GenerateStationName(*st, area.tile, area.w, area.h, STATIONNAMING_RAIL);
 
 			if (Company::IsValidID(_current_company)) {
 				SetBit((*st)->town->have_ratings, _current_company);
@@ -677,11 +891,16 @@
 static void DeleteStationIfEmpty(BaseStation *st)
 {
 	if (!st->IsInUse()) {
+		if (Station::IsExpected(st)) Overlays::Instance()->RemoveStation((Station *)st);
 		st->delete_ctr = 0;
 		InvalidateWindowData(WC_STATION_LIST, st->owner, 0);
 	}
 	/* station remains but it probably lost some parts - station sign should stay in the station boundaries */
 	UpdateStationSignCoord(st);
+
+	if (Station::IsExpected(st)) {
+		MarkWholeScreenDirty();
+	}
 }
 
 CommandCost ClearTile_Station(TileIndex tile, DoCommandFlag flags);
@@ -955,6 +1174,47 @@
 	return cost;
 }
 
+/** Checks if an airport can be built at the given area.
+ * @param tile_area Area to check.
+ * @param flags Operation to perform.
+ * @param station StationID of airport allowed in search area.
+ * @return The cost in case of success, or an error code if it failed.
+ */
+static CommandCost CheckFlatLandAirport(TileArea tile_area, DoCommandFlag flags, StationID *station)
+{
+	CommandCost cost(EXPENSES_CONSTRUCTION);
+	int allowed_z = -1;
+
+	TILE_AREA_LOOP(tile_cur, tile_area) {
+		CommandCost ret = CheckBuildableTile(tile_cur, 0, allowed_z, true);
+		if (ret.Failed()) return ret;
+		cost.AddCost(ret);
+
+		/* if station is set, then allow building on top of an already
+		 * existing airport, either the one in *station if it is not
+		 * INVALID_STATION, or anyone otherwise and store which one
+		 * in *station */
+		if (station != NULL && IsTileType(tile_cur, MP_STATION)) {
+			if (!IsAirport(tile_cur)) {
+				return ClearTile_Station(tile_cur, DC_AUTO); // get error message
+			} else {
+				StationID st = GetStationIndex(tile_cur);
+				if (*station == INVALID_STATION) {
+					*station = st;
+				} else if (*station != st) {
+					return_cmd_error(STR_ERROR_ADJOINS_MORE_THAN_ONE_EXISTING);
+				}
+			}
+		} else {
+			ret = DoCommand(tile_cur, 0, 0, flags, CMD_LANDSCAPE_CLEAR);
+			if (ret.Failed()) return ret;
+			cost.AddCost(ret);
+		}
+	}
+
+	return cost;
+}
+
 /**
  * Check whether we can expand the rail part of the given station.
  * @param st the station to expand
@@ -1034,47 +1294,62 @@
 /**
  * Find a nearby station that joins this station.
  * @tparam T the class to find a station for
- * @tparam error_message the error message when building a station on top of others
  * @param existing_station an existing station we build over
  * @param station_to_join the station to join to
  * @param adjacent whether adjacent stations are allowed
  * @param ta the area of the newly build station
  * @param st 'return' pointer for the found station
+ * @param error_message the error message when building a station on top of others
  * @return command cost with the error or 'okay'
  */
-template <class T, StringID error_message>
-CommandCost FindJoiningBaseStation(StationID existing_station, StationID station_to_join, bool adjacent, TileArea ta, T **st)
+template <class T>
+CommandCost FindJoiningBaseStation(StationID existing_station, StationID station_to_join, bool adjacent, const TileArea ta, T **st, StringID error_message)
 {
 	assert(*st == NULL);
-	bool check_surrounding = true;
 
-	if (_settings_game.station.adjacent_stations) {
-		if (existing_station != INVALID_STATION) {
-			if (adjacent && existing_station != station_to_join) {
-				/* You can't build an adjacent station over the top of one that
-				 * already exists. */
-				return_cmd_error(error_message);
+       /* List all stations that we would have to join to (e.g. the "station_to_join" or adjacent stations). */
+       SmallVector<T*, 4> joining_stations;
+       bool join_stations_around = !adjacent || !_settings_game.station.adjacent_stations;
+       if (existing_station != INVALID_STATION) { // there is a station inside the area
+               if (station_to_join != INVALID_STATION) {
+                       /* We can overbuild only these stations whitch we are willing to join. */
+                       if (station_to_join != existing_station) return_cmd_error(error_message);
+               } else {
+                       /* You can't build an adjacent station over the top of one that already exists. */
+                       if (adjacent) return_cmd_error(error_message);
+               }
+               /* Join to the overbuilt station. */
+               joining_stations.Include(T::Get(existing_station));
+       } else { // no station found yet
+               if (station_to_join != INVALID_STATION) {
+                       /* Test if we are not braking the distant-join rule. */
+                       if (_settings_game.station.distant_join_stations) {
+                               /* No restrictions, just join. */
+                               joining_stations.Include(T::Get(station_to_join));
 			} else {
-				/* Extend the current station, and don't check whether it will
-				 * be near any other stations. */
-				*st = T::GetIfValid(existing_station);
-				check_surrounding = (*st == NULL);
+                               /* Distant-joining is not allowed. We must check stations around whether there is
+                                * the station_to_join among them. */
+                               if (!join_stations_around) {
+                                       SmallVector<T*, 4> stations_around;
+                                       GetStationsAround<T>(ta, &stations_around);
+                                       if (stations_around.Contains(T::Get(station_to_join))) joining_stations.Include(T::Get(station_to_join));
+                               }
 			}
-		} else {
-			/* There's no station here. Don't check the tiles surrounding this
-			 * one if the company wanted to build an adjacent station. */
-			if (adjacent) check_surrounding = false;
 		}
 	}
 
-	if (check_surrounding) {
-		/* Make sure there are no similar stations around us. */
-		CommandCost ret = GetStationAround(ta, existing_station, st);
-		if (ret.Failed()) return ret;
-	}
+       if (join_stations_around) GetStationsAround<T>(ta, &joining_stations, 2);
+       /* if the station_to_join is not present in the joining_stations then we failed because of a distatnt-join */
+       if (station_to_join != INVALID_STATION && !joining_stations.Contains(T::Get(station_to_join))) return_cmd_error(STR_ERROR_CAN_T_DISTANT_JOIN);
+       /* are there any joining stations found? */
+       if (joining_stations.Length() > 0) {
+               /* if there is at least one station that we must join to then fail if the caller wish to crate a new station */
+               if (station_to_join == INVALID_STATION && adjacent) return_cmd_error(STR_ERROR_ADJOINS_EXISTING);
+               /* check if we are not joining too much */
+               if (joining_stations.Length() > 1) return_cmd_error(STR_ERROR_ADJOINS_MORE_THAN_ONE_EXISTING);
 
-	/* Distant join */
-	if (*st == NULL && station_to_join != INVALID_STATION) *st = T::GetIfValid(station_to_join);
+               *st = joining_stations[0];
+       }
 
 	return CommandCost();
 }
@@ -1086,11 +1361,12 @@
  * @param adjacent whether adjacent stations are allowed
  * @param ta the area of the newly build station
  * @param st 'return' pointer for the found station
+ * @param error_message the error message when building a station on top of others
  * @return command cost with the error or 'okay'
  */
-static CommandCost FindJoiningStation(StationID existing_station, StationID station_to_join, bool adjacent, TileArea ta, Station **st)
+static CommandCost FindJoiningStation(StationID existing_station, StationID station_to_join, bool adjacent, TileArea ta, Station **st, StringID error_message = STR_ERROR_MUST_REMOVE_RAILWAY_STATION_FIRST)
 {
-	return FindJoiningBaseStation<Station, STR_ERROR_MUST_REMOVE_RAILWAY_STATION_FIRST>(existing_station, station_to_join, adjacent, ta, st);
+	return FindJoiningBaseStation<Station>(existing_station, station_to_join, adjacent, ta, st, error_message);
 }
 
 /**
@@ -1104,7 +1380,12 @@
  */
 CommandCost FindJoiningWaypoint(StationID existing_waypoint, StationID waypoint_to_join, bool adjacent, TileArea ta, Waypoint **wp)
 {
-	return FindJoiningBaseStation<Waypoint, STR_ERROR_MUST_REMOVE_RAILWAYPOINT_FIRST>(existing_waypoint, waypoint_to_join, adjacent, ta, wp);
+	return FindJoiningBaseStation<Waypoint>(existing_waypoint, waypoint_to_join, adjacent, ta, wp, STR_ERROR_MUST_REMOVE_RAILWAYPOINT_FIRST);
+}
+
+static bool IsRegularRailStation(StationClassID spec_class, uint spec_index)
+{
+	return (spec_class == STAT_CLASS_DFLT || spec_class == STAT_CLASS_WAYP) && spec_index == 0;
 }
 
 /**
@@ -1159,10 +1440,8 @@
 
 	bool reuse = (station_to_join != NEW_STATION);
 	if (!reuse) station_to_join = INVALID_STATION;
-	bool distant_join = (station_to_join != INVALID_STATION);
-
-	if (distant_join && (!_settings_game.station.distant_join_stations || !Station::IsValidID(station_to_join))) return CMD_ERROR;
 
+	if (station_to_join != INVALID_STATION && !Station::IsValidID(station_to_join)) return CMD_ERROR;
 	if (h_org > _settings_game.station.station_spread || w_org > _settings_game.station.station_spread) return CMD_ERROR;
 
 	/* these values are those that will be stored in train_tile and station_platforms */
@@ -1220,6 +1499,7 @@
 		st->AddFacility(FACIL_TRAIN, new_location.tile);
 
 		st->rect.BeforeAddRect(tile_org, w_org, h_org, StationRect::ADD_TRY);
+		st->catchment.BeforeAddRect(tile_org, w_org, h_org, CA_TRAIN);
 
 		if (statspec != NULL) {
 			/* Include this station spec's animation trigger bitmask
@@ -1274,7 +1554,10 @@
 				if (!IsStationTileBlocked(tile)) c->infrastructure.rail[rt]++;
 				c->infrastructure.station++;
 
-				if (statspec != NULL) {
+				if ((flags & DC_PASTE) && IsRegularRailStation(spec_class, spec_index)) {
+					/* Apply station gfx, but only to regular stations. */
+					SetStationGfx(tile, _station_gfx_to_paste);
+				} else if (statspec != NULL) {
 					/* Use a fixed axis for GetPlatformInfo as our platforms / numtracks are always the right way around */
 					uint32 platinfo = GetPlatformInfo(AXIS_X, GetStationGfx(tile), plat_len, numtracks_orig, plat_len - w, numtracks_orig - numtracks, false);
 
@@ -1465,6 +1748,7 @@
 			Track track = GetRailStationTrack(tile);
 			Owner owner = GetTileOwner(tile);
 			RailType rt = GetRailType(tile);
+			if (Station::IsExpected(st)) ((Station *)st)->catchment.AfterRemoveTile(tile, CA_TRAIN);
 			Train *v = NULL;
 
 			if (HasStationReservation(tile)) {
@@ -1485,6 +1769,7 @@
 			DoClearSquare(tile);
 			DeleteNewGRFInspectWindow(GSF_STATIONS, tile);
 			if (build_rail) MakeRailNormal(tile, owner, TrackToTrackBits(track), rt);
+			if (Station::IsExpected(st) && Overlays::Instance()->HasStation((Station *)st)) ((Station *)st)->MarkAcceptanceTilesDirty();
 			Company::Get(owner)->infrastructure.station--;
 			DirtyCompanyInfrastructureWindows(owner);
 
@@ -1557,6 +1842,7 @@
 		Station *st = *stp;
 
 		if (st->train_station.tile == INVALID_TILE) SetWindowWidgetDirty(WC_STATION_VIEW, st->index, WID_SV_TRAINS);
+		if (Overlays::Instance()->HasStation(st)) st->MarkAcceptanceTilesDirty();
 		st->MarkTilesDirty(false);
 		st->RecomputeIndustriesNear();
 	}
@@ -1623,6 +1909,7 @@
 			/* read variables before the station tile is removed */
 			Track track = GetRailStationTrack(tile);
 			Owner owner = GetTileOwner(tile); // _current_company can be OWNER_WATER
+			if (Station::IsExpected(st)) ((Station *)st)->catchment.AfterRemoveTile(tile, CA_TRAIN);
 			Train *v = NULL;
 			if (HasStationReservation(tile)) {
 				v = GetTrainForReservation(tile, track);
@@ -1632,6 +1919,7 @@
 			Company::Get(owner)->infrastructure.station--;
 			DoClearSquare(tile);
 			DeleteNewGRFInspectWindow(GSF_STATIONS, tile);
+			if (Station::IsExpected(st) && Overlays::Instance()->HasStation((Station *)st)) ((Station *)st)->MarkAcceptanceTilesDirty();
 			AddTrackToSignalBuffer(tile, track, owner);
 			YapfNotifyTrackLayoutChange(tile, track);
 			if (v != NULL) TryPathReserve(v, true);
@@ -1730,7 +2018,7 @@
  */
 static CommandCost FindJoiningRoadStop(StationID existing_stop, StationID station_to_join, bool adjacent, TileArea ta, Station **st)
 {
-	return FindJoiningBaseStation<Station, STR_ERROR_MUST_REMOVE_ROAD_STOP_FIRST>(existing_stop, station_to_join, adjacent, ta, st);
+	return FindJoiningBaseStation<Station>(existing_stop, station_to_join, adjacent, ta, st, STR_ERROR_MUST_REMOVE_ROAD_STOP_FIRST);
 }
 
 /**
@@ -1756,7 +2044,6 @@
 	StationID station_to_join = GB(p2, 16, 16);
 	bool reuse = (station_to_join != NEW_STATION);
 	if (!reuse) station_to_join = INVALID_STATION;
-	bool distant_join = (station_to_join != INVALID_STATION);
 
 	uint8 width = (uint8)GB(p1, 0, 8);
 	uint8 lenght = (uint8)GB(p1, 8, 8);
@@ -1770,7 +2057,7 @@
 
 	TileArea roadstop_area(tile, width, lenght);
 
-	if (distant_join && (!_settings_game.station.distant_join_stations || !Station::IsValidID(station_to_join))) return CMD_ERROR;
+	if (station_to_join != INVALID_STATION && !Station::IsValidID(station_to_join)) return CMD_ERROR;
 
 	if (!HasExactlyOneBit(rts) || !HasRoadTypesAvail(_current_company, rts)) return CMD_ERROR;
 
@@ -1830,6 +2117,7 @@
 			st->AddFacility((type) ? FACIL_TRUCK_STOP : FACIL_BUS_STOP, cur_tile);
 
 			st->rect.BeforeAddTile(cur_tile, StationRect::ADD_TRY);
+			st->catchment.BeforeAddTile(cur_tile, type ? CA_TRUCK : CA_BUS);
 
 			RoadStopType rs_type = type ? ROADSTOP_TRUCK : ROADSTOP_BUS;
 			if (is_drive_through) {
@@ -1958,6 +2246,7 @@
 			DoClearSquare(tile);
 		}
 
+		if (Overlays::Instance()->HasStation(st)) st->MarkAcceptanceTilesDirty();
 		SetWindowWidgetDirty(WC_STATION_VIEW, st->index, WID_SV_ROADVEHS);
 		delete cur_stop;
 
@@ -1971,6 +2260,7 @@
 		}
 
 		st->rect.AfterRemoveTile(st, tile);
+		st->catchment.AfterRemoveTile(tile, is_truck ? CA_TRUCK : CA_BUS);
 
 		st->UpdateVirtCoord();
 		st->RecomputeIndustriesNear();
@@ -2148,6 +2438,37 @@
 	}
 }
 
+
+/**
+ * Checks if an airport can be removed (no aircraft on it or landing)
+ * @param st Station whose airport is to be removed
+ * @param flags Operation to perform
+ * @return Cost or failure of operation
+ */
+static CommandCost CanRemoveAirport(Station *st, DoCommandFlag flags)
+{
+	const Aircraft *a;
+	FOR_ALL_AIRCRAFT(a) {
+		if (!a->IsNormalAircraft()) continue;
+		if (a->targetairport == st->index && a->state != FLYING)
+			return_cmd_error(STR_ERROR_AIRCRAFT_IN_THE_WAY);
+	}
+
+	CommandCost cost(EXPENSES_CONSTRUCTION);
+
+	TILE_AREA_LOOP(tile_cur, st->airport) {
+		if (!st->TileBelongsToAirport(tile_cur)) continue;
+
+		CommandCost ret = EnsureNoVehicleOnGround(tile_cur);
+		if (ret.Failed()) return ret;
+
+		cost.AddCost(_price[PR_CLEAR_STATION_AIRPORT]);
+	}
+
+	return cost;
+}
+
+
 /**
  * Place an Airport.
  * @param tile tile where airport will be built
@@ -2166,11 +2487,10 @@
 	StationID station_to_join = GB(p2, 16, 16);
 	bool reuse = (station_to_join != NEW_STATION);
 	if (!reuse) station_to_join = INVALID_STATION;
-	bool distant_join = (station_to_join != INVALID_STATION);
 	byte airport_type = GB(p1, 0, 8);
 	byte layout = GB(p1, 8, 8);
 
-	if (distant_join && (!_settings_game.station.distant_join_stations || !Station::IsValidID(station_to_join))) return CMD_ERROR;
+	if (station_to_join != INVALID_STATION && !Station::IsValidID(station_to_join)) return CMD_ERROR;
 
 	if (airport_type >= NUM_AIRPORTS) return CMD_ERROR;
 
@@ -2191,13 +2511,43 @@
 		return_cmd_error(STR_ERROR_STATION_TOO_SPREAD_OUT);
 	}
 
-	CommandCost cost = CheckFlatLand(airport_area, flags);
+	StationID est = INVALID_STATION;
+	CommandCost cost = CheckFlatLandAirport(airport_area, flags, &est);
 	if (cost.Failed()) return cost;
 
+	Station *st = NULL;
+	ret = FindJoiningStation(est, station_to_join, HasBit(p2, 0), airport_area, &st, STR_ERROR_MUST_DEMOLISH_AIRPORT_FIRST);
+	if (ret.Failed()) return ret;
+
+	ret = BuildStationPart(&st, flags, reuse, airport_area, (GetAirport(airport_type)->flags & AirportFTAClass::AIRPLANES) ? STATIONNAMING_AIRPORT : STATIONNAMING_HELIPORT);
+	if (ret.Failed()) return ret;
+
+	/* action to be performed */
+	enum {
+		AIRPORT_NEW,      // airport is a new station
+		AIRPORT_ADD,      // add an airport to an existing station
+		AIRPORT_UPGRADE,  // upgrade the airport in a station
+	} action =
+		(est != INVALID_STATION) ? AIRPORT_UPGRADE :
+		(st != NULL) ? AIRPORT_ADD : AIRPORT_NEW;
+
+	if (action == AIRPORT_ADD && st->airport.tile != INVALID_TILE) {
+		return_cmd_error(STR_ERROR_TOO_CLOSE_TO_ANOTHER_AIRPORT);
+	}
+
 	/* The noise level is the noise from the airport and reduce it to account for the distance to the town center. */
 	AirportTileTableIterator iter(as->table[layout], tile);
 	Town *nearest = AirportGetNearestTown(as, iter);
-	uint newnoise_level = GetAirportNoiseLevelForTown(as, iter, nearest->xy);
+	uint newnoise_level = nearest->noise_reached + GetAirportNoiseLevelForTown(as, iter, nearest->xy);
+
+	if (action == AIRPORT_UPGRADE) {
+		const AirportSpec *old_as = st->airport.GetSpec();
+		AirportTileTableIterator old_iter(old_as->table[st->airport.layout], st->airport.tile);
+		Town *old_nearest = AirportGetNearestTown(old_as, old_iter);
+		if (old_nearest == nearest) {
+			newnoise_level -= GetAirportNoiseLevelForTown(old_as, old_iter, nearest->xy);
+		}
+	}
 
 	/* Check if local auth would allow a new airport */
 	StringID authority_refuse_message = STR_NULL;
@@ -2205,11 +2555,11 @@
 
 	if (_settings_game.economy.station_noise_level) {
 		/* do not allow to build a new airport if this raise the town noise over the maximum allowed by town */
-		if ((nearest->noise_reached + newnoise_level) > nearest->MaxTownNoise()) {
+		if (newnoise_level > nearest->MaxTownNoise()) {
 			authority_refuse_message = STR_ERROR_LOCAL_AUTHORITY_REFUSES_NOISE;
 			authority_refuse_town = nearest;
 		}
-	} else {
+	} else if (action != AIRPORT_UPGRADE) {
 		Town *t = ClosestTownFromTile(tile, UINT_MAX);
 		uint num = 0;
 		const Station *st;
@@ -2227,18 +2577,11 @@
 		return_cmd_error(authority_refuse_message);
 	}
 
-	Station *st = NULL;
-	ret = FindJoiningStation(INVALID_STATION, station_to_join, HasBit(p2, 0), airport_area, &st);
-	if (ret.Failed()) return ret;
-
-	/* Distant join */
-	if (st == NULL && distant_join) st = Station::GetIfValid(station_to_join);
-
-	ret = BuildStationPart(&st, flags, reuse, airport_area, (GetAirport(airport_type)->flags & AirportFTAClass::AIRPLANES) ? STATIONNAMING_AIRPORT : STATIONNAMING_HELIPORT);
-	if (ret.Failed()) return ret;
-
-	if (st != NULL && st->airport.tile != INVALID_TILE) {
-		return_cmd_error(STR_ERROR_TOO_CLOSE_TO_ANOTHER_AIRPORT);
+	if (action == AIRPORT_UPGRADE) {
+		/* check that the old airport can be removed */
+		CommandCost r = CanRemoveAirport(st, flags);
+		if (r.Failed()) return r;
+		cost.AddCost(r);
 	}
 
 	for (AirportTileTableIterator iter(as->table[layout], tile); iter != INVALID_TILE; ++iter) {
@@ -2246,13 +2589,45 @@
 	}
 
 	if (flags & DC_EXEC) {
+		if (action == AIRPORT_UPGRADE) {
+			/* delete old airport if upgrading */
+			const AirportSpec *old_as = st->airport.GetSpec();
+			AirportTileTableIterator old_iter(old_as->table[st->airport.layout], st->airport.tile);
+			Town *old_nearest = AirportGetNearestTown(old_as, old_iter);
+
+			if (old_nearest != nearest) {
+				old_nearest->noise_reached -= GetAirportNoiseLevelForTown(old_as, old_iter, old_nearest->xy);
+				if (_settings_game.economy.station_noise_level) {
+					SetWindowDirty(WC_TOWN_VIEW, st->town->index);
+				}
+			}
+
+			TILE_AREA_LOOP(tile_cur, st->airport) {
+				if (IsHangarTile(tile_cur)) OrderBackup::Reset(tile_cur, false);
+				DeleteAnimatedTile(tile_cur);
+				DoClearSquare(tile_cur);
+				DeleteNewGRFInspectWindow(GSF_AIRPORTTILES, tile_cur);
+			}
+
+			for (uint i = 0; i < st->airport.GetNumHangars(); ++i) {
+				DeleteWindowById(
+					WC_VEHICLE_DEPOT, st->airport.GetHangarTile(i)
+				);
+			}
+
+			st->rect.AfterRemoveRect(st, st->airport);
+			st->airport.Clear();
+		}
+
 		/* Always add the noise, so there will be no need to recalculate when option toggles */
-		nearest->noise_reached += newnoise_level;
+		nearest->noise_reached = newnoise_level;
 
 		st->AddFacility(FACIL_AIRPORT, tile);
 		st->airport.type = airport_type;
 		st->airport.layout = layout;
 		st->airport.flags = 0;
+    st->airport.flags2 = 0;
+    st->airport.num_circle = 0;
 		st->airport.rotation = rotation;
 
 		st->rect.BeforeAddRect(tile, w, h, StationRect::ADD_TRY);
@@ -2261,6 +2636,7 @@
 			MakeAirport(iter, st->owner, st->index, iter.GetStationGfx(), WATER_CLASS_INVALID);
 			SetStationTileRandomBits(iter, GB(Random(), 0, 4));
 			st->airport.Add(iter);
+			st->catchment.BeforeAddTile(iter, as->catchment);
 
 			if (AirportTileSpec::Get(GetTranslatedAirportTileID(iter.GetStationGfx()))->animation.status != ANIM_STATUS_NO_ANIMATION) AddAnimatedTile(iter);
 		}
@@ -2270,12 +2646,16 @@
 			AirportTileAnimationTrigger(st, iter, AAT_BUILT);
 		}
 
-		UpdateAirplanesOnNewStation(st);
+		if (action != AIRPORT_NEW) UpdateAirplanesOnNewStation(st);
 
-		Company::Get(st->owner)->infrastructure.airport++;
-		DirtyCompanyInfrastructureWindows(st->owner);
+		if (action == AIRPORT_UPGRADE) {
+			UpdateStationSignCoord(st);
+		} else {
+			Company::Get(st->owner)->infrastructure.airport++;
+			DirtyCompanyInfrastructureWindows(st->owner);
+			st->UpdateVirtCoord();
+		}
 
-		st->UpdateVirtCoord();
 		UpdateStationAcceptance(st, false);
 		st->RecomputeIndustriesNear();
 		InvalidateWindowData(WC_SELECT_STATION, 0, 0);
@@ -2305,15 +2685,8 @@
 		if (ret.Failed()) return ret;
 	}
 
-	tile = st->airport.tile;
-
-	CommandCost cost(EXPENSES_CONSTRUCTION);
-
-	const Aircraft *a;
-	FOR_ALL_AIRCRAFT(a) {
-		if (!a->IsNormalAircraft()) continue;
-		if (a->targetairport == st->index && a->state != FLYING) return CMD_ERROR;
-	}
+	CommandCost cost = CanRemoveAirport(st, flags);
+	if (cost.Failed()) return cost;
 
 	if (flags & DC_EXEC) {
 		const AirportSpec *as = st->airport.GetSpec();
@@ -2323,25 +2696,14 @@
 		AirportTileIterator it(st);
 		Town *nearest = AirportGetNearestTown(as, it);
 		nearest->noise_reached -= GetAirportNoiseLevelForTown(as, it, nearest->xy);
-	}
-
-	TILE_AREA_LOOP(tile_cur, st->airport) {
-		if (!st->TileBelongsToAirport(tile_cur)) continue;
-
-		CommandCost ret = EnsureNoVehicleOnGround(tile_cur);
-		if (ret.Failed()) return ret;
-
-		cost.AddCost(_price[PR_CLEAR_STATION_AIRPORT]);
-
-		if (flags & DC_EXEC) {
+               TILE_AREA_LOOP(tile_cur, st->airport) {
+			const AirportSpec *as = st->airport.GetSpec();  
 			if (IsHangarTile(tile_cur)) OrderBackup::Reset(tile_cur, false);
 			DeleteAnimatedTile(tile_cur);
+			st->catchment.AfterRemoveTile(tile_cur, as->catchment); 
 			DoClearSquare(tile_cur);
 			DeleteNewGRFInspectWindow(GSF_AIRPORTTILES, tile_cur);
 		}
-	}
-
-	if (flags & DC_EXEC) {
 		/* Clear the persistent storage. */
 		delete st->airport.psa;
 
@@ -2445,9 +2807,8 @@
 	StationID station_to_join = GB(p2, 16, 16);
 	bool reuse = (station_to_join != NEW_STATION);
 	if (!reuse) station_to_join = INVALID_STATION;
-	bool distant_join = (station_to_join != INVALID_STATION);
 
-	if (distant_join && (!_settings_game.station.distant_join_stations || !Station::IsValidID(station_to_join))) return CMD_ERROR;
+	if (station_to_join != INVALID_STATION && !Station::IsValidID(station_to_join)) return CMD_ERROR;
 
 	DiagDirection direction = GetInclinedSlopeDirection(GetTileSlope(tile));
 	if (direction == INVALID_DIAGDIR) return_cmd_error(STR_ERROR_SITE_UNSUITABLE);
@@ -2466,21 +2827,32 @@
 
 	TileIndex tile_cur = tile + TileOffsByDiagDir(direction);
 
-	if (!IsTileType(tile_cur, MP_WATER) || GetTileSlope(tile_cur) != SLOPE_FLAT) {
-		return_cmd_error(STR_ERROR_SITE_UNSUITABLE);
+	/* Get the water class of the water tile before it is cleared. */
+	WaterClass wc;
+	/* When pasting a dock, there may be no water yet (a canal will be placed when DC_EXE'ing).
+	 * Ignore that there is no water so we can calculate the cost more precisely. */
+	if ((flags & DC_PASTE) && !(flags & DC_EXEC)) {
+		wc = WATER_CLASS_INVALID;
+	} else {
+		if (!IsTileType(tile_cur, MP_WATER)) {
+			assert(!(flags & DC_PASTE)); // whem pasting, it must be a water tile, we assumend that
+			return_cmd_error(STR_ERROR_SITE_UNSUITABLE);
+		}
+		wc = GetWaterClass(tile_cur);
 	}
 
-	if (MayHaveBridgeAbove(tile_cur) && IsBridgeAbove(tile_cur)) return_cmd_error(STR_ERROR_MUST_DEMOLISH_BRIDGE_FIRST);
+	if (GetTileSlope(tile_cur) != SLOPE_FLAT) return_cmd_error(STR_ERROR_SITE_UNSUITABLE);
 
-	/* Get the water class of the water tile before it is cleared.*/
-	WaterClass wc = GetWaterClass(tile_cur);
+	if (MayHaveBridgeAbove(tile_cur) && IsBridgeAbove(tile_cur)) return_cmd_error(STR_ERROR_MUST_DEMOLISH_BRIDGE_FIRST);
 
 	ret = DoCommand(tile_cur, 0, 0, flags, CMD_LANDSCAPE_CLEAR);
 	if (ret.Failed()) return ret;
 
-	tile_cur += TileOffsByDiagDir(direction);
-	if (!IsTileType(tile_cur, MP_WATER) || GetTileSlope(tile_cur) != SLOPE_FLAT) {
-		return_cmd_error(STR_ERROR_SITE_UNSUITABLE);
+	if (!(flags & DC_PASTE)) {
+		tile_cur += TileOffsByDiagDir(direction);
+		if (!IsTileType(tile_cur, MP_WATER) || GetTileSlope(tile_cur) != SLOPE_FLAT) {
+			return_cmd_error(STR_ERROR_SITE_UNSUITABLE);
+		}
 	}
 
 	TileArea dock_area = TileArea(tile + ToTileIndexDiff(_dock_tileoffs_chkaround[direction]),
@@ -2491,9 +2863,6 @@
 	ret = FindJoiningStation(INVALID_STATION, station_to_join, HasBit(p1, 0), dock_area, &st);
 	if (ret.Failed()) return ret;
 
-	/* Distant join */
-	if (st == NULL && distant_join) st = Station::GetIfValid(station_to_join);
-
 	ret = BuildStationPart(&st, flags, reuse, dock_area, STATIONNAMING_DOCK);
 	if (ret.Failed()) return ret;
 
@@ -2504,6 +2873,7 @@
 		st->AddFacility(FACIL_DOCK, tile);
 
 		st->rect.BeforeAddRect(dock_area.tile, dock_area.w, dock_area.h, StationRect::ADD_TRY);
+		st->catchment.BeforeAddRect(dock_area.tile, dock_area.w, dock_area.h, CA_DOCK);
 
 		/* If the water part of the dock is on a canal, update infrastructure counts.
 		 * This is needed as we've unconditionally cleared that tile before. */
@@ -2513,6 +2883,7 @@
 		Company::Get(st->owner)->infrastructure.station += 2;
 		DirtyCompanyInfrastructureWindows(st->owner);
 
+		assert(wc != WATER_CLASS_INVALID);
 		MakeDock(tile, st->owner, st->index, direction, wc);
 
 		st->UpdateVirtCoord();
@@ -2548,10 +2919,13 @@
 	if (ret.Failed()) return ret;
 
 	if (flags & DC_EXEC) {
+		st->catchment.AfterRemoveTile(tile1, CA_DOCK);
+		st->catchment.AfterRemoveTile(tile2, CA_DOCK);
 		DoClearSquare(tile1);
 		MarkTileDirtyByTile(tile1);
 		MakeWaterKeepingClass(tile2, st->owner);
 
+		if (Overlays::Instance()->HasStation(st)) st->MarkAcceptanceTilesDirty();
 		st->rect.AfterRemoveTile(st, tile1);
 		st->rect.AfterRemoveTile(st, tile2);
 
@@ -2876,6 +3250,8 @@
 		}
 	}
 
+	DrawOverlay(ti, MP_STATION);
+
 	if (HasStationRail(ti->tile) && HasCatenaryDrawn(GetRailType(ti->tile))) DrawCatenary(ti);
 
 	if (HasBit(roadtypes, ROADTYPE_TRAM)) {
@@ -3254,8 +3630,27 @@
 			}
 
 			if (!skip) {
-				int b = ge->last_speed - 85;
-				if (b >= 0) rating += b >> 2;
+				int b = ge->last_speed;
+ 
+				if ((st->last_vehicle_type == VEH_TRAIN) || (st->last_vehicle_type == VEH_AIRCRAFT)) {
+					b -= 85;
+					if (b >= 0) rating += b>>2;
+				}
+				else	{
+					if (st->last_vehicle_type == VEH_ROAD)	{
+						b -= 60;
+						if (b >= 0) rating += b>>1;
+					}
+					else	{
+						//ships LSB is 0.5km/h not 1km/h
+						if (st->last_vehicle_type == VEH_SHIP)	{
+							b -= 40;
+							if (b >= 0) rating += b;
+						}
+					}
+					//looks that rating <= 42, cause trains/plains has max 42
+					if (rating > 42 ) rating = 42;
+				}
 
 				byte waittime = ge->time_since_pickup;
 				if (st->last_vehicle_type == VEH_SHIP) waittime >>= 2;
@@ -3289,10 +3684,33 @@
 
 				/* if rating is <= 64 and more than 200 items waiting,
 				 * remove some random amount of goods from the station */
+
+//Lost cargo initialize money facter
+	const StationRect *r = &st->rect;
+//	if (r->IsEmpty()) return; // no tiles belong to this station
+	int x = TileX(st->xy) * TILE_SIZE;
+	int y = TileY(st->xy) * TILE_SIZE;
+	int z = GetSlopePixelZ(x,y);
+	Company *c = Company::Get(st->owner);
+	byte m = 0;
+	if (c && Company::IsValidID(st->owner)) m = c->money_fraction;
 				if (rating <= 64 && waiting >= 200) {
 					int dec = Random() & 0x1F;
 					if (waiting < 400) dec &= 7;
-					waiting -= dec + 1;
+					int lost = dec + 1;
+					waiting -= lost;
+//Lost cargo cost
+					if (  _settings_game.economy.lost_cargo && c && Company::IsValidID(st->owner))
+					    {
+					    CommandCost cost(EXPENSES_LOST_RUN, lost * cs->current_payment);
+					    SubtractMoneyFromCompanyFract((st)->owner,cost);
+					    Money costb = cost.GetCost();
+					    c->money_fraction = m - (byte)costb;
+					    costb >>= 8;
+					    if (c->money_fraction > m) costb++;
+					    ShowCostOrIncomeAnimation(x,y,z, costb );
+					}
+//
 					waiting_changed = true;
 				}
 
@@ -3301,7 +3719,20 @@
 					uint32 r = Random();
 					if (rating <= (int)GB(r, 0, 7)) {
 						/* Need to have int, otherwise it will just overflow etc. */
-						waiting = max((int)waiting - (int)GB(r, 8, 2) - 1, 0);
+						int lost = (int)GB(r, 8, 2) + 1;
+						waiting = max((int)waiting - lost, 0);
+//Lost cargo cost
+						if (  _settings_game.economy.lost_cargo && c && Company::IsValidID(st->owner))
+						    {
+						    CommandCost cost(EXPENSES_LOST_RUN, lost * cs->current_payment);
+						    SubtractMoneyFromCompanyFract((st)->owner,cost);
+						    Money costb = cost.GetCost();
+						    c->money_fraction = m - (byte)costb;
+						    costb >>= 8;
+						    if (c->money_fraction > m) costb++;
+						    ShowCostOrIncomeAnimation(x,y,z, costb );
+						}
+//
 						waiting_changed = true;
 					}
 				}
@@ -3363,6 +3794,17 @@
 			TriggerStationAnimation(st, st->xy, SAT_250_TICKS);
 			if (Station::IsExpected(st)) AirportAnimationTrigger(Station::From(st), AAT_STATION_250_TICKS);
 		}
+
+		if (Station::IsExpected(st)) {
+			/* Age and expire route links. */
+			Station *s = Station::From(st);
+			if (s->index % DAY_TICKS == _date_fract) AgeRouteLinks(s);
+
+			/* Decrement cargo update counter. */
+			for (CargoID cid = 0; cid < NUM_CARGO; cid++) {
+				if (s->goods[cid].cargo_counter > 0) s->goods[cid].cargo_counter--;
+			}
+		}
 	}
 }
 
@@ -3380,6 +3822,461 @@
 	}
 }
 
+struct StationIDPasteMap : SmallMap<StationID, StationID> {
+	StationID QueryIDForStation(StationID src_sid) const
+	{
+		assert(src_sid != INVALID_STATION);
+		StationIDPasteMap::const_iterator pos = this->Find(src_sid);
+		return (pos != this->End()) ? pos->second : NEW_STATION;
+	}
+
+	void ConfirmIDForStation(StationID src_sid, StationID dst_sid)
+	{
+		assert(src_sid != INVALID_STATION && dst_sid != INVALID_STATION && dst_sid != NEW_STATION);
+		StationIDPasteMap::iterator pos = this->Find(src_sid);
+		if (pos == this->End()) {
+			this->Insert(src_sid, dst_sid);
+		} else {
+			assert(pos->second == dst_sid);
+		}
+	}
+};
+
+static const StationID ADJOINING_MULTIPLE_STATIONS = NEW_STATION;
+
+struct StationPartPasteInfo {
+	GenericTileIndex src_tile;
+	TileIndex dst_tile;
+	StationID adjoining_station;
+};
+
+static std::deque<StationPartPasteInfo> _copy_paste_station_parts_queue;
+static StationIDPasteMap _copy_paste_station_id_paste_map;
+ClipboardStationsBuilder _clipboard_stations_builder;
+
+static void GetSpecFromGenericStation(GenericTileIndex tile, StationClassID *spec_class, int *spec_index)
+{
+	assert(HasStationTileRail(tile));
+
+	*spec_class = IsRailWaypointTile(tile) ? STAT_CLASS_WAYP : STAT_CLASS_DFLT;
+	*spec_index = 0;
+
+	if (IsMainMapTile(tile)) {
+		TileIndex t = AsMainMapTile(tile);
+		if (IsCustomStationSpecIndex(t)) {
+			const StationSpecList *spec = &(BaseStation::GetByTile(t)->speclist[GetCustomStationSpecIndex(t)]);
+			*spec_class = spec->spec->cls_id;
+			StationClass::GetByGrf(spec->grfid, spec->localidx, spec_index);
+		}
+	} else {
+		const ClipboardStation::Spec *spec = ClipboardStation::GetSpecByTile(tile);
+		if (spec != NULL) {
+			*spec_class = spec->spec_class;
+			*spec_index = spec->spec_index;
+		}
+	}
+}
+
+static void GetTypeLayoutFromGenericAirport(GenericTileIndex tile, AirportTypes *type, byte *layout)
+{
+	if (IsMainMapTile(tile)) {
+		Station *st = Station::GetByTile(AsMainMapTile(tile));
+		*type = (AirportTypes)st->airport.type;
+		*layout = st->airport.layout;
+	} else {
+		ClipboardStation *st = ClipboardStation::GetByTile(tile);
+		*type = st->airport.type;
+		*layout = st->airport.layout;
+	}
+}
+
+/**
+ * Test a given station tile if there is any contented to be copied from it.
+ *
+ * Stations are copy/pasted part by part, where a part is a minimal station piece that we can move
+ * e.g. a single rail station tile or a whole airport. The function writes bounds of that piece to
+ * location pointed by \c station_part_area but only once per a piece - when a cartin tile is being
+ * tested:
+ *    - in case of docks, it's the tile with land section
+ *    - in other cases, it's the most norhern tile
+ * For the rest of tiles the function still returns \c true but writes "invalid" area.
+ *
+ * If the funtion returns \c false, \c object_rect remains unchanged.
+ *
+ * @param tile the tile to test
+ * @param src_area the area we are copying
+ * @param mode copy-paste mode
+ * @param station_part_area (out, may be NULL) bounds of the station part or "invalid" area, depending on which tile was given
+ * @param company the #Company to check ownership against to
+ * @param preview (out, may be NULL) information on how to higlight preview of the tile
+ * @return whether this tile needs to be copy-pasted
+ */
+bool TestStationTileCopyability(GenericTileIndex tile, const GenericTileArea &src_area, CopyPasteMode mode, GenericTileArea *station_part_area, CompanyID company = _current_company, TileContentPastePreview *preview = NULL)
+{
+	if (preview != NULL) MemSetT(preview, 0);
+
+	StationType type = GetStationType(tile);
+	if (type != STATION_BUOY && IsMainMapTile(tile) && !IsTileOwner(tile, company)) return false;
+
+	switch (type) {
+		case STATION_WAYPOINT:
+		case STATION_RAIL:
+			if (!(mode & CPM_WITH_RAIL_TRANSPORT)) return false;
+			if (station_part_area != NULL) *station_part_area = GenericTileArea(tile, 1, 1);
+			if (preview != NULL) preview->highlight_track_bits = GetRailStationTrackBits(tile);
+			break;
+
+		case STATION_AIRPORT:
+			if (!(mode & CPM_WITH_AIR_TRANSPORT)) return false;
+			if (IsMainMapTile(tile) || station_part_area != NULL) {
+				GenericTileArea area;
+				if (IsMainMapTile(tile)) {
+					area = Station::GetByTile(AsMainMapTile(tile))->airport;
+					if (!src_area.Contains(area)) return false;
+				} else {
+					area = GenericTileArea(ClipboardStation::GetByTile(tile)->airport, MapOf(tile));
+				}
+
+				if (station_part_area != NULL) {
+					if (tile != area.tile) {
+						*station_part_area = GenericTileArea(GenericTileIndex(INVALID_TILE_INDEX, MapOf(tile)), 0, 0);
+					} else {
+						*station_part_area = area;
+					}
+				}
+			}
+			break;
+
+		case STATION_TRUCK:
+		case STATION_BUS:
+			if (!(mode & CPM_WITH_ROAD_TRANSPORT)) return false;
+			if (station_part_area != NULL) *station_part_area = GenericTileArea(tile, 1, 1);
+			break;
+
+		case STATION_OILRIG:
+			return false;
+
+		case STATION_DOCK: {
+			if (!(mode & CPM_WITH_WATER_TRANSPORT)) return false;
+			if (IsMainMapTile(tile) || station_part_area != NULL) {
+				GenericTileIndex other_tile = GetOtherDockTile(tile);
+				if (IsMainMapTile(tile) && !src_area.Contains(other_tile)) return false;
+				if (station_part_area != NULL) *station_part_area = IsLandDockSection(tile) ? GenericTileArea(tile, other_tile) : GenericTileArea(GenericTileIndex(INVALID_TILE_INDEX, MapOf(tile)), 0, 0);
+			}
+			break;
+		}
+
+		case STATION_BUOY:
+			if (!(mode & CPM_WITH_WATER_TRANSPORT)) return false;
+			if (station_part_area != NULL) *station_part_area = GenericTileArea(tile, 1, 1);
+			break;
+
+		default:
+			return false;
+	}
+
+	if (preview != NULL) preview->highlight_tile_rect = true;
+	return true;
+}
+
+static StationGfx TransformRegularRailStationGfx(StationGfx gfx, DirTransformation transformation)
+{
+	if (TransformAxis(AXIS_X, transformation) != AXIS_X) gfx ^= 0x1; // change axis
+	if ((gfx & 0x4) && IsInsideBS(transformation, DTR_ROTATE_180, 4)) gfx ^= 0x2; // mirror double-tile graphics
+	return gfx;
+}
+
+static bool IsAirportTransformable(AirportTypes type, DirTransformation dtr)
+{
+	if (type >= NEW_AIRPORT_OFFSET) return dtr == DTR_IDENTITY;
+	if (TransformAxis(AXIS_X, dtr) == AXIS_X) return true;
+	const AirportSpec *as = AirportSpec::Get(type);
+	return as->size_x == as->size_y;
+}
+
+static void CopyPastePlaceRailStation(GenericTileIndex tile, StationID sid, Axis axis, StationGfx gfx, StationClassID spec_class, byte spec_index, RailType rt, bool adjacent)
+{
+	if (IsMainMapTile(tile)) {
+		uint32 p1 = 0;
+		SB(p1, 0, 4, rt);
+		SB(p1, 4, 1, axis);
+		SB(p1, 8, 8, 1); // number of tracks
+		SB(p1, 16, 8, 1); // platform length
+		SB(p1, 24, 1, adjacent);
+		uint32 p2 = 0;
+		SB(p2, 0, 8, spec_class);
+		SB(p2, 8, 8, spec_index);
+		SB(p2, 16, 16, sid);
+		_station_gfx_to_paste = gfx;
+		_current_pasting->DoCommand(AsMainMapTile(tile), p1, p2, CMD_BUILD_RAIL_STATION | CMD_MSG(STR_ERROR_CAN_T_BUILD_RAILROAD_STATION));
+	} else {
+		MakeRailStation(tile, OWNER_NONE, sid, axis, gfx - axis, rt);
+		uint custom_specindex = _clipboard_stations_builder.AddRailStationPart(sid, spec_class, spec_index);
+		SetCustomStationSpecIndex(tile, custom_specindex);
+	}
+}
+
+static void CopyPastePlaceAirport(GenericTileIndex tile, StationID sid, AirportTypes type, byte layout, bool adjacent)
+{
+	if (IsMainMapTile(tile)) {
+		uint32 p1 = 0;
+		SB(p1, 0, 8, type);
+		SB(p1, 8, 8, layout);
+		uint32 p2 = 0;
+		SB(p2, 0, 1, adjacent);
+		SB(p2, 16, 16, sid);
+		_current_pasting->DoCommand(AsMainMapTile(tile), p1, p2, CMD_BUILD_AIRPORT | CMD_MSG(STR_ERROR_CAN_T_BUILD_AIRPORT_HERE));
+	} else {
+		for (AirportTileTableIteratorT<true> iter(AirportSpec::Get(type)->table[layout], tile); IsValidTileIndex(iter); ++iter) {
+			MakeAirport(iter, OWNER_NONE, sid, 0, WATER_CLASS_INVALID);
+		}
+		_clipboard_stations_builder.AddAirportPart(IndexOf(tile), sid, type, layout);
+	}
+}
+
+static void CopyPastePlaceRoadStop(GenericTileIndex tile, StationID sid, bool drive_through, RoadStopType rst, RoadTypes rt, DiagDirection dir, bool adjacent)
+{
+	if (drive_through) dir = (DiagDirection)DiagDirToAxis(dir);
+
+	if (IsMainMapTile(tile)) {
+		uint32 p1 = 0;
+		SB(p1, 0 , 8, 1); // width
+		SB(p1, 8 , 8, 1); // height
+		uint32 p2 = 0;
+		SB(p2, 0 , 1, rst);
+		SB(p2, 1 , 1, drive_through);
+		SB(p2, 2 , 2, rt);
+		SB(p2, 5 , 1, adjacent); //
+		SB(p2, 6 , 2, dir);
+		SB(p2, 16 , 16, sid);
+		_current_pasting->DoCommand(AsMainMapTile(tile), p1, p2, CMD_BUILD_ROAD_STOP | CMD_MSG(STR_ERROR_CAN_T_BUILD_BUS_STATION + rst));
+	} else {
+		if (drive_through) {
+			MakeDriveThroughRoadStop(tile, OWNER_NONE, OWNER_NONE, OWNER_NONE, sid, rst, rt, DiagDirToAxis(dir));
+		} else {
+			MakeRoadStop(tile, OWNER_NONE, sid, rst, rt, dir);
+		}
+		_clipboard_stations_builder.AddRoadStopPart(sid);
+	}
+}
+
+static void CopyPastePlaceDock(GenericTileIndex tile, StationID sid, DiagDirection dir, WaterClass wc, bool adjacent)
+{
+	if (IsMainMapTile(tile)) {
+		TileIndex t = AsMainMapTile(tile);
+		TileIndex t_lower = TileAddByDiagDir(t, dir);
+		if (!HasTileWaterGround(t_lower)) {
+			CopyPastePlaceCannal(GenericTileIndex(t_lower));
+			if (_current_pasting->last_result.Failed()) return;
+		}
+
+		uint32 p1 = 0;
+		SB(p1, 0, 1, adjacent);
+		uint32 p2 = 0;
+		SB(p2, 16 , 16, sid);
+		_current_pasting->DoCommand(t, p1, p2, CMD_BUILD_DOCK | CMD_MSG(STR_ERROR_CAN_T_BUILD_DOCK_HERE));
+	} else {
+		MakeDock(tile, OWNER_NONE, sid, dir, wc);
+		_clipboard_stations_builder.AddDockPart(sid);
+	}
+}
+
+static void CopyPasteStation(GenericTileIndex src_tile, GenericTileIndex dst_tile, const CopyPasteParams &copy_paste, StationID dst_sid, bool adjacent = true)
+{
+	StationType station_type = GetStationType(src_tile);
+	switch (station_type) {
+		case STATION_RAIL:
+		case STATION_WAYPOINT: {
+			StationGfx gfx = GetStationGfx(src_tile);
+			Axis axis = TransformAxis(GetRailStationAxis(src_tile), copy_paste.transformation);
+			StationClassID spec_class;
+			int spec_index;
+			GetSpecFromGenericStation(src_tile, &spec_class, &spec_index);
+
+			if (IsRegularRailStation(spec_class, spec_index)) {
+				gfx = TransformRegularRailStationGfx(gfx, copy_paste.transformation);
+			} else {
+				const StationSpec *statspec = StationClass::Get(spec_class)->GetSpec(spec_index);
+				if (statspec == NULL || statspec->disallowed_lengths & 1 || statspec->disallowed_platforms & 1) {
+					/* convert to a standart station  */
+					if (spec_class != STAT_CLASS_WAYP) spec_class = STAT_CLASS_DFLT;
+					spec_index = 0;
+					gfx = axis;
+				}
+			}
+
+			RailType railtype = (copy_paste.mode & CPM_CONVERT_RAILTYPE) ? copy_paste.railtype : GetRailType(src_tile);
+			switch (station_type) {
+				case STATION_RAIL: CopyPastePlaceRailStation(dst_tile, dst_sid, axis, gfx, spec_class, spec_index, railtype, adjacent); break;
+				case STATION_WAYPOINT: CopyPastePlaceRailWaypoint(dst_tile, dst_sid, axis, gfx, spec_class, spec_index, railtype, adjacent); break;
+				default: NOT_REACHED();
+			}
+
+			break;
+		}
+
+		case STATION_AIRPORT: {
+			AirportTypes type;
+			byte layout;
+			GetTypeLayoutFromGenericAirport(src_tile, &type, &layout);
+			if (!IsAirportTransformable(type, copy_paste.transformation)) {
+				assert(IsMainMapTile(dst_tile)); // copying should be always successful
+				_current_pasting->CollectError(AsMainMapTile(dst_tile), STR_ERROR_INAPPLICABLE_TRANSFORMATION, STR_ERROR_CAN_T_BUILD_AIRPORT_HERE);
+				return;
+			}
+			CopyPastePlaceAirport(dst_tile, dst_sid, type, layout, adjacent);
+			break;
+		}
+
+		case STATION_TRUCK:
+		case STATION_BUS:
+			CopyPastePlaceRoadStop(dst_tile, dst_sid, IsDriveThroughStopTile(src_tile), GetRoadStopType(src_tile),
+					GetRoadTypes(src_tile), TransformDiagDir(GetRoadStopDir(src_tile), copy_paste.transformation), adjacent);
+			break;
+
+		case STATION_DOCK: CopyPastePlaceDock(dst_tile, dst_sid, TransformDiagDir(GetDockDirection(src_tile), copy_paste.transformation), GetWaterClass(src_tile), adjacent); break;
+		case STATION_BUOY: CopyPastePlaceBuoy(dst_tile, dst_sid, GetWaterClass(src_tile)); break;
+
+		default:
+			NOT_REACHED();
+	}
+}
+
+void CopyPasteTile_Station(GenericTileIndex src_tile, GenericTileIndex dst_tile, const CopyPasteParams &copy_paste)
+{
+	GenericTileArea part_src_rect;
+	if (!TestStationTileCopyability(src_tile, copy_paste.src_area, copy_paste.mode, &part_src_rect)) return;
+	if (part_src_rect.tile.index == INVALID_TILE_INDEX) return; // copy this part only once
+
+	if (IsMainMapTile(dst_tile)) {
+		TileIndex t = copy_paste.src_area.ReverseTransformTile(src_tile, AsMainMapTile(dst_tile), copy_paste.transformation); // transformed northern tile of the copy_paste.src_area
+		t = copy_paste.src_area.TransformTile(part_src_rect.tile, t, copy_paste.transformation); // transformed northern tile of the part_src_rect
+		t = part_src_rect.ReverseTransformedNorth(t, copy_paste.transformation); // northern tile of the transformed part_src_rect
+		TileArea part_dst_rect = TransformTileArea(part_src_rect, t, copy_paste.transformation); // transformed part_src_rect
+
+		/* Terraform tiles */
+		if ((copy_paste.mode & CPM_TERRAFORM_MASK) == CPM_TERRAFORM_MINIMAL) {
+			CopyPasteHeights(part_src_rect, GenericTileIndex(part_dst_rect.tile), copy_paste.transformation, copy_paste.height_delta);
+			if (IsPastingInterrupted()) return;
+		}
+
+		StationType station_type = GetStationType(src_tile);
+		if ((station_type != STATION_BUOY) && (_current_pasting->dc_flags & DC_EXEC)) {
+			/* Firstly find all joining stations. We must find all station candidates to be joined
+			 * to and we must do if before we try to build any station part to avoid joining new
+			 * stations together. */
+			BaseStation *st = NULL;
+			CommandCost ret;
+			if (station_type != STATION_WAYPOINT) {
+				Station *station = NULL;
+				ret = FindJoiningStation(INVALID_STATION, INVALID_STATION, false, part_dst_rect, &station);
+				st = station;
+			} else {
+				Waypoint *waypoint = NULL;
+				ret = FindJoiningWaypoint(INVALID_STATION, INVALID_STATION, false, part_dst_rect, &waypoint);
+				st = waypoint;
+			}
+
+			StationPartPasteInfo info = { src_tile, AsMainMapTile(dst_tile), INVALID_STATION };
+			if (ret.Succeeded() && st != NULL) info.adjoining_station = st->index;
+			if (ret.Failed() && ret.GetErrorMessage() != STR_ERROR_ADJOINS_MORE_THAN_ONE_EXISTING) {
+				info.adjoining_station = ADJOINING_MULTIPLE_STATIONS;
+			}
+
+			/* process joining parts before non-joining so we can find the station to join */
+			if (info.adjoining_station != INVALID_STATION) {
+				_copy_paste_station_parts_queue.push_front(info);
+			} else {
+				_copy_paste_station_parts_queue.push_back(info);
+			}
+		} else {
+			CopyPasteStation(src_tile, dst_tile, copy_paste, NEW_STATION, false);
+		}
+	} else { // !IsMainMapTile(dst_tile)
+		CopyPasteStation(src_tile, dst_tile, copy_paste, GetStationIndex(src_tile));
+	}
+}
+
+void ProcessStationPartPasteQueue(const CopyPasteParams &copy_paste)
+{
+	if (_copy_paste_station_parts_queue.empty()) return;
+
+	while (!IsPastingInterrupted()) {
+		uint queue_size = _copy_paste_station_parts_queue.size();
+		for (uint i = 0; i < queue_size; i++) {
+			StationPartPasteInfo info = _copy_paste_station_parts_queue.front();
+			_copy_paste_station_parts_queue.pop_front();
+			StationID src_sid = GetStationIndex(info.src_tile);
+			StationID dst_sid = _copy_paste_station_id_paste_map.QueryIDForStation(src_sid);
+			bool adjacent = true;
+
+			if (info.adjoining_station != INVALID_STATION) {
+				/* 'adjoining_station == ADJOINING_MULTIPLE_STATIONS' means that we've found multiple
+				 *  stations adjoining to this part when running the pre-search (see CopyPasteTile_Station). */
+				if ((info.adjoining_station == ADJOINING_MULTIPLE_STATIONS) ||
+						/*'dst_sid != NEW_STATION' means that we already chose the station to join.
+						 * If 'dst_sid != info.adjoining_station' then it's not the station that was
+						 * found adjoining to this part in the pre-search. */
+						(dst_sid != NEW_STATION && dst_sid != info.adjoining_station)) {
+					/* In booth these cases we just wan't to fail. If we won't allow to build
+					 * adjacently then we will get a nice "adjoins more then one existing" error. */
+					adjacent = false;
+				}
+				/* If so far no parts have been built then we will try to choose the station to join.
+				 * Try the one that was found adjoining to this part. */
+				if (dst_sid == NEW_STATION && info.adjoining_station != ADJOINING_MULTIPLE_STATIONS) dst_sid = info.adjoining_station;
+			}
+
+			CopyPasteStation(info.src_tile, GenericTileIndex(info.dst_tile), copy_paste, dst_sid, adjacent);
+
+			if (_current_pasting->last_result.Succeeded()) {
+				/* Confirm that this station will use a certain ID. */
+				_copy_paste_station_id_paste_map.ConfirmIDForStation(src_sid, GetStationIndex(info.dst_tile));
+			} else if (_current_pasting->last_result.GetErrorMessage() == STR_ERROR_CAN_T_DISTANT_JOIN) {
+				/* If we can't distant-join now then perhaps we will be able to do it later, after other parts. */
+				if (_current_pasting->err_message == STR_ERROR_CAN_T_DISTANT_JOIN) {
+					/* discard the "can't distatnt-join" error */
+					_current_pasting->err_tile = INVALID_TILE;
+					_current_pasting->err_message = STR_ERROR_NOTHING_TO_DO;
+				}
+				_copy_paste_station_parts_queue.push_back(info);
+			}
+		}
+		if (queue_size == _copy_paste_station_parts_queue.size()) break; // don't retry if the queue didn't shrink
+	}
+
+	/* set the "can't distatnt-join" error if not all retries were successfull */
+	if (_copy_paste_station_parts_queue.size() != 0) {
+		/* execute command just to fail and get proper error message */
+		const StationPartPasteInfo &info = _copy_paste_station_parts_queue.front();
+		StationID dst_sid = _copy_paste_station_id_paste_map.QueryIDForStation(GetStationIndex(info.src_tile));
+		CopyPasteStation(info.src_tile, GenericTileIndex(info.dst_tile), copy_paste, dst_sid, true);
+	}
+
+	_copy_paste_station_parts_queue.clear();
+}
+
+void AfterPastingStations(const CopyPasteParams &copy_paste)
+{
+	ProcessStationPartPasteQueue(copy_paste);
+
+	for (StationIDPasteMap::iterator it = _copy_paste_station_id_paste_map.Begin(); it != _copy_paste_station_id_paste_map.End(); it++) {
+		BaseStation *st = BaseStation::Get(it->second);
+		assert(st != NULL);
+		TILE_AREA_LOOP(tile, st->train_station) {
+			if (st->TileBelongsToRailStation(tile) && GetStationSpec(tile) != NULL) {
+				TriggerStationAnimation(st, tile, SAT_BUILT);
+			}
+		}
+	};
+	_copy_paste_station_id_paste_map.Clear();
+}
+
+void AfterCopyingStations(const CopyPasteParams &copy_paste)
+{
+	_clipboard_stations_builder.BuildDone(MapOf(copy_paste.dst_area.tile));
+}
+
 
 void ModifyStationRatingAround(TileIndex tile, Owner owner, int amount, uint radius)
 {
@@ -3399,7 +4296,7 @@
 	}
 }
 
-static uint UpdateStationWaiting(Station *st, CargoID type, uint amount, SourceType source_type, SourceID source_id)
+uint UpdateStationWaiting(Station *st, CargoID type, uint amount, SourceType source_type, SourceID source_id, TileIndex dest_tile, SourceType dest_type, SourceID dest_id, OrderID next_hop, StationID next_unload, byte flags)
 {
 	/* We can't allocate a CargoPacket? Then don't do anything
 	 * at all; i.e. just discard the incoming cargo. */
@@ -3413,7 +4310,7 @@
 	/* No new "real" cargo item yet. */
 	if (amount == 0) return 0;
 
-	ge.cargo.Append(new CargoPacket(st->index, st->xy, amount, source_type, source_id));
+	ge.cargo.Append(new CargoPacket(st->index, st->xy, amount, source_type, source_id, dest_tile, dest_type, dest_id, next_hop, next_unload, flags));
 
 	if (!HasBit(ge.acceptance_pickup, GoodsEntry::GES_PICKUP)) {
 		InvalidateWindowData(WC_STATION_LIST, st->index);
@@ -3538,11 +4435,14 @@
 	return &this->stations;
 }
 
-uint MoveGoodsToStation(CargoID type, uint amount, SourceType source_type, SourceID source_id, const StationList *all_stations)
+uint MoveGoodsToStation(CargoID type, uint amount, SourceType source_type, SourceID source_id, const StationList *all_stations, TileIndex src_tile)
 {
 	/* Return if nothing to do. Also the rounding below fails for 0. */
 	if (amount == 0) return 0;
 
+	/* Handle cargo that has cargo destinations enabled. */
+	if (MoveCargoWithDestinationToStation(type, &amount, source_type, source_id, all_stations, src_tile)) return amount;
+
 	Station *st1 = NULL;   // Station with best rating
 	Station *st2 = NULL;   // Second best station
 	uint best_rating1 = 0; // rating of st1
@@ -3614,7 +4514,7 @@
 	Station *st = new Station(tile);
 	st->town = ClosestTownFromTile(tile, UINT_MAX);
 
-	st->string_id = GenerateStationName(st, tile, STATIONNAMING_OILRIG);
+	st->string_id = GenerateStationName(st, tile, 1, 1, STATIONNAMING_OILRIG);
 
 	assert(IsTileType(tile, MP_INDUSTRY));
 	DeleteAnimatedTile(tile);
@@ -3628,6 +4528,7 @@
 	st->build_date = _date;
 
 	st->rect.BeforeAddTile(tile, StationRect::ADD_FORCE);
+	st->catchment.BeforeAddTile(tile, st->GetCatchmentRadius());
 
 	st->UpdateVirtCoord();
 	UpdateStationAcceptance(st, false);
@@ -3638,6 +4539,7 @@
 {
 	Station *st = Station::GetByTile(tile);
 
+	st->catchment.AfterRemoveTile(tile, st->GetCatchmentRadius());
 	MakeWaterKeepingClass(tile, OWNER_NONE);
 
 	st->dock_tile = INVALID_TILE;
@@ -3645,6 +4547,7 @@
 	st->facilities &= ~(FACIL_AIRPORT | FACIL_DOCK);
 	st->airport.flags = 0;
 
+	if (Overlays::Instance()->HasStation(st)) st->MarkAcceptanceTilesDirty();
 	st->rect.AfterRemoveTile(st, tile);
 
 	st->UpdateVirtCoord();
@@ -3859,4 +4762,5 @@
 	VehicleEnter_Station,       // vehicle_enter_tile_proc
 	GetFoundation_Station,      // get_foundation_proc
 	TerraformTile_Station,      // terraform_tile_proc
+	CopyPasteTile_Station,      // copypaste_tile_proc
 };
diff -urNad openttd-1.3.2/src/station.cpp openttd-1.3.2-DC3.0RC3/src/station.cpp
--- openttd-1.3.2/src/station.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/station.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -24,6 +24,8 @@
 #include "roadstop_base.h"
 #include "industry.h"
 #include "core/random_func.hpp"
+#include "cargodest_func.h"
+#include "overlay_cmd.h"
 
 #include "table/strings.h"
 
@@ -93,6 +95,9 @@
 		if (v->last_station_visited == this->index) {
 			v->last_station_visited = INVALID_STATION;
 		}
+		if (v->last_station_loaded == this->index) {
+			v->last_station_loaded = INVALID_STATION;
+		}
 	}
 
 	/* Clear the persistent storage. */
@@ -105,6 +110,10 @@
 		InvalidateWindowData(WC_STATION_LIST, this->owner, 0);
 	}
 
+	if (Overlays::Instance()->HasStation(Station::Get(this->index))) {
+		Overlays::Instance()->ToggleStation(Station::Get(this->index));
+	};
+
 	DeleteWindowById(WC_STATION_VIEW, index);
 
 	/* Now delete all orders that go to the station */
@@ -118,8 +127,22 @@
 	}
 
 	CargoPacket::InvalidateAllFrom(this->index);
+	InvalidateStationRouteLinks(this);
 }
 
+bool Station::IsTileInCatchmentArea(const TileInfo* ti, CatchmentType type) const
+{
+	switch (type) {
+		case ACCEPTANCE:
+			return this->rect.PtInExtendedRect(TileX(ti->tile),TileY(ti->tile),this->GetCatchmentRadius());
+		case PRODUCTION:
+			return this->catchment.IsTileInCatchment(ti->tile);
+		case INDUSTRY:
+			return false;
+		default:
+			NOT_REACHED();
+	}
+}
 
 /**
  * Invalidating of the JoinStation window has to be done
@@ -169,6 +192,43 @@
 }
 
 /**
+ * Called when happen ctrl+click on row in StationView.
+ * Delete this item from current acceptance of production.
+ * Two parts: when click first time just stop get new production from indestries.
+ * On second click clear that cargo list on this station.
+ * @param cargo_type_to_drop CargoID that need to be dropped on this station.
+ * @param waitind Click happen in WaitingCargo list or not.
+ */
+void Station::ChangeAcceptance(CargoID cargo_type, bool waiting)
+{
+	GoodsEntry &ge = this->goods[cargo_type];
+	
+	if (waiting) {
+		if (HasBit(ge.acceptance_pickup, GoodsEntry::GES_PICKUP)) {
+			/* Stop getting new cargoes from industry around*/
+			ClrBit(ge.acceptance_pickup, GoodsEntry::GES_PICKUP);
+			ge.time_since_pickup = 255;
+			ge.last_speed = 0;
+			ge.last_age = 255;
+		}
+		else {
+			/* Clear this cargo list. Station will be completely empty of this type of cargo. */
+			ge.cargo.Truncate(0);
+		}
+	}
+	else {
+		if (!HasBit(ge.acceptance_pickup, GoodsEntry::GES_PICKUP)) {
+			/* Start getting new cargoes from industry around */
+			SetBit(ge.acceptance_pickup, GoodsEntry::GES_PICKUP);
+			ge.time_since_pickup = 100; // Some penalties: vehicle on station is still good thing.
+			ge.last_speed = 1;
+			ge.last_age = 50;
+			ge.rating = ge.rating * 0.8;
+		}
+	}
+}
+
+/**
  * Marks the tiles of the station as dirty.
  *
  * @ingroup dirty
@@ -200,6 +260,18 @@
 	}
 }
 
+void Station::MarkAcceptanceTilesDirty() const
+{
+	Rect rec = this->GetCatchmentRect();
+	TileIndex top_left = TileXY(rec.left, rec.top);
+	int width = rec.right - rec.left + 1;
+	int height = rec.bottom - rec.top + 1;
+
+	TILE_AREA_LOOP(tile, TileArea(top_left, width, height) ) {
+		MarkTileDirtyByTile(tile);
+	}
+}
+
 /* virtual */ uint Station::GetPlatformLength(TileIndex tile) const
 {
 	assert(this->TileBelongsToRailStation(tile));
@@ -385,6 +457,23 @@
 			this->top - distance <= y && y <= this->bottom + distance;
 }
 
+/**
+ * Determines whether a tile area intersects the station rectangle with a given offset.
+ * @param area The tile area to test.
+ * @param distance Offset the station rect is grown on all sides (L1 norm).
+ * @return True if the tile area intersects with the station rectangle.
+ */
+bool StationRect::AreaInExtendedRect(const TileArea& area, int distance) const
+{
+	int area_left = TileX(area.tile);
+	int area_right = area_left + area.w;
+	int area_top = TileY(area.tile);
+	int area_bottom = area_top + area.h;
+
+	return this->left - distance <= area_right && area_left <= this->right + distance &&
+			this->top - distance <= area_bottom && area_top <= this->bottom + distance;
+}
+
 bool StationRect::IsEmpty() const
 {
 	return this->left == 0 || this->left > this->right || this->top > this->bottom;
@@ -541,3 +630,89 @@
 	/* 3 bits fraction for the maintenance cost factor. */
 	return total_cost >> 3;
 }
+
+
+/************************************************************************/
+/*                   StationCatchment implementation                    */
+/************************************************************************/
+
+StationCatchment::StationCatchment()
+{
+}
+
+/**
+ * Determines whether a given point (x, y) is within the station catchment area
+ * @param tile TileIndex to test
+ * @return true if the point is within the station catchment area
+ */
+bool StationCatchment::IsTileInCatchment(TileIndex tile) const
+{
+	return this->catchmentTiles.find(tile) != this->catchmentTiles.end();
+}
+
+bool StationCatchment::IsEmpty() const
+{
+	return this->catchmentTiles.empty();
+}
+
+void StationCatchment::BeforeAddTile(TileIndex tile, uint catchmentRadius)
+{
+	int x = TileX(tile);
+	int y = TileY(tile);
+	TileIndex top_left = TileXY(max<int>(x - catchmentRadius,0),max<int>(y - catchmentRadius, 0));
+	int w = min<int>(x + catchmentRadius, MapMaxX()) - TileX(top_left) + 1;
+	int h = min<int>(y + catchmentRadius, MapMaxY()) - TileY(top_left) + 1;
+	if (IsEmpty()) {
+		/* we are adding the first station tile */
+		TILE_AREA_LOOP(t, TileArea(top_left, w, h) ) {
+			std::set<TileIndex> fromSet;
+			fromSet.insert(tile);
+			this->catchmentTiles[t] = fromSet;
+		}
+	} else {		
+		TILE_AREA_LOOP(t, TileArea(top_left, w, h) ) {
+			std::map<TileIndex, std::set<TileIndex> >::iterator found = this->catchmentTiles.find(t);
+			if ( found == this->catchmentTiles.end()) {
+				std::set<TileIndex> fromSet;
+				fromSet.insert(tile);
+				this->catchmentTiles[t] = fromSet;
+			} else if ((*found).second.find(tile) == (*found).second.end()) {
+				(*found).second.insert(tile);
+			}
+		}
+	}
+}
+
+void StationCatchment::BeforeAddRect(TileIndex tile, int w, int h, uint catchmentRadius)
+{
+	TILE_AREA_LOOP(t, TileArea(tile, w, h) ) {
+		this->BeforeAddTile(t, catchmentRadius);
+	}
+}
+
+void StationCatchment::AfterRemoveTile(TileIndex tile, uint catchmentRadius)
+{
+	int x = TileX(tile);
+	int y = TileY(tile);
+	TileIndex top_left = TileXY(max<int>(x - catchmentRadius,0),max<int>(y - catchmentRadius, 0));
+	int w = min<int>(x + catchmentRadius, MapMaxX()) - TileX(top_left) + 1;
+	int h = min<int>(y + catchmentRadius, MapMaxY()) - TileY(top_left) + 1;
+	TILE_AREA_LOOP(t, TileArea(top_left, w, h)) {
+		std::map<TileIndex, std::set<TileIndex> >::iterator found = this->catchmentTiles.find(t);
+		assert(found != this->catchmentTiles.end());
+		std::set<TileIndex>::iterator stTileIter = (*found).second.find(tile);
+		assert(stTileIter != (*found).second.end());
+		(*found).second.erase(stTileIter);
+		if ((*found).second.empty()) {
+			// tile t is no longer in StationCatchment
+			this->catchmentTiles.erase(found);
+		}
+	}
+}
+
+void StationCatchment::AfterRemoveRect(TileIndex tile, int w, int h, uint catchmentRadius)
+{
+	TILE_AREA_LOOP(t, TileArea(tile, w, h)) {
+		this->AfterRemoveTile(t, catchmentRadius);
+	}
+}
diff -urNad openttd-1.3.2/src/station_func.h openttd-1.3.2-DC3.0RC3/src/station_func.h
--- openttd-1.3.2/src/station_func.h	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/station_func.h	2013-11-22 05:49:07.000000000 +0100
@@ -17,6 +17,7 @@
 #include "road_type.h"
 #include "economy_func.h"
 #include "rail.h"
+#include "order_type.h"
 
 void ModifyStationRatingAround(TileIndex tile, Owner owner, int amount, uint radius);
 
@@ -28,7 +29,11 @@
 CargoArray GetProductionAroundTiles(TileIndex tile, int w, int h, int rad);
 CargoArray GetAcceptanceAroundTiles(TileIndex tile, int w, int h, int rad, uint32 *always_accepted = NULL);
 
+CargoArray GetProductionRateAroundTiles(TileIndex tile, int w, int h, int rad);
+CargoArray GetAcceptanceRateAroundTiles(TileIndex tile, int w, int h, int rad);
+
 void UpdateStationAcceptance(Station *st, bool show_msg);
+uint UpdateStationWaiting(Station *st, CargoID type, uint amount, SourceType source_type, SourceID source_id, TileIndex dest_tile = INVALID_TILE, SourceType dest_type = ST_INDUSTRY, SourceID dest_id = INVALID_SOURCE, OrderID next_hop = INVALID_ORDER, StationID next_unload = INVALID_STATION, byte flags = 0);
 
 const DrawTileSprites *GetStationTileLayout(StationType st, byte gfx);
 void StationPickerDrawSprite(int x, int y, StationType st, RailType railtype, RoadType roadtype, int image);
diff -urNad openttd-1.3.2/src/station_gui.cpp openttd-1.3.2-DC3.0RC3/src/station_gui.cpp
--- openttd-1.3.2/src/station_gui.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/station_gui.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -29,11 +29,17 @@
 #include "sortlist_type.h"
 #include "core/geometry_func.hpp"
 #include "vehiclelist.h"
+#include "core/math_func.hpp"
+#include "overlay_cmd.h"
 #include "town.h"
+#include "industry.h"
+#include "cargodest_base.h"
+#include "departures_gui.h"
 
 #include "widgets/station_widget.h"
 
 #include "table/strings.h"
+#include "table/control_codes.h"
 
 /**
  * Calculates and draws the accepted or supplied cargo around the selected tile(s)
@@ -51,10 +57,13 @@
 	uint32 cargo_mask = 0;
 	if (_thd.drawstyle == HT_RECT && tile < MapSize()) {
 		CargoArray cargoes;
+		CargoArray rates;
 		if (supplies) {
 			cargoes = GetProductionAroundTiles(tile, _thd.size.x / TILE_SIZE, _thd.size.y / TILE_SIZE, rad);
+			rates = GetProductionRateAroundTiles(tile, _thd.size.x / TILE_SIZE, _thd.size.y / TILE_SIZE, rad);
 		} else {
 			cargoes = GetAcceptanceAroundTiles(tile, _thd.size.x / TILE_SIZE, _thd.size.y / TILE_SIZE, rad);
+			rates = GetAcceptanceRateAroundTiles(tile, _thd.size.x / TILE_SIZE, _thd.size.y / TILE_SIZE, rad);
 		}
 
 		/* Convert cargo counts to a set of cargo bits, and draw the result. */
@@ -66,9 +75,18 @@
 				default: NOT_REACHED();
 			}
 			if (cargoes[i] >= (supplies ? 1U : 8U)) SetBit(cargo_mask, i);
+
+			if (i == CT_PASSENGERS) {
+				SetDParam(2, rates[i]);
+			} else if (i == CT_MAIL) {
+				SetDParam(3, rates[i]);
+			}
 		}
 	}
 	SetDParam(0, cargo_mask);
+
+	/* SCC_CARGO_LIST works as a magic number to let FormatString() know it's being called from here. */
+	SetDParam(1, SCC_CARGO_LIST);
 	return DrawStringMultiLine(left, right, top, INT32_MAX, supplies ? STR_STATION_BUILD_SUPPLIES_CARGO : STR_STATION_BUILD_ACCEPTS_CARGO);
 }
 
@@ -733,6 +751,8 @@
 	NWidget(NWID_HORIZONTAL),
 		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
 		NWidget(WWT_CAPTION, COLOUR_GREY, WID_SV_CAPTION), SetDataTip(STR_STATION_VIEW_CAPTION, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+                NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_SV_DEPARTURES), SetMinimalSize(50, 12),
+                    SetDataTip(STR_STATION_VIEW_DEPARTURES_BUTTON, STR_STATION_VIEW_DEPARTURES_TOOLTIP),
 		NWidget(WWT_SHADEBOX, COLOUR_GREY),
 		NWidget(WWT_STICKYBOX, COLOUR_GREY),
 	EndContainer(),
@@ -743,14 +763,18 @@
 	NWidget(WWT_PANEL, COLOUR_GREY, WID_SV_ACCEPT_RATING_LIST), SetMinimalSize(249, 32), SetResize(1, 0), EndContainer(),
 	NWidget(NWID_HORIZONTAL),
 		NWidget(NWID_HORIZONTAL, NC_EQUALSIZE),
-			NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_SV_LOCATION), SetMinimalSize(45, 12), SetResize(1, 0), SetFill(1, 1),
+//I don't like the cover button
+//                       NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_SV_COVERAGE), SetMinimalSize(60, 12), SetResize(1, 0), SetFill(1, 1),
+//                                       SetDataTip(STR_BUTTON_COVERAGE, STR_STATION_VIEW_COVERAGE_TIP),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_SV_LOCATION), SetMinimalSize(36, 12), SetResize(1, 0), SetFill(1, 1),
 					SetDataTip(STR_BUTTON_LOCATION, STR_STATION_VIEW_CENTER_TOOLTIP),
-			NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_SV_ACCEPTS_RATINGS), SetMinimalSize(46, 12), SetResize(1, 0), SetFill(1, 1),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_SV_ACCEPTS_RATINGS), SetMinimalSize(37, 12), SetResize(1, 0), SetFill(1, 1),
 					SetDataTip(STR_STATION_VIEW_RATINGS_BUTTON, STR_STATION_VIEW_RATINGS_TOOLTIP),
-			NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_SV_RENAME), SetMinimalSize(45, 12), SetResize(1, 0), SetFill(1, 1),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_SV_CARGO_FROM_TO_VIA), SetMinimalSize(36, 12), SetResize(1, 0), SetFill(1, 1),
+					SetDataTip(STR_STATION_VIEW_WAITING_VIA_BUTTON, STR_STATION_VIEW_WAITING_VIA_TOOLTIP),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_SV_RENAME), SetMinimalSize(36, 12), SetResize(1, 0), SetFill(1, 1),
 					SetDataTip(STR_BUTTON_RENAME, STR_STATION_VIEW_RENAME_TOOLTIP),
-		EndContainer(),
-		NWidget(WWT_TEXTBTN, COLOUR_GREY, WID_SV_CLOSE_AIRPORT), SetMinimalSize(45, 12), SetResize(1, 0), SetFill(1, 1),
+		NWidget(WWT_TEXTBTN, COLOUR_GREY, WID_SV_CLOSE_AIRPORT), SetMinimalSize(36, 12), SetResize(1, 0), SetFill(1, 1),
 				SetDataTip(STR_STATION_VIEW_CLOSE_AIRPORT, STR_STATION_VIEW_CLOSE_AIRPORT_TOOLTIP),
 		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_SV_TRAINS), SetMinimalSize(14, 12), SetFill(0, 1), SetDataTip(STR_TRAIN, STR_STATION_VIEW_SCHEDULED_TRAINS_TOOLTIP),
 		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_SV_ROADVEHS), SetMinimalSize(14, 12), SetFill(0, 1), SetDataTip(STR_LORRY, STR_STATION_VIEW_SCHEDULED_ROAD_VEHICLES_TOOLTIP),
@@ -786,28 +810,161 @@
 
 struct CargoData {
 	CargoID cargo;
-	StationID source;
+	union {
+		StationID station;
+		SourceID  css;
+	};
 	uint count;
+	SourceType type;
 
-	CargoData(CargoID cargo, StationID source, uint count) :
+	CargoData(CargoID cargo, StationID station, uint count, SourceType type = ST_INDUSTRY) :
 		cargo(cargo),
-		source(source),
-		count(count)
+		station(station),
+		count(count),
+		type(type)
 	{ }
 };
 
 typedef std::list<CargoData> CargoDataList;
 
+/** List of cargo for either one next hop or one destination. */
+struct CargoDestEntry {
+	typedef std::list<CargoDestEntry> List;
+
+	/** Enum for type of stored data. */
+	enum Type {
+		FINAL_DEST,   ///< Data is the final destination.
+		NEXT_HOP,     ///< Data is the next hop.
+		TRANSFER_HOP  ///< Data is the transfer station.
+	};
+
+	List          children;       ///< Child entries of this entry.
+	CargoData     data;           ///< Stores the info for the current item.
+	Type          type;           ///< Type of the data stored in #entry.
+	uint16        start_row;      ///< Row number of the header line.
+	bool          expanded;       ///< Is this entry expanded?
+
+	CargoDestEntry(Type type, StationID station, uint count, SourceType st = ST_INDUSTRY) :
+		data(INVALID_CARGO, station, count, st),
+		type(type),
+		start_row(0),
+		expanded(false)
+	{ }
+
+	/** Zero out this entry and all child entries. */
+	void Zero()
+	{
+		for (List::iterator i = this->children.begin(); i != this->children.end(); ++i ) {
+			i->Zero();
+		}
+		this->data.count = 0;
+		this->start_row = 0;
+	}
+
+	/** Remove all empty child entries. */
+	void RemoveEmpty()
+	{
+		for (List::iterator i = this->children.begin(); i != this->children.end(); ) {
+			if (i->data.count > 0) {
+				i->RemoveEmpty();
+				++i;
+			} else {
+				i = this->children.erase(i);
+			}
+		}
+	}
+
+	/** Update header row number. */
+	int UpdateRowCount(int row)
+	{
+		this->start_row = ++row;
+		if (this->expanded) {
+			for (List::iterator i = this->children.begin(); i != this->children.end(); ++i) {
+				row = i->UpdateRowCount(row);
+			}
+		}
+		return row;
+	}
+};
+
+/**
+ * Get the next hop of a cargo packet.
+ * @param ge Station cargo info for the matching cargo type.
+ * @param cp The cargo packet.
+ * @return Station ID of the next hop or INVALID_STATION if not possible.
+ */
+static StationID GetNextHopStation(const GoodsEntry &ge, const CargoPacket *cp)
+{
+	StationID next = INVALID_STATION;
+	for (RouteLinkList::const_iterator i = ge.routes.begin(); i != ge.routes.end(); ++i) {
+		if ((*i)->GetOriginOrderId() == cp->NextHop()) {
+			next = (*i)->GetDestination();
+			break;
+		}
+	}
+	return next;
+}
+
+/**
+ * Add a cargo packet to a #CargoDestEntry list.
+ * @param list The list to add the packet to.
+ * @param type Which value to select as the entry info.
+ * @param cp The cargo packet.
+ * @param ge Where this cargo packets belongs to.
+ * @return Pointer to the added entry or NULL if the packet had no valid destination of the specified type.
+ */
+static CargoDestEntry *AddCargoPacketToList(CargoDestEntry::List &list, CargoDestEntry::Type type, const CargoPacket *cp, const GoodsEntry &ge)
+{
+	assert_compile(INVALID_STATION == INVALID_SOURCE);
+
+	/* Extract the wanted sort type from the cargo packet. */
+	uint16 sort_val;
+	switch (type) {
+		case CargoDestEntry::FINAL_DEST:
+			sort_val = cp->DestinationID();
+			break;
+		case CargoDestEntry::NEXT_HOP:
+			sort_val = GetNextHopStation(ge, cp);
+			break;
+		case CargoDestEntry::TRANSFER_HOP:
+			sort_val = cp->NextStation();
+			break;
+		default:
+			NOT_REACHED();
+	}
+
+	if (sort_val == INVALID_STATION) return NULL;
+
+	/* Search for a matching child. */
+	for (CargoDestEntry::List::iterator i = list.begin(); i != list.end(); ++i) {
+		if (type == CargoDestEntry::FINAL_DEST ? i->data.css == sort_val && i->data.type == cp->DestinationType() : i->data.station == sort_val) {
+			i->data.count += cp->Count();
+			return &*i;
+		}
+	}
+
+	/* No entry found, add new. */
+	list.push_back(CargoDestEntry(type, sort_val, cp->Count(), cp->DestinationType()));
+	return &list.back();
+}
+
+
 /**
  * The StationView window
  */
 struct StationViewWindow : public Window {
 	uint32 cargo;                 ///< Bitmask of cargo types to expand
 	uint16 cargo_rows[NUM_CARGO]; ///< Header row for each cargo type
+	bool stdacceptratings;        ///< Standart or extended type of ACCEPTRATINGS list.
+	CargoArray cargo_around;      ///< Array of extra cargo that not visible in standart view.
 	uint expand_shrink_width;     ///< The width allocated to the expand/shrink 'button'
 	int rating_lines;             ///< Number of lines in the cargo ratings view.
 	int accepts_lines;            ///< Number of lines in the accepted cargo view.
 	Scrollbar *vscroll;
+	CargoDestEntry::List cargodest_list[NUM_CARGO]; ///< List of cargoes sorted by destination.
+
+	static StringID last_cargo_from_str;
+	static StringID last_cargo_from_tooltip;
 
 	/** Height of the #WID_SV_ACCEPT_RATING_LIST widget for different views. */
 	enum AcceptListHeight {
@@ -819,9 +976,11 @@
 	{
 		this->rating_lines  = ALH_RATING;
 		this->accepts_lines = ALH_ACCEPTS;
+		this->stdacceptratings = true;
 
 		this->CreateNestedTree(desc);
 		this->vscroll = this->GetScrollbar(WID_SV_SCROLLBAR);
+		this->GetWidget<NWidgetCore>(WID_SV_CARGO_FROM_TO_VIA)->SetDataTip(StationViewWindow::last_cargo_from_str, StationViewWindow::last_cargo_from_tooltip);
 		/* Nested widget tree creation is done in two steps to ensure that this->GetWidget<NWidgetCore>(WID_SV_ACCEPTS_RATINGS) exists in UpdateWidgetSize(). */
 		this->FinishInitNested(desc, window_number);
 
@@ -831,6 +990,8 @@
 
 	~StationViewWindow()
 	{
+		Overlays::Instance()->RemoveStation(Station::Get(this->window_number));
+		MarkWholeScreenDirty();
 		Owner owner = Station::Get(this->window_number)->owner;
 		DeleteWindowById(WC_TRAINS_LIST,   VehicleListIdentifier(VL_STATION_LIST, VEH_TRAIN,    owner, this->window_number).Pack(), false);
 		DeleteWindowById(WC_ROADVEH_LIST,  VehicleListIdentifier(VL_STATION_LIST, VEH_ROAD,     owner, this->window_number).Pack(), false);
@@ -866,9 +1027,30 @@
 	{
 		CargoDataList cargolist;
 		uint32 transfers = 0;
-		this->OrderWaitingCargo(&cargolist, &transfers);
 
-		this->vscroll->SetCount((int)cargolist.size() + 1); // update scrollbar
+		NWidgetCore *cargo_btn = this->GetWidget<NWidgetCore>(WID_SV_CARGO_FROM_TO_VIA);
+		if (cargo_btn->widget_data == STR_STATION_VIEW_WAITING_TO_BUTTON) {
+			this->OrderWaitingCargo(&cargolist, &transfers);
+			this->vscroll->SetCount((int)cargolist.size() + 1); // update scrollbar
+		} else {
+			/* Determine the current view. */
+			CargoDestEntry::Type dest_type;
+			switch (cargo_btn->widget_data) {
+				case STR_STATION_VIEW_WAITING_VIA_BUTTON:
+					dest_type = CargoDestEntry::FINAL_DEST;
+					break;
+				case STR_STATION_VIEW_WAITING_TRANSFER_BUTTON:
+					dest_type = CargoDestEntry::NEXT_HOP;
+					break;
+				case STR_STATION_VIEW_WAITING_BUTTON:
+					dest_type = CargoDestEntry::TRANSFER_HOP;
+					break;
+				default:
+					NOT_REACHED();
+			}
+			int num = this->FillCargodestList(dest_type, this->cargodest_list);
+			this->vscroll->SetCount(num + 1); // update scrollbar
+		}
 
 		/* disable some buttons */
 		const Station *st = Station::Get(this->window_number);
@@ -880,6 +1062,10 @@
 		this->SetWidgetDisabledState(WID_SV_CLOSE_AIRPORT, !(st->facilities & FACIL_AIRPORT) || st->owner != _local_company || st->owner == OWNER_NONE); // Also consider SE, where _local_company == OWNER_NONE
 		this->SetWidgetLoweredState(WID_SV_CLOSE_AIRPORT, (st->facilities & FACIL_AIRPORT) && (st->airport.flags & AIRPORT_CLOSED_block) != 0);
 
+//I don't like the cover button
+		/* check lowered stated for some buttons */
+//		this->SetWidgetLoweredState(WID_SV_COVERAGE, Overlays::Instance()->HasStation(st));
+
 		this->DrawWidgets();
 
 		if (!this->IsShaded()) {
@@ -894,7 +1080,7 @@
 					return;
 				}
 			} else {
-				int lines = this->DrawCargoRatings(r);
+				int lines = this->stdacceptratings ? this->DrawCargoRatings(r) : this->DrawExtraCargoRatings(r);
 				if (lines > this->rating_lines) { // Resize the widget, and perform re-initialization of the window.
 					this->rating_lines = lines;
 					this->ReInit();
@@ -905,7 +1091,11 @@
 			/* Draw waiting cargo. */
 			NWidgetBase *nwi = this->GetWidget<NWidgetBase>(WID_SV_WAITING);
 			Rect waiting_rect = {nwi->pos_x, nwi->pos_y, nwi->pos_x + nwi->current_x - 1, nwi->pos_y + nwi->current_y - 1};
-			this->DrawWaitingCargo(waiting_rect, cargolist, transfers);
+			if (cargo_btn->widget_data == STR_STATION_VIEW_WAITING_TO_BUTTON) {
+				this->DrawWaitingCargo(waiting_rect, cargolist, transfers);
+			} else {
+				this->DrawWaitingCargoByDest(waiting_rect, this->cargodest_list);
+			}
 		}
 	}
 
@@ -959,13 +1149,12 @@
 						/* Check if we already have this source in the list */
 						for (CargoDataList::iterator jt(cargolist->begin()); jt != cargolist->end(); jt++) {
 							CargoData *cd = &(*jt);
-							if (cd->cargo == i && cd->source == cp->SourceStation()) {
+							if (cd->cargo == i && cd->station == cp->SourceStation()) {
 								cd->count += cp->Count();
 								added = true;
 								break;
 							}
 						}
-
 						if (!added) cargolist->push_back(CargoData(i, cp->SourceStation(), cp->Count()));
 					}
 				}
@@ -974,6 +1163,70 @@
 	}
 
 	/**
+	 * Fill cargo list sorted by type and destination/next hop.
+	 * @param sort_via Set to true to sort by next hop, false to sort by final destination.
+	 * @param list Cargo list to fill.
+	 * @return Number of visible lines.
+	 */
+	int FillCargodestList(CargoDestEntry::Type sort_by, CargoDestEntry::List *list)
+	{
+		StationID station_id = this->window_number;
+		const Station *st = Station::Get(station_id);
+
+		int lines = 0;
+
+		/* Fill the list for each cargo type. */
+		for (CargoID cid = 0; cid < NUM_CARGO; cid++) {
+			/* Zero out all existing items. */
+			for (CargoDestEntry::List::iterator i = list[cid].begin(); i != list[cid].end(); ++i) {
+				i->Zero();
+			}
+
+			/* Remove all entries if no cargo of this type is present. */
+			if (st->goods[cid].cargo.Empty()) {
+				this->cargo_rows[cid] = 0;
+				list[cid].clear();
+				continue;
+			}
+
+			/* Store line number of the header line. */
+			this->cargo_rows[cid] = ++lines;
+
+			/* Add each cargo packet to the list. */
+			const StationCargoList::List *packets = st->goods[cid].cargo.Packets();
+			for (StationCargoList::ConstIterator it = packets->begin(); it != packets->end(); ++it) {
+				const CargoPacket *cp = *it;
+
+				/* Add entry and sub-entries according to the chosen sort type. */
+				static const CargoDestEntry::Type sort_types[][3] = {
+					{CargoDestEntry::FINAL_DEST, CargoDestEntry::NEXT_HOP, CargoDestEntry::TRANSFER_HOP},
+					{CargoDestEntry::NEXT_HOP, CargoDestEntry::TRANSFER_HOP, CargoDestEntry::FINAL_DEST},
+					{CargoDestEntry::TRANSFER_HOP, CargoDestEntry::NEXT_HOP, CargoDestEntry::FINAL_DEST}
+				};
+
+				CargoDestEntry *entry = AddCargoPacketToList(list[cid], sort_types[sort_by][0], cp, st->goods[cid]);
+				if (entry != NULL) {
+					entry = AddCargoPacketToList(entry->children, sort_types[sort_by][1], cp, st->goods[cid]);
+					if (entry != NULL) AddCargoPacketToList(entry->children, sort_types[sort_by][2], cp, st->goods[cid]);
+				}
+			}
+
+			/* Remove all empty list items and update visible row numbers. */
+			for (CargoDestEntry::List::iterator i = list[cid].begin(); i != list[cid].end(); )  {
+				if (i->data.count > 0) {
+					i->RemoveEmpty();
+					if (HasBit(this->cargo, cid)) lines = i->UpdateRowCount(lines);
+					++i;
+				} else {
+					i = list[cid].erase(i);
+				}
+			}
+		}
+
+		return lines;
+	}
+
+	/**
 	 * Draw waiting cargo.
 	 * @param r Rectangle of the widget.
 	 * @param cargolist Cargo, ordered by type and destination.
@@ -1006,7 +1259,7 @@
 		for (CargoDataList::const_iterator it = cargolist.begin(); it != cargolist.end() && pos > -maxrows; ++it) {
 			if (--pos < 0) {
 				const CargoData *cd = &(*it);
-				if (cd->source == INVALID_STATION) {
+				if (cd->station == INVALID_STATION) {
 					/* Heading */
 					DrawCargoIcons(cd->cargo, cd->count, r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, y);
 					SetDParam(0, cd->cargo);
@@ -1022,12 +1275,116 @@
 				} else {
 					SetDParam(0, cd->cargo);
 					SetDParam(1, cd->count);
-					SetDParam(2, cd->source);
+					SetDParam(2, cd->station);
 					DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, y, STR_STATION_VIEW_EN_ROUTE_FROM, TC_FROMSTRING, SA_RIGHT);
 				}
+				y += FONT_HEIGHT_NORMAL;
+			}
+		}
+	}
+
+	/**
+	 * Draw a dest entry and its children.
+	 * @param cid Current cargo type.
+	 * @param pos Scroll position
+	 * @param maxrows Number of visible rows.
+	 * @param left Left string bound.
+	 * @param right Right string bound.
+	 * @param shrink_left Left bound of the expand marker.
+	 * @param shrink_right Right bound of the expand marker.
+	 * @param offs_left Child offset of the left bound.
+	 * @param offs_right Child offset of the right bound.
+	 * @param y Top of the current line.
+	 * @param entry The entry to draw.
+	 * @return The new y value.
+	 */
+	int DrawSingleDestEntry(CargoID cid, int *pos, int maxrows, int left, int right, int shrink_left, int shrink_right, int offs_left, int offs_right, int y, const CargoDestEntry &entry) const
+	{
+		if (--(*pos) < 0) {
+			/* Draw current line. */
+			StringID str;
+
+			SetDParam(0, cid);
+			SetDParam(1, entry.data.count);
+			if (entry.type == CargoDestEntry::FINAL_DEST) {
+				SetDParam(2, entry.data.type == ST_INDUSTRY ? STR_INDUSTRY_NAME : (entry.data.type == ST_TOWN ? STR_TOWN_NAME : STR_COMPANY_NAME));
+				SetDParam(3, entry.data.css);
+				str = STR_STATION_VIEW_WAITING_TO;
+			} else {
+				SetDParam(2, entry.data.station);
+				str = (entry.type == CargoDestEntry::NEXT_HOP) ? STR_STATION_VIEW_WAITING_VIA : STR_STATION_VIEW_WAITING_TRANSFER;
+			}
+			DrawString(left, right, y, str);
+			y += FONT_HEIGHT_NORMAL;
+
+			if (!entry.children.empty()) {
+				/* Draw expand/collapse marker. */
+				DrawString(shrink_left, shrink_right, y - FONT_HEIGHT_NORMAL, entry.expanded ? "-" : "+", TC_YELLOW, SA_RIGHT);
+
+				if (entry.expanded) {
+					/* Draw visible children. */
+					for (CargoDestEntry::List::const_iterator i = entry.children.begin(); i != entry.children.end() && *pos > -maxrows; ++i) {
+						y = this->DrawSingleDestEntry(cid, pos, maxrows, left + offs_left, right + offs_right, shrink_left, shrink_right, offs_left, offs_right, y, *i);
+					}
+				}
+			}
+		}
+
+		return y;
+	}
+
+	/**
+	 * Draw waiting cargo ordered by destination/next hop.
+	 * @param r Rectangle of the widget.
+	 * @param list List to draw.
+	 */
+	void DrawWaitingCargoByDest(const Rect &r, const CargoDestEntry::List *list) const
+	{
+		int y = r.top + WD_FRAMERECT_TOP;
+		int pos = this->vscroll->GetPosition();
+
+		const Station *st = Station::Get(this->window_number);
+		if (--pos < 0) {
+			StringID str = STR_JUST_NOTHING;
+			for (CargoID i = 0; i < NUM_CARGO; i++) {
+				if (!st->goods[i].cargo.Empty()) str = STR_EMPTY;
+			}
+			SetDParam(0, str);
+			DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, y, STR_STATION_VIEW_WAITING_TITLE);
+			y += FONT_HEIGHT_NORMAL;
+		}
+
+		bool rtl = _current_text_dir == TD_RTL;
+		int text_left    = rtl ? r.left + this->expand_shrink_width : r.left + WD_FRAMERECT_LEFT;
+		int text_right   = rtl ? r.right - WD_FRAMERECT_LEFT : r.right - this->expand_shrink_width;
+		int shrink_left  = rtl ? r.left + WD_FRAMERECT_LEFT : r.right - this->expand_shrink_width + WD_FRAMERECT_LEFT;
+		int shrink_right = rtl ? r.left + this->expand_shrink_width - WD_FRAMERECT_RIGHT : r.right - WD_FRAMERECT_RIGHT;
+
+		int offs_left   = rtl ? 0 : this->expand_shrink_width;
+		int offs_right  = rtl ? this->expand_shrink_width : 0;
+
+		int maxrows = this->vscroll->GetCapacity();
+		for (CargoID cid = 0; cid < NUM_CARGO && pos > -maxrows; cid++) {
+			if (st->goods[cid].cargo.Empty()) continue;
 
+			if (--pos < 0) {
+				/* Draw heading. */
+				DrawCargoIcons(cid, st->goods[cid].cargo.Count(), r.left + WD_FRAMETEXT_LEFT, r.right - WD_FRAMERECT_RIGHT, y);
+				SetDParam(0, cid);
+				SetDParam(1, st->goods[cid].cargo.Count());
+				DrawString(text_left, text_right, y, STR_STATION_VIEW_WAITING_CARGO, TC_FROMSTRING, SA_RIGHT);
+				if (!list[cid].empty()) {
+					DrawString(shrink_left, shrink_right, y, HasBit(this->cargo, cid) ? "-" : "+", TC_YELLOW, SA_RIGHT);
+				}
 				y += FONT_HEIGHT_NORMAL;
 			}
+
+			/* Draw sub-entries. */
+			if (HasBit(this->cargo, cid)) {
+				for (CargoDestEntry::List::const_iterator i = list[cid].begin(); i != list[cid].end() && pos > -maxrows; ++i) {
+					y = this->DrawSingleDestEntry(cid, &pos, maxrows, text_left + offs_left, text_right + offs_right, shrink_left, shrink_right, offs_left, offs_right, y, *i);
+				}
+			}
 		}
 	}
 
@@ -1072,7 +1429,39 @@
 		FOR_ALL_SORTED_STANDARD_CARGOSPECS(cs) {
 			const GoodsEntry *ge = &st->goods[cs->Index()];
 			if (!HasBit(ge->acceptance_pickup, GoodsEntry::GES_PICKUP)) continue;
+			SetDParam(0, cs->name);
+			SetDParam(2, ToPercent8(ge->rating));
+			SetDParam(1, STR_CARGO_RATING_APPALLING + (ge->rating >> 5));
+			DrawString(r.left + WD_FRAMERECT_LEFT + 6, r.right - WD_FRAMERECT_RIGHT - 6, y, STR_STATION_VIEW_CARGO_RATING);
+			y += FONT_HEIGHT_NORMAL;
+		}
+		return CeilDiv(y - r.top - WD_FRAMERECT_TOP, FONT_HEIGHT_NORMAL);
+	}
+	
+	/**
+	 * Draw cargo ratings that is not in the standart #WID_SV_ACCEPT_RATING_LIST widget.
+	 * @param r Rectangle of the widget.
+	 * @return Number of lines needed for drawing the cargo ratings.
+	 */
+	int DrawExtraCargoRatings(const Rect &r)
+	{
+		const Station *st = Station::Get(this->window_number);
+		Rect sr = st->GetCatchmentRect();
+		cargo_around = GetProductionAroundTiles(TileXY(sr.left, sr.top), sr.right - sr.left + 1, sr.bottom - sr.top + 1, 0);
 
+		int y = r.top + WD_FRAMERECT_TOP;
+		DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, y, STR_STATION_VIEW_CARGO_RATINGS_TITLE);
+		y += FONT_HEIGHT_NORMAL;
+		
+		/* Stop drawing if there no any production around */	
+		if (cargo_around.GetCount() == 0) return CeilDiv(y - r.top - WD_FRAMERECT_TOP, FONT_HEIGHT_NORMAL);		
+		
+		CargoID counter = 0; /* Count rows of finded industries */
+		const CargoSpec *cs;
+		FOR_ALL_SORTED_STANDARD_CARGOSPECS(cs) {
+			const GoodsEntry *ge = &st->goods[cs->Index()];
+			if (HasBit(ge->acceptance_pickup, GoodsEntry::GES_PICKUP) || cargo_around[cs->Index()] == 0) continue;
+			cargo_around[cs->Index()] = ++counter;
 			SetDParam(0, cs->name);
 			SetDParam(2, ToPercent8(ge->rating));
 			SetDParam(1, STR_CARGO_RATING_APPALLING + (ge->rating >> 5));
@@ -1082,25 +1471,139 @@
 		return CeilDiv(y - r.top - WD_FRAMERECT_TOP, FONT_HEIGHT_NORMAL);
 	}
 
+	/**
+	 * Test and handle a possible mouse click on a dest entry and its children.
+	 * @param entry The entry to test for a hit.
+	 * @param row The number of the clicked row.
+	 * @return True if further entries need to be processed.
+	 */
+	bool HandleCargoDestEntryClick(CargoDestEntry &entry, int row)
+	{
+		if (entry.start_row == row) {
+			if (_ctrl_pressed) {
+				/* Scroll viewport to destination tile .*/
+				TileIndex dest_tile = 0;
+				switch (entry.type) {
+					case CargoDestEntry::FINAL_DEST:
+						switch (entry.data.type) {
+							case ST_INDUSTRY:
+								dest_tile = Industry::Get(entry.data.css)->location.tile;
+								break;
+							case ST_TOWN:
+								dest_tile = Town::Get(entry.data.css)->xy;
+								break;
+							case ST_HEADQUARTERS:
+								dest_tile = Company::Get(entry.data.css)->location_of_HQ;
+								break;
+
+							default:
+								NOT_REACHED();
+						}
+						break;
+
+					case CargoDestEntry::NEXT_HOP:
+					case CargoDestEntry::TRANSFER_HOP:
+						dest_tile = Station::Get(entry.data.station)->xy;
+						break;
+
+					default:
+						NOT_REACHED();
+				}
+				ScrollMainWindowToTile(dest_tile);
+			} else if (!entry.children.empty()) {
+				/* Expand/collapse entry. */
+				entry.expanded = !entry.expanded;
+				this->SetWidgetDirty(WID_SV_WAITING);
+				this->SetWidgetDirty(WID_SV_SCROLLBAR);
+			}
+		}
+
+		if (entry.start_row < row) {
+			/* Test child entries. */
+			for (CargoDestEntry::List::iterator i = entry.children.begin(); i != entry.children.end(); ++i) {
+				if (!this->HandleCargoDestEntryClick(*i, row)) return false;
+			}
+			return true;
+		}
+
+		return false;
+	}
+
+       void HandleAcceptRatingClick(int row)
+       {
+               if (row == 0 || !_ctrl_pressed || !_settings_game.station.advanced_control) return;
+
+               for (CargoID c = 0; c < NUM_CARGO; c++) {
+                       if (this->cargo_around[c] == (uint16)row) {
+                               DoCommandP(0, this->window_number , c, CMD_CHANGE_STATION_ACCEPTANCE);
+                               break;
+                       }
+               }
+       }
+
 	void HandleCargoWaitingClick(int row)
 	{
 		if (row == 0) return;
 
+		bool dest_view = this->GetWidget<NWidgetCore>(WID_SV_CARGO_FROM_TO_VIA)->widget_data != STR_STATION_VIEW_WAITING_TO_BUTTON;
+
 		for (CargoID c = 0; c < NUM_CARGO; c++) {
+			/* Test for cargo type line. */
 			if (this->cargo_rows[c] == row) {
-				ToggleBit(this->cargo, c);
-				this->SetWidgetDirty(WID_SV_WAITING);
+                               /* Check for ctrl-click. If not - do thing as when old good times. */
+                               if (!_ctrl_pressed || !_settings_game.station.advanced_control) {
+                                       ToggleBit(this->cargo, c);
+                               }
+                               else {
+                                       /* If ctrl-click happen - stop accepting it/delete this cargo from list. */
+                                       DoCommandP(0, this->window_number , c | 0x0100, CMD_CHANGE_STATION_ACCEPTANCE);
+                               }
 				break;
 			}
+
+			if (dest_view) {
+				/* Test for dest view lines. */
+				for (CargoDestEntry::List::iterator i = this->cargodest_list[c].begin(); i != this->cargodest_list[c].end(); ++i) {
+					if (!this->HandleCargoDestEntryClick(*i, row)) break;
+				}
+			}
+		}
+	}
+
+	/** Clear the 'cargo by destination' list. */
+	void ClearCargodestList()
+	{
+		for (CargoID cid = 0; cid < NUM_CARGO; cid++) {
+			this->cargodest_list[cid].clear();
 		}
 	}
 
 	virtual void OnClick(Point pt, int widget, int click_count)
 	{
 		switch (widget) {
-			case WID_SV_WAITING:
-				this->HandleCargoWaitingClick(this->vscroll->GetScrolledRowFromWidget(pt.y, this, WID_SV_WAITING, WD_FRAMERECT_TOP, FONT_HEIGHT_NORMAL));
+			case WID_SV_WAITING: {
+				if (click_count == 1) {
+					this->HandleCargoWaitingClick(this->vscroll->GetScrolledRowFromWidget(pt.y, this, WID_SV_WAITING, WD_FRAMERECT_TOP, FONT_HEIGHT_NORMAL));
+				}
+				else {
+					/* Toggle draw list with std/extra oprions */
+					this->stdacceptratings = this->stdacceptratings ? false : true;
+				}
+				this->SetWidgetDirty(WID_SV_WAITING);
+				this->SetWidgetDirty(WID_SV_ACCEPT_RATING_LIST);
+				break;
+			}
+			
+			case WID_SV_ACCEPT_RATING_LIST: {
+				if (click_count == 1) {
+					this->HandleAcceptRatingClick(this->GetRowFromWidget(pt.y, WID_SV_ACCEPT_RATING_LIST, WD_FRAMERECT_TOP, FONT_HEIGHT_NORMAL));
+				}
+				else {
+					this->stdacceptratings = this->stdacceptratings ? false : true;
+				}
+				this->SetWidgetDirty(WID_SV_ACCEPT_RATING_LIST);
 				break;
+			}
 
 			case WID_SV_LOCATION:
 				if (_ctrl_pressed) {
@@ -1110,6 +1613,12 @@
 				}
 				break;
 
+//I don't like the cover button
+//			case WID_SV_COVERAGE:
+//				Overlays::Instance()->ToggleStation(Station::Get(this->window_number));
+//				MarkWholeScreenDirty();
+//				break;
+
 			case WID_SV_ACCEPTS_RATINGS: {
 				/* Swap between 'accepts' and 'ratings' view. */
 				int height_change;
@@ -1125,6 +1634,38 @@
 				break;
 			}
 
+			case WID_SV_CARGO_FROM_TO_VIA: {
+				/* Swap between 'Source', 'Destination', 'Next hop' and 'Transfer' view.
+				 * Store the new view so the next opened station window shows the same view. */
+				NWidgetCore *nwi = this->GetWidget<NWidgetCore>(WID_SV_CARGO_FROM_TO_VIA);
+				switch (nwi->widget_data) {
+					case STR_STATION_VIEW_WAITING_BUTTON:
+						StationViewWindow::last_cargo_from_str     = STR_STATION_VIEW_WAITING_TO_BUTTON;
+						StationViewWindow::last_cargo_from_tooltip = STR_STATION_VIEW_WAITING_TO_TOOLTIP;
+						break;
+					case STR_STATION_VIEW_WAITING_TO_BUTTON:
+						StationViewWindow::last_cargo_from_str     = STR_STATION_VIEW_WAITING_VIA_BUTTON;
+						StationViewWindow::last_cargo_from_tooltip = STR_STATION_VIEW_WAITING_VIA_TOOLTIP;
+						break;
+					case STR_STATION_VIEW_WAITING_VIA_BUTTON:
+						StationViewWindow::last_cargo_from_str     = STR_STATION_VIEW_WAITING_TRANSFER_BUTTON;
+						StationViewWindow::last_cargo_from_tooltip = STR_STATION_VIEW_WAITING_TRANSFER_TOOLTIP;
+						break;
+					case STR_STATION_VIEW_WAITING_TRANSFER_BUTTON:
+						StationViewWindow::last_cargo_from_str     = STR_STATION_VIEW_WAITING_BUTTON;
+						StationViewWindow::last_cargo_from_tooltip = STR_STATION_VIEW_WAITING_TOOLTIP;
+						break;
+					default:
+						NOT_REACHED();
+				}
+				nwi->SetDataTip(StationViewWindow::last_cargo_from_str, StationViewWindow::last_cargo_from_tooltip);
+				this->ClearCargodestList();
+				this->SetWidgetDirty(WID_SV_CARGO_FROM_TO_VIA);
+				this->SetWidgetDirty(WID_SV_WAITING);
+				this->SetWidgetDirty(WID_SV_SCROLLBAR);
+				break;
+			}
+
 			case WID_SV_RENAME:
 				SetDParam(0, this->window_number);
 				ShowQueryString(STR_STATION_NAME, STR_STATION_VIEW_RENAME_STATION_CAPTION, MAX_LENGTH_STATION_NAME_CHARS,
@@ -1142,7 +1683,11 @@
 				Owner owner = Station::Get(this->window_number)->owner;
 				ShowVehicleListWindow(owner, (VehicleType)(widget - WID_SV_TRAINS), (StationID)this->window_number);
 				break;
-			}
+            }
+
+			case WID_SV_DEPARTURES:
+				ShowStationDepartures((StationID)this->window_number);
+				break;
 		}
 	}
 
@@ -1169,6 +1714,8 @@
 	}
 };
 
+StringID StationViewWindow::last_cargo_from_str     = STR_STATION_VIEW_WAITING_VIA_BUTTON;
+StringID StationViewWindow::last_cargo_from_tooltip = STR_STATION_VIEW_WAITING_VIA_TOOLTIP;
 
 static const WindowDesc _station_view_desc(
 	WDP_AUTO, 249, 110,
@@ -1184,7 +1731,12 @@
  */
 void ShowStationViewWindow(StationID station)
 {
-	AllocateWindowDescFront<StationViewWindow>(&_station_view_desc, station);
+       if (_ctrl_pressed) {
+               Overlays::Instance()->ToggleStation(Station::Get(station));
+               MarkWholeScreenDirty();
+       } else {
+               AllocateWindowDescFront<StationViewWindow>(&_station_view_desc, station);
+       }
 }
 
 /** Struct containing TileIndex and StationID */
@@ -1412,6 +1964,8 @@
 		this->vscroll->SetCount(_stations_nearby_list.Length() + 1);
 		this->SetDirty();
 	}
+protected:
+    void Get(WindowNumber window_number);
 };
 
 static const WindowDesc _select_station_desc(
diff -urNad openttd-1.3.2/src/station_map.h openttd-1.3.2-DC3.0RC3/src/station_map.h
--- openttd-1.3.2/src/station_map.h	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/station_map.h	2013-11-22 05:49:07.000000000 +0100
@@ -26,11 +26,16 @@
  * @pre IsTileType(t, MP_STATION)
  * @return Station ID of the station at \a t
  */
-static inline StationID GetStationIndex(TileIndex t)
+template <bool Tgeneric>
+static inline StationID GetStationIndex(typename TileIndexT<Tgeneric>::T t)
 {
 	assert(IsTileType(t, MP_STATION));
-	return (StationID)_m[t].m2;
+	return (StationID)GetTile(t)->m2;
 }
+/** @copydoc GetStationIndex(TileIndexT<Tgeneric>::T) */
+static inline StationID GetStationIndex(TileIndex t) { return GetStationIndex<false>(t); }
+/** @copydoc GetStationIndex(TileIndexT<Tgeneric>::T) */
+static inline StationID GetStationIndex(GenericTileIndex t) { return GetStationIndex<true>(t); }
 
 
 static const int GFX_DOCK_BASE_WATER_PART          =  4; ///< The offset for the water parts.
@@ -42,11 +47,16 @@
  * @pre IsTileType(t, MP_STATION)
  * @return the station type
  */
-static inline StationType GetStationType(TileIndex t)
+template <bool Tgeneric>
+static inline StationType GetStationType(typename TileIndexT<Tgeneric>::T t)
 {
 	assert(IsTileType(t, MP_STATION));
-	return (StationType)GB(_m[t].m6, 3, 3);
+	return (StationType)GB(GetTileEx(t)->m6, 3, 3);
 }
+/** @copydoc GetStationType(TileIndexT<Tgeneric>::T) */
+static inline StationType GetStationType(TileIndex t) { return GetStationType<false>(t); }
+/** @copydoc GetStationType(TileIndexT<Tgeneric>::T) */
+static inline StationType GetStationType(GenericTileIndex t) { return GetStationType<true>(t); }
 
 /**
  * Get the road stop type of this tile
@@ -54,11 +64,16 @@
  * @pre GetStationType(t) == STATION_TRUCK || GetStationType(t) == STATION_BUS
  * @return the road stop type
  */
-static inline RoadStopType GetRoadStopType(TileIndex t)
+template <bool Tgeneric>
+static inline RoadStopType GetRoadStopType(typename TileIndexT<Tgeneric>::T t)
 {
 	assert(GetStationType(t) == STATION_TRUCK || GetStationType(t) == STATION_BUS);
 	return GetStationType(t) == STATION_TRUCK ? ROADSTOP_TRUCK : ROADSTOP_BUS;
 }
+/** @copydoc GetRoadStopType(TileIndexT<Tgeneric>::T) */
+static inline RoadStopType GetRoadStopType(TileIndex t) { return GetRoadStopType<false>(t); }
+/** @copydoc GetRoadStopType(TileIndexT<Tgeneric>::T) */
+static inline RoadStopType GetRoadStopType(GenericTileIndex t) { return GetRoadStopType<true>(t); }
 
 /**
  * Get the station graphics of this tile
@@ -66,11 +81,16 @@
  * @pre IsTileType(t, MP_STATION)
  * @return the station graphics
  */
-static inline StationGfx GetStationGfx(TileIndex t)
+template <bool Tgeneric>
+static inline StationGfx GetStationGfx(typename TileIndexT<Tgeneric>::T t)
 {
 	assert(IsTileType(t, MP_STATION));
-	return _m[t].m5;
+	return GetTile(t)->m5;
 }
+/** @copydoc GetStationGfx(TileIndexT<Tgeneric>::T) */
+static inline StationGfx GetStationGfx(TileIndex t) { return GetStationGfx<false>(t); }
+/** @copydoc GetStationGfx(TileIndexT<Tgeneric>::T) */
+static inline StationGfx GetStationGfx(GenericTileIndex t) { return GetStationGfx<true>(t); }
 
 /**
  * Set the station graphics of this tile
@@ -78,11 +98,16 @@
  * @param gfx the new graphics
  * @pre IsTileType(t, MP_STATION)
  */
-static inline void SetStationGfx(TileIndex t, StationGfx gfx)
+template <bool Tgeneric>
+static inline void SetStationGfx(typename TileIndexT<Tgeneric>::T t, StationGfx gfx)
 {
 	assert(IsTileType(t, MP_STATION));
-	_m[t].m5 = gfx;
+	GetTile(t)->m5 = gfx;
 }
+/** @copydoc SetStationGfx(TileIndexT<Tgeneric>::T,StationGfx) */
+static inline void SetStationGfx(TileIndex t, StationGfx gfx) { SetStationGfx<false>(t, gfx); }
+/** @copydoc SetStationGfx(TileIndexT<Tgeneric>::T,StationGfx) */
+static inline void SetStationGfx(GenericTileIndex t, StationGfx gfx) { SetStationGfx<true>(t, gfx); }
 
 /**
  * Is this station tile a rail station?
@@ -90,20 +115,30 @@
  * @pre IsTileType(t, MP_STATION)
  * @return true if and only if the tile is a rail station
  */
-static inline bool IsRailStation(TileIndex t)
+template <bool Tgeneric>
+static inline bool IsRailStation(typename TileIndexT<Tgeneric>::T t)
 {
 	return GetStationType(t) == STATION_RAIL;
 }
+/** @copydoc IsRailStation(TileIndexT<Tgeneric>::T) */
+static inline bool IsRailStation(TileIndex t) { return IsRailStation<false>(t); }
+/** @copydoc IsRailStation(TileIndexT<Tgeneric>::T) */
+static inline bool IsRailStation(GenericTileIndex t) { return IsRailStation<true>(t); }
 
 /**
  * Is this tile a station tile and a rail station?
  * @param t the tile to get the information from
  * @return true if and only if the tile is a rail station
  */
-static inline bool IsRailStationTile(TileIndex t)
+template <bool Tgeneric>
+static inline bool IsRailStationTile(typename TileIndexT<Tgeneric>::T t)
 {
 	return IsTileType(t, MP_STATION) && IsRailStation(t);
 }
+/** @copydoc IsRailStationTile(TileIndexT<Tgeneric>::T) */
+static inline bool IsRailStationTile(TileIndex t) { return IsRailStationTile<false>(t); }
+/** @copydoc IsRailStationTile(TileIndexT<Tgeneric>::T) */
+static inline bool IsRailStationTile(GenericTileIndex t) { return IsRailStationTile<true>(t); }
 
 /**
  * Is this station tile a rail waypoint?
@@ -111,20 +146,30 @@
  * @pre IsTileType(t, MP_STATION)
  * @return true if and only if the tile is a rail waypoint
  */
-static inline bool IsRailWaypoint(TileIndex t)
+template <bool Tgeneric>
+static inline bool IsRailWaypoint(typename TileIndexT<Tgeneric>::T t)
 {
 	return GetStationType(t) == STATION_WAYPOINT;
 }
+/** @copydoc IsRailWaypoint(TileIndexT<Tgeneric>::T) */
+static inline bool IsRailWaypoint(TileIndex t) { return IsRailWaypoint<false>(t); }
+/** @copydoc IsRailWaypoint(TileIndexT<Tgeneric>::T) */
+static inline bool IsRailWaypoint(GenericTileIndex t) { return IsRailWaypoint<true>(t); }
 
 /**
  * Is this tile a station tile and a rail waypoint?
  * @param t the tile to get the information from
  * @return true if and only if the tile is a rail waypoint
  */
-static inline bool IsRailWaypointTile(TileIndex t)
+template <bool Tgeneric>
+static inline bool IsRailWaypointTile(typename TileIndexT<Tgeneric>::T t)
 {
 	return IsTileType(t, MP_STATION) && IsRailWaypoint(t);
 }
+/** @copydoc IsRailWaypointTile(TileIndexT<Tgeneric>::T) */
+static inline bool IsRailWaypointTile(TileIndex t) { return IsRailWaypointTile<false>(t); }
+/** @copydoc IsRailWaypointTile(TileIndexT<Tgeneric>::T) */
+static inline bool IsRailWaypointTile(GenericTileIndex t) { return IsRailWaypointTile<true>(t); }
 
 /**
  * Has this station tile a rail? In other words, is this station
@@ -133,10 +178,15 @@
  * @pre IsTileType(t, MP_STATION)
  * @return true if and only if the tile has rail
  */
-static inline bool HasStationRail(TileIndex t)
+template <bool Tgeneric>
+static inline bool HasStationRail(typename TileIndexT<Tgeneric>::T t)
 {
 	return IsRailStation(t) || IsRailWaypoint(t);
 }
+/** @copydoc HasStationRail(TileIndexT<Tgeneric>::T) */
+static inline bool HasStationRail(TileIndex t) { return HasStationRail<false>(t); }
+/** @copydoc HasStationRail(TileIndexT<Tgeneric>::T) */
+static inline bool HasStationRail(GenericTileIndex t) { return HasStationRail<true>(t); }
 
 /**
  * Has this station tile a rail? In other words, is this station
@@ -144,10 +194,15 @@
  * @param t the tile to check
  * @return true if and only if the tile is a station tile and has rail
  */
-static inline bool HasStationTileRail(TileIndex t)
+template <bool Tgeneric>
+static inline bool HasStationTileRail(typename TileIndexT<Tgeneric>::T t)
 {
 	return IsTileType(t, MP_STATION) && HasStationRail(t);
 }
+/** @copydoc HasStationTileRail(TileIndexT<Tgeneric>::T) */
+static inline bool HasStationTileRail(TileIndex t) { return HasStationTileRail<false>(t); }
+/** @copydoc HasStationTileRail(TileIndexT<Tgeneric>::T) */
+static inline bool HasStationTileRail(GenericTileIndex t) { return HasStationTileRail<true>(t); }
 
 /**
  * Is this station tile an airport?
@@ -155,20 +210,30 @@
  * @pre IsTileType(t, MP_STATION)
  * @return true if and only if the tile is an airport
  */
-static inline bool IsAirport(TileIndex t)
+template <bool Tgeneric>
+static inline bool IsAirport(typename TileIndexT<Tgeneric>::T t)
 {
 	return GetStationType(t) == STATION_AIRPORT;
 }
+/** @copydoc IsAirport(TileIndexT<Tgeneric>::T) */
+static inline bool IsAirport(TileIndex t) { return IsAirport<false>(t); }
+/** @copydoc IsAirport(TileIndexT<Tgeneric>::T) */
+static inline bool IsAirport(GenericTileIndex t) { return IsAirport<true>(t); }
 
 /**
  * Is this tile a station tile and an airport tile?
  * @param t the tile to get the information from
  * @return true if and only if the tile is an airport
  */
-static inline bool IsAirportTile(TileIndex t)
+template <bool Tgeneric>
+static inline bool IsAirportTile(typename TileIndexT<Tgeneric>::T t)
 {
 	return IsTileType(t, MP_STATION) && IsAirport(t);
 }
+/** @copydoc IsAirportTile(TileIndexT<Tgeneric>::T) */
+static inline bool IsAirportTile(TileIndex t) { return IsAirportTile<false>(t); }
+/** @copydoc IsAirportTile(TileIndexT<Tgeneric>::T) */
+static inline bool IsAirportTile(GenericTileIndex t) { return IsAirportTile<true>(t); }
 
 bool IsHangar(TileIndex t);
 
@@ -178,10 +243,15 @@
  * @pre IsTileType(t, MP_STATION)
  * @return \c true if station is a truck stop, \c false otherwise
  */
-static inline bool IsTruckStop(TileIndex t)
+template <bool Tgeneric>
+static inline bool IsTruckStop(typename TileIndexT<Tgeneric>::T t)
 {
 	return GetStationType(t) == STATION_TRUCK;
 }
+/** @copydoc IsTruckStop(TileIndexT<Tgeneric>::T) */
+static inline bool IsTruckStop(TileIndex t) { return IsTruckStop<false>(t); }
+/** @copydoc IsTruckStop(TileIndexT<Tgeneric>::T) */
+static inline bool IsTruckStop(GenericTileIndex t) { return IsTruckStop<true>(t); }
 
 /**
  * Is the station at \a t a bus stop?
@@ -189,10 +259,15 @@
  * @pre IsTileType(t, MP_STATION)
  * @return \c true if station is a bus stop, \c false otherwise
  */
-static inline bool IsBusStop(TileIndex t)
+template <bool Tgeneric>
+static inline bool IsBusStop(typename TileIndexT<Tgeneric>::T t)
 {
 	return GetStationType(t) == STATION_BUS;
 }
+/** @copydoc IsBusStop(TileIndexT<Tgeneric>::T) */
+static inline bool IsBusStop(TileIndex t) { return IsBusStop<false>(t); }
+/** @copydoc IsBusStop(TileIndexT<Tgeneric>::T) */
+static inline bool IsBusStop(GenericTileIndex t) { return IsBusStop<true>(t); }
 
 /**
  * Is the station at \a t a road station?
@@ -200,41 +275,61 @@
  * @pre IsTileType(t, MP_STATION)
  * @return \c true if station at the tile is a bus top or a truck stop, \c false otherwise
  */
-static inline bool IsRoadStop(TileIndex t)
+template <bool Tgeneric>
+static inline bool IsRoadStop(typename TileIndexT<Tgeneric>::T t)
 {
 	assert(IsTileType(t, MP_STATION));
 	return IsTruckStop(t) || IsBusStop(t);
 }
+/** @copydoc IsRoadStop(TileIndexT<Tgeneric>::T) */
+static inline bool IsRoadStop(TileIndex t) { return IsRoadStop<false>(t); }
+/** @copydoc IsRoadStop(TileIndexT<Tgeneric>::T) */
+static inline bool IsRoadStop(GenericTileIndex t) { return IsRoadStop<true>(t); }
 
 /**
  * Is tile \a t a road stop station?
  * @param t Tile to check
  * @return \c true if the tile is a station tile and a road stop
  */
-static inline bool IsRoadStopTile(TileIndex t)
+template <bool Tgeneric>
+static inline bool IsRoadStopTile(typename TileIndexT<Tgeneric>::T t)
 {
 	return IsTileType(t, MP_STATION) && IsRoadStop(t);
 }
+/** @copydoc IsRoadStopTile(TileIndexT<Tgeneric>::T) */
+static inline bool IsRoadStopTile(TileIndex t) { return IsRoadStopTile<false>(t); }
+/** @copydoc IsRoadStopTile(TileIndexT<Tgeneric>::T) */
+static inline bool IsRoadStopTile(GenericTileIndex t) { return IsRoadStopTile<true>(t); }
 
 /**
  * Is tile \a t a standard (non-drive through) road stop station?
  * @param t Tile to check
  * @return \c true if the tile is a station tile and a standard road stop
  */
-static inline bool IsStandardRoadStopTile(TileIndex t)
+template <bool Tgeneric>
+static inline bool IsStandardRoadStopTile(typename TileIndexT<Tgeneric>::T t)
 {
 	return IsRoadStopTile(t) && GetStationGfx(t) < GFX_TRUCK_BUS_DRIVETHROUGH_OFFSET;
 }
+/** @copydoc IsStandardRoadStopTile(TileIndexT<Tgeneric>::T) */
+static inline bool IsStandardRoadStopTile(TileIndex t) { return IsStandardRoadStopTile<false>(t); }
+/** @copydoc IsStandardRoadStopTile(TileIndexT<Tgeneric>::T) */
+static inline bool IsStandardRoadStopTile(GenericTileIndex t) { return IsStandardRoadStopTile<true>(t); }
 
 /**
  * Is tile \a t a drive through road stop station?
  * @param t Tile to check
  * @return \c true if the tile is a station tile and a drive through road stop
  */
-static inline bool IsDriveThroughStopTile(TileIndex t)
+template <bool Tgeneric>
+static inline bool IsDriveThroughStopTile(typename TileIndexT<Tgeneric>::T t)
 {
 	return IsRoadStopTile(t) && GetStationGfx(t) >= GFX_TRUCK_BUS_DRIVETHROUGH_OFFSET;
 }
+/** @copydoc IsDriveThroughStopTile(TileIndexT<Tgeneric>::T) */
+static inline bool IsDriveThroughStopTile(TileIndex t) { return IsDriveThroughStopTile<false>(t); }
+/** @copydoc IsDriveThroughStopTile(TileIndexT<Tgeneric>::T) */
+static inline bool IsDriveThroughStopTile(GenericTileIndex t) { return IsDriveThroughStopTile<true>(t); }
 
 /**
  * Get the station graphics of this airport tile
@@ -255,7 +350,8 @@
  * @pre IsRoadStopTile(t)
  * @return the direction of the entrance
  */
-static inline DiagDirection GetRoadStopDir(TileIndex t)
+template <bool Tgeneric>
+static inline DiagDirection GetRoadStopDir(typename TileIndexT<Tgeneric>::T t)
 {
 	StationGfx gfx = GetStationGfx(t);
 	assert(IsRoadStopTile(t));
@@ -265,6 +361,10 @@
 		return (DiagDirection)(gfx - GFX_TRUCK_BUS_DRIVETHROUGH_OFFSET);
 	}
 }
+/** @copydoc GetRoadStopDir(TileIndexT<Tgeneric>::T) */
+static inline DiagDirection GetRoadStopDir(TileIndex t) { return GetRoadStopDir<false>(t); }
+/** @copydoc GetRoadStopDir(TileIndexT<Tgeneric>::T) */
+static inline DiagDirection GetRoadStopDir(GenericTileIndex t) { return GetRoadStopDir<true>(t); }
 
 /**
  * Is tile \a t part of an oilrig?
@@ -283,20 +383,30 @@
  * @pre IsTileType(t, MP_STATION)
  * @return \c true if the tile is a dock
  */
-static inline bool IsDock(TileIndex t)
+template <bool Tgeneric>
+static inline bool IsDock(typename TileIndexT<Tgeneric>::T t)
 {
 	return GetStationType(t) == STATION_DOCK;
 }
+/** @copydoc IsDock(TileIndexT<Tgeneric>::T) */
+static inline bool IsDock(TileIndex t) { return IsDock<false>(t); }
+/** @copydoc IsDock(TileIndexT<Tgeneric>::T) */
+static inline bool IsDock(GenericTileIndex t) { return IsDock<true>(t); }
 
 /**
  * Is tile \a t a dock tile?
  * @param t Tile to check
  * @return \c true if the tile is a dock
  */
-static inline bool IsDockTile(TileIndex t)
+template <bool Tgeneric>
+static inline bool IsDockTile(typename TileIndexT<Tgeneric>::T t)
 {
 	return IsTileType(t, MP_STATION) && GetStationType(t) == STATION_DOCK;
 }
+/** @copydoc IsDockTile(TileIndexT<Tgeneric>::T) */
+static inline bool IsDockTile(TileIndex t) { return IsDockTile<false>(t); }
+/** @copydoc IsDockTile(TileIndexT<Tgeneric>::T) */
+static inline bool IsDockTile(GenericTileIndex t) { return IsDockTile<true>(t); }
 
 /**
  * Is tile \a t a buoy tile?
@@ -304,20 +414,30 @@
  * @pre IsTileType(t, MP_STATION)
  * @return \c true if the tile is a buoy
  */
-static inline bool IsBuoy(TileIndex t)
+template <bool Tgeneric>
+static inline bool IsBuoy(typename TileIndexT<Tgeneric>::T t)
 {
 	return GetStationType(t) == STATION_BUOY;
 }
+/** @copydoc IsBuoy(TileIndexT<Tgeneric>::T) */
+static inline bool IsBuoy(TileIndex t) { return IsBuoy<false>(t); }
+/** @copydoc IsBuoy(TileIndexT<Tgeneric>::T) */
+static inline bool IsBuoy(GenericTileIndex t) { return IsBuoy<true>(t); }
 
 /**
  * Is tile \a t a buoy tile?
  * @param t Tile to check
  * @return \c true if the tile is a buoy
  */
-static inline bool IsBuoyTile(TileIndex t)
+template <bool Tgeneric>
+static inline bool IsBuoyTile(typename TileIndexT<Tgeneric>::T t)
 {
 	return IsTileType(t, MP_STATION) && IsBuoy(t);
 }
+/** @copydoc IsBuoyTile(TileIndexT<Tgeneric>::T) */
+static inline bool IsBuoyTile(TileIndex t) { return IsBuoyTile<false>(t); }
+/** @copydoc IsBuoyTile(TileIndexT<Tgeneric>::T) */
+static inline bool IsBuoyTile(GenericTileIndex t) { return IsBuoyTile<true>(t); }
 
 /**
  * Is tile \a t an hangar tile?
@@ -335,11 +455,16 @@
  * @pre HasStationRail(t)
  * @return The direction of the rails on tile \a t.
  */
-static inline Axis GetRailStationAxis(TileIndex t)
+template <bool Tgeneric>
+static inline Axis GetRailStationAxis(typename TileIndexT<Tgeneric>::T t)
 {
 	assert(HasStationRail(t));
 	return HasBit(GetStationGfx(t), 0) ? AXIS_Y : AXIS_X;
 }
+/** @copydoc GetRailStationAxis(TileIndexT<Tgeneric>::T) */
+static inline Axis GetRailStationAxis(TileIndex t) { return GetRailStationAxis<false>(t); }
+/** @copydoc GetRailStationAxis(TileIndexT<Tgeneric>::T) */
+static inline Axis GetRailStationAxis(GenericTileIndex t) { return GetRailStationAxis<true>(t); }
 
 /**
  * Get the rail track of a rail station tile.
@@ -347,10 +472,15 @@
  * @pre HasStationRail(t)
  * @return The rail track of the rails on tile \a t.
  */
-static inline Track GetRailStationTrack(TileIndex t)
+template <bool Tgeneric>
+static inline Track GetRailStationTrack(typename TileIndexT<Tgeneric>::T t)
 {
 	return AxisToTrack(GetRailStationAxis(t));
 }
+/** @copydoc GetRailStationTrack(TileIndexT<Tgeneric>::T) */
+static inline Track GetRailStationTrack(TileIndex t) { return GetRailStationTrack<false>(t); }
+/** @copydoc GetRailStationTrack(TileIndexT<Tgeneric>::T) */
+static inline Track GetRailStationTrack(GenericTileIndex t) { return GetRailStationTrack<true>(t); }
 
 /**
  * Get the trackbits of a rail station tile.
@@ -358,10 +488,15 @@
  * @pre HasStationRail(t)
  * @return The trackbits of the rails on tile \a t.
  */
-static inline TrackBits GetRailStationTrackBits(TileIndex t)
+template <bool Tgeneric>
+static inline TrackBits GetRailStationTrackBits(typename TileIndexT<Tgeneric>::T t)
 {
 	return AxisToTrackBits(GetRailStationAxis(t));
 }
+/** @copydoc GetRailStationTrackBits(TileIndexT<Tgeneric>::T) */
+static inline TrackBits GetRailStationTrackBits(TileIndex t) { return GetRailStationTrackBits<false>(t); }
+/** @copydoc GetRailStationTrackBits(TileIndexT<Tgeneric>::T) */
+static inline TrackBits GetRailStationTrackBits(GenericTileIndex t) { return GetRailStationTrackBits<true>(t); }
 
 /**
  * Check if a tile is a valid continuation to a railstation tile.
@@ -394,7 +529,7 @@
 static inline bool HasStationReservation(TileIndex t)
 {
 	assert(HasStationRail(t));
-	return HasBit(_m[t].m6, 2);
+	return HasBit(GetTileEx(t)->m6, 2);
 }
 
 /**
@@ -403,11 +538,16 @@
  * @param t the station tile
  * @param b the reservation state
  */
-static inline void SetRailStationReservation(TileIndex t, bool b)
+template <bool Tgeneric>
+static inline void SetRailStationReservation(typename TileIndexT<Tgeneric>::T t, bool b)
 {
 	assert(HasStationRail(t));
-	SB(_m[t].m6, 2, 1, b ? 1 : 0);
+	SB(GetTileEx(t)->m6, 2, 1, b ? 1 : 0);
 }
+/** @copydoc SetRailStationReservation(TileIndexT<Tgeneric>::T) */
+static inline void SetRailStationReservation(TileIndex t, bool b) { SetRailStationReservation<false>(t, b); }
+/** @copydoc SetRailStationReservation(TileIndexT<Tgeneric>::T) */
+static inline void SetRailStationReservation(GenericTileIndex t, bool b) { SetRailStationReservation<true>(t, b); }
 
 /**
  * Get the reserved track bits for a waypoint
@@ -421,18 +561,56 @@
 }
 
 /**
+ * Test whether a given water dock tile is the land part of the dock
+ * @param t the water dock tile
+ * @return if the given tile is the land part of a dock
+ * @pre IsDockTile(t)
+ */
+template <bool Tgeneric>
+static inline bool IsLandDockSection(typename TileIndexT<Tgeneric>::T t)
+{
+	assert(IsDockTile(t));
+	return GetStationGfx(t) < GFX_DOCK_BASE_WATER_PART;
+}
+/** @copydoc IsLandDockSection<bool> */
+static inline bool IsLandDockSection(TileIndex t) { return IsLandDockSection<false>(t); }
+/** @copydoc IsLandDockSection<bool> */
+static inline bool IsLandDockSection(GenericTileIndex t) { return IsLandDockSection<true>(t); }
+
+/**
  * Get the direction of a dock.
  * @param t Tile to query
- * @pre IsDock(t)
+ * @pre IsLandDockSection(t)
  * @pre \a t is the land part of the dock
  * @return The direction of the dock on tile \a t.
  */
-static inline DiagDirection GetDockDirection(TileIndex t)
+template <bool Tgeneric>
+static inline DiagDirection GetDockDirection(typename TileIndexT<Tgeneric>::T t)
 {
-	StationGfx gfx = GetStationGfx(t);
-	assert(IsDock(t) && gfx < GFX_DOCK_BASE_WATER_PART);
-	return (DiagDirection)(gfx);
+	assert(IsLandDockSection(t));
+	return (DiagDirection)GetStationGfx(t);
 }
+/** @copydoc GetDockDirection(TileIndexT<Tgeneric>::T) */
+static inline DiagDirection GetDockDirection(TileIndex t) { return GetDockDirection<false>(t); }
+/** @copydoc GetDockDirection(TileIndexT<Tgeneric>::T) */
+static inline DiagDirection GetDockDirection(GenericTileIndex t) { return GetDockDirection<true>(t); }
+
+/**
+ * Get the other tile of a dock.
+ * @param t Tile to query
+ * @pre IsDockTile(t)
+ * @return The other tile of the dock.
+ */
+template <bool Tgeneric>
+static inline typename TileIndexT<Tgeneric>::T GetOtherDockTile(typename TileIndexT<Tgeneric>::T t)
+{
+	TileIndexDiff delta = ToTileIndexDiff(TileIndexDiffCByDiagDir(AxisToDiagDir((Axis)(GetStationGfx(t) & 0x1))), MapOf(t));
+	return IsDockTile(t + delta) ? t + delta : t - delta;
+}
+/** @copydoc GetOtherDockTile<bool> */
+static inline TileIndex GetOtherDockTile(TileIndex t) { return GetOtherDockTile<false>(t); }
+/** @copydoc GetOtherDockTile<bool> */
+static inline GenericTileIndex GetOtherDockTile(GenericTileIndex t) { return GetOtherDockTile<true>(t); }
 
 /**
  * Get the tileoffset from this tile a ship should target to get to this dock.
@@ -467,11 +645,16 @@
  * @pre HasStationTileRail(t)
  * @return True if this station is part of a newgrf station.
  */
-static inline bool IsCustomStationSpecIndex(TileIndex t)
+template <bool Tgeneric>
+static inline bool IsCustomStationSpecIndex(typename TileIndexT<Tgeneric>::T t)
 {
 	assert(HasStationTileRail(t));
-	return _m[t].m4 != 0;
+	return GetTile(t)->m4 != 0;
 }
+/** @copydoc IsCustomStationSpecIndex(TileIndexT<Tgeneric>::T) */
+static inline bool IsCustomStationSpecIndex(TileIndex t) { return IsCustomStationSpecIndex<false>(t); }
+/** @copydoc IsCustomStationSpecIndex(TileIndexT<Tgeneric>::T) */
+static inline bool IsCustomStationSpecIndex(GenericTileIndex t) { return IsCustomStationSpecIndex<true>(t); }
 
 /**
  * Set the custom station spec for this tile.
@@ -479,11 +662,16 @@
  * @param specindex The new spec.
  * @pre HasStationTileRail(t)
  */
-static inline void SetCustomStationSpecIndex(TileIndex t, byte specindex)
+template <bool Tgeneric>
+static inline void SetCustomStationSpecIndex(typename TileIndexT<Tgeneric>::T t, byte specindex)
 {
 	assert(HasStationTileRail(t));
-	_m[t].m4 = specindex;
+	GetTile(t)->m4 = specindex;
 }
+/** @copydoc SetCustomStationSpecIndex(TileIndexT<Tgeneric>::T,byte) */
+static inline void SetCustomStationSpecIndex(TileIndex t, byte specindex) { return SetCustomStationSpecIndex<false>(t, specindex); }
+/** @copydoc SetCustomStationSpecIndex(TileIndexT<Tgeneric>::T,byte) */
+static inline void SetCustomStationSpecIndex(GenericTileIndex t, byte specindex) { return SetCustomStationSpecIndex<true>(t, specindex); }
 
 /**
  * Get the custom station spec for this tile.
@@ -491,11 +679,16 @@
  * @pre HasStationTileRail(t)
  * @return The custom station spec of this tile.
  */
-static inline uint GetCustomStationSpecIndex(TileIndex t)
+template <bool Tgeneric>
+static inline uint GetCustomStationSpecIndex(typename TileIndexT<Tgeneric>::T t)
 {
 	assert(HasStationTileRail(t));
-	return _m[t].m4;
+	return GetTile(t)->m4;
 }
+/** @copydoc GetCustomStationSpecIndex(TileIndexT<Tgeneric>::T) */
+static inline uint GetCustomStationSpecIndex(TileIndex t) { return GetCustomStationSpecIndex<false>(t); }
+/** @copydoc GetCustomStationSpecIndex(TileIndexT<Tgeneric>::T) */
+static inline uint GetCustomStationSpecIndex(GenericTileIndex t) { return GetCustomStationSpecIndex<true>(t); }
 
 /**
  * Set the random bits for a station tile.
@@ -506,7 +699,7 @@
 static inline void SetStationTileRandomBits(TileIndex t, byte random_bits)
 {
 	assert(IsTileType(t, MP_STATION));
-	SB(_m[t].m3, 4, 4, random_bits);
+	SB(GetTile(t)->m3, 4, 4, random_bits);
 }
 
 /**
@@ -518,7 +711,7 @@
 static inline byte GetStationTileRandomBits(TileIndex t)
 {
 	assert(IsTileType(t, MP_STATION));
-	return GB(_m[t].m3, 4, 4);
+	return GB(GetTile(t)->m3, 4, 4);
 }
 
 /**
@@ -530,19 +723,24 @@
  * @param section the StationGfx to be used for this tile
  * @param wc The water class of the station
  */
-static inline void MakeStation(TileIndex t, Owner o, StationID sid, StationType st, byte section, WaterClass wc = WATER_CLASS_INVALID)
+template <bool Tgeneric>
+static inline void MakeStation(typename TileIndexT<Tgeneric>::T t, Owner o, StationID sid, StationType st, byte section, WaterClass wc = WATER_CLASS_INVALID)
 {
 	SetTileType(t, MP_STATION);
 	SetTileOwner(t, o);
 	SetWaterClass(t, wc);
-	_m[t].m2 = sid;
-	_m[t].m3 = 0;
-	_m[t].m4 = 0;
-	_m[t].m5 = section;
-	SB(_m[t].m6, 2, 1, 0);
-	SB(_m[t].m6, 3, 3, st);
-	_me[t].m7 = 0;
+	GetTile(t)->m2 = sid;
+	GetTile(t)->m3 = 0;
+	GetTile(t)->m4 = 0;
+	GetTile(t)->m5 = section;
+	SB(GetTileEx(t)->m6, 2, 1, 0);
+	SB(GetTileEx(t)->m6, 3, 3, st);
+	GetTileEx(t)->m7 = 0;
 }
+/** @copydoc MakeStation(TileIndexT<Tgeneric>::T,Owner,StationID,StationType,byte,WaterClass) */
+static inline void MakeStation(TileIndex t, Owner o, StationID sid, StationType st, byte section, WaterClass wc = WATER_CLASS_INVALID) { MakeStation<false>(t, o, sid, st, section, wc); }
+/** @copydoc MakeStation(TileIndexT<Tgeneric>::T,Owner,StationID,StationType,byte,WaterClass) */
+static inline void MakeStation(GenericTileIndex t, Owner o, StationID sid, StationType st, byte section, WaterClass wc = WATER_CLASS_INVALID) { MakeStation<true>(t, o, sid, st, section, wc); }
 
 /**
  * Make the given tile a rail station tile.
@@ -553,12 +751,17 @@
  * @param section the StationGfx to be used for this tile
  * @param rt the railtype of this tile
  */
-static inline void MakeRailStation(TileIndex t, Owner o, StationID sid, Axis a, byte section, RailType rt)
+template <bool Tgeneric>
+static inline void MakeRailStation(typename TileIndexT<Tgeneric>::T t, Owner o, StationID sid, Axis a, byte section, RailType rt)
 {
 	MakeStation(t, o, sid, STATION_RAIL, section + a);
 	SetRailType(t, rt);
 	SetRailStationReservation(t, false);
 }
+/** @copydoc MakeRailStation(TileIndexT<Tgeneric>::T,Owner,StationID,Axis,byte,RailType) */
+static inline void MakeRailStation(TileIndex t, Owner o, StationID sid, Axis a, byte section, RailType rt) { MakeRailStation<false>(t, o, sid, a, section, rt); }
+/** @copydoc MakeRailStation(TileIndexT<Tgeneric>::T,Owner,StationID,Axis,byte,RailType) */
+static inline void MakeRailStation(GenericTileIndex t, Owner o, StationID sid, Axis a, byte section, RailType rt) { MakeRailStation<true>(t, o, sid, a, section, rt); }
 
 /**
  * Make the given tile a rail waypoint tile.
@@ -569,12 +772,17 @@
  * @param section the StationGfx to be used for this tile
  * @param rt the railtype of this tile
  */
-static inline void MakeRailWaypoint(TileIndex t, Owner o, StationID sid, Axis a, byte section, RailType rt)
+template <bool Tgeneric>
+static inline void MakeRailWaypoint(typename TileIndexT<Tgeneric>::T t, Owner o, StationID sid, Axis a, byte section, RailType rt)
 {
 	MakeStation(t, o, sid, STATION_WAYPOINT, section + a);
 	SetRailType(t, rt);
 	SetRailStationReservation(t, false);
 }
+/** @copydoc MakeRailWaypoint(TileIndexT<Tgeneric>::T,Owner,StationID,Axis,byte,RailType) */
+static inline void MakeRailWaypoint(TileIndex t, Owner o, StationID sid, Axis a, byte section, RailType rt) { MakeRailWaypoint<false>(t, o, sid, a, section, rt); }
+/** @copydoc MakeRailWaypoint(TileIndexT<Tgeneric>::T,Owner,StationID,Axis,byte,RailType) */
+static inline void MakeRailWaypoint(GenericTileIndex t, Owner o, StationID sid, Axis a, byte section, RailType rt) { MakeRailWaypoint<true>(t, o, sid, a, section, rt); }
 
 /**
  * Make the given tile a roadstop tile.
@@ -585,13 +793,18 @@
  * @param rt the roadtypes on this tile
  * @param d the direction of the roadstop
  */
-static inline void MakeRoadStop(TileIndex t, Owner o, StationID sid, RoadStopType rst, RoadTypes rt, DiagDirection d)
+template <bool Tgeneric>
+static inline void MakeRoadStop(typename TileIndexT<Tgeneric>::T t, Owner o, StationID sid, RoadStopType rst, RoadTypes rt, DiagDirection d)
 {
 	MakeStation(t, o, sid, (rst == ROADSTOP_BUS ? STATION_BUS : STATION_TRUCK), d);
 	SetRoadTypes(t, rt);
 	SetRoadOwner(t, ROADTYPE_ROAD, o);
 	SetRoadOwner(t, ROADTYPE_TRAM, o);
 }
+/** @copydoc MakeRoadStop(TileIndexT<Tgeneric>::T,Owner,StationID,RoadStopType,RoadTypes,DiagDirection) */
+static inline void MakeRoadStop(TileIndex t, Owner o, StationID sid, RoadStopType rst, RoadTypes rt, DiagDirection d) { MakeRoadStop<false>(t, o, sid, rst, rt, d); }
+/** @copydoc MakeRoadStop(TileIndexT<Tgeneric>::T,Owner,StationID,RoadStopType,RoadTypes,DiagDirection) */
+static inline void MakeRoadStop(GenericTileIndex t, Owner o, StationID sid, RoadStopType rst, RoadTypes rt, DiagDirection d) { MakeRoadStop<true>(t, o, sid, rst, rt, d); }
 
 /**
  * Make the given tile a drivethrough roadstop tile.
@@ -604,13 +817,18 @@
  * @param rt the roadtypes on this tile
  * @param a the direction of the roadstop
  */
-static inline void MakeDriveThroughRoadStop(TileIndex t, Owner station, Owner road, Owner tram, StationID sid, RoadStopType rst, RoadTypes rt, Axis a)
+template <bool Tgeneric>
+static inline void MakeDriveThroughRoadStop(typename TileIndexT<Tgeneric>::T t, Owner station, Owner road, Owner tram, StationID sid, RoadStopType rst, RoadTypes rt, Axis a)
 {
 	MakeStation(t, station, sid, (rst == ROADSTOP_BUS ? STATION_BUS : STATION_TRUCK), GFX_TRUCK_BUS_DRIVETHROUGH_OFFSET + a);
 	SetRoadTypes(t, rt);
 	SetRoadOwner(t, ROADTYPE_ROAD, road);
 	SetRoadOwner(t, ROADTYPE_TRAM, tram);
 }
+/** @copydoc MakeDriveThroughRoadStop(TileIndexT<Tgeneric>::T,Owner,Owner,Owner,StationID,RoadStopType,RoadTypes,Axis) */
+static inline void MakeDriveThroughRoadStop(TileIndex t, Owner station, Owner road, Owner tram, StationID sid, RoadStopType rst, RoadTypes rt, Axis a) { MakeDriveThroughRoadStop<false>(t, station, road, tram, sid, rst, rt, a); }
+/** @copydoc MakeDriveThroughRoadStop(TileIndexT<Tgeneric>::T,Owner,Owner,Owner,StationID,RoadStopType,RoadTypes,Axis) */
+static inline void MakeDriveThroughRoadStop(GenericTileIndex t, Owner station, Owner road, Owner tram, StationID sid, RoadStopType rst, RoadTypes rt, Axis a) { MakeDriveThroughRoadStop<true>(t, station, road, tram, sid, rst, rt, a); }
 
 /**
  * Make the given tile an airport tile.
@@ -620,10 +838,15 @@
  * @param section the StationGfx to be used for this tile
  * @param wc the type of water on this tile
  */
-static inline void MakeAirport(TileIndex t, Owner o, StationID sid, byte section, WaterClass wc)
+template <bool Tgeneric>
+static inline void MakeAirport(typename TileIndexT<Tgeneric>::T t, Owner o, StationID sid, byte section, WaterClass wc)
 {
 	MakeStation(t, o, sid, STATION_AIRPORT, section, wc);
 }
+/** @copydoc MakeAirport(TileIndexT<Tgeneric>::T,Owner,StationID,byte,WaterClass) */
+static inline void MakeAirport(TileIndex t, Owner o, StationID sid, byte section, WaterClass wc) { MakeAirport<false>(t, o, sid, section, wc); }
+/** @copydoc MakeAirport(TileIndexT<Tgeneric>::T,Owner,StationID,byte,WaterClass) */
+static inline void MakeAirport(GenericTileIndex t, Owner o, StationID sid, byte section, WaterClass wc) { MakeAirport<true>(t, o, sid, section, wc); }
 
 /**
  * Make the given tile a buoy tile.
@@ -631,13 +854,18 @@
  * @param sid the station to which this tile belongs
  * @param wc the type of water on this tile
  */
-static inline void MakeBuoy(TileIndex t, StationID sid, WaterClass wc)
+template <bool Tgeneric>
+static inline void MakeBuoy(typename TileIndexT<Tgeneric>::T t, StationID sid, WaterClass wc)
 {
 	/* Make the owner of the buoy tile the same as the current owner of the
 	 * water tile. In this way, we can reset the owner of the water to its
 	 * original state when the buoy gets removed. */
 	MakeStation(t, GetTileOwner(t), sid, STATION_BUOY, 0, wc);
 }
+/** @copydoc MakeBuoy(TileIndexT<Tgeneric>::T,StationID,WaterClass) */
+static inline void MakeBuoy(TileIndex t, StationID sid, WaterClass wc) { MakeBuoy<false>(t, sid, wc); }
+/** @copydoc MakeBuoy(TileIndexT<Tgeneric>::T,StationID,WaterClass) */
+static inline void MakeBuoy(GenericTileIndex t, StationID sid, WaterClass wc) { MakeBuoy<true>(t, sid, wc); }
 
 /**
  * Make the given tile a dock tile.
@@ -647,11 +875,16 @@
  * @param d the direction of the dock
  * @param wc the type of water on this tile
  */
-static inline void MakeDock(TileIndex t, Owner o, StationID sid, DiagDirection d, WaterClass wc)
+template <bool Tgeneric>
+static inline void MakeDock(typename TileIndexT<Tgeneric>::T t, Owner o, StationID sid, DiagDirection d, WaterClass wc)
 {
 	MakeStation(t, o, sid, STATION_DOCK, d);
-	MakeStation(t + TileOffsByDiagDir(d), o, sid, STATION_DOCK, GFX_DOCK_BASE_WATER_PART + DiagDirToAxis(d), wc);
+	MakeStation(TileAddByDiagDir(t, d), o, sid, STATION_DOCK, GFX_DOCK_BASE_WATER_PART + DiagDirToAxis(d), wc);
 }
+/** @copydoc MakeDock(TileIndexT<Tgeneric>::T,Owner,StationID,DiagDirection,WaterClass) */
+static inline void MakeDock(TileIndex t, Owner o, StationID sid, DiagDirection d, WaterClass wc) { MakeDock<false>(t, o, sid, d, wc); }
+/** @copydoc MakeDock(TileIndexT<Tgeneric>::T,Owner,StationID,DiagDirection,WaterClass) */
+static inline void MakeDock(GenericTileIndex t, Owner o, StationID sid, DiagDirection d, WaterClass wc) { MakeDock<true>(t, o, sid, d, wc); }
 
 /**
  * Make the given tile an oilrig tile.
diff -urNad openttd-1.3.2/src/station_type.h openttd-1.3.2-DC3.0RC3/src/station_type.h
--- openttd-1.3.2/src/station_type.h	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/station_type.h	2013-11-22 05:49:07.000000000 +0100
@@ -85,7 +85,7 @@
 	MAX_CATCHMENT      = 10, ///< Maximum catchment for airports with "modified catchment" enabled
 };
 
-static const uint MAX_LENGTH_STATION_NAME_CHARS = 32; ///< The maximum length of a station name in characters including '\0'
+static const uint MAX_LENGTH_STATION_NAME_CHARS = 168; ///< The maximum length of a station name in characters including '\0'
 
 /** List of stations */
 typedef SmallVector<Station *, 2> StationList;
diff -urNad openttd-1.3.2/src/statusbar_gui.cpp openttd-1.3.2-DC3.0RC3/src/statusbar_gui.cpp
--- openttd-1.3.2/src/statusbar_gui.cpp	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/statusbar_gui.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -131,8 +131,8 @@
 		switch (widget) {
 			case WID_S_LEFT:
 				/* Draw the date */
-				SetDParam(0, _date);
-				DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP, STR_WHITE_DATE_LONG, TC_FROMSTRING, SA_HOR_CENTER);
+				SetDParam(0, ((DateTicks)_date * DAY_TICKS_DAY_LENGTH) + _date_fract);
+				DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP + 2, STR_WHITE_DATE_WALLCLOCK_LONG, TC_FROMSTRING, SA_HOR_CENTER);
 				break;
 
 			case WID_S_RIGHT: {
@@ -140,7 +140,7 @@
 				const Company *c = Company::GetIfValid(_local_company);
 				if (c != NULL) {
 					SetDParam(0, c->money);
-					DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP, STR_COMPANY_MONEY, TC_FROMSTRING, SA_HOR_CENTER);
+					DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP + 2, STR_COMPANY_MONEY, TC_FROMSTRING, SA_HOR_CENTER);
 				}
 				break;
 			}
@@ -148,26 +148,26 @@
 			case WID_S_MIDDLE:
 				/* Draw status bar */
 				if (this->saving) { // true when saving is active
-					DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP, STR_STATUSBAR_SAVING_GAME, TC_FROMSTRING, SA_HOR_CENTER);
+					DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP + 2, STR_STATUSBAR_SAVING_GAME, TC_FROMSTRING, SA_HOR_CENTER);
 				} else if (_do_autosave) {
-					DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP, STR_STATUSBAR_AUTOSAVE, TC_FROMSTRING, SA_HOR_CENTER);
+					DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP + 2, STR_STATUSBAR_AUTOSAVE, TC_FROMSTRING, SA_HOR_CENTER);
 				} else if (_pause_mode != PM_UNPAUSED) {
-					DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP, STR_STATUSBAR_PAUSED, TC_FROMSTRING, SA_HOR_CENTER);
+					DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP + 2, STR_STATUSBAR_PAUSED, TC_FROMSTRING, SA_HOR_CENTER);
 				} else if (this->ticker_scroll < TICKER_STOP && FindWindowById(WC_NEWS_WINDOW, 0) == NULL && _statusbar_news_item != NULL && _statusbar_news_item->string_id != 0) {
 					/* Draw the scrolling news text */
-					if (!DrawScrollingStatusText(_statusbar_news_item, this->ticker_scroll, r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP, r.bottom)) {
+					if (!DrawScrollingStatusText(_statusbar_news_item, this->ticker_scroll, r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP + 2, r.bottom)) {
 						InvalidateWindowData(WC_STATUS_BAR, 0, SBI_NEWS_DELETED);
 						if (Company::IsValidID(_local_company)) {
 							/* This is the default text */
 							SetDParam(0, _local_company);
-							DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP, STR_STATUSBAR_COMPANY_NAME, TC_FROMSTRING, SA_HOR_CENTER);
+							DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP + 2, STR_STATUSBAR_COMPANY_NAME, TC_FROMSTRING, SA_HOR_CENTER);
 						}
 					}
 				} else {
 					if (Company::IsValidID(_local_company)) {
 						/* This is the default text */
 						SetDParam(0, _local_company);
-						DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP, STR_STATUSBAR_COMPANY_NAME, TC_FROMSTRING, SA_HOR_CENTER);
+						DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP + 2, STR_STATUSBAR_COMPANY_NAME, TC_FROMSTRING, SA_HOR_CENTER);
 					}
 				}
 
@@ -213,6 +213,14 @@
 	{
 		if (_pause_mode != PM_UNPAUSED) return;
 
+		if (_settings_client.gui.time_in_minutes) {
+			this->SetWidgetDirty(WID_S_LEFT);
+		}
+
+		if (_settings_client.gui.time_in_minutes) {
+			this->SetWidgetDirty(WID_S_LEFT);
+		}
+
 		if (this->ticker_scroll < TICKER_STOP) { // Scrolling text
 			this->ticker_scroll += COUNTER_STEP;
 			this->SetWidgetDirty(WID_S_MIDDLE);
@@ -229,9 +237,9 @@
 
 static const NWidgetPart _nested_main_status_widgets[] = {
 	NWidget(NWID_HORIZONTAL),
-		NWidget(WWT_PANEL, COLOUR_GREY, WID_S_LEFT), SetMinimalSize(140, 12), EndContainer(),
-		NWidget(WWT_PUSHBTN, COLOUR_GREY, WID_S_MIDDLE), SetMinimalSize(40, 12), SetDataTip(0x0, STR_STATUSBAR_TOOLTIP_SHOW_LAST_NEWS), SetResize(1, 0),
-		NWidget(WWT_PUSHBTN, COLOUR_GREY, WID_S_RIGHT), SetMinimalSize(140, 12),
+		NWidget(WWT_PANEL, COLOUR_GREY, WID_S_LEFT), SetMinimalSize(160, 12), EndContainer(),
+		NWidget(WWT_PUSHBTN, COLOUR_GREY, WID_S_MIDDLE), SetMinimalSize(40, 14), SetDataTip(0x0, STR_STATUSBAR_TOOLTIP_SHOW_LAST_NEWS), SetResize(1, 0),
+		NWidget(WWT_PUSHBTN, COLOUR_GREY, WID_S_RIGHT), SetMinimalSize(140, 14),
 	EndContainer(),
 };
 
diff -urNad openttd-1.3.2/src/strings.cpp openttd-1.3.2-DC3.0RC3/src/strings.cpp
--- openttd-1.3.2/src/strings.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/strings.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -259,11 +259,13 @@
 			NOT_REACHED();
 	}
 
+//DC unkomment fagyás miatt
 	if (index >= _langtab_num[tab]) {
 		if (game_script) {
 			return GetStringWithArgs(buffr, STR_UNDEFINED, args, last);
 		}
 		error("String 0x%X is invalid. You are probably using an old version of the .lng file.\n", string);
+//		DEBUG(sprite, 1, "String 0x%X is invalid. You are probably using an old version of the .lng file.\n", string);
 	}
 
 	return FormatString(buffr, GetStringPtr(string), args, last, case_index);
@@ -416,6 +418,29 @@
 	return buff;
 }
 
+static char *FormatWallClockString(char *buff, DateTicks ticks, const char *last, bool show_date, uint case_index)
+{
+	Minutes minutes = ticks / _settings_client.gui.ticks_per_minute + _settings_client.gui.clock_offset;
+	char hour[3], minute[3];
+	snprintf(hour,   lengthof(hour),   "%02i", MINUTES_HOUR(minutes)  );
+	snprintf(minute, lengthof(minute), "%02i", MINUTES_MINUTE(minutes));
+	if (show_date) {
+		int64 args[3] = { (int64)hour, (int64)minute, (int64)ticks / DAY_TICKS_DAY_LENGTH };
+		if (_settings_client.gui.date_with_time == 1) {
+			YearMonthDay ymd;
+			ConvertDateToYMD(args[2], &ymd);
+			args[2] = ymd.year;
+		}
+
+		StringParameters tmp_params(args);
+		return FormatString(buff, GetStringPtr(STR_FORMAT_DATE_MINUTES + _settings_client.gui.date_with_time), &tmp_params, last, case_index);
+	} else {
+		int64 args[2] = { (int64)hour, (int64)minute };
+		StringParameters tmp_params(args);
+		return FormatString(buff, GetStringPtr(STR_FORMAT_DATE_MINUTES), &tmp_params, last, case_index);
+	}
+}
+
 static char *FormatYmdString(char *buff, Date date, const char *last, uint case_index)
 {
 	YearMonthDay ymd;
@@ -1160,6 +1185,8 @@
 
 				const CargoSpec *cs;
 				FOR_ALL_SORTED_CARGOSPECS(cs) {
+					int n;
+
 					if (!HasBit(cmask, cs->Index())) continue;
 
 					if (buff >= last - 2) break; // ',' and ' '
@@ -1173,6 +1200,20 @@
 					}
 
 					buff = GetStringWithArgs(buff, cs->name, args, last, next_substr_case_index, game_script);
+
+					if (args->GetParam(1) != SCC_CARGO_LIST || !_settings_client.gui.forecast_display) {
+						continue;
+					}
+
+					/* Shows only passengers and mails since other cargoes provide no useful value. (all 1) */
+					if (cs->Index() == CT_PASSENGERS || cs->Index() == CT_MAIL) {
+						if (cs->Index() == CT_PASSENGERS) {
+							n = sprintf(buff, "(%d)", args->GetParam(2));
+						} else {
+							n = sprintf(buff, "(%d)", args->GetParam(3));
+						}
+						buff += n;
+					}
 				}
 
 				/* If first is still true then no cargo is accepted */
@@ -1208,6 +1249,42 @@
 				next_substr_case_index = 0;
 				break;
 
+			case SCC_DATE_WALLCLOCK_LONG: { // {DATE_WALLCLOCK_LONG}
+				if (_settings_client.gui.time_in_minutes) {
+					buff = FormatWallClockString(buff, args->GetInt64(SCC_DATE_WALLCLOCK_LONG), last, _settings_client.gui.date_with_time, next_substr_case_index);
+				} else {
+					buff = FormatYmdString(buff, args->GetInt64(SCC_DATE_WALLCLOCK_LONG) / DAY_TICKS_DAY_LENGTH, last, next_substr_case_index);
+				}
+				break;
+			}
+
+			case SCC_DATE_WALLCLOCK_SHORT: { // {DATE_WALLCLOCK_SHORT}
+				if (_settings_client.gui.time_in_minutes) {
+					buff = FormatWallClockString(buff, args->GetInt64(SCC_DATE_WALLCLOCK_SHORT), last, _settings_client.gui.date_with_time, next_substr_case_index);
+				} else {
+					buff = FormatYmdString(buff, args->GetInt64(SCC_DATE_WALLCLOCK_SHORT) / DAY_TICKS_DAY_LENGTH, last, next_substr_case_index);
+				}
+				break;
+			}
+
+			case SCC_DATE_WALLCLOCK_TINY: { // {DATE_WALLCLOCK_TINY}
+				if (_settings_client.gui.time_in_minutes) {
+					buff = FormatWallClockString(buff, args->GetInt64(SCC_DATE_WALLCLOCK_TINY), last, false, next_substr_case_index);
+				} else {
+					buff = FormatTinyOrISODate(buff, args->GetInt64(SCC_DATE_WALLCLOCK_TINY) / DAY_TICKS_DAY_LENGTH, STR_FORMAT_DATE_TINY, last);
+				}
+				break;
+			}
+
+			case SCC_DATE_WALLCLOCK_ISO: { // {DATE_WALLCLOCK_ISO}
+				if (_settings_client.gui.time_in_minutes) {
+					buff = FormatWallClockString(buff, args->GetInt64(SCC_DATE_WALLCLOCK_ISO), last, false, next_substr_case_index);
+				} else {
+					buff = FormatTinyOrISODate(buff, args->GetInt64(SCC_DATE_WALLCLOCK_ISO) / DAY_TICKS_DAY_LENGTH, STR_FORMAT_DATE_ISO, last);
+				}
+				break;
+			}
+
 			case SCC_DATE_ISO: // {DATE_ISO}
 				buff = FormatTinyOrISODate(buff, args->GetInt32(), STR_FORMAT_DATE_ISO, last);
 				break;
@@ -1472,12 +1549,21 @@
 					int64 args_array[] = {(uint64)(size_t)v->name};
 					StringParameters tmp_params(args_array);
 					buff = GetStringWithArgs(buff, STR_JUST_RAW_STRING, &tmp_params, last);
-				} else {
+				}
+				 else {
 					int64 args_array[] = {v->unitnumber};
 					StringParameters tmp_params(args_array);
-
 					StringID str;
 					switch (v->type) {
+
+/*2szer is itt fagyott le
+Error: NOT_REACHED triggered at line 1540 of /tmp/openttd-1.3.2-DC-atc/src/strings.cpp
+Crash encountered, generating crash log...
+						default: NULL;
+						default: break;
+Az a tapasztalat, hogy csak akkor fagy le, ha aktív a menetrend az állomáson, azaz éppen nézzük
+*/
+//						default: str = STR_SV_TRAIN_NAME;
 						default: NOT_REACHED();
 						case VEH_TRAIN:    str = STR_SV_TRAIN_NAME; break;
 						case VEH_ROAD:     str = STR_SV_ROAD_VEHICLE_NAME; break;
@@ -1818,6 +1904,7 @@
 	/* Some lists need to be sorted again after a language change. */
 	ReconsiderGameScriptLanguage();
 	InitializeSortedCargoSpecs();
+	BuildCargoTypesLegend();
 	SortIndustryTypes();
 	BuildIndustriesLegend();
 	SortNetworkLanguages();
diff -urNad openttd-1.3.2/src/subsidy.cpp openttd-1.3.2-DC3.0RC3/src/subsidy.cpp
--- openttd-1.3.2/src/subsidy.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/subsidy.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -24,6 +24,7 @@
 #include "core/random_func.hpp"
 #include "game/game.hpp"
 #include "command_func.h"
+#include "cargodest_func.h"
 
 #include "table/strings.h"
 
@@ -296,13 +297,22 @@
 {
 	if (!Subsidy::CanAllocateItem()) return false;
 
-	const Town *src = Town::GetRandom();
+	Town *src = Town::GetRandom();
 	if (src->cache.population < SUBSIDY_PAX_MIN_POPULATION ||
 			src->GetPercentTransported(CT_PASSENGERS) > SUBSIDY_MAX_PCT_TRANSPORTED) {
 		return false;
 	}
 
-	const Town *dst = Town::GetRandom();
+	const Town *dst = NULL;
+	if (CargoHasDestinations(CT_PASSENGERS)) {
+		/* Try to get a town from the demand destinations. */
+		CargoLink *link = src->GetRandomLink(CT_PASSENGERS, false);
+		if (link == src->cargo_links[CT_PASSENGERS].End()) return NULL;
+		if (link->dest != NULL && link->dest->GetType() != ST_TOWN) return NULL;
+		dst = static_cast<const Town *>(link->dest);
+	}
+	if (dst == NULL) dst = Town::GetRandom();
+
 	if (dst->cache.population < SUBSIDY_PAX_MIN_POPULATION || src == dst) {
 		return false;
 	}
@@ -408,11 +418,22 @@
 	/* Choose a random destination. Only consider towns if they can accept the cargo. */
 	SourceType dst_type = (HasBit(_town_cargoes_accepted, cid) && Chance16(1, 2)) ? ST_TOWN : ST_INDUSTRY;
 
+	CargoSourceSink *src_sink = (src_type == ST_TOWN) ? (CargoSourceSink *) Town::Get(src) : (CargoSourceSink *) Industry::Get(src);
+
 	SourceID dst;
 	switch (dst_type) {
 		case ST_TOWN: {
 			/* Select a random town. */
-			const Town *dst_town = Town::GetRandom();
+			const Town *dst_town = NULL;
+
+			if (CargoHasDestinations(cid)) {
+				/* Try to get a town from the demand destinations. */
+				CargoLink *link = src_sink->GetRandomLink(cid, false);
+				if (link == src_sink->cargo_links[cid].End()) return NULL;
+				if (link->dest != NULL && link->dest->GetType() != dst_type) return NULL;
+				dst_town = static_cast<const Town *>(link->dest);
+			}
+			if (dst_town == NULL) dst_town = Town::GetRandom();
 
 			/* Check if the town can accept this cargo. */
 			if (!HasBit(dst_town->cargo_accepted_total, cid)) return false;
@@ -425,15 +446,24 @@
 			/* Select a random industry. */
 			const Industry *dst_ind = Industry::GetRandom();
 
+			if (CargoHasDestinations(cid)) {
+				/* Try to get a town from the demand destinations. */
+				CargoLink *link = src_sink->GetRandomLink(cid, false);
+				if (link == src_sink->cargo_links[cid].End()) return NULL;
+				if (link->dest != NULL && link->dest->GetType() != dst_type) return NULL;
+				dst_ind = static_cast<const Industry *>(link->dest);
+			}
+			if (dst_ind == NULL) dst_ind = Industry::GetRandom();
+
+			dst = dst_ind->index;
+
 			/* The industry must accept the cargo */
-			if (dst_ind == NULL ||
+			if (dst_ind == NULL || (src_type == dst_type && src == dst) ||
 					(cid != dst_ind->accepts_cargo[0] &&
 					 cid != dst_ind->accepts_cargo[1] &&
 					 cid != dst_ind->accepts_cargo[2])) {
 				return false;
 			}
-
-			dst = dst_ind->index;
 			break;
 		}
 
diff -urNad openttd-1.3.2/src/table/airport_defaults.h openttd-1.3.2-DC3.0RC3/src/table/airport_defaults.h
--- openttd-1.3.2/src/table/airport_defaults.h	2013-07-27 17:09:31.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/table/airport_defaults.h	2013-11-22 05:49:07.000000000 +0100
@@ -333,6 +333,369 @@
 	_tile_table_intercontinental_0,
 };
 
+/** Tiles for test Airport (large) - 4 runways */
+static AirportTileTable _tile_table_intercontinental2_0[] = {
+	MK(0, 0, APT_EMPTY),
+	MK(1, 0, APT_BUILDING_1),
+	MK(2, 0, APT_BUILDING_2),
+	MK(3, 0, APT_BUILDING_3),
+	MK(4, 0, APT_BUILDING_1),
+	MK(5, 0, APT_BUILDING_3),
+	MK(6, 0, APT_TOWER),
+	MK(7, 0, APT_BUILDING_1),
+	MK(8, 0, APT_BUILDING_3),
+	MK(9, 0, APT_BUILDING_2),
+	MK(10, 0, APT_BUILDING_1),
+	MK(11, 0, APT_EMPTY),
+	MK(0, 1, APT_DEPOT_SE),
+	MK(1, 1, APT_STAND),
+	MK(2, 1, APT_STAND),
+	MK(3, 1, APT_STAND),
+	MK(4, 1, APT_STAND),
+	MK(5, 1, APT_HELIPAD_2),
+	MK(6, 1, APT_HELIPAD_2),
+	MK(7, 1, APT_STAND),
+	MK(8, 1, APT_STAND),
+	MK(9, 1, APT_STAND),
+	MK(10, 1, APT_STAND),
+	MK(11, 1, APT_DEPOT_SE),
+	MK(0, 2, APT_APRON_FENCE_NE),
+	MK(1, 2, APT_APRON),
+	MK(2, 2, APT_APRON),
+	MK(3, 2, APT_APRON),
+	MK(4, 2, APT_APRON),
+	MK(5, 2, APT_APRON),
+	MK(6, 2, APT_APRON),
+	MK(7, 2, APT_APRON),
+	MK(8, 2, APT_APRON),
+	MK(9, 2, APT_APRON),
+	MK(10, 2, APT_APRON),
+	MK(11, 2, APT_APRON_FENCE_SW),
+	MK(0, 3, APT_APRON_FENCE_NE),
+	MK(1, 3, APT_EMPTY),
+	MK(2, 3, APT_APRON),
+	MK(3, 3, APT_EMPTY),
+	MK(4, 3, APT_APRON),
+	MK(5, 3, APT_EMPTY),
+	MK(6, 3, APT_EMPTY),
+	MK(7, 3, APT_APRON),
+	MK(8, 3, APT_EMPTY),
+	MK(9, 3, APT_APRON),
+	MK(10, 3, APT_EMPTY),
+	MK(11, 3, APT_APRON_FENCE_SW),
+ 	MK(0, 4, APT_APRON_FENCE_NE),
+	MK(1, 4, APT_APRON),
+	MK(2, 4, APT_APRON),
+	MK(3, 4, APT_APRON),
+	MK(4, 4, APT_APRON),
+	MK(5, 4, APT_APRON),
+	MK(6, 4, APT_APRON),
+	MK(7, 4, APT_APRON),
+	MK(8, 4, APT_APRON),
+	MK(9, 4, APT_APRON),
+	MK(10, 4, APT_APRON),
+	MK(11, 4, APT_APRON_FENCE_SW),
+	MK(0, 5, APT_APRON_FENCE_NE),
+	MK(1, 5, APT_EMPTY),
+	MK(2, 5, APT_EMPTY),
+	MK(3, 5, APT_EMPTY),
+	MK(4, 5, APT_EMPTY),
+	MK(5, 5, APT_EMPTY),
+	MK(6, 5, APT_EMPTY),
+	MK(7, 5, APT_EMPTY),
+	MK(8, 5, APT_EMPTY),
+	MK(9, 5, APT_EMPTY),
+	MK(10, 5, APT_EMPTY),
+	MK(11, 5, APT_APRON_FENCE_SW),
+	MK(0, 6, APT_APRON_FENCE_NE),
+	MK(1, 6, APT_APRON_FENCE_SE),
+	MK(2, 6, APT_RUNWAY_END_FENCE_SE),
+	MK(3, 6, APT_RUNWAY_2),
+	MK(4, 6, APT_RUNWAY_2),
+	MK(5, 6, APT_RUNWAY_2),
+	MK(6, 6, APT_RUNWAY_2),
+	MK(7, 6, APT_RUNWAY_2),
+	MK(8, 6, APT_RUNWAY_END_FENCE_SE_SW),
+	MK(9, 6, APT_EMPTY),
+	MK(10, 6, APT_EMPTY),
+	MK(11, 6, APT_APRON_FENCE_SW),
+	MK(0, 7, APT_APRON_FENCE_NE),
+	MK(1, 7, APT_EMPTY),
+	MK(2, 7, APT_EMPTY),
+	MK(3, 7, APT_RUNWAY_END_FENCE_NE_SE),
+	MK(4, 7, APT_RUNWAY_2),
+	MK(5, 7, APT_RUNWAY_2),
+	MK(6, 7, APT_RUNWAY_2),
+	MK(7, 7, APT_RUNWAY_2),
+	MK(8, 7, APT_RUNWAY_2),
+	MK(9, 7, APT_RUNWAY_END_FENCE_SE),
+	MK(10, 7, APT_APRON_FENCE_SE),
+	MK(11, 7, APT_APRON_FENCE_SW),
+	MK(0, 8, APT_RUNWAY_END_FENCE_NE_SE),
+	MK(1, 8, APT_RUNWAY_2),
+	MK(2, 8, APT_RUNWAY_2),
+	MK(3, 8, APT_RUNWAY_2),
+	MK(4, 8, APT_RUNWAY_2),
+	MK(5, 8, APT_RUNWAY_2),
+	MK(6, 8, APT_RUNWAY_END_FENCE_SE_SW),
+	MK(7, 8, APT_EMPTY),
+	MK(8, 8, APT_EMPTY),
+	MK(9, 8, APT_EMPTY),
+	MK(10, 8, APT_EMPTY),
+	MK(11, 8, APT_APRON_FENCE_SW),
+	MK(0, 9, APT_RADAR_FENCE_NE),
+	MK(1, 9, APT_EMPTY),
+	MK(2, 9, APT_EMPTY),
+	MK(3, 9, APT_EMPTY),
+	MK(4, 9, APT_EMPTY),
+	MK(5, 9, APT_RUNWAY_END_FENCE_NE_SE),
+	MK(6, 9, APT_RUNWAY_2),
+	MK(7, 9, APT_RUNWAY_2),
+	MK(8, 9, APT_RUNWAY_2),
+	MK(9, 9, APT_RUNWAY_2),
+	MK(10, 9, APT_RUNWAY_2),
+	MK(11, 9, APT_RUNWAY_END_FENCE_SE_SW),
+	MKEND
+};
+
+static AirportTileTable *_tile_table_intercontinental2[] = {
+	_tile_table_intercontinental2_0,
+};
+
+/** Tiles for Circle Airport */
+static AirportTileTable _tile_table_circle_0[] = {
+  MK(0, 0, APT_RUNWAY_END_NE_NW_SE),
+  MK(1, 0, APT_RUNWAY_2_NW_SE),
+  MK(2, 0, APT_RUNWAY_2_NW_SE),
+  MK(3, 0, APT_RUNWAY_2_NW_SE),
+  MK(4, 0, APT_RUNWAY_2_NW_SE),
+  MK(5, 0, APT_RUNWAY_END_FENCE_NW_SW),
+  MK(6, 0, APT_RUNWAY_END_FENCE_NE_NW),
+  MK(7, 0, APT_RUNWAY_2_NW_SE),
+  MK(8, 0, APT_RUNWAY_2_NW_SE),
+  MK(9, 0, APT_RUNWAY_2_NW_SE),
+  MK(10, 0, APT_RUNWAY_2_NW_SE),
+  MK(11, 0, APT_RUNWAY_END_NW_SE_SW),
+  MK(12, 0, APT_EMPTY),
+  MK(13, 0, APT_EMPTY),
+  MK(14, 0, APT_NSRUNWAY_END_NE_NW_SW),
+  MK(0, 1, APT_EMPTY),
+  MK(1, 1, APT_EMPTY),
+  MK(2, 1, APT_EMPTY),
+  MK(3, 1, APT_EMPTY),
+  MK(4, 1, APT_APRON_HALF_SOUTH),
+  MK(5, 1, APT_APRON),
+  MK(6, 1, APT_APRON),
+  MK(7, 1, APT_APRON),
+  MK(8, 1, APT_APRON),
+  MK(9, 1, APT_APRON),
+  MK(10, 1, APT_APRON_HALF_EAST),
+  MK(11, 1, APT_EMPTY),
+  MK(12, 1, APT_EMPTY),
+  MK(13, 1, APT_EMPTY),
+  MK(14, 1, APT_NSRUNWAY_4_NE_SW),
+  MK(0, 2, APT_EMPTY),
+  MK(1, 2, APT_EMPTY),
+  MK(2, 2, APT_HELI_NO_FENCES),
+  MK(3, 2, APT_APRON_Q_NO_NW_0),
+  MK(4, 2, APT_APRON_HALF_NORTH),
+  MK(5, 2, APT_APRON),
+  MK(6, 2, APT_APRON_HALF_WEST),
+  MK(7, 2, APT_APRON_HALF_EAST),
+  MK(8, 2, APT_APRON_HALF_WEST),
+  MK(9, 2, APT_APRON_HALF_EAST),
+  MK(10, 2, APT_APRON_HALF_WEST),
+  MK(11, 2, APT_APRON_Q_NO_NW_1),
+  MK(12, 2, APT_HELI_NO_FENCES),
+  MK(13, 2, APT_EMPTY),
+  MK(14, 2, APT_NSRUNWAY_4_NE_SW),
+  MK(0, 3, APT_NSRUNWAY_END_NE_NW_SW),
+  MK(1, 3, APT_EMPTY),
+  MK(2, 3, APT_APRON_Q_NO_NE_0),
+  MK(3, 3, APT_APRON),
+  MK(4, 3, APT_APRON),
+  MK(5, 3, APT_APRON),
+  MK(6, 3, APT_APRON),
+  MK(7, 3, APT_APRON),
+  MK(8, 3, APT_APRON),
+  MK(9, 3, APT_APRON),
+  MK(10, 3, APT_APRON),
+  MK(11, 3, APT_APRON),
+  MK(12, 3, APT_APRON_Q_NO_SW_1),
+  MK(13, 3, APT_EMPTY),
+  MK(14, 3, APT_NSRUNWAY_4_NE_SW),
+  MK(0, 4, APT_NSRUNWAY_4_NE_SW),
+  MK(1, 4, APT_APRON_HALF_SOUTH),
+  MK(2, 4, APT_APRON_HALF_NORTH),
+  MK(3, 4, APT_APRON),
+  MK(4, 4, APT_STAND),
+  MK(5, 4, APT_STAND),
+  MK(6, 4, APT_STAND),
+  MK(7, 4, APT_APRON),
+  MK(8, 4, APT_STAND),
+  MK(9, 4, APT_STAND),
+  MK(10, 4, APT_STAND),
+  MK(11, 4, APT_APRON),
+  MK(12, 4, APT_APRON_HALF_WEST),
+  MK(13, 4, APT_APRON_HALF_EAST),
+  MK(14, 4, APT_NSRUNWAY_4_NE_SW),
+  MK(0, 5, APT_NSRUNWAY_4_NE_SW),
+  MK(1, 5, APT_APRON),
+  MK(2, 5, APT_APRON_HALF_SOUTH),
+  MK(3, 5, APT_APRON),
+  MK(4, 5, APT_STAND),
+  MK(5, 5, APT_BUILDING_1),
+  MK(6, 5, APT_BUILDING_1),
+  MK(7, 5, APT_APRON),
+  MK(8, 5, APT_BUILDING_1),
+  MK(9, 5, APT_BUILDING_1),
+  MK(10, 5, APT_STAND),
+  MK(11, 5, APT_APRON),
+  MK(12, 5, APT_APRON),
+  MK(13, 5, APT_APRON),
+  MK(14, 5, APT_NSRUNWAY_END_SE_SW),
+  MK(0, 6, APT_NSRUNWAY_4_NE_SW),
+  MK(1, 6, APT_APRON),
+  MK(2, 6, APT_APRON_HALF_NORTH),
+  MK(3, 6, APT_APRON),
+  MK(4, 6, APT_STAND),
+  MK(5, 6, APT_BUILDING_1),
+  MK(6, 6, APT_DEPOT_SW),
+  MK(7, 6, APT_APRON),
+  MK(8, 6, APT_DEPOT_SE),
+  MK(9, 6, APT_BUILDING_1),
+  MK(10, 6, APT_STAND),
+  MK(11, 6, APT_APRON),
+  MK(12, 6, APT_APRON_HALF_SOUTH),
+  MK(13, 6, APT_APRON),
+  MK(14, 6, APT_NSRUNWAY_END_NW_SW),
+  MK(0, 7, APT_NSRUNWAY_4_NE_SW),
+  MK(1, 7, APT_APRON),
+  MK(2, 7, APT_APRON_HALF_SOUTH),
+  MK(3, 7, APT_APRON),
+  MK(4, 7, APT_APRON),
+  MK(5, 7, APT_APRON),
+  MK(6, 7, APT_APRON),
+  MK(7, 7, APT_TOWER),
+  MK(8, 7, APT_APRON),
+  MK(9, 7, APT_APRON),
+  MK(10, 7, APT_APRON),
+  MK(11, 7, APT_APRON),
+  MK(12, 7, APT_APRON_HALF_NORTH),
+  MK(13, 7, APT_APRON),
+  MK(14, 7, APT_NSRUNWAY_4_NE_SW),
+  MK(0, 8, APT_NSRUNWAY_END_NE_SE),
+  MK(1, 8, APT_APRON),
+  MK(2, 8, APT_APRON_HALF_NORTH),
+  MK(3, 8, APT_APRON),
+  MK(4, 8, APT_STAND),
+  MK(5, 8, APT_BUILDING_1),
+  MK(6, 8, APT_DEPOT_NW),
+  MK(7, 8, APT_APRON),
+  MK(8, 8, APT_DEPOT_NE),
+  MK(9, 8, APT_BUILDING_1),
+  MK(10, 8, APT_STAND),
+  MK(11, 8, APT_APRON),
+  MK(12, 8, APT_APRON_HALF_SOUTH),
+  MK(13, 8, APT_APRON),
+  MK(14, 8, APT_NSRUNWAY_4_NE_SW),
+  MK(0, 9, APT_NSRUNWAY_END_NE_NW),
+  MK(1, 9, APT_APRON),
+  MK(2, 9, APT_APRON),
+  MK(3, 9, APT_APRON),
+  MK(4, 9, APT_STAND),
+  MK(5, 9, APT_BUILDING_1),
+  MK(6, 9, APT_BUILDING_1),
+  MK(7, 9, APT_APRON),
+  MK(8, 9, APT_BUILDING_1),
+  MK(9, 9, APT_BUILDING_1),
+  MK(10, 9, APT_STAND),
+  MK(11, 9, APT_APRON),
+  MK(12, 9, APT_APRON_HALF_NORTH),
+  MK(13, 9, APT_APRON),
+  MK(14, 9, APT_NSRUNWAY_4_NE_SW),
+  MK(0, 10, APT_NSRUNWAY_4_NE_SW),
+  MK(1, 10, APT_APRON_HALF_WEST),
+  MK(2, 10, APT_APRON_HALF_EAST),
+  MK(3, 10, APT_APRON),
+  MK(4, 10, APT_STAND),
+  MK(5, 10, APT_STAND),
+  MK(6, 10, APT_STAND),
+  MK(7, 10, APT_APRON),
+  MK(8, 10, APT_STAND),
+  MK(9, 10, APT_STAND),
+  MK(10, 10, APT_STAND),
+  MK(11, 10, APT_APRON),
+  MK(12, 10, APT_APRON_HALF_SOUTH),
+  MK(13, 10, APT_APRON_HALF_NORTH),
+  MK(14, 10, APT_NSRUNWAY_4_NE_SW),
+  MK(0, 11, APT_NSRUNWAY_4_NE_SW),
+  MK(1, 11, APT_EMPTY),
+  MK(2, 11, APT_APRON_Q_NO_NE_1),
+  MK(3, 11, APT_APRON),
+  MK(4, 11, APT_APRON),
+  MK(5, 11, APT_APRON),
+  MK(6, 11, APT_APRON),
+  MK(7, 11, APT_APRON),
+  MK(8, 11, APT_APRON),
+  MK(9, 11, APT_APRON),
+  MK(10, 11, APT_APRON),
+  MK(11, 11, APT_APRON),
+  MK(12, 11, APT_APRON_Q_NO_SW_0),
+  MK(13, 11, APT_EMPTY),
+  MK(14, 11, APT_NSRUNWAY_END_NE_SE_SW),
+  MK(0, 12, APT_NSRUNWAY_4_NE_SW),
+  MK(1, 12, APT_EMPTY),
+  MK(2, 12, APT_HELI_NO_FENCES),
+  MK(3, 12, APT_APRON_Q_NO_SE_1),
+  MK(4, 12, APT_APRON_HALF_EAST),
+  MK(5, 12, APT_APRON_HALF_WEST),
+  MK(6, 12, APT_APRON_HALF_EAST),
+  MK(7, 12, APT_APRON_HALF_WEST),
+  MK(8, 12, APT_APRON_HALF_EAST),
+  MK(9, 12, APT_APRON),
+  MK(10, 12, APT_APRON_HALF_SOUTH),
+  MK(11, 12, APT_APRON_Q_NO_SE_0),
+  MK(12, 12, APT_HELI_NO_FENCES),
+  MK(13, 12, APT_EMPTY),
+  MK(14, 12, APT_EMPTY),
+  MK(0, 13, APT_NSRUNWAY_4_NE_SW),
+  MK(1, 13, APT_EMPTY),
+  MK(2, 13, APT_EMPTY),
+  MK(3, 13, APT_EMPTY),
+  MK(4, 13, APT_APRON_HALF_WEST),
+  MK(5, 13, APT_APRON),
+  MK(6, 13, APT_APRON),
+  MK(7, 13, APT_APRON),
+  MK(8, 13, APT_APRON),
+  MK(9, 13, APT_APRON),
+  MK(10, 13, APT_APRON_HALF_NORTH),
+  MK(11, 13, APT_EMPTY),
+  MK(12, 13, APT_EMPTY),
+  MK(13, 13, APT_EMPTY),
+  MK(14, 13, APT_EMPTY),
+  MK(0, 14, APT_NSRUNWAY_END_NE_SE_SW),
+  MK(1, 14, APT_EMPTY),
+  MK(2, 14, APT_EMPTY),
+  MK(3, 14, APT_RUNWAY_END_NE_NW_SE),
+  MK(4, 14, APT_RUNWAY_2_NW_SE),
+  MK(5, 14, APT_RUNWAY_2_NW_SE),
+  MK(6, 14, APT_RUNWAY_2_NW_SE),
+  MK(7, 14, APT_RUNWAY_2_NW_SE),
+  MK(8, 14, APT_RUNWAY_END_FENCE_SE_SW),
+  MK(9, 14, APT_RUNWAY_END_FENCE_NE_SE),
+  MK(10, 14, APT_RUNWAY_2_NW_SE),
+  MK(11, 14, APT_RUNWAY_2_NW_SE),
+  MK(12, 14, APT_RUNWAY_2_NW_SE),
+  MK(13, 14, APT_RUNWAY_2_NW_SE),
+  MK(14, 14, APT_RUNWAY_END_NW_SE_SW),
+  MKEND
+};
+
+static AirportTileTable *_tile_table_circle[] = {
+	_tile_table_circle_0,
+};
+
 /** Tiles for Heliport */
 static AirportTileTable _tile_table_heliport_0[] = {
 	MK(0, 0, APT_HELIPORT),
@@ -381,18 +744,23 @@
 #undef MKEND
 
 /** General AirportSpec definition. */
-#define AS_GENERIC(fsm, att, rot, att_len, depot_tbl, num_depots, size_x, size_y, noise, catchment, min_year, max_year, maint_cost, ttdpatch_type, class_id, name, preview, enabled) \
-	{fsm, att, rot, att_len, depot_tbl, num_depots, size_x, size_y, noise, catchment, min_year, max_year, name, ttdpatch_type, class_id, preview, maint_cost, enabled, GRFFileProps(AT_INVALID)}
+#define AS_GENERIC(fsm, att, rot, att_len, depot_tbl, num_depots, size_x, size_y, noise, catchment, min_year, max_year, maint_cost, max_circle, ttdpatch_type, class_id, name, preview, enabled) \
+	{fsm, att, rot, att_len, depot_tbl, num_depots, size_x, size_y, noise, catchment, min_year, max_year, name, ttdpatch_type, class_id, preview, maint_cost, max_circle, enabled, GRFFileProps(AT_INVALID)}
 
 /** AirportSpec definition for airports without any depot. */
 #define AS_ND(ap_name, size_x, size_y, min_year, max_year, catchment, noise, maint_cost, ttdpatch_type, class_id, name, preview) \
 	AS_GENERIC(&_airportfta_##ap_name, _tile_table_##ap_name, _default_airports_rotation, lengthof(_tile_table_##ap_name), NULL, 0, \
-		size_x, size_y, noise, catchment, min_year, max_year, maint_cost, ttdpatch_type, class_id, name, preview, true)
+		size_x, size_y, noise, catchment, min_year, max_year, maint_cost, 0, ttdpatch_type, class_id, name, preview, true)
 
 /** AirportSpec definition for airports with at least one depot. */
 #define AS(ap_name, size_x, size_y, min_year, max_year, catchment, noise, maint_cost, ttdpatch_type, class_id, name, preview) \
 	AS_GENERIC(&_airportfta_##ap_name, _tile_table_##ap_name, _default_airports_rotation, lengthof(_tile_table_##ap_name), _airport_depots_##ap_name, lengthof(_airport_depots_##ap_name), \
-		size_x, size_y, noise, catchment, min_year, max_year, maint_cost, ttdpatch_type, class_id, name, preview, true)
+		size_x, size_y, noise, catchment, min_year, max_year, maint_cost, 0, ttdpatch_type, class_id, name, preview, true)
+
+/** AirportSpec definition for airports with at least one depot and one circle part */
+#define AS_C(ap_name, size_x, size_y, min_year, max_year, catchment, noise, maint_cost, max_circle, ttdpatch_type, class_id, name, preview) \
+	AS_GENERIC(&_airportfta_##ap_name, _tile_table_##ap_name, _default_airports_rotation, lengthof(_tile_table_##ap_name), _airport_depots_##ap_name, lengthof(_airport_depots_##ap_name), \
+		size_x, size_y, noise, catchment, min_year, max_year, maint_cost, max_circle, ttdpatch_type, class_id, name, preview, true)
 
 /* The helidepot and helistation have ATP_TTDP_SMALL because they are at ground level */
 extern const AirportSpec _origin_airport_specs[] = {
@@ -405,13 +773,16 @@
 	AS(helidepot,        2, 2,  1976, MAX_YEAR,  4,  2,  7, ATP_TTDP_SMALL,    APC_HELIPORT, STR_AIRPORT_HELIDEPOT,        SPR_AIRPORT_PREVIEW_HELIDEPOT),
 	AS(intercontinental, 9, 11, 2002, MAX_YEAR, 10, 25, 72, ATP_TTDP_LARGE,    APC_HUB,      STR_AIRPORT_INTERCONTINENTAL, SPR_AIRPORT_PREVIEW_INTERCONTINENTAL),
 	AS(helistation,      4, 2,  1980, MAX_YEAR,  4,  3, 14, ATP_TTDP_SMALL,    APC_HELIPORT, STR_AIRPORT_HELISTATION,      SPR_AIRPORT_PREVIEW_HELISTATION),
-	AS_GENERIC(&_airportfta_oilrig, NULL, _default_airports_rotation, 0, NULL, 0, 1, 1, 0, 4, 0, 0, 0, ATP_TTDP_OILRIG, APC_HELIPORT, STR_NULL, 0, false),
+	AS(intercontinental2,12,10, 2005, MAX_YEAR, 11, 30, 80, ATP_TTDP_LARGE,    APC_HUGE,     STR_AIRPORT_INTERCONTINENTAL2, 0),
+	AS_C(circle,         15,15, 2015, MAX_YEAR, 15, 50,150, 30, ATP_TTDP_LARGE,APC_HUGE,     STR_AIRPORT_CIRCLE,            0),
+	AS_GENERIC(&_airportfta_oilrig, NULL, _default_airports_rotation, 0, NULL, 0, 1, 1, 0, 4, 0, 0, 0, 0, ATP_TTDP_OILRIG, APC_HELIPORT, STR_NULL, 0, false),
 };
 
 assert_compile(NEW_AIRPORT_OFFSET == lengthof(_origin_airport_specs));
 
-AirportSpec AirportSpec::dummy = AS_GENERIC(&_airportfta_dummy, NULL, _default_airports_rotation, 0, NULL, 0, 0, 0, 0, 0, MIN_YEAR, MIN_YEAR, 0, ATP_TTDP_LARGE, APC_BEGIN, STR_NULL, 0, false);
+AirportSpec AirportSpec::dummy = AS_GENERIC(&_airportfta_dummy, NULL, _default_airports_rotation, 0, NULL, 0, 0, 0, 0, 0, MIN_YEAR, MIN_YEAR, 0, 0, ATP_TTDP_LARGE, APC_BEGIN, STR_NULL, 0, false);
 
+#undef AS_C
 #undef AS
 #undef AS_ND
 #undef AS_GENERIC
diff -urNad openttd-1.3.2/src/table/airport_movement.h openttd-1.3.2-DC3.0RC3/src/table/airport_movement.h
--- openttd-1.3.2/src/table/airport_movement.h	2013-07-27 17:09:31.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/table/airport_movement.h	2013-11-22 05:49:07.000000000 +0100
@@ -18,10 +18,11 @@
  * Finite sTate mAchine --> FTA
  */
 struct AirportFTAbuildup {
-	byte position; ///< The position that an airplane is at.
-	byte heading;  ///< The current orders (eg. TAKEOFF, HANGAR, ENDLANDING, etc.).
-	uint64 block;  ///< The block this position is on on the airport (st->airport.flags).
-	byte next;     ///< Next position from this position.
+	uint16 position; ///< The position that an airplane is at.
+	byte heading;    ///< The current orders (eg. TAKEOFF, HANGAR, ENDLANDING, etc.).
+	uint64 block;    ///< The block this position is on on the airport (st->airport.flags).
+  uint64 block2;   ///< The block this position is on on the airport (st->airport.flags2).
+	byte next;       ///< Next position from this position.
 };
 
 ///////////////////////////////////////////////////////////////////////
@@ -316,6 +317,263 @@
 	AMD(  197,  168, AMED_NOSPDCLAMP | AMED_SLOWTURN, DIR_N ), // 76 Fly to landing position in air1
 };
 
+//** Intercontinental 2 */
+static const AirportMovingData _airport_moving_data_intercontinental2[] = {
+	AMD(   8,    21, AMED_EXACTPOS,                   DIR_SE), // 00 In Hangar
+	AMD(   184,  21, AMED_EXACTPOS,                   DIR_SE), // 01 In Hangar2
+	AMD(   8,    38, 0,                               DIR_N),  // 02 Taxi outside depot
+	AMD(   184,  38, 0,                               DIR_N),  // 03 Taxi outside depot2
+	AMD(   24,   22, AMED_EXACTPOS,                   DIR_NW), // 04 Terminal 1
+	AMD(   40,   22, AMED_EXACTPOS,                   DIR_NW), // 05 Terminal 2
+	AMD(   56,   22, AMED_EXACTPOS,                   DIR_NW), // 06 Terminal 3
+	AMD(   72,   22, AMED_EXACTPOS,                   DIR_NW), // 07 Terminal 4
+	AMD(   120,  22, AMED_EXACTPOS,                   DIR_NW), // 08 Terminal 5
+	AMD(   136,  22, AMED_EXACTPOS,                   DIR_NW), // 09 Terminal 6
+	AMD(   152,  22, AMED_EXACTPOS,                   DIR_NW), // 10 Terminal 7
+	AMD(   168,  22, AMED_EXACTPOS,                   DIR_NW), // 11 Terminal 8
+	AMD(   24,   38, 0,                               DIR_N ), // 12 taxi 1
+	AMD(   40,   38, 0,                               DIR_N ), // 13 taxi 2
+	AMD(   56,   38, 0,                               DIR_N ), // 14 taxi 3
+	AMD(   72,   38, 0,                               DIR_N ), // 15 taxi 4
+	AMD(   120,  38, 0,                               DIR_N ), // 16 taxi 5
+	AMD(   136,  38, 0,                               DIR_N ), // 17 taxi 6
+	AMD(   152,  38, 0,                               DIR_N ), // 18 taxi 7
+	AMD(   168,  38, 0,                               DIR_N ), // 19 taxi 8
+	AMD(   184,  54, 0,                               DIR_N ), // 20 pre-Fly or Gate?
+	AMD(   184,  70, 0,                               DIR_N ), // 21 Fly or Gate?
+	AMD(   168,  70, 0,                               DIR_N ), // 22 Answer: Gate
+	AMD(   152,  70, 0,                               DIR_N ), // 23 Terminal 7,8 Free?
+	AMD(   120,  70, 0,                               DIR_N ), // 24 Terminal 5,6 Free?
+	AMD(   72,   70, 0,                               DIR_N ), // 25 Terminal 4 Free?
+	AMD(   40,   70, 0,                               DIR_N ), // 26 Terminal 2,3 Free? or DEPO?
+	AMD(   8,    70, 0,                               DIR_N ), // 27 pre-pre-outside depot
+	AMD(   8,    54, 0,                               DIR_N ), // 28 pre-outside depo
+	AMD(   88,   38, 0,                               DIR_N ), // 29 taxi helipad 1
+	AMD(   104,  38, 0,                               DIR_N ), // 30 taxi helipad 2
+	AMD(   184,  86, 0,                               DIR_N ), // 31 Answer: Fly
+	AMD(   184,  102,0,                               DIR_N ), // 32 pre-runway 1 or 2 out crossing
+	AMD(   184,  118,0,                               DIR_N ), // 33 runway 1 or 2 out crossing
+	AMD(   184,  134,0,                               DIR_N ), // 34 taxi near runway 1
+	AMD(   168,  118,0,                               DIR_N ), // 35 taxi near runway 2
+	AMD(   8,    118,0,                               DIR_N ), // 36 after land runway 1b (pre-crossing)
+	AMD(   24,   102,0,                               DIR_N ), // 37 after land runway 2b (pre-crossing)
+	AMD(   8,    102,0,                               DIR_N ), // 38 after land crossing
+	AMD(   8,    86, 0,                               DIR_N ), // 39 after crossing - enter airport
+	AMD(   184,  150,AMED_EXACTPOS,                   DIR_NE), // 40 taxi to end position
+	AMD(   88,   150,AMED_NOSPDCLAMP,                 DIR_N ), // 41 runway end
+	AMD(  -2,    150,AMED_NOSPDCLAMP | AMED_TAKEOFF,  DIR_N ), // 42 takeoff
+	AMD(   156,  118,AMED_EXACTPOS,                   DIR_NE), // 43 taxi to end position 2
+	AMD(   56,   118,AMED_NOSPDCLAMP,                 DIR_N ), // 44 runway end 2
+	AMD(  -34,   118,AMED_NOSPDCLAMP | AMED_TAKEOFF,  DIR_N ), // 45 takeoff 2
+	AMD(   88,   24, AMED_EXACTPOS,                   DIR_NE), // 46 Helipad 1
+	AMD(  104,   24, AMED_EXACTPOS,                   DIR_NE), // 47 Helipad 2
+	AMD(  224,   134,AMED_NOSPDCLAMP | AMED_SLOWTURN, DIR_N ), // 48 Fly to landing position in air 1
+	AMD(  104,   134,AMED_NOSPDCLAMP | AMED_LAND,     DIR_N ), // 49 Going down for land 1
+	AMD(    8,   134,AMED_NOSPDCLAMP | AMED_BRAKE,    DIR_N ), // 50 brake until end 1
+	AMD(  256,   102,AMED_NOSPDCLAMP | AMED_SLOWTURN, DIR_N ), // 51 Fly to landing position in air 2
+ 	AMD(  136,   102,AMED_NOSPDCLAMP | AMED_LAND,     DIR_N ), // 52 Going down for land 2
+	AMD(   40,   102,AMED_NOSPDCLAMP | AMED_BRAKE,    DIR_N ), // 53 brake until end 2
+	AMD(  136,   280,AMED_NOSPDCLAMP | AMED_SLOWTURN, DIR_N ), // 54 fly around
+	AMD(  500,   300,AMED_NOSPDCLAMP | AMED_SLOWTURN, DIR_N ), // 55 fly around
+ 	AMD(  104,  -40, AMED_NOSPDCLAMP | AMED_SLOWTURN, DIR_N ), // 56 fly around
+	AMD(  500,  -60, AMED_NOSPDCLAMP | AMED_SLOWTURN, DIR_N ), // 57 fly around
+	AMD(  104,   70, 0,                               DIR_N ), // 58 taxi
+	AMD(   88,   70, 0,                               DIR_N ), // 59 taxi
+	AMD(   88,   24, AMED_EXACTPOS,                   DIR_SE), // 60 pre-helitakeoff helipad 1
+	AMD(  104,   24, AMED_EXACTPOS,                   DIR_SE), // 61 pre-helitakeoff helipad 2
+	AMD(   80,   24, AMED_HELI_RAISE,                 DIR_N ), // 62 Takeoff Helipad1
+	AMD(   96,   24, AMED_HELI_RAISE,                 DIR_N ), // 63 Takeoff Helipad2
+	AMD(   80,   24, AMED_HELI_LOWER,                 DIR_N ), // 64 Land at Helipad1
+	AMD(   96,   24, AMED_HELI_LOWER,                 DIR_N ), // 65 Land at Helipad2
+	AMD(  140,    0, AMED_NOSPDCLAMP | AMED_SLOWTURN, DIR_N ), // 66 Bufferspace before helipad
+	AMD(  140,    0, AMED_NOSPDCLAMP | AMED_SLOWTURN, DIR_N ), // 67 Bufferspace before helipad
+	AMD(   80,   24, AMED_NOSPDCLAMP | AMED_SLOWTURN, DIR_N ), // 68 Get in position for Helipad1
+	AMD(   96,   24, AMED_NOSPDCLAMP | AMED_SLOWTURN, DIR_N ), // 69 Get in position for Helipad2
+	AMD(   88,   70, AMED_HELI_RAISE,                 DIR_N ), // 70 Takeoff from taxi
+	AMD(  520,   80, AMED_NOSPDCLAMP | AMED_SLOWTURN, DIR_N ), // 71 fly around
+	AMD(  520,  160, AMED_NOSPDCLAMP | AMED_SLOWTURN, DIR_N ), // 72 fly around
+	AMD(  192,   38, AMED_NOSPDCLAMP | AMED_SLOWTURN, DIR_N ), // 73 Go to position for Hangarentrance in air
+	AMD(  192,   38, AMED_HELI_LOWER,                 DIR_N ), // 74 Land in front of hangar
+};
+
+static const AirportMovingData _airport_moving_data_circle[] = {
+	AMD(  104,  104, AMED_EXACTPOS,                       DIR_SW ),  // 00 In Hangar 1
+	AMD(  104,  136, AMED_EXACTPOS,                       DIR_NW ),  // 01 In Hangar 2
+	AMD(  136,  104, AMED_EXACTPOS,                       DIR_SE ),  // 02 In Hangar 3
+	AMD(  136,  136, AMED_EXACTPOS,                       DIR_NE ),  // 03 In Hangar 4
+	AMD(  120,  104, 0,                                   DIR_N  ),  // 04 Taxi outside depot 1
+	AMD(  104,  120, 0,                                   DIR_N  ),  // 05 Taxi outside depot 2
+	AMD(  136,  120, 0,                                   DIR_N  ),  // 06 Taxi outside depot 3
+	AMD(  120,  136, 0,                                   DIR_N  ),  // 07 Taxi outside depot 4
+	AMD(   72,  168, AMED_EXACTPOS,                       DIR_W  ),  // 08 Terminal 1
+	AMD(   72,  152, AMED_EXACTPOS,                       DIR_SW ),  // 09 Terminal 2
+	AMD(   72,  136, AMED_EXACTPOS,                       DIR_S  ),  // 10 Terminal 3
+	AMD(   72,  104, AMED_EXACTPOS,                       DIR_W  ),  // 11 Terminal 4
+	AMD(   72,   88, AMED_EXACTPOS,                       DIR_SW ),  // 12 Terminal 5
+	AMD(   72,   72, AMED_EXACTPOS,                       DIR_S  ),  // 13 Terminal 6
+	AMD(   88,   72, AMED_EXACTPOS,                       DIR_SE ),  // 14 Terminal 7
+	AMD(  104,   72, AMED_EXACTPOS,                       DIR_E  ),  // 15 Terminal 8
+	AMD(  136,   72, AMED_EXACTPOS,                       DIR_S  ),  // 16 Terminal 9
+	AMD(  152,   72, AMED_EXACTPOS,                       DIR_SE ),  // 17 Terminal 10
+	AMD(  168,   72, AMED_EXACTPOS,                       DIR_E  ),  // 18 Terminal 11
+	AMD(  168,   86, AMED_EXACTPOS,                       DIR_NE ),  // 19 Terminal 12
+	AMD(  168,  104, AMED_EXACTPOS,                       DIR_N  ),  // 20 Terminal 13
+	AMD(  168,  136, AMED_EXACTPOS,                       DIR_E  ),  // 21 Terminal 14
+	AMD(  168,  152, AMED_EXACTPOS,                       DIR_NE ),  // 22 Terminal 15
+	AMD(  168,  168, AMED_EXACTPOS,                       DIR_N  ),  // 23 Terminal 16
+	AMD(  152,  168, AMED_EXACTPOS,                       DIR_NW ),  // 24 Terminal 17
+	AMD(  136,  168, AMED_EXACTPOS,                       DIR_W  ),  // 25 Terminal 18
+	AMD(  104,  168, AMED_EXACTPOS,                       DIR_N  ),  // 26 Terminal 19
+	AMD(   88,  168, AMED_EXACTPOS,                       DIR_NW ),  // 27 Terminal 20
+	AMD(   72,  184, 0,                                   DIR_N  ),  // 28 taxi 1a
+	AMD(   56,  168, 0,                                   DIR_N  ),  // 29 taxi 1b
+	AMD(   56,  152, 0,                                   DIR_N  ),  // 30 taxi 2
+	AMD(   56,  136, 0,                                   DIR_N  ),  // 31 taxi 3a
+	AMD(   72,  120, 0,                                   DIR_N  ),  // 32 taxi 3b4b
+	AMD(   56,  104, 0,                                   DIR_N  ),  // 33 taxi 4a
+	AMD(   56,   88, 0,                                   DIR_N  ),  // 34 taxi 5
+	AMD(   56,   72, 0,                                   DIR_N  ),  // 35 taxi 6a
+	AMD(   72,   56, 0,                                   DIR_N  ),  // 36 taxi 6b
+	AMD(   88,   56, 0,                                   DIR_N  ),  // 37 taxi 7
+	AMD(  104,   56, 0,                                   DIR_N  ),  // 38 taxi 8a
+	AMD(  120,   72, 0,                                   DIR_N  ),  // 39 taxi 8b9b
+	AMD(  136,   56, 0,                                   DIR_N  ),  // 40 taxi 9a
+	AMD(  152,   56, 0,                                   DIR_N  ),  // 41 taxi 10
+	AMD(  168,   56, 0,                                   DIR_N  ),  // 42 taxi 11a
+	AMD(  184,   72, 0,                                   DIR_N  ),  // 43 taxi 11b
+	AMD(  184,   88, 0,                                   DIR_N  ),  // 44 taxi 12
+	AMD(  184,  104, 0,                                   DIR_N  ),  // 45 taxi 13a
+	AMD(  168,  120, 0,                                   DIR_N  ),  // 46 taxi 13b14b
+	AMD(  184,  136, 0,                                   DIR_N  ),  // 47 taxi 14a
+	AMD(  184,  152, 0,                                   DIR_N  ),  // 48 taxi 15
+	AMD(  184,  168, 0,                                   DIR_N  ),  // 49 taxi 16a
+	AMD(  168,  184, 0,                                   DIR_N  ),  // 50 taxi 16b
+	AMD(  152,  184, 0,                                   DIR_N  ),  // 51 taxi 17
+	AMD(  136,  184, 0,                                   DIR_N  ),  // 52 taxi 18a
+	AMD(  120,  168, 0,                                   DIR_N  ),  // 53 taxi 18b19b
+	AMD(  104,  184, 0,                                   DIR_N  ),  // 54 taxi 19a
+	AMD(   88,  184, 0,                                   DIR_N  ),  // 55 taxi 20
+	AMD(   56,  184, 0,                                   DIR_N  ),  // 56 taxi 1a to 1b
+	AMD(   56,  120, 0,                                   DIR_N  ),  // 57 taxi 3a to 4a x 3b4b
+	AMD(   56,   56, 0,                                   DIR_N  ),  // 58 taxi 6a to 6b
+	AMD(  120,   56, 0,                                   DIR_N  ),  // 59 taxi 8a to 9a x 8b9b
+	AMD(  184,   56, 0,                                   DIR_N  ),  // 60 taxi 11a to 11b
+	AMD(  184,  120, 0,                                   DIR_N  ),  // 61 taxi 13a to 14a x 13b14b
+	AMD(  184,  184, 0,                                   DIR_N  ),  // 62 taxi 16a to 16b
+	AMD(  120,  184, 0,                                   DIR_N  ),  // 63 taxi 18a to 19a x 18b19b
+	AMD(   40,  176, 0,                                   DIR_N  ),  // 64 taxi to 1a->1b part 1
+	AMD(   48,  184, 0,                                   DIR_N  ),  // 65 taxi to 1a->1b part 2
+	AMD(   40,  152, 0,                                   DIR_N  ),  // 66 taxi to 2
+	AMD(   48,  120, 0,                                   DIR_N  ),  // 67 taxi from 3a->4a to takeoff part 1
+	AMD(   40,  128, 0,                                   DIR_N  ),  // 68 taxi from 3a->4a to takeoff part 2
+	AMD(   32,  136, 0,                                   DIR_N  ),  // 69 taxi from 3a->4a to takeoff part 3
+	AMD(   48,   88, 0,                                   DIR_N  ),  // 70 taxi from 5 to takeoff part 1
+	AMD(   40,   96, 0,                                   DIR_N  ),  // 71 taxi from 5 to takeoff part 2
+	AMD(   48,   56, 0,                                   DIR_N  ),  // 72 taxi from 6a->6b to takeoff part 1
+	AMD(   40,   64, 0,                                   DIR_N  ),  // 73 taxi from 6a->6b to takeoff part 2
+	AMD(   64,   40, 0,                                   DIR_N  ),  // 74 taxi to 6a->6b part 1
+	AMD(   56,   48, 0,                                   DIR_N  ),  // 75 taxi to 6a->6b part 2
+	AMD(   88,   40, 0,                                   DIR_N  ),  // 76 taxi to 7
+	AMD(  120,   48, 0,                                   DIR_N  ),  // 77 taxi from 8a->9a to takeoff part 1
+	AMD(  112,   40, 0,                                   DIR_N  ),  // 78 taxi from 8a->9a to takeoff part 2
+	AMD(  104,   32, 0,                                   DIR_N  ),  // 79 taxi from 8a->9a to takeoff part 3
+	AMD(  152,   48, 0,                                   DIR_N  ),  // 80 taxi from 10 to takeoff part 1
+	AMD(  144,   40, 0,                                   DIR_N  ),  // 81 taxi from 10 to takeoff part 2
+	AMD(  184,   48, 0,                                   DIR_N  ),  // 82 taxi from 11a->11b to takeoff part 1
+	AMD(  176,   40, 0,                                   DIR_N  ),  // 83 taxi from 11a->11b to takeoff part 2
+	AMD(  200,   64, 0,                                   DIR_N  ),  // 84 taxi to 11a->11b part 1
+	AMD(  192,   56, 0,                                   DIR_N  ),  // 85 taxi to 11a->11b part 2
+	AMD(  200,   88, 0,                                   DIR_N  ),  // 86 taxi to 12
+	AMD(  192,  120, 0,                                   DIR_N  ),  // 87 taxi from 13a->14a to takeoff part 1
+	AMD(  200,  112, 0,                                   DIR_N  ),  // 88 taxi from 13a->14a to takeoff part 2
+	AMD(  208,  104, 0,                                   DIR_N  ),  // 89 taxi from 13a->14a to takeoff part 3
+	AMD(  192,  152, 0,                                   DIR_N  ),  // 90 taxi from 15 to takeoff part 1
+	AMD(  200,  144, 0,                                   DIR_N  ),  // 91 taxi from 15 to takeoff part 2
+	AMD(  192,  184, 0,                                   DIR_N  ),  // 92 taxi from 16a->16b to takeoff part 1
+	AMD(  200,  176, 0,                                   DIR_N  ),  // 93 taxi from 16a->16b to takeoff part 2
+	AMD(  176,  200, 0,                                   DIR_N  ),  // 94 taxi to 16a->16b part 1
+	AMD(  184,  192, 0,                                   DIR_N  ),  // 95 taxi to 16a->16b part 2
+	AMD(  152,  200, 0,                                   DIR_N  ),  // 96 taxi to 17
+	AMD(  120,  192, 0,                                   DIR_N  ),  // 97 taxi from 18a->19a to takeoff part 1
+	AMD(  128,  200, 0,                                   DIR_N  ),  // 98 taxi from 18a->19a to takeoff part 2
+	AMD(  136,  208, 0,                                   DIR_N  ),  // 99 taxi from 18a->19a to takeoff part 3
+	AMD(   88,  192, 0,                                   DIR_N  ),  // 100 taxi from 20 to takeoff part 1
+	AMD(   96,  200, 0,                                   DIR_N  ),  // 101 taxi from 20 to takeoff part 2
+	AMD(   56,  192, 0,                                   DIR_N  ),  // 102 taxi from 1a->1b to takeoff part 1
+	AMD(   64,  200, 0,                                   DIR_N  ),  // 103 taxi from 1a->1b to takeoff part 2
+	AMD(   24,   80, 0,                                   DIR_N  ),  // 104 pre takeoff n1
+	AMD(   24,   86, 0,                                   DIR_N  ),  // 105 pre takeoff n2p
+	AMD(   24,  112, 0,                                   DIR_N  ),  // 106 pre takeoff n3
+	AMD(   24,  118, 0,                                   DIR_N  ),  // 107 pre takeoff n4p
+	AMD(   24,  136, 0,                                   DIR_N  ),  // 108 pre takeoff n5p
+	AMD(   16,  152, 0,                                   DIR_N  ),  // 109 afterland n6
+	AMD(   24,  152, 0,                                   DIR_N  ),  // 110 afterland n7ap
+	AMD(   24,  160, 0,                                   DIR_N  ),  // 111 afterland n7bp
+	AMD(  160,   24, 0,                                   DIR_N  ),  // 112 pre takeoff w1
+	AMD(  154,   24, 0,                                   DIR_N  ),  // 113 pre takeoff w2p
+	AMD(  128,   24, 0,                                   DIR_N  ),  // 114 pre takeoff w3
+	AMD(  122,   24, 0,                                   DIR_N  ),  // 115 pre takeoff w4p
+	AMD(  104,   24, 0,                                   DIR_N  ),  // 116 pre takeoff w5p
+	AMD(   88,   16, 0,                                   DIR_N  ),  // 117 afterland w6
+	AMD(   88,   24, 0,                                   DIR_N  ),  // 118 afterland w7ap
+	AMD(   80,   24, 0,                                   DIR_N  ),  // 119 afterland w7bp
+	AMD(  216,  160, 0,                                   DIR_N  ),  // 120 pre takeoff s1
+	AMD(  216,  154, 0,                                   DIR_N  ),  // 121 pre takeoff s2p
+	AMD(  216,  128, 0,                                   DIR_N  ),  // 122 pre takeoff s3
+	AMD(  216,  122, 0,                                   DIR_N  ),  // 123 pre takeoff s4p
+	AMD(  216,  104, 0,                                   DIR_N  ),  // 124 pre takeoff s5p
+	AMD(  224,   88, 0,                                   DIR_N  ),  // 125 afterland s6
+	AMD(  216,   88, 0,                                   DIR_N  ),  // 126 afterland s7ap
+	AMD(  216,   80, 0,                                   DIR_N  ),  // 127 afterland s7bp
+	AMD(   80,  216, 0,                                   DIR_N  ),  // 128 pre takeoff e1
+	AMD(   86,  216, 0,                                   DIR_N  ),  // 129 pre takeoff e2p
+	AMD(  112,  216, 0,                                   DIR_N  ),  // 130 pre takeoff e3
+	AMD(  118,  216, 0,                                   DIR_N  ),  // 131 pre takeoff e4p
+	AMD(  136,  216, 0,                                   DIR_N  ),  // 132 pre takeoff e5p
+	AMD(  152,  224, 0,                                   DIR_N  ),  // 133 afterland e6
+	AMD(  152,  216, 0,                                   DIR_N  ),  // 134 afterland e7ap
+	AMD(  160,  216, 0,                                   DIR_N  ),  // 135 afterland e7bp
+	AMD(    8,  136, AMED_EXACTPOS,                       DIR_NW ),  // 136 Taxi to start of runway 1b
+	AMD(    8,   56, AMED_NOSPDCLAMP,                     DIR_N  ),  // 137 Accelerate to end of runway 1b
+	AMD(    8,  -26, AMED_NOSPDCLAMP | AMED_TAKEOFF,      DIR_N  ),  // 138 Take off 1b
+	AMD(  104,    8, AMED_EXACTPOS,                       DIR_SW ),  // 139 Taxi to start of runway 2b
+	AMD(  182,    8, AMED_NOSPDCLAMP,                     DIR_N  ),  // 140 Accelerate to end of runway 2b
+	AMD(  264,    8, AMED_NOSPDCLAMP | AMED_TAKEOFF,      DIR_N  ),  // 141 Take off 2b
+	AMD(  232,  104, AMED_EXACTPOS,                       DIR_SE ),  // 142 Taxi to start of runway 3b
+	AMD(  232,  182, AMED_NOSPDCLAMP,                     DIR_N  ),  // 143 Accelerate to end of runway 3b
+	AMD(  232,  264, AMED_NOSPDCLAMP | AMED_TAKEOFF,      DIR_N  ),  // 144 Take off 3b
+	AMD(  136,  232, AMED_EXACTPOS,                       DIR_NE ),  // 145 Taxi to start of runway 4b
+	AMD(   56,  232, AMED_NOSPDCLAMP,                     DIR_N  ),  // 146 Accelerate to end of runway 4b
+	AMD(  -26,  232, AMED_NOSPDCLAMP | AMED_TAKEOFF,      DIR_N  ),  // 147 Take off 4b
+	AMD(    8,  352, AMED_NOSPDCLAMP | AMED_SLOWTURN,     DIR_N  ),  // 148 Fly to landing position in air 1a
+	AMD(    8,  232, AMED_NOSPDCLAMP | AMED_LAND,         DIR_N  ),  // 149 Going down for land 1a
+	AMD(    8,  152, AMED_NOSPDCLAMP | AMED_BRAKE,        DIR_N  ),  // 150 Brake until end of runway 1a
+	AMD( -112,    8, AMED_NOSPDCLAMP | AMED_SLOWTURN,     DIR_N  ),  // 151 Fly to landing position in air 2a
+	AMD(    8,    8, AMED_NOSPDCLAMP | AMED_LAND,         DIR_N  ),  // 152 Going down for land 2a
+	AMD(   88,    8, AMED_NOSPDCLAMP | AMED_BRAKE,        DIR_N  ),  // 153 Brake until end of runway 2a
+	AMD(  232, -112, AMED_NOSPDCLAMP | AMED_SLOWTURN,     DIR_N  ),  // 154 Fly to landing position in air 3a
+	AMD(  232,    8, AMED_NOSPDCLAMP | AMED_LAND,         DIR_N  ),  // 155 Going down for land 3a
+	AMD(  232,   88, AMED_NOSPDCLAMP | AMED_BRAKE,        DIR_N  ),  // 156 Brake until end of runway 3a
+	AMD(  352,  232, AMED_NOSPDCLAMP | AMED_SLOWTURN,     DIR_N  ),  // 157 Fly to landing position in air 4a
+	AMD(  232,  232, AMED_NOSPDCLAMP | AMED_LAND,         DIR_N  ),  // 158 Going down for land 4a
+	AMD(  152,  232, AMED_NOSPDCLAMP | AMED_BRAKE,        DIR_N  ),  // 159 Brake until end of runway 4a
+	AMD(   72,  468, AMED_NOSPDCLAMP | AMED_SLOWTURN,     DIR_N  ),  // 160 fly around
+	AMD( -228,   72, AMED_NOSPDCLAMP | AMED_SLOWTURN,     DIR_N  ),  // 161 fly around
+ 	AMD(  168, -228, AMED_NOSPDCLAMP | AMED_SLOWTURN,     DIR_N  ),  // 162 fly around
+	AMD(  468,  168, AMED_NOSPDCLAMP | AMED_SLOWTURN,     DIR_N  ),  // 163 fly around
+	AMD(   40,   40, AMED_EXACTPOS,                       DIR_SE ),  // 164 pre-helitakeoff spot 1
+	AMD(   40,   40, AMED_HELI_RAISE,                     DIR_N  ),  // 165 helitakeoff spot 1
+ 	AMD(  200,  200, AMED_EXACTPOS,                       DIR_SE ),  // 166 pre-helitakeoff spot 2
+	AMD(  200,  200, AMED_HELI_RAISE,                     DIR_N  ),  // 167 helitakeoff spot 2
+	AMD(   40,  200, AMED_EXACTPOS,                       DIR_SE ),  // 168 pre-helitakeoff spot 3l
+	AMD(   40,  200, AMED_HELI_RAISE,                     DIR_N  ),  // 169 helitakeoff spot 3l
+ 	AMD(  200,   40, AMED_EXACTPOS,                       DIR_SE ),  // 170 pre-helitakeoff spot 4l
+	AMD(  200,   40, AMED_HELI_RAISE,                     DIR_N  ),  // 171 helitakeoff spot 4l
+	AMD(   40,  192, AMED_NOSPDCLAMP | AMED_SLOWTURN,     DIR_N  ),  // 172 Go to position spot 3l
+	AMD(   40,  192, AMED_HELI_LOWER,                     DIR_N  ),  // 173 Land in spot 3l
+	AMD(  200,   48, AMED_NOSPDCLAMP | AMED_SLOWTURN,     DIR_N  ),  // 174 Go to position spot 4l
+	AMD(  200,   48, AMED_HELI_LOWER,                     DIR_N  ),  // 175 Land in spot 4l
+};
 
 /** Heliport (heliport). */
 static const AirportMovingData _airport_moving_data_heliport[9] = {
@@ -408,11 +666,11 @@
 /////**********Movement Machine on Airports*********************///////
 static const byte _airport_entries_dummy[] = {0, 1, 2, 3};
 static const AirportFTAbuildup _airport_fta_dummy[] = {
-	{ 0, 0, 0, 3},
-	{ 1, 0, 0, 0},
-	{ 2, 0, 0, 1},
-	{ 3, 0, 0, 2},
-	{ MAX_ELEMENTS, 0, 0, 0 } // end marker. DO NOT REMOVE
+  { 0, 0, 0, 0, 3},
+  { 1, 0, 0, 0, 0},
+  { 2, 0, 0, 0, 1},
+  { 3, 0, 0, 0, 2},
+	{ MAX_ELEMENTS, 0, 0, 0, 0 } // end marker. DO NOT REMOVE
 };
 
 /* First element of terminals array tells us how many depots there are (to know size of array)
@@ -421,226 +679,226 @@
 static const byte _airport_terminal_country[] = {1, 2};
 static const byte _airport_entries_country[] = {16, 15, 18, 17};
 static const AirportFTAbuildup _airport_fta_country[] = {
-	{  0, HANGAR, NOTHING_block, 1 },
-	{  1, 255, AIRPORT_BUSY_block, 0 }, { 1, HANGAR, 0, 0 }, { 1, TERM1, TERM1_block, 2 }, { 1, TERM2, 0, 4 }, { 1, HELITAKEOFF, 0, 19 }, { 1, 0, 0, 6 },
-	{  2, TERM1, TERM1_block, 1 },
-	{  3, TERM2, TERM2_block, 5 },
-	{  4, 255, AIRPORT_BUSY_block, 0 }, { 4, TERM2, 0, 5 }, { 4, HANGAR, 0, 1 }, { 4, TAKEOFF, 0, 6 }, { 4, HELITAKEOFF, 0, 1 },
-	{  5, 255, AIRPORT_BUSY_block, 0 }, { 5, TERM2, TERM2_block, 3 }, { 5, 0, 0, 4 },
-	{  6, 0, AIRPORT_BUSY_block, 7 },
+ 	{  0, HANGAR, NOTHING_block, 0, 1 },
+	{  1, 255, AIRPORT_BUSY_block, 0, 0 }, { 1, HANGAR, 0, 0, 0 }, { 1, TERM1, TERM1_block, 0, 2 }, { 1, TERM2, 0, 0, 4 }, { 1, HELITAKEOFF, 0, 0, 19 }, { 1, 0, 0, 0, 6 },
+	{  2, TERM1, TERM1_block, 0, 1 },
+	{  3, TERM2, TERM2_block, 0, 5 },
+	{  4, 255, AIRPORT_BUSY_block, 0, 0 }, { 4, TERM2, 0, 0, 5 }, { 4, HANGAR, 0, 0, 1 }, { 4, TAKEOFF, 0, 0, 6 }, { 4, HELITAKEOFF, 0, 0, 1 },
+	{  5, 255, AIRPORT_BUSY_block, 0, 0 }, { 5, TERM2, TERM2_block, 0, 3 }, { 5, 0, 0, 0, 4 },
+	{  6, 0, AIRPORT_BUSY_block, 0, 7 },
 	/* takeoff */
-	{  7, TAKEOFF, AIRPORT_BUSY_block, 8 },
-	{  8, STARTTAKEOFF, NOTHING_block, 9 },
-	{  9, ENDTAKEOFF, NOTHING_block, 0 },
+	{  7, TAKEOFF, AIRPORT_BUSY_block, 0, 8 },
+	{  8, STARTTAKEOFF, NOTHING_block, 0, 9 },
+	{  9, ENDTAKEOFF, NOTHING_block, 0, 0 },
 	/* landing */
-	{ 10, FLYING, NOTHING_block, 15 }, { 10, LANDING, 0, 11 }, { 10, HELILANDING, 0, 20 },
-	{ 11, LANDING, AIRPORT_BUSY_block, 12 },
-	{ 12, 0, AIRPORT_BUSY_block, 13 },
-	{ 13, ENDLANDING, AIRPORT_BUSY_block, 14 }, { 13, TERM2, 0, 5 }, { 13, 0, 0, 14 },
-	{ 14, 0, AIRPORT_BUSY_block, 1 },
+	{ 10, FLYING, NOTHING_block, 0, 15 }, { 10, LANDING, 0, 0, 11 }, { 10, HELILANDING, 0, 0, 20 },
+	{ 11, LANDING, AIRPORT_BUSY_block, 0, 12 },
+	{ 12, 0, AIRPORT_BUSY_block, 0, 13 },
+	{ 13, ENDLANDING, AIRPORT_BUSY_block, 0, 14 }, { 13, TERM2, 0, 0, 5 }, { 13, 0, 0, 0, 14 },
+	{ 14, 0, AIRPORT_BUSY_block, 0, 1 },
 	/* In air */
-	{ 15, 0, NOTHING_block, 16 },
-	{ 16, 0, NOTHING_block, 17 },
-	{ 17, 0, NOTHING_block, 18 },
-	{ 18, 0, NOTHING_block, 10 },
-	{ 19, HELITAKEOFF, NOTHING_block, 0 },
-	{ 20, HELILANDING, AIRPORT_BUSY_block, 21 },
-	{ 21, HELIENDLANDING, AIRPORT_BUSY_block, 1 },
-	{ MAX_ELEMENTS, 0, 0, 0 } // end marker. DO NOT REMOVE
+	{ 15, 0, NOTHING_block, 0, 16 },
+	{ 16, 0, NOTHING_block, 0, 17 },
+	{ 17, 0, NOTHING_block, 0, 18 },
+	{ 18, 0, NOTHING_block, 0, 10 },
+	{ 19, HELITAKEOFF, NOTHING_block, 0, 0 },
+	{ 20, HELILANDING, AIRPORT_BUSY_block, 0, 21 },
+	{ 21, HELIENDLANDING, AIRPORT_BUSY_block, 0, 1 },
+	{ MAX_ELEMENTS, 0, 0, 0, 0 } // end marker. DO NOT REMOVE
 };
 
 static const HangarTileTable _airport_depots_commuter[] = { {{4, 0}, DIR_SE, 0} };
 static const byte _airport_terminal_commuter[] = { 1, 3 };
 static const byte _airport_entries_commuter[] = {22, 21, 24, 23};
 static const AirportFTAbuildup _airport_fta_commuter[] = {
-	{  0, HANGAR, NOTHING_block, 1 }, { 0, HELITAKEOFF, HELIPAD2_block, 1 }, { 0, 0, 0, 1 },
-	{  1, 255, TAXIWAY_BUSY_block, 0 }, { 1, HANGAR, 0, 0 }, { 1, TAKEOFF, 0, 11 }, { 1, TERM1, TAXIWAY_BUSY_block, 10 }, { 1, TERM2, TAXIWAY_BUSY_block, 10 }, { 1, TERM3, TAXIWAY_BUSY_block, 10 }, { 1, HELIPAD1, TAXIWAY_BUSY_block, 10 }, { 1, HELIPAD2, TAXIWAY_BUSY_block, 10 }, { 1, HELITAKEOFF, TAXIWAY_BUSY_block, 10 }, { 1, 0, 0, 0 },
-	{  2, 255, AIRPORT_ENTRANCE_block, 2 }, { 2, HANGAR, 0, 8 }, { 2, TERM1, 0, 8 }, { 2, TERM2, 0, 8 }, { 2, TERM3, 0, 8 }, { 2, HELIPAD1, 0, 8 }, { 2, HELIPAD2, 0, 8 }, { 2, HELITAKEOFF, 0, 8 }, { 2, 0, 0, 2 },
-	{  3, TERM1, TERM1_block, 8 }, { 3, HANGAR, 0, 8 }, { 3, TAKEOFF, 0, 8 }, { 3, 0, 0, 3 },
-	{  4, TERM2, TERM2_block, 9 }, { 4, HANGAR, 0, 9 }, { 4, TAKEOFF, 0, 9 }, { 4, 0, 0, 4 },
-	{  5, TERM3, TERM3_block, 10 }, { 5, HANGAR, 0, 10 }, { 5, TAKEOFF, 0, 10 }, { 5, 0, 0, 5 },
-	{  6, HELIPAD1, HELIPAD1_block, 6 }, { 6, HANGAR, TAXIWAY_BUSY_block, 9 }, { 6, HELITAKEOFF, 0, 35 },
-	{  7, HELIPAD2, HELIPAD2_block, 7 }, { 7, HANGAR, TAXIWAY_BUSY_block, 10 }, { 7, HELITAKEOFF, 0, 36 },
-	{  8, 255, TAXIWAY_BUSY_block, 8 }, { 8, TAKEOFF, TAXIWAY_BUSY_block, 9 }, { 8, HANGAR, TAXIWAY_BUSY_block, 9 }, { 8, TERM1, TERM1_block, 3 }, { 8, 0, TAXIWAY_BUSY_block, 9 },
-	{  9, 255, TAXIWAY_BUSY_block, 9 }, { 9, TAKEOFF, TAXIWAY_BUSY_block, 10 }, { 9, HANGAR, TAXIWAY_BUSY_block, 10 }, { 9, TERM2, TERM2_block, 4 }, { 9, HELIPAD1, HELIPAD1_block, 6 }, { 9, HELITAKEOFF, HELIPAD1_block, 6 }, { 9, TERM1, TAXIWAY_BUSY_block, 8 }, { 9, 0, TAXIWAY_BUSY_block, 10 },
-	{ 10, 255, TAXIWAY_BUSY_block, 10 }, { 10, TERM3, TERM3_block, 5 }, { 10, HELIPAD1, 0, 9 }, { 10, HELIPAD2, HELIPAD2_block, 7 }, { 10, HELITAKEOFF, HELIPAD2_block, 7 }, { 10, TAKEOFF, TAXIWAY_BUSY_block, 1 }, { 10, HANGAR, TAXIWAY_BUSY_block, 1 }, { 10, 0, TAXIWAY_BUSY_block, 9 },
-	{ 11, 0, OUT_WAY_block, 12 },
+	{  0, HANGAR, NOTHING_block, 0, 1 }, { 0, HELITAKEOFF, HELIPAD2_block, 0, 1 }, { 0, 0, 0, 0, 1 },
+	{  1, 255, TAXIWAY_BUSY_block, 0, 0 }, { 1, HANGAR, 0, 0, 0 }, { 1, TAKEOFF, 0, 0, 11 }, { 1, TERM1, TAXIWAY_BUSY_block, 0, 10 }, { 1, TERM2, TAXIWAY_BUSY_block, 0, 10 }, { 1, TERM3, TAXIWAY_BUSY_block, 0, 10 }, { 1, HELIPAD1, TAXIWAY_BUSY_block, 0, 10 }, { 1, HELIPAD2, TAXIWAY_BUSY_block, 0, 10 }, { 1, HELITAKEOFF, TAXIWAY_BUSY_block, 0, 10 }, { 1, 0, 0, 0, 0 },
+	{  2, 255, AIRPORT_ENTRANCE_block, 0, 2 }, { 2, HANGAR, 0, 0, 8 }, { 2, TERM1, 0, 0, 8 }, { 2, TERM2, 0, 0, 8 }, { 2, TERM3, 0, 0, 8 }, { 2, HELIPAD1, 0, 0, 8 }, { 2, HELIPAD2, 0, 0, 8 }, { 2, HELITAKEOFF, 0, 0, 8 }, { 2, 0, 0, 0, 2 },
+	{  3, TERM1, TERM1_block, 0, 8 }, { 3, HANGAR, 0, 0, 8 }, { 3, TAKEOFF, 0, 0, 8 }, { 3, 0, 0, 0, 3 },
+	{  4, TERM2, TERM2_block, 0, 9 }, { 4, HANGAR, 0, 0, 9 }, { 4, TAKEOFF, 0, 0, 9 }, { 4, 0, 0, 0, 4 },
+	{  5, TERM3, TERM3_block, 0, 10 }, { 5, HANGAR, 0, 0, 10 }, { 5, TAKEOFF, 0, 0, 10 }, { 5, 0, 0, 0, 5 },
+	{  6, HELIPAD1, HELIPAD1_block, 0, 6 }, { 6, HANGAR, TAXIWAY_BUSY_block, 0, 9 }, { 6, HELITAKEOFF, 0, 0, 35 },
+	{  7, HELIPAD2, HELIPAD2_block, 0, 7 }, { 7, HANGAR, TAXIWAY_BUSY_block, 0, 10 }, { 7, HELITAKEOFF, 0, 0, 36 },
+	{  8, 255, TAXIWAY_BUSY_block, 0, 8 }, { 8, TAKEOFF, TAXIWAY_BUSY_block, 0, 9 }, { 8, HANGAR, TAXIWAY_BUSY_block, 0, 9 }, { 8, TERM1, TERM1_block, 0, 3 }, { 8, 0, TAXIWAY_BUSY_block, 0, 9 },
+	{  9, 255, TAXIWAY_BUSY_block, 0, 9 }, { 9, TAKEOFF, TAXIWAY_BUSY_block, 0, 10 }, { 9, HANGAR, TAXIWAY_BUSY_block, 0, 10 }, { 9, TERM2, TERM2_block, 0, 4 }, { 9, HELIPAD1, HELIPAD1_block, 0, 6 }, { 9, HELITAKEOFF, HELIPAD1_block, 0, 6 }, { 9, TERM1, TAXIWAY_BUSY_block, 0, 8 }, { 9, 0, TAXIWAY_BUSY_block, 0, 10 },
+	{ 10, 255, TAXIWAY_BUSY_block, 0, 10 }, { 10, TERM3, TERM3_block, 0, 5 }, { 10, HELIPAD1, 0, 0, 9 }, { 10, HELIPAD2, HELIPAD2_block, 0, 7 }, { 10, HELITAKEOFF, HELIPAD2_block, 0, 7 }, { 10, TAKEOFF, TAXIWAY_BUSY_block, 0, 1 }, { 10, HANGAR, TAXIWAY_BUSY_block, 0, 1 }, { 10, 0, TAXIWAY_BUSY_block, 0, 9 },
+	{ 11, 0, OUT_WAY_block, 0, 12 },
 	/* takeoff */
-	{ 12, TAKEOFF, RUNWAY_IN_OUT_block, 13 },
-	{ 13, 0, RUNWAY_IN_OUT_block, 14 },
-	{ 14, STARTTAKEOFF, RUNWAY_IN_OUT_block, 15 },
-	{ 15, ENDTAKEOFF, NOTHING_block, 0 },
+	{ 12, TAKEOFF, RUNWAY_IN_OUT_block, 0, 13 },
+	{ 13, 0, RUNWAY_IN_OUT_block, 0, 14 },
+	{ 14, STARTTAKEOFF, RUNWAY_IN_OUT_block, 0, 15 },
+	{ 15, ENDTAKEOFF, NOTHING_block, 0, 0 },
 	/* landing */
-	{ 16, FLYING, NOTHING_block, 21 }, { 16, LANDING, IN_WAY_block, 17 }, { 16, HELILANDING, 0, 25 },
-	{ 17, LANDING, RUNWAY_IN_OUT_block, 18 },
-	{ 18, 0, RUNWAY_IN_OUT_block, 19 },
-	{ 19, 0, RUNWAY_IN_OUT_block, 20 },
-	{ 20, ENDLANDING, IN_WAY_block, 2 },
+	{ 16, FLYING, NOTHING_block, 0, 21 }, { 16, LANDING, IN_WAY_block, 0, 17 }, { 16, HELILANDING, 0, 0, 25 },
+	{ 17, LANDING, RUNWAY_IN_OUT_block, 0, 18 },
+	{ 18, 0, RUNWAY_IN_OUT_block, 0, 19 },
+	{ 19, 0, RUNWAY_IN_OUT_block, 0, 20 },
+	{ 20, ENDLANDING, IN_WAY_block, 0, 2 },
 	/* In Air */
-	{ 21, 0, NOTHING_block, 22 },
-	{ 22, 0, NOTHING_block, 23 },
-	{ 23, 0, NOTHING_block, 24 },
-	{ 24, 0, NOTHING_block, 16 },
+	{ 21, 0, NOTHING_block, 0, 22 },
+	{ 22, 0, NOTHING_block, 0, 23 },
+	{ 23, 0, NOTHING_block, 0, 24 },
+	{ 24, 0, NOTHING_block, 0, 16 },
 	/* Helicopter -- stay in air in special place as a buffer to choose from helipads */
-	{ 25, HELILANDING, PRE_HELIPAD_block, 26 },
-	{ 26, HELIENDLANDING, PRE_HELIPAD_block, 26 }, { 26, HELIPAD1, 0, 27 }, { 26, HELIPAD2, 0, 28 }, { 26, HANGAR, 0, 33 },
-	{ 27, 0, NOTHING_block, 29 }, // helipad1 approach
-	{ 28, 0, NOTHING_block, 30 },
+	{ 25, HELILANDING, PRE_HELIPAD_block, 0, 26 },
+	{ 26, HELIENDLANDING, PRE_HELIPAD_block, 0, 26 }, { 26, HELIPAD1, 0, 0, 27 }, { 26, HELIPAD2, 0, 0, 28 }, { 26, HANGAR, 0, 0, 33 },
+	{ 27, 0, NOTHING_block, 0, 29 }, // helipad1 approach
+	{ 28, 0, NOTHING_block, 0, 30 },
 	/* landing */
-	{ 29, 255, NOTHING_block, 0 }, { 29, HELIPAD1, HELIPAD1_block, 6 },
-	{ 30, 255, NOTHING_block, 0 }, { 30, HELIPAD2, HELIPAD2_block, 7 },
+	{ 29, 255, NOTHING_block, 0, 0 }, { 29, HELIPAD1, HELIPAD1_block, 0, 6 },
+	{ 30, 255, NOTHING_block, 0, 0 }, { 30, HELIPAD2, HELIPAD2_block, 0, 7 },
 	/* Helicopter -- takeoff */
-	{ 31, HELITAKEOFF, NOTHING_block, 0 },
-	{ 32, HELITAKEOFF, NOTHING_block, 0 },
-	{ 33, 0, TAXIWAY_BUSY_block, 34 }, // need to go to hangar when waiting in air
-	{ 34, 0, TAXIWAY_BUSY_block, 1 },
-	{ 35, 0, HELIPAD1_block, 31 },
-	{ 36, 0, HELIPAD2_block, 32 },
-	{ MAX_ELEMENTS, 0, 0, 0 } // end marker. DO NOT REMOVE
+	{ 31, HELITAKEOFF, NOTHING_block, 0, 0 },
+	{ 32, HELITAKEOFF, NOTHING_block, 0, 0 },
+	{ 33, 0, TAXIWAY_BUSY_block, 0, 34 }, // need to go to hangar when waiting in air
+	{ 34, 0, TAXIWAY_BUSY_block, 0, 1 },
+	{ 35, 0, HELIPAD1_block, 0, 31 },
+	{ 36, 0, HELIPAD2_block, 0, 32 },
+	{ MAX_ELEMENTS, 0, 0, 0, 0 } // end marker. DO NOT REMOVE
 };
 
 static const HangarTileTable _airport_depots_city[] = { {{5, 0}, DIR_SE, 0} };
 static const byte _airport_terminal_city[] = { 1, 3 };
 static const byte _airport_entries_city[] = {26, 29, 27, 28};
 static const AirportFTAbuildup _airport_fta_city[] = {
-	{  0, HANGAR, NOTHING_block, 1 }, { 0, TAKEOFF, OUT_WAY_block, 1 }, { 0, 0, 0, 1 },
-	{  1, 255, TAXIWAY_BUSY_block, 0 }, { 1, HANGAR, 0, 0 }, { 1, TERM2, 0, 6 }, { 1, TERM3, 0, 6 }, { 1, 0, 0, 7 }, // for all else, go to 7
-	{  2, TERM1, TERM1_block, 7 }, { 2, TAKEOFF, OUT_WAY_block, 7 }, { 2, 0, 0, 7 },
-	{  3, TERM2, TERM2_block, 5 }, { 3, TAKEOFF, OUT_WAY_block, 6 }, { 3, 0, 0, 6 },
-	{  4, TERM3, TERM3_block, 5 }, { 4, TAKEOFF, OUT_WAY_block, 5 }, { 4, 0, 0, 5 },
-	{  5, 255, TAXIWAY_BUSY_block, 0 }, { 5, TERM2, TERM2_block, 3 }, { 5, TERM3, TERM3_block, 4 }, { 5, 0, 0, 6 },
-	{  6, 255, TAXIWAY_BUSY_block, 0 }, { 6, TERM2, TERM2_block, 3 }, { 6, TERM3, 0, 5 }, { 6, HANGAR, 0, 1 }, { 6, 0, 0, 7 },
-	{  7, 255, TAXIWAY_BUSY_block, 0 }, { 7, TERM1, TERM1_block, 2 }, { 7, TAKEOFF, OUT_WAY_block, 8 }, { 7, HELITAKEOFF, 0, 22 }, { 7, HANGAR, 0, 1 }, { 7, 0, 0, 6 },
-	{  8, 0, OUT_WAY_block, 9 },
-	{  9, 0, RUNWAY_IN_OUT_block, 10 },
+	{  0, HANGAR, NOTHING_block, 0, 1 }, { 0, TAKEOFF, OUT_WAY_block, 0, 1 }, { 0, 0, 0, 0, 1 },
+	{  1, 255, TAXIWAY_BUSY_block, 0, 0 }, { 1, HANGAR, 0, 0, 0 }, { 1, TERM2, 0, 0, 6 }, { 1, TERM3, 0, 0, 6 }, { 1, 0, 0, 0, 7 }, // for all else, go to 7
+	{  2, TERM1, TERM1_block, 0, 7 }, { 2, TAKEOFF, OUT_WAY_block, 0, 7 }, { 2, 0, 0, 0, 7 },
+	{  3, TERM2, TERM2_block, 0, 5 }, { 3, TAKEOFF, OUT_WAY_block, 0, 6 }, { 3, 0, 0, 0, 6 },
+	{  4, TERM3, TERM3_block, 0, 5 }, { 4, TAKEOFF, OUT_WAY_block, 0, 5 }, { 4, 0, 0, 0, 5 },
+	{  5, 255, TAXIWAY_BUSY_block, 0, 0 }, { 5, TERM2, TERM2_block, 0, 3 }, { 5, TERM3, TERM3_block, 0, 4 }, { 5, 0, 0, 0, 6 },
+	{  6, 255, TAXIWAY_BUSY_block, 0, 0 }, { 6, TERM2, TERM2_block, 0, 3 }, { 6, TERM3, 0, 0, 5 }, { 6, HANGAR, 0, 0, 1 }, { 6, 0, 0, 0, 7 },
+	{  7, 255, TAXIWAY_BUSY_block, 0, 0 }, { 7, TERM1, TERM1_block, 0, 2 }, { 7, TAKEOFF, OUT_WAY_block, 0, 8 }, { 7, HELITAKEOFF, 0, 0, 22 }, { 7, HANGAR, 0, 0, 1 }, { 7, 0, 0, 0, 6 },
+	{  8, 0, OUT_WAY_block, 0, 9 },
+	{  9, 0, RUNWAY_IN_OUT_block, 0, 10 },
 	/* takeoff */
-	{ 10, TAKEOFF, RUNWAY_IN_OUT_block, 11 },
-	{ 11, STARTTAKEOFF, NOTHING_block, 12 },
-	{ 12, ENDTAKEOFF, NOTHING_block, 0 },
+	{ 10, TAKEOFF, RUNWAY_IN_OUT_block, 0, 11 },
+	{ 11, STARTTAKEOFF, NOTHING_block, 0, 12 },
+	{ 12, ENDTAKEOFF, NOTHING_block, 0, 0 },
 	/* landing */
-	{ 13, FLYING, NOTHING_block, 18 }, { 13, LANDING, 0, 14 }, { 13, HELILANDING, 0, 23 },
-	{ 14, LANDING, RUNWAY_IN_OUT_block, 15 },
-	{ 15, 0, RUNWAY_IN_OUT_block, 17 },
-	{ 16, 0, RUNWAY_IN_OUT_block, 17 }, // not used, left for compatibility
-	{ 17, ENDLANDING, IN_WAY_block, 7 },
+	{ 13, FLYING, NOTHING_block, 0, 18 }, { 13, LANDING, 0, 0, 14 }, { 13, HELILANDING, 0, 0, 23 },
+	{ 14, LANDING, RUNWAY_IN_OUT_block, 0, 15 },
+	{ 15, 0, RUNWAY_IN_OUT_block, 0, 17 },
+	{ 16, 0, RUNWAY_IN_OUT_block, 0, 17 }, // not used, left for compatibility
+	{ 17, ENDLANDING, IN_WAY_block, 0, 7 },
 	/* In Air */
-	{ 18, 0, NOTHING_block, 25 },
-	{ 19, 0, NOTHING_block, 20 },
-	{ 20, 0, NOTHING_block, 21 },
-	{ 21, 0, NOTHING_block, 13 },
+	{ 18, 0, NOTHING_block, 0, 25 },
+	{ 19, 0, NOTHING_block, 0, 20 },
+	{ 20, 0, NOTHING_block, 0, 21 },
+	{ 21, 0, NOTHING_block, 0, 13 },
 	/* helicopter */
-	{ 22, HELITAKEOFF, NOTHING_block, 0 },
-	{ 23, HELILANDING, IN_WAY_block, 24 },
-	{ 24, HELIENDLANDING, IN_WAY_block, 17 },
-	{ 25, 0, NOTHING_block, 20},
-	{ 26, 0, NOTHING_block, 19},
-	{ 27, 0, NOTHING_block, 28},
-	{ 28, 0, NOTHING_block, 19},
-	{ 29, 0, NOTHING_block, 26},
-	{ MAX_ELEMENTS, 0, 0, 0 } // end marker. DO NOT REMOVE
+	{ 22, HELITAKEOFF, NOTHING_block, 0, 0 },
+	{ 23, HELILANDING, IN_WAY_block, 0, 24 },
+	{ 24, HELIENDLANDING, IN_WAY_block, 0, 17 },
+	{ 25, 0, NOTHING_block, 0, 20},
+	{ 26, 0, NOTHING_block, 0, 19},
+	{ 27, 0, NOTHING_block, 0, 28},
+	{ 28, 0, NOTHING_block, 0, 19},
+	{ 29, 0, NOTHING_block, 0, 26},
+	{ MAX_ELEMENTS, 0, 0, 0, 0 } // end marker. DO NOT REMOVE
 };
 
 static const HangarTileTable _airport_depots_metropolitan[] = { {{5, 0}, DIR_SE, 0} };
 static const byte _airport_terminal_metropolitan[] = { 1, 3 };
 static const byte _airport_entries_metropolitan[] = {20, 19, 22, 21};
 static const AirportFTAbuildup _airport_fta_metropolitan[] = {
-	{  0, HANGAR, NOTHING_block, 1 },
-	{  1, 255, TAXIWAY_BUSY_block, 0 }, { 1, HANGAR, 0, 0 }, { 1, TERM2, 0, 6 }, { 1, TERM3, 0, 6 }, { 1, 0, 0, 7 }, // for all else, go to 7
-	{  2, TERM1, TERM1_block, 7 },
-	{  3, TERM2, TERM2_block, 6 },
-	{  4, TERM3, TERM3_block, 5 },
-	{  5, 255, TAXIWAY_BUSY_block, 0 }, { 5, TERM2, TERM2_block, 3 }, { 5, TERM3, TERM3_block, 4 }, { 5, 0, 0, 6 },
-	{  6, 255, TAXIWAY_BUSY_block, 0 }, { 6, TERM2, TERM2_block, 3 }, { 6, TERM3, 0, 5 }, { 6, HANGAR, 0, 1 }, { 6, 0, 0, 7 },
-	{  7, 255, TAXIWAY_BUSY_block, 0 }, { 7, TERM1, TERM1_block, 2 }, { 7, TAKEOFF, 0, 8 }, { 7, HELITAKEOFF, 0, 23 }, { 7, HANGAR, 0, 1 }, { 7, 0, 0, 6 },
-	{  8, 0, OUT_WAY_block, 9 },
-	{  9, 0, RUNWAY_OUT_block, 10 },
+	{  0, HANGAR, NOTHING_block, 0, 1 },
+	{  1, 255, TAXIWAY_BUSY_block, 0, 0 }, { 1, HANGAR, 0, 0, 0 }, { 1, TERM2, 0, 0, 6 }, { 1, TERM3, 0, 0, 6 }, { 1, 0, 0, 0, 7 }, // for all else, go to 7
+	{  2, TERM1, TERM1_block, 0, 7 },
+	{  3, TERM2, TERM2_block, 0, 6 },
+	{  4, TERM3, TERM3_block, 0, 5 },
+	{  5, 255, TAXIWAY_BUSY_block, 0, 0 }, { 5, TERM2, TERM2_block, 0, 3 }, { 5, TERM3, TERM3_block, 0, 4 }, { 5, 0, 0, 0, 6 },
+	{  6, 255, TAXIWAY_BUSY_block, 0, 0 }, { 6, TERM2, TERM2_block, 0, 3 }, { 6, TERM3, 0, 0, 5 }, { 6, HANGAR, 0, 0, 1 }, { 6, 0, 0, 0, 7 },
+	{  7, 255, TAXIWAY_BUSY_block, 0, 0 }, { 7, TERM1, TERM1_block, 0, 2 }, { 7, TAKEOFF, 0, 0, 8 }, { 7, HELITAKEOFF, 0, 0, 23 }, { 7, HANGAR, 0, 0, 1 }, { 7, 0, 0, 0, 6 },
+	{  8, 0, OUT_WAY_block, 0, 9 },
+	{  9, 0, RUNWAY_OUT_block, 0, 10 },
 	/* takeoff */
-	{ 10, TAKEOFF, RUNWAY_OUT_block, 11 },
-	{ 11, STARTTAKEOFF, NOTHING_block, 12 },
-	{ 12, ENDTAKEOFF, NOTHING_block, 0 },
+	{ 10, TAKEOFF, RUNWAY_OUT_block, 0, 11 },
+	{ 11, STARTTAKEOFF, NOTHING_block, 0, 12 },
+	{ 12, ENDTAKEOFF, NOTHING_block, 0, 0 },
 	/* landing */
-	{ 13, FLYING, NOTHING_block, 19 }, { 13, LANDING, 0, 14 }, { 13, HELILANDING, 0, 25 },
-	{ 14, LANDING, RUNWAY_IN_block, 15 },
-	{ 15, 0, RUNWAY_IN_block, 16 },
-	{ 16, 255, RUNWAY_IN_block, 0 }, { 16, ENDLANDING, IN_WAY_block, 17 },
-	{ 17, 255, RUNWAY_OUT_block, 0 }, { 17, ENDLANDING, IN_WAY_block, 18 },
-	{ 18, ENDLANDING, IN_WAY_block, 27 },
+	{ 13, FLYING, NOTHING_block, 0, 19 }, { 13, LANDING, 0, 0, 14 }, { 13, HELILANDING, 0, 0, 25 },
+	{ 14, LANDING, RUNWAY_IN_block, 0, 15 },
+	{ 15, 0, RUNWAY_IN_block, 0, 16 },
+	{ 16, 255, RUNWAY_IN_block, 0, 0 }, { 16, ENDLANDING, IN_WAY_block, 0, 17 },
+	{ 17, 255, RUNWAY_OUT_block, 0, 0 }, { 17, ENDLANDING, IN_WAY_block, 0, 18 },
+	{ 18, ENDLANDING, IN_WAY_block, 0, 27 },
 	/* In Air */
-	{ 19, 0, NOTHING_block, 20 },
-	{ 20, 0, NOTHING_block, 21 },
-	{ 21, 0, NOTHING_block, 22 },
-	{ 22, 0, NOTHING_block, 13 },
+	{ 19, 0, NOTHING_block, 0, 20 },
+	{ 20, 0, NOTHING_block, 0, 21 },
+	{ 21, 0, NOTHING_block, 0, 22 },
+	{ 22, 0, NOTHING_block, 0, 13 },
 	/* helicopter */
-	{ 23, 0, NOTHING_block, 24 },
-	{ 24, HELITAKEOFF, NOTHING_block, 0 },
-	{ 25, HELILANDING, IN_WAY_block, 26 },
-	{ 26, HELIENDLANDING, IN_WAY_block, 18 },
-	{ 27, 255, TAXIWAY_BUSY_block, 27 }, { 27, TERM1, TERM1_block, 2 }, { 27, 0, 0, 7 },
-	{ MAX_ELEMENTS, 0, 0, 0 } // end marker. DO NOT REMOVE
+	{ 23, 0, NOTHING_block, 0, 24 },
+	{ 24, HELITAKEOFF, NOTHING_block, 0, 0 },
+	{ 25, HELILANDING, IN_WAY_block, 0, 26 },
+	{ 26, HELIENDLANDING, IN_WAY_block, 0, 18 },
+	{ 27, 255, TAXIWAY_BUSY_block, 0, 27 }, { 27, TERM1, TERM1_block, 0, 2 }, { 27, 0, 0, 0, 7 },
+	{ MAX_ELEMENTS, 0, 0, 0, 0 } // end marker. DO NOT REMOVE
 };
 
 static const HangarTileTable _airport_depots_international[] = { {{0, 3}, DIR_SE, 0}, {{6, 1}, DIR_SE, 1} };
 static const byte _airport_terminal_international[] = { 2, 3, 3 };
 static const byte _airport_entries_international[] = { 38, 37, 40, 39 };
 static const AirportFTAbuildup _airport_fta_international[] = {
-	{  0, HANGAR, NOTHING_block, 2 }, { 0, 255, TERM_GROUP1_block, 0 }, { 0, 255, TERM_GROUP2_ENTER1_block, 1 }, { 0, HELITAKEOFF, HELIPAD1_block, 2 }, { 0, 0, 0, 2 },
-	{  1, HANGAR, NOTHING_block, 3 }, { 1, 255, HANGAR2_AREA_block, 1 }, { 1, HELITAKEOFF, HELIPAD2_block, 3 }, { 1, 0, 0, 3 },
-	{  2, 255, AIRPORT_ENTRANCE_block, 0 }, { 2, HANGAR, 0, 0 }, { 2, TERM4, 0, 12 }, { 2, TERM5, 0, 12 }, { 2, TERM6, 0, 12 }, { 2, HELIPAD1, 0, 12 }, { 2, HELIPAD2, 0, 12 }, { 2, HELITAKEOFF, 0, 12 }, { 2, 0, 0, 23 },
-	{  3, 255, HANGAR2_AREA_block, 0 }, { 3, HANGAR, 0, 1 }, { 3, 0, 0, 18 },
-	{  4, TERM1, TERM1_block, 23 }, { 4, HANGAR, AIRPORT_ENTRANCE_block, 23 }, { 4, 0, 0, 23 },
-	{  5, TERM2, TERM2_block, 24 }, { 5, HANGAR, AIRPORT_ENTRANCE_block, 24 }, { 5, 0, 0, 24 },
-	{  6, TERM3, TERM3_block, 25 }, { 6, HANGAR, AIRPORT_ENTRANCE_block, 25 }, { 6, 0, 0, 25 },
-	{  7, TERM4, TERM4_block, 16 }, { 7, HANGAR, HANGAR2_AREA_block, 16 }, { 7, 0, 0, 16 },
-	{  8, TERM5, TERM5_block, 17 }, { 8, HANGAR, HANGAR2_AREA_block, 17 }, { 8, 0, 0, 17 },
-	{  9, TERM6, TERM6_block, 18 }, { 9, HANGAR, HANGAR2_AREA_block, 18 }, { 9, 0, 0, 18 },
-	{ 10, HELIPAD1, HELIPAD1_block, 10 }, { 10, HANGAR, HANGAR2_AREA_block, 16 }, { 10, HELITAKEOFF, 0, 47 },
-	{ 11, HELIPAD2, HELIPAD2_block, 11 }, { 11, HANGAR, HANGAR2_AREA_block, 17 }, { 11, HELITAKEOFF, 0, 48 },
-	{ 12, 0, TERM_GROUP2_ENTER1_block, 13 },
-	{ 13, 0, TERM_GROUP2_ENTER1_block, 14 },
-	{ 14, 0, TERM_GROUP2_ENTER2_block, 15 },
-	{ 15, 0, TERM_GROUP2_ENTER2_block, 16 },
-	{ 16, 255, TERM_GROUP2_block, 0 }, { 16, TERM4, TERM4_block, 7 }, { 16, HELIPAD1, HELIPAD1_block, 10 }, { 16, HELITAKEOFF, HELIPAD1_block, 10 }, { 16, 0, 0, 17 },
-	{ 17, 255, TERM_GROUP2_block, 0 }, { 17, TERM5, TERM5_block, 8 }, { 17, TERM4, 0, 16 }, { 17, HELIPAD1, 0, 16 }, { 17, HELIPAD2, HELIPAD2_block, 11 }, { 17, HELITAKEOFF, HELIPAD2_block, 11 }, { 17, 0, 0, 18 },
-	{ 18, 255, TERM_GROUP2_block, 0 }, { 18, TERM6, TERM6_block, 9 }, { 18, TAKEOFF, 0, 19 }, { 18, HANGAR, HANGAR2_AREA_block, 3 }, { 18, 0, 0, 17 },
-	{ 19, 0, TERM_GROUP2_EXIT1_block, 20 },
-	{ 20, 0, TERM_GROUP2_EXIT1_block, 21 },
-	{ 21, 0, TERM_GROUP2_EXIT2_block, 22 },
-	{ 22, 0, TERM_GROUP2_EXIT2_block, 26 },
-	{ 23, 255, TERM_GROUP1_block, 0 }, { 23, TERM1, TERM1_block, 4 }, { 23, HANGAR, AIRPORT_ENTRANCE_block, 2 }, { 23, 0, 0, 24 },
-	{ 24, 255, TERM_GROUP1_block, 0 }, { 24, TERM2, TERM2_block, 5 }, { 24, TERM1, 0, 23 }, { 24, HANGAR, 0, 23 }, { 24, 0, 0, 25 },
-	{ 25, 255, TERM_GROUP1_block, 0 }, { 25, TERM3, TERM3_block, 6 }, { 25, TAKEOFF, 0, 26 }, { 25, 0, 0, 24 },
-	{ 26, 255, TAXIWAY_BUSY_block, 0 }, { 26, TAKEOFF, 0, 27 }, { 26, 0, 0, 25 },
-	{ 27, 0, OUT_WAY_block, 28 },
+	{  0, HANGAR, NOTHING_block, 0, 2 }, { 0, 255, TERM_GROUP1_block, 0, 0 }, { 0, 255, TERM_GROUP2_ENTER1_block, 0, 1 }, { 0, HELITAKEOFF, HELIPAD1_block, 0, 2 }, { 0, 0, 0, 0, 2 },
+	{  1, HANGAR, NOTHING_block, 0, 3 }, { 1, 255, HANGAR2_AREA_block, 0, 1 }, { 1, HELITAKEOFF, HELIPAD2_block, 0, 3 }, { 1, 0, 0, 0, 3 },
+	{  2, 255, AIRPORT_ENTRANCE_block, 0, 0 }, { 2, HANGAR, 0, 0, 0 }, { 2, TERM4, 0, 0, 12 }, { 2, TERM5, 0, 0, 12 }, { 2, TERM6, 0, 0, 12 }, { 2, HELIPAD1, 0, 0, 12 }, { 2, HELIPAD2, 0, 0, 12 }, { 2, HELITAKEOFF, 0, 0, 12 }, { 2, 0, 0, 0, 23 },
+	{  3, 255, HANGAR2_AREA_block, 0, 0 }, { 3, HANGAR, 0, 0, 1 }, { 3, 0, 0, 0, 18 },
+	{  4, TERM1, TERM1_block, 0, 23 }, { 4, HANGAR, AIRPORT_ENTRANCE_block, 0, 23 }, { 4, 0, 0, 0, 23 },
+	{  5, TERM2, TERM2_block, 0, 24 }, { 5, HANGAR, AIRPORT_ENTRANCE_block, 0, 24 }, { 5, 0, 0, 0, 24 },
+	{  6, TERM3, TERM3_block, 0, 25 }, { 6, HANGAR, AIRPORT_ENTRANCE_block, 0, 25 }, { 6, 0, 0, 0, 25 },
+	{  7, TERM4, TERM4_block, 0, 16 }, { 7, HANGAR, HANGAR2_AREA_block, 0, 16 }, { 7, 0, 0, 0, 16 },
+	{  8, TERM5, TERM5_block, 0, 17 }, { 8, HANGAR, HANGAR2_AREA_block, 0, 17 }, { 8, 0, 0, 0, 17 },
+	{  9, TERM6, TERM6_block, 0, 18 }, { 9, HANGAR, HANGAR2_AREA_block, 0, 18 }, { 9, 0, 0, 0, 18 },
+	{ 10, HELIPAD1, HELIPAD1_block, 0, 10 }, { 10, HANGAR, HANGAR2_AREA_block, 0, 16 }, { 10, HELITAKEOFF, 0, 0, 47 },
+	{ 11, HELIPAD2, HELIPAD2_block, 0, 11 }, { 11, HANGAR, HANGAR2_AREA_block, 0, 17 }, { 11, HELITAKEOFF, 0, 0, 48 },
+	{ 12, 0, TERM_GROUP2_ENTER1_block, 0, 13 },
+	{ 13, 0, TERM_GROUP2_ENTER1_block, 0, 14 },
+	{ 14, 0, TERM_GROUP2_ENTER2_block, 0, 15 },
+	{ 15, 0, TERM_GROUP2_ENTER2_block, 0, 16 },
+	{ 16, 255, TERM_GROUP2_block, 0, 0 }, { 16, TERM4, TERM4_block, 0, 7 }, { 16, HELIPAD1, HELIPAD1_block, 0, 10 }, { 16, HELITAKEOFF, HELIPAD1_block, 0, 10 }, { 16, 0, 0, 0, 17 },
+	{ 17, 255, TERM_GROUP2_block, 0, 0 }, { 17, TERM5, TERM5_block, 0, 8 }, { 17, TERM4, 0, 0, 16 }, { 17, HELIPAD1, 0, 0, 16 }, { 17, HELIPAD2, HELIPAD2_block, 0, 11 }, { 17, HELITAKEOFF, HELIPAD2_block, 0, 11 }, { 17, 0, 0, 0, 18 },
+	{ 18, 255, TERM_GROUP2_block, 0, 0 }, { 18, TERM6, TERM6_block, 0, 9 }, { 18, TAKEOFF, 0, 0, 19 }, { 18, HANGAR, HANGAR2_AREA_block, 0, 3 }, { 18, 0, 0, 0, 17 },
+	{ 19, 0, TERM_GROUP2_EXIT1_block, 0, 20 },
+	{ 20, 0, TERM_GROUP2_EXIT1_block, 0, 21 },
+	{ 21, 0, TERM_GROUP2_EXIT2_block, 0, 22 },
+	{ 22, 0, TERM_GROUP2_EXIT2_block, 0, 26 },
+	{ 23, 255, TERM_GROUP1_block, 0, 0 }, { 23, TERM1, TERM1_block, 0, 4 }, { 23, HANGAR, AIRPORT_ENTRANCE_block, 0, 2 }, { 23, 0, 0, 0, 24 },
+	{ 24, 255, TERM_GROUP1_block, 0, 0 }, { 24, TERM2, TERM2_block, 0, 5 }, { 24, TERM1, 0, 0, 23 }, { 24, HANGAR, 0, 0, 23 }, { 24, 0, 0, 0, 25 },
+	{ 25, 255, TERM_GROUP1_block, 0, 0 }, { 25, TERM3, TERM3_block, 0, 6 }, { 25, TAKEOFF, 0, 0, 26 }, { 25, 0, 0, 0, 24 },
+	{ 26, 255, TAXIWAY_BUSY_block, 0, 0 }, { 26, TAKEOFF, 0, 0, 27 }, { 26, 0, 0, 0, 25 },
+	{ 27, 0, OUT_WAY_block, 0, 28 },
 	/* takeoff */
-	{ 28, TAKEOFF, OUT_WAY_block, 29 },
-	{ 29, 0, RUNWAY_OUT_block, 30 },
-	{ 30, STARTTAKEOFF, NOTHING_block, 31 },
-	{ 31, ENDTAKEOFF, NOTHING_block, 0 },
+	{ 28, TAKEOFF, OUT_WAY_block, 0, 29 },
+	{ 29, 0, RUNWAY_OUT_block, 0, 30 },
+	{ 30, STARTTAKEOFF, NOTHING_block, 0, 31 },
+	{ 31, ENDTAKEOFF, NOTHING_block, 0, 0 },
 	/* landing */
-	{ 32, FLYING, NOTHING_block, 37 }, { 32, LANDING, 0, 33 }, { 32, HELILANDING, 0, 41 },
-	{ 33, LANDING, RUNWAY_IN_block, 34 },
-	{ 34, 0, RUNWAY_IN_block, 35 },
-	{ 35, 0, RUNWAY_IN_block, 36 },
-	{ 36, ENDLANDING, IN_WAY_block, 36 }, { 36, 255, TERM_GROUP1_block, 0 }, { 36, 255, TERM_GROUP2_ENTER1_block, 1 }, { 36, TERM4, 0, 12 }, { 36, TERM5, 0, 12 }, { 36, TERM6, 0, 12 }, { 36, 0, 0, 2 },
+	{ 32, FLYING, NOTHING_block, 0, 37 }, { 32, LANDING, 0, 0, 33 }, { 32, HELILANDING, 0, 0, 41 },
+	{ 33, LANDING, RUNWAY_IN_block, 0, 34 },
+	{ 34, 0, RUNWAY_IN_block, 0, 35 },
+	{ 35, 0, RUNWAY_IN_block, 0, 36 },
+	{ 36, ENDLANDING, IN_WAY_block, 0, 36 }, { 36, 255, TERM_GROUP1_block, 0, 0 }, { 36, 255, TERM_GROUP2_ENTER1_block, 0, 1 }, { 36, TERM4, 0, 0, 12 }, { 36, TERM5, 0, 0, 12 }, { 36, TERM6, 0, 0, 12 }, { 36, 0, 0, 0, 2 },
 	/* In Air */
-	{ 37, 0, NOTHING_block, 38 },
-	{ 38, 0, NOTHING_block, 39 },
-	{ 39, 0, NOTHING_block, 40 },
-	{ 40, 0, NOTHING_block, 32 },
+	{ 37, 0, NOTHING_block, 0, 38 },
+	{ 38, 0, NOTHING_block, 0, 39 },
+	{ 39, 0, NOTHING_block, 0, 40 },
+	{ 40, 0, NOTHING_block, 0, 32 },
 	/* Helicopter -- stay in air in special place as a buffer to choose from helipads */
-	{ 41, HELILANDING, PRE_HELIPAD_block, 42 },
-	{ 42, HELIENDLANDING, PRE_HELIPAD_block, 42 }, { 42, HELIPAD1, 0, 43 }, { 42, HELIPAD2, 0, 44 }, { 42, HANGAR, 0, 49 },
-	{ 43, 0, NOTHING_block, 45 },
-	{ 44, 0, NOTHING_block, 46 },
+	{ 41, HELILANDING, PRE_HELIPAD_block, 0, 42 },
+	{ 42, HELIENDLANDING, PRE_HELIPAD_block, 0, 42 }, { 42, HELIPAD1, 0, 0, 43 }, { 42, HELIPAD2, 0, 0, 44 }, { 42, HANGAR, 0, 0, 49 },
+	{ 43, 0, NOTHING_block, 0, 45 },
+	{ 44, 0, NOTHING_block, 0, 46 },
 	/* landing */
-	{ 45, 255, NOTHING_block, 0 }, { 45, HELIPAD1, HELIPAD1_block, 10 },
-	{ 46, 255, NOTHING_block, 0 }, { 46, HELIPAD2, HELIPAD2_block, 11 },
+	{ 45, 255, NOTHING_block, 0, 0 }, { 45, HELIPAD1, HELIPAD1_block, 0, 10 },
+	{ 46, 255, NOTHING_block, 0, 0 }, { 46, HELIPAD2, HELIPAD2_block, 0, 11 },
 	/* Helicopter -- takeoff */
-	{ 47, HELITAKEOFF, NOTHING_block, 0 },
-	{ 48, HELITAKEOFF, NOTHING_block, 0 },
-	{ 49, 0, HANGAR2_AREA_block, 50 }, // need to go to hangar when waiting in air
-	{ 50, 0, HANGAR2_AREA_block, 3 },
-	{ MAX_ELEMENTS, 0, 0, 0 } // end marker. DO NOT REMOVE
+	{ 47, HELITAKEOFF, NOTHING_block, 0, 0 },
+	{ 48, HELITAKEOFF, NOTHING_block, 0, 0 },
+	{ 49, 0, HANGAR2_AREA_block, 0, 50 }, // need to go to hangar when waiting in air
+	{ 50, 0, HANGAR2_AREA_block, 0, 3 },
+	{ MAX_ELEMENTS, 0, 0, 0, 0 } // end marker. DO NOT REMOVE
 };
 
 /* intercontinental */
@@ -648,109 +906,399 @@
 static const byte _airport_terminal_intercontinental[] = { 2, 4, 4 };
 static const byte _airport_entries_intercontinental[] = { 44, 43, 46, 45 };
 static const AirportFTAbuildup _airport_fta_intercontinental[] = {
-	{  0, HANGAR, NOTHING_block, 2 }, { 0, 255, HANGAR1_AREA_block | TERM_GROUP1_block, 0 }, { 0, 255, HANGAR1_AREA_block | TERM_GROUP1_block, 1 }, { 0, TAKEOFF, HANGAR1_AREA_block | TERM_GROUP1_block, 2 }, { 0, 0, 0, 2 },
-	{  1, HANGAR, NOTHING_block, 3 }, { 1, 255, HANGAR2_AREA_block, 1 }, { 1, 255, HANGAR2_AREA_block, 0 }, { 1, 0, 0, 3 },
-	{  2, 255, HANGAR1_AREA_block, 0 }, { 2, 255, TERM_GROUP1_block, 0 }, { 2, 255, TERM_GROUP1_block, 1 }, { 2, HANGAR, 0, 0 }, { 2, TAKEOFF, TERM_GROUP1_block, 27 }, { 2, TERM5, 0, 26 }, { 2, TERM6, 0, 26 }, { 2, TERM7, 0, 26 }, { 2, TERM8, 0, 26 }, { 2, HELIPAD1, 0, 26 }, { 2, HELIPAD2, 0, 26 }, { 2, HELITAKEOFF, 0, 74 }, { 2, 0, 0, 27 },
-	{  3, 255, HANGAR2_AREA_block, 0 }, { 3, HANGAR, 0, 1 }, { 3, HELITAKEOFF, 0, 75 }, {3, TAKEOFF, 0, 59}, { 3, 0, 0, 20 },
-	{  4, TERM1, TERM1_block, 26 }, { 4, HANGAR, HANGAR1_AREA_block | TERM_GROUP1_block, 26 }, { 4, 0, 0, 26 },
-	{  5, TERM2, TERM2_block, 27 }, { 5, HANGAR, HANGAR1_AREA_block | TERM_GROUP1_block, 27 }, { 5, 0, 0, 27 },
-	{  6, TERM3, TERM3_block, 28 }, { 6, HANGAR, HANGAR1_AREA_block | TERM_GROUP1_block, 28 }, { 6, 0, 0, 28 },
-	{  7, TERM4, TERM4_block, 29 }, { 7, HANGAR, HANGAR1_AREA_block | TERM_GROUP1_block, 29 }, { 7, 0, 0, 29 },
-	{  8, TERM5, TERM5_block, 18 }, { 8, HANGAR, HANGAR2_AREA_block, 18 }, { 8, 0, 0, 18 },
-	{  9, TERM6, TERM6_block, 19 }, { 9, HANGAR, HANGAR2_AREA_block, 19 }, { 9, 0, 0, 19 },
-	{ 10, TERM7, TERM7_block, 20 }, { 10, HANGAR, HANGAR2_AREA_block, 20 }, { 10, 0, 0, 20 },
-	{ 11, TERM8, TERM8_block, 21 }, { 11, HANGAR, HANGAR2_AREA_block, 21 }, { 11, 0, 0, 21 },
-	{ 12, HELIPAD1, HELIPAD1_block, 12 }, { 12, HANGAR, 0, 70 }, { 12, HELITAKEOFF, 0, 72 },
-	{ 13, HELIPAD2, HELIPAD2_block, 13 }, { 13, HANGAR, 0, 71 }, { 13, HELITAKEOFF, 0, 73 },
-	{ 14, 0, TERM_GROUP2_ENTER1_block, 15 },
-	{ 15, 0, TERM_GROUP2_ENTER1_block, 16 },
-	{ 16, 0, TERM_GROUP2_ENTER2_block, 17 },
-	{ 17, 0, TERM_GROUP2_ENTER2_block, 18 },
-	{ 18, 255, TERM_GROUP2_block, 0 }, { 18, TERM5, TERM5_block, 8 }, { 18, TAKEOFF, 0, 19 }, { 18, HELITAKEOFF, HELIPAD1_block, 19 }, { 18, 0, TERM_GROUP2_EXIT1_block, 19 },
-	{ 19, 255, TERM_GROUP2_block, 0 }, { 19, TERM6, TERM6_block, 9 }, { 19, TERM5, 0, 18 }, { 19, TAKEOFF, 0, 57 }, { 19, HELITAKEOFF, HELIPAD1_block, 20 }, { 19, 0, TERM_GROUP2_EXIT1_block, 20 }, // add exit to runway out 2
-	{ 20, 255, TERM_GROUP2_block, 0 }, { 20, TERM7, TERM7_block, 10 }, { 20, TERM5, 0, 19 }, { 20, TERM6, 0, 19 }, { 20, HANGAR, HANGAR2_AREA_block, 3 }, { 20, TAKEOFF, 0, 19 }, { 20, 0, TERM_GROUP2_EXIT1_block, 21 },
-	{ 21, 255, TERM_GROUP2_block, 0 }, { 21, TERM8, TERM8_block, 11 }, { 21, HANGAR, HANGAR2_AREA_block, 20 }, { 21, TERM5, 0, 20 }, { 21, TERM6, 0, 20 }, { 21, TERM7, 0, 20 }, { 21, TAKEOFF, 0, 20 }, { 21, 0, TERM_GROUP2_EXIT1_block, 22 },
-	{ 22, 255, TERM_GROUP2_block, 0 }, { 22, HANGAR, 0, 21 }, { 22, TERM5, 0, 21 }, { 22, TERM6, 0, 21 }, { 22, TERM7, 0, 21 }, { 22, TERM8, 0, 21 }, { 22, TAKEOFF, 0, 21 }, { 22, 0, 0, 23 },
-	{ 23, 0, TERM_GROUP2_EXIT1_block, 70 },
-	{ 24, 0, TERM_GROUP2_EXIT2_block, 25 },
-	{ 25, 255, TERM_GROUP2_EXIT2_block, 0 }, { 25, HANGAR, HANGAR1_AREA_block | TERM_GROUP1_block, 29 }, { 25, 0, 0, 29 },
-	{ 26, 255, TERM_GROUP1_block, 0 }, { 26, TERM1, TERM1_block, 4 }, { 26, HANGAR, HANGAR1_AREA_block, 27 }, { 26, TERM5, TERM_GROUP2_ENTER1_block, 14 }, { 26, TERM6, TERM_GROUP2_ENTER1_block, 14 }, { 26, TERM7, TERM_GROUP2_ENTER1_block, 14 }, { 26, TERM8, TERM_GROUP2_ENTER1_block, 14 }, { 26, HELIPAD1, TERM_GROUP2_ENTER1_block, 14 }, { 26, HELIPAD2, TERM_GROUP2_ENTER1_block, 14 }, { 26, HELITAKEOFF, TERM_GROUP2_ENTER1_block, 14 }, { 26, 0, 0, 27 },
-	{ 27, 255, TERM_GROUP1_block, 0 }, { 27, TERM2, TERM2_block, 5 }, { 27, HANGAR, HANGAR1_AREA_block, 2 }, { 27, TERM1, 0, 26 }, { 27, TERM5, 0, 26 }, { 27, TERM6, 0, 26 }, { 27, TERM7, 0, 26 }, { 27, TERM8, 0, 26 }, { 27, HELIPAD1, 0, 14 }, { 27, HELIPAD2, 0, 14 }, { 27, 0, 0, 28 },
-	{ 28, 255, TERM_GROUP1_block, 0 }, { 28, TERM3, TERM3_block, 6 }, { 28, HANGAR, HANGAR1_AREA_block, 27 }, { 28, TERM1, 0, 27 }, { 28, TERM2, 0, 27 }, { 28, TERM4, 0, 29 }, { 28, TERM5, 0, 14 }, { 28, TERM6, 0, 14 }, { 28, TERM7, 0, 14 }, { 28, TERM8, 0, 14 }, { 28, HELIPAD1, 0, 14 }, { 28, HELIPAD2, 0, 14 }, { 28, 0, 0, 29 },
-	{ 29, 255, TERM_GROUP1_block, 0 }, { 29, TERM4, TERM4_block, 7 }, { 29, HANGAR, HANGAR1_AREA_block, 27 }, { 29, TAKEOFF, 0, 30 }, { 29, 0, 0, 28 },
-	{ 30, 0, OUT_WAY_block2, 31 },
-	{ 31, 0, OUT_WAY_block, 32 },
+	{  0, HANGAR, NOTHING_block, 0, 2 }, { 0, 255, HANGAR1_AREA_block | TERM_GROUP1_block, 0, 0 }, { 0, 255, HANGAR1_AREA_block | TERM_GROUP1_block, 0, 1 }, { 0, TAKEOFF, HANGAR1_AREA_block | TERM_GROUP1_block, 0, 2 }, { 0, 0, 0, 0, 2 },
+	{  1, HANGAR, NOTHING_block, 0, 3 }, { 1, 255, HANGAR2_AREA_block, 0, 1 }, { 1, 255, HANGAR2_AREA_block, 0, 0 }, { 1, 0, 0, 0, 3 },
+	{  2, 255, HANGAR1_AREA_block, 0, 0 }, { 2, 255, TERM_GROUP1_block, 0, 0 }, { 2, 255, TERM_GROUP1_block, 0, 1 }, { 2, HANGAR, 0, 0, 0 }, { 2, TAKEOFF, TERM_GROUP1_block, 0, 27 }, { 2, TERM5, 0, 0, 26 }, { 2, TERM6, 0, 0, 26 }, { 2, TERM7, 0, 0, 26 }, { 2, TERM8, 0, 0, 26 }, { 2, HELIPAD1, 0, 0, 26 }, { 2, HELIPAD2, 0, 0, 26 }, { 2, HELITAKEOFF, 0, 0, 74 }, { 2, 0, 0, 0, 27 },
+	{  3, 255, HANGAR2_AREA_block, 0, 0 }, { 3, HANGAR, 0, 0, 1 }, { 3, HELITAKEOFF, 0, 0, 75 }, {3, TAKEOFF, 0, 0, 59}, { 3, 0, 0, 0, 20 },
+	{  4, TERM1, TERM1_block, 0, 26 }, { 4, HANGAR, HANGAR1_AREA_block | TERM_GROUP1_block, 0, 26 }, { 4, 0, 0, 0, 26 },
+	{  5, TERM2, TERM2_block, 0, 27 }, { 5, HANGAR, HANGAR1_AREA_block | TERM_GROUP1_block, 0, 27 }, { 5, 0, 0, 0, 27 },
+	{  6, TERM3, TERM3_block, 0, 28 }, { 6, HANGAR, HANGAR1_AREA_block | TERM_GROUP1_block, 0, 28 }, { 6, 0, 0, 0, 28 },
+	{  7, TERM4, TERM4_block, 0, 29 }, { 7, HANGAR, HANGAR1_AREA_block | TERM_GROUP1_block, 0, 29 }, { 7, 0, 0, 0, 29 },
+	{  8, TERM5, TERM5_block, 0, 18 }, { 8, HANGAR, HANGAR2_AREA_block, 0, 18 }, { 8, 0, 0, 0, 18 },
+	{  9, TERM6, TERM6_block, 0, 19 }, { 9, HANGAR, HANGAR2_AREA_block, 0, 19 }, { 9, 0, 0, 0, 19 },
+	{ 10, TERM7, TERM7_block, 0, 20 }, { 10, HANGAR, HANGAR2_AREA_block, 0, 20 }, { 10, 0, 0, 0, 20 },
+	{ 11, TERM8, TERM8_block, 0, 21 }, { 11, HANGAR, HANGAR2_AREA_block, 0, 21 }, { 11, 0, 0, 0, 21 },
+	{ 12, HELIPAD1, HELIPAD1_block, 0, 12 }, { 12, HANGAR, 0, 0, 70 }, { 12, HELITAKEOFF, 0, 0, 72 },
+	{ 13, HELIPAD2, HELIPAD2_block, 0, 13 }, { 13, HANGAR, 0, 0, 71 }, { 13, HELITAKEOFF, 0, 0, 73 },
+	{ 14, 0, TERM_GROUP2_ENTER1_block, 0, 15 },
+	{ 15, 0, TERM_GROUP2_ENTER1_block, 0, 16 },
+	{ 16, 0, TERM_GROUP2_ENTER2_block, 0, 17 },
+	{ 17, 0, TERM_GROUP2_ENTER2_block, 0, 18 },
+	{ 18, 255, TERM_GROUP2_block, 0, 0 }, { 18, TERM5, TERM5_block, 0, 8 }, { 18, TAKEOFF, 0, 0, 19 }, { 18, HELITAKEOFF, HELIPAD1_block, 0, 19 }, { 18, 0, TERM_GROUP2_EXIT1_block, 0, 19 },
+	{ 19, 255, TERM_GROUP2_block, 0, 0 }, { 19, TERM6, TERM6_block, 0, 9 }, { 19, TERM5, 0, 0, 18 }, { 19, TAKEOFF, 0, 0, 57 }, { 19, HELITAKEOFF, HELIPAD1_block, 0, 20 }, { 19, 0, TERM_GROUP2_EXIT1_block, 0, 20 }, // add exit to runway out 2
+	{ 20, 255, TERM_GROUP2_block, 0, 0 }, { 20, TERM7, TERM7_block, 0, 10 }, { 20, TERM5, 0, 0, 19 }, { 20, TERM6, 0, 0, 19 }, { 20, HANGAR, HANGAR2_AREA_block, 0, 3 }, { 20, TAKEOFF, 0, 0, 19 }, { 20, 0, TERM_GROUP2_EXIT1_block, 0, 21 },
+	{ 21, 255, TERM_GROUP2_block, 0, 0 }, { 21, TERM8, TERM8_block, 0, 11 }, { 21, HANGAR, HANGAR2_AREA_block, 0, 20 }, { 21, TERM5, 0, 0, 20 }, { 21, TERM6, 0, 0, 20 }, { 21, TERM7, 0, 0, 20 }, { 21, TAKEOFF, 0, 0, 20 }, { 21, 0, TERM_GROUP2_EXIT1_block, 0, 22 },
+	{ 22, 255, TERM_GROUP2_block, 0, 0 }, { 22, HANGAR, 0, 0, 21 }, { 22, TERM5, 0, 0, 21 }, { 22, TERM6, 0, 0, 21 }, { 22, TERM7, 0, 0, 21 }, { 22, TERM8, 0, 0, 21 }, { 22, TAKEOFF, 0, 0, 21 }, { 22, 0, 0, 0, 23 },
+	{ 23, 0, TERM_GROUP2_EXIT1_block, 0, 70 },
+	{ 24, 0, TERM_GROUP2_EXIT2_block, 0, 25 },
+	{ 25, 255, TERM_GROUP2_EXIT2_block, 0, 0 }, { 25, HANGAR, HANGAR1_AREA_block | TERM_GROUP1_block, 0, 29 }, { 25, 0, 0, 0, 29 },
+	{ 26, 255, TERM_GROUP1_block, 0, 0 }, { 26, TERM1, TERM1_block, 0, 4 }, { 26, HANGAR, HANGAR1_AREA_block, 0, 27 }, { 26, TERM5, TERM_GROUP2_ENTER1_block, 0, 14 }, { 26, TERM6, TERM_GROUP2_ENTER1_block, 0, 14 }, { 26, TERM7, TERM_GROUP2_ENTER1_block, 0, 14 }, { 26, TERM8, TERM_GROUP2_ENTER1_block, 0, 14 }, { 26, HELIPAD1, TERM_GROUP2_ENTER1_block, 0, 14 }, { 26, HELIPAD2, TERM_GROUP2_ENTER1_block, 0, 14 }, { 26, HELITAKEOFF, TERM_GROUP2_ENTER1_block, 0, 14 }, { 26, 0, 0, 0, 27 },
+	{ 27, 255, TERM_GROUP1_block, 0, 0 }, { 27, TERM2, TERM2_block, 0, 5 }, { 27, HANGAR, HANGAR1_AREA_block, 0, 2 }, { 27, TERM1, 0, 0, 26 }, { 27, TERM5, 0, 0, 26 }, { 27, TERM6, 0, 0, 26 }, { 27, TERM7, 0, 0, 26 }, { 27, TERM8, 0, 0, 26 }, { 27, HELIPAD1, 0, 0, 14 }, { 27, HELIPAD2, 0, 0, 14 }, { 27, 0, 0, 0, 28 },
+	{ 28, 255, TERM_GROUP1_block, 0, 0 }, { 28, TERM3, TERM3_block, 0, 6 }, { 28, HANGAR, HANGAR1_AREA_block, 0, 27 }, { 28, TERM1, 0, 0, 27 }, { 28, TERM2, 0, 0, 27 }, { 28, TERM4, 0, 0, 29 }, { 28, TERM5, 0, 0, 14 }, { 28, TERM6, 0, 0, 14 }, { 28, TERM7, 0, 0, 14 }, { 28, TERM8, 0, 0, 14 }, { 28, HELIPAD1, 0, 0, 14 }, { 28, HELIPAD2, 0, 0, 14 }, { 28, 0, 0, 0, 29 },
+	{ 29, 255, TERM_GROUP1_block, 0, 0 }, { 29, TERM4, TERM4_block, 0, 7 }, { 29, HANGAR, HANGAR1_AREA_block, 0, 27 }, { 29, TAKEOFF, 0, 0, 30 }, { 29, 0, 0, 0, 28 },
+	{ 30, 0, OUT_WAY_block2, 0, 31 },
+	{ 31, 0, OUT_WAY_block, 0, 32 },
 	/* takeoff */
-	{ 32, TAKEOFF, RUNWAY_OUT_block, 33 },
-	{ 33, 0, RUNWAY_OUT_block, 34 },
-	{ 34, STARTTAKEOFF, NOTHING_block, 35 },
-	{ 35, ENDTAKEOFF, NOTHING_block, 0 },
+	{ 32, TAKEOFF, RUNWAY_OUT_block, 0, 33 },
+	{ 33, 0, RUNWAY_OUT_block, 0, 34 },
+	{ 34, STARTTAKEOFF, NOTHING_block, 0, 35 },
+	{ 35, ENDTAKEOFF, NOTHING_block, 0, 0 },
 	/* landing */
-	{ 36, 0, 0, 0 },
-	{ 37, LANDING, RUNWAY_IN_block, 38 },
-	{ 38, 0, RUNWAY_IN_block, 39 },
-	{ 39, 0, RUNWAY_IN_block, 40 },
-	{ 40, ENDLANDING, RUNWAY_IN_block, 41 },
-	{ 41, 0, IN_WAY_block, 42 },
-	{ 42, 255, IN_WAY_block, 0 }, { 42, 255, TERM_GROUP1_block, 0 }, { 42, 255, TERM_GROUP1_block, 1 }, { 42, HANGAR, 0, 2 }, { 42, 0, 0, 26 },
+	{ 36, 0, 0, 0, 0 },
+	{ 37, LANDING, RUNWAY_IN_block, 0, 38 },
+	{ 38, 0, RUNWAY_IN_block, 0, 39 },
+	{ 39, 0, RUNWAY_IN_block, 0, 40 },
+	{ 40, ENDLANDING, RUNWAY_IN_block, 0, 41 },
+	{ 41, 0, IN_WAY_block, 0, 42 },
+	{ 42, 255, IN_WAY_block, 0, 0 }, { 42, 255, TERM_GROUP1_block, 0, 0 }, { 42, 255, TERM_GROUP1_block, 0, 1 }, { 42, HANGAR, 0, 0, 2 }, { 42, 0, 0, 0, 26 },
 	/* In Air */
-	{ 43, 0, 0, 44 },
-	{ 44, FLYING, 0, 45 }, { 44, HELILANDING, 0, 47 }, { 44, LANDING, 0, 69 }, { 44, 0, 0, 45 },
-	{ 45, 0, 0, 46 },
-	{ 46, FLYING, 0, 43 }, { 46, LANDING, 0, 76 }, { 46, 0, 0, 43 },
+	{ 43, 0, 0, 0, 44 },
+	{ 44, FLYING, 0, 0, 45 }, { 44, HELILANDING, 0, 0, 47 }, { 44, LANDING, 0, 0, 69 }, { 44, 0, 0, 0, 45 },
+	{ 45, 0, 0, 0, 46 },
+	{ 46, FLYING, 0, 0, 43 }, { 46, LANDING, 0, 0, 76 }, { 46, 0, 0, 0, 43 },
 	/* Helicopter -- stay in air in special place as a buffer to choose from helipads */
-	{ 47, HELILANDING, PRE_HELIPAD_block, 48 },
-	{ 48, HELIENDLANDING, PRE_HELIPAD_block, 48 }, { 48, HELIPAD1, 0, 49 }, { 48, HELIPAD2, 0, 50 }, { 48, HANGAR, 0, 55 },
-	{ 49, 0, NOTHING_block, 51 },
-	{ 50, 0, NOTHING_block, 52 },
+	{ 47, HELILANDING, PRE_HELIPAD_block, 0, 48 },
+	{ 48, HELIENDLANDING, PRE_HELIPAD_block, 0, 48 }, { 48, HELIPAD1, 0, 0, 49 }, { 48, HELIPAD2, 0, 0, 50 }, { 48, HANGAR, 0, 0, 55 },
+	{ 49, 0, NOTHING_block, 0, 51 },
+	{ 50, 0, NOTHING_block, 0, 52 },
 	/* landing */
-	{ 51, 255, NOTHING_block, 0 }, { 51, HELIPAD1, HELIPAD1_block, 12 }, { 51, HANGAR, 0, 55 }, { 51, 0, 0, 12 },
-	{ 52, 255, NOTHING_block, 0 }, { 52, HELIPAD2, HELIPAD2_block, 13 }, { 52, HANGAR, 0, 55 }, { 52, 0, 0, 13 },
+	{ 51, 255, NOTHING_block, 0, 0 }, { 51, HELIPAD1, HELIPAD1_block, 0, 12 }, { 51, HANGAR, 0, 0, 55 }, { 51, 0, 0, 0, 12 },
+	{ 52, 255, NOTHING_block, 0, 0 }, { 52, HELIPAD2, HELIPAD2_block, 0, 13 }, { 52, HANGAR, 0, 0, 55 }, { 52, 0, 0, 0, 13 },
 	/* Helicopter -- takeoff */
-	{ 53, HELITAKEOFF, NOTHING_block, 0 },
-	{ 54, HELITAKEOFF, NOTHING_block, 0 },
-	{ 55, 0, HANGAR2_AREA_block, 56 }, // need to go to hangar when waiting in air
-	{ 56, 0, HANGAR2_AREA_block, 3 },
+	{ 53, HELITAKEOFF, NOTHING_block, 0, 0 },
+	{ 54, HELITAKEOFF, NOTHING_block, 0, 0 },
+	{ 55, 0, HANGAR2_AREA_block, 0, 56 }, // need to go to hangar when waiting in air
+	{ 56, 0, HANGAR2_AREA_block, 0, 3 },
 	/* runway 2 out support */
-	{ 57, 255, OUT_WAY2_block, 0 }, { 57, TAKEOFF, 0, 58 }, { 57, 0, 0, 58 },
-	{ 58, 0, OUT_WAY2_block, 59 },
-	{ 59, TAKEOFF, RUNWAY_OUT2_block, 60 }, // takeoff
-	{ 60, 0, RUNWAY_OUT2_block, 61 },
-	{ 61, STARTTAKEOFF, NOTHING_block, 62 },
-	{ 62, ENDTAKEOFF, NOTHING_block, 0 },
+	{ 57, 255, OUT_WAY2_block, 0, 0 }, { 57, TAKEOFF, 0, 0, 58 }, { 57, 0, 0, 0, 58 },
+	{ 58, 0, OUT_WAY2_block, 0, 59 },
+	{ 59, TAKEOFF, RUNWAY_OUT2_block, 0, 60 }, // takeoff
+	{ 60, 0, RUNWAY_OUT2_block, 0, 61 },
+	{ 61, STARTTAKEOFF, NOTHING_block, 0, 62 },
+	{ 62, ENDTAKEOFF, NOTHING_block, 0, 0 },
 	/* runway 2 in support */
-	{ 63, LANDING, RUNWAY_IN2_block, 64 },
-	{ 64, 0, RUNWAY_IN2_block, 65 },
-	{ 65, 0, RUNWAY_IN2_block, 66 },
-	{ 66, ENDLANDING, RUNWAY_IN2_block, 0 }, { 66, 255, 0, 1 }, { 66, 255, 0, 0 }, { 66, 0, 0, 67 },
-	{ 67, 0, IN_WAY2_block, 68 },
-	{ 68, 255, IN_WAY2_block, 0 }, { 68, 255, TERM_GROUP2_block, 1 }, { 68, 255, TERM_GROUP1_block, 0 }, { 68, HANGAR, HANGAR2_AREA_block, 22 }, { 68, 0, 0, 22 },
-	{ 69, 255, RUNWAY_IN2_block, 0 }, { 69, 0, RUNWAY_IN2_block, 63 },
-	{ 70, 255, TERM_GROUP2_EXIT1_block, 0 }, { 70, HELIPAD1, HELIPAD1_block, 12 }, { 70, HELITAKEOFF, HELIPAD1_block, 12 }, { 70, 0, 0, 71 },
-	{ 71, 255, TERM_GROUP2_EXIT1_block, 0 }, { 71, HELIPAD2, HELIPAD2_block, 13 }, { 71, HELITAKEOFF, HELIPAD1_block, 12 }, { 71, 0, 0, 24 },
-	{ 72, 0, HELIPAD1_block, 53 },
-	{ 73, 0, HELIPAD2_block, 54 },
-	{ 74, HELITAKEOFF, NOTHING_block, 0 },
-	{ 75, HELITAKEOFF, NOTHING_block, 0 },
-	{ 76, 255, RUNWAY_IN_block, 0 }, { 76, 0, RUNWAY_IN_block, 37 },
-	{ MAX_ELEMENTS, 0, 0, 0 } // end marker. DO NOT REMOVE
+	{ 63, LANDING, RUNWAY_IN2_block, 0, 64 },
+	{ 64, 0, RUNWAY_IN2_block, 0, 65 },
+	{ 65, 0, RUNWAY_IN2_block, 0, 66 },
+	{ 66, ENDLANDING, RUNWAY_IN2_block, 0, 0 }, { 66, 255, 0, 0, 1 }, { 66, 255, 0, 0, 0 }, { 66, 0, 0, 0, 67 },
+	{ 67, 0, IN_WAY2_block, 0, 68 },
+	{ 68, 255, IN_WAY2_block, 0, 0 }, { 68, 255, TERM_GROUP2_block, 0, 1 }, { 68, 255, TERM_GROUP1_block, 0, 0 }, { 68, HANGAR, HANGAR2_AREA_block, 0, 22 }, { 68, 0, 0, 0, 22 },
+	{ 69, 255, RUNWAY_IN2_block, 0, 0 }, { 69, 0, RUNWAY_IN2_block, 0, 63 },
+	{ 70, 255, TERM_GROUP2_EXIT1_block, 0, 0 }, { 70, HELIPAD1, HELIPAD1_block, 0, 12 }, { 70, HELITAKEOFF, HELIPAD1_block, 0, 12 }, { 70, 0, 0, 0, 71 },
+	{ 71, 255, TERM_GROUP2_EXIT1_block, 0, 0 }, { 71, HELIPAD2, HELIPAD2_block, 0, 13 }, { 71, HELITAKEOFF, HELIPAD1_block, 0, 12 }, { 71, 0, 0, 0, 24 },
+	{ 72, 0, HELIPAD1_block, 0, 53 },
+	{ 73, 0, HELIPAD2_block, 0, 54 },
+	{ 74, HELITAKEOFF, NOTHING_block, 0, 0 },
+	{ 75, HELITAKEOFF, NOTHING_block, 0, 0 },
+	{ 76, 255, RUNWAY_IN_block, 0, 0 }, { 76, 0, RUNWAY_IN_block, 0, 37 },
+	{ MAX_ELEMENTS, 0, 0, 0, 0 } // end marker. DO NOT REMOVE
 };
 
+static const HangarTileTable _airport_depots_intercontinental2[] = { {{0, 1}, DIR_SE, 0}, {{11, 1}, DIR_SE, 1}  };
+static const byte _airport_terminal_intercontinental2[] = {2, 1, 2, 1, 2, 2};
+static const byte _airport_entries_intercontinental2[] = {55, 54, 56, 57};
+static const AirportFTAbuildup _airport_fta_intercontinental2[] = {
+  /* Hangars */
+	{  0, HANGAR, NOTHING_block, 0, 2 }, { 0, 255, 0, 0, 0}, { 0, 255, 0, 0, 1}, { 0, 255, 0, 0, 2}, { 0, 255, 0, 0, 3}, { 0, 255, 0, 0, 4}, { 0, 0, 0, 0, 2},
+  {  1, HANGAR, NOTHING_block, 0, 3 }, { 1, 255, TERM_GROUP1_block, 0, 4}, { 1, 255, TERM_GROUP1_block, 0, 3}, { 1, 255, TERM_GROUP1_block, 0, 2}, { 1, 255, TERM_GROUP1_block, 0, 1},  { 1, 255, TERM_GROUP1_block, 0, 0},  { 1, TAKEOFF, 0, 0, 3}, { 1, 0, TERM_GROUP1_block, 0, 3 },
+  /* Taxi */
+  {  2, 255,HANGAR1_AREA_block, 0, 0 }, { 2, HANGAR, 0, 0, 0 }, { 2, 0 ,0, 0, 12 },
+  {  3, 255,HANGAR2_AREA_block, 0, 0 }, { 3, HANGAR, 0, 0, 1 }, { 3, 0, 0, 0, 20 },
+  /* Terminals */
+  {  4, TERM1, TERM1_block, 0, 12 },
+	{  5, TERM2, TERM2_block, 0, 13 },
+	{  6, TERM3, TERM3_block, 0, 14 },
+  {  7, TERM4, TERM4_block, 0, 15 },
+  {  8, TERM5, TERM5_block, 0, 16 },
+  {  9, TERM6, TERM6_block, 0, 17 },
+  { 10, TERM7, TERM7_block, 0, 18 },
+  { 11, TERM8, TERM8_block, 0, 19 },
+  /* Taxi */
+  { 12, 255, NEW_block, 0, 0 }, { 12, TERM1, TERM1_block, 0, 4 }, { 12, 0,0, 0, 13 },
+	{ 13, 255, NEW2_block, 0, 0 }, { 13, TERM2, TERM2_block, 0, 5 }, { 13, 0,0, 0, 14 },
+	{ 14, 255, NEW3_block, 0, 0 }, { 14, TERM3, TERM3_block, 0, 6 }, { 14, 0, 0, 0, 15 },
+  { 15, 255, NEW4_block, 0, 0 }, { 15, TERM4, TERM4_block, 0, 7 }, { 15, 0, 0, 0, 29 },
+  { 16, 255, NEW5_block, 0, 0 }, { 16, TERM5, TERM5_block, 0, 8 }, { 16, 0, 0, 0, 17 },
+  { 17, 255, NEW6_block, 0, 0 }, { 17, TERM6, TERM6_block, 0, 9 }, { 17, 0,0, 0, 18 },
+  { 18, 255, NEW7_block, 0, 0 }, { 18, TERM7, TERM7_block, 0, 10 }, { 18, 0, 0, 0, 19 },
+  { 19, 255, NEW8_block, 0, 0 }, { 19, TERM8, TERM8_block, 0, 11 }, { 19, 0, 0, 0, 3},
+  { 20, 0, NEW9_block, 0, 21 },
+  { 21, 255, TERM_GROUP2_ENTER2_block, 0, 0 }, { 21, TAKEOFF,0, 0, 31 }, { 21, 0,TERM_GROUP1_block , 0, 22 },
+  { 22, 0, TERM_GROUP1_block , 0, 23 },
+  { 23, 255, NEW11_block, 0, 0 }, { 23, TERM7, 0, 0, 18 }, { 23, TERM8, 0, 0, 18 }, { 23, 0, 0, 0, 24 },
+  { 24, 255, NEW12_block, 0, 0 }, { 24, HANGAR,0, 0, 16 }, { 24, TERM5, 0, 0, 16 }, { 24, TERM6, 0, 0, 16 }, { 24, 0, 0, 0, 58 },
+  { 25, 255, NEW13_block, 0, 0 }, { 25, HANGAR, 0, 0, 26 }, { 25, TERM4, 0, 0, 15 }, { 25, HELIPAD1, 0, 0, 15 }, { 25, HELIPAD2, 0, 0, 15 }, { 25, 0, 0, 0, 26 },
+  { 26, 255, NEW14_block, 0, 0 }, { 26, HANGAR, 0, 0, 27 }, { 26, TERM2, 0, 0, 13 }, { 26, TERM3, 0, 0, 13 }, { 26, 0, 0, 0, 27 },
+  { 27, 0,TAXIWAY_BUSY_block, 0, 28 },
+  { 28, 0, TERM_GROUP2_ENTER1_block, 0, 2 },
+  { 29, 255, TERM_GROUP2_EXIT1_block, 0, 0 }, { 29, HELIPAD1, HELIPAD1_block, 0, 46 },  { 29, 0, 0, 0, 30 },
+  { 30, 255, TERM_GROUP2_EXIT2_block, 0, 0 }, { 30, HELIPAD2, HELIPAD2_block, 0, 47 },  { 30, 0, 0, 0, 16 },
+	{ 31, 0, NEW15_block, 0, 32 },
+	{ 32, 0, NEW16_block, 0, 33 },
+  { 33, 255, NEW17_block, 0, 0 }, { 33, 0, 0, 0, 34 }, { 33, 0, 0, 0, 35 },
+  { 34, 0, OUT_WAY_block, 0, 40 },
+  { 35, 0, OUT_WAY2_block, 0, 43 },
+  { 36, 0, IN_WAY_block, 0, 38 },
+  { 37, 0, IN_WAY2_block, 0, 38 },
+  { 38, 0, NEW18_block, 0, 39 },
+  { 39, 0, NEW19_block, 0, 27 },
+	/* takeoff */
+	{ 40, TAKEOFF, RUNWAY_OUT_block, 0, 41 },
+	{ 41, STARTTAKEOFF, NOTHING_block, 0, 42 },
+	{ 42, ENDTAKEOFF, NOTHING_block, 0, 0 },
+	/* takeoff 2 */
+	{ 43, TAKEOFF, OUT_WAY_block2, 0, 44 },
+	{ 44, STARTTAKEOFF, NOTHING_block, 0, 45 },
+	{ 45, ENDTAKEOFF, NOTHING_block, 0, 0 },
+  /* Helipads */
+  { 46, HELIPAD1, HELIPAD1_block, 0, 46 }, { 46, HANGAR, 0, 0, 29 }, { 46, HELITAKEOFF, 0, 0, 60 },
+	{ 47, HELIPAD2, HELIPAD2_block, 0, 47 }, { 47, HANGAR, 0, 0, 30 }, { 47, HELITAKEOFF, 0, 0, 61 },  
+	/* landing */
+	{ 48, FLYING, NOTHING_block, 0, 56 }, { 48, LANDING, 0, 0, 49 },  { 48, HELILANDING, 0, 0, 66 },
+	{ 49, LANDING, RUNWAY_IN_block, 0, 50 },
+	{ 50, ENDLANDING, RUNWAY_IN_block, 0, 0 }, { 50, 255, 0, 0, 0}, { 50, 255, 0, 0, 1}, { 50, 255, 0, 0, 2}, { 50, 255, 0, 0, 3}, { 50, 255, 0, 0, 4}, { 50, 0, 0, 0, 36},
+	/* landing 2 */
+	{ 51, FLYING, NOTHING_block, 0, 54 }, { 51, LANDING, 0, 0, 52 }, { 51, HELILANDING, 0, 0, 66 },
+	{ 52, LANDING, RUNWAY_IN2_block, 0, 53 },
+	{ 53, ENDLANDING, RUNWAY_IN2_block, 0, 0 }, { 53, 255, 0, 0, 0}, { 53, 255, 0, 0, 1}, { 53, 255, 0, 0, 2}, { 53, 255, 0, 0, 3}, { 53, 255, 0, 0, 4}, { 53, 0, 0, 0, 37},
+	/* In air */
+	{ 54, 0, NOTHING_block, 0, 55 },
+	{ 55, 0, NOTHING_block, 0, 72 },
+	{ 56, 0, NOTHING_block, 0, 57 },
+	{ 57, 0, NOTHING_block, 0, 71 },
+  /* Taxi */
+  { 58, 0, NEW20_block, 0, 59 },
+  { 59, 255, TERM_GROUP2_block, 0, 0 }, {  59, HELITAKEOFF, 0, 0, 70 }, {  59, 0, 0, 0, 25 },
+  /* Helitakeoff */ 
+  { 60, 0, HELIPAD1_block, 0, 62 },
+  { 61, 0, HELIPAD2_block, 0, 63 },
+  { 62, HELITAKEOFF, NOTHING_block, 0, 0 },
+  { 63, HELITAKEOFF, NOTHING_block, 0, 0 },
+  /* Landing */
+	{ 64, 255, NOTHING_block, 0, 0 }, { 64, HELIPAD1, HELIPAD1_block, 0, 46 },
+	{ 65, 255, NOTHING_block, 0, 0 }, { 65, HELIPAD2, HELIPAD2_block, 0, 47 },
+	/* Helicopter -- stay in air in special place as a buffer to choose from helipads */
+	{ 66, HELILANDING, PRE_HELIPAD_block, 0, 67 },
+	{ 67, HELIENDLANDING, PRE_HELIPAD_block, 0, 67 }, { 67, HELIPAD1, 0, 0, 68 }, { 67, HELIPAD2, 0, 0, 69 }, { 67, HANGAR, 0, 0, 73 },
+	{ 68, 0, NOTHING_block, 0, 64 }, // helipad1 approach
+	{ 69, 0, NOTHING_block, 0, 65 },
+  { 70, HELITAKEOFF, NOTHING_block, 0, 0 },
+	{ 71, 0, NOTHING_block, 0, 51 },
+	{ 72, 0, NOTHING_block, 0, 48 },
+	{ 73, 0, HANGAR2_AREA_block, 0, 74 },
+	{ 74, 0, HANGAR2_AREA_block, 0, 3 },
+	{ MAX_ELEMENTS, 0, 0, 0, 0 } // end marker. DO NOT REMOVE
+};
+
+static const HangarTileTable _airport_depots_circle[] = {{ {6, 6}, DIR_SW, 0 }, {{6, 8}, DIR_NW, 1 }, {{8, 6}, DIR_SE, 2 }, {{8, 8}, DIR_NE, 3 } };
+static const byte _airport_terminal_circle[] = {4, 2, 2, 1, 2, 2, 1, 2, 2, 1, 2, 2, 1 };
+static const byte _airport_entries_circle[] = {163, 162, 161, 160};
+static const AirportFTAbuildup _airport_fta_circle[] = {
+  /* Hangars */
+  { 0, HANGAR, NOTHING_block, 0, 4 }, { 0, 255, HANGAR1_AREA_block | NEW12_block, 0, 4 }, { 0, 255, HANGAR1_AREA_block | NEW11_block | NEW12_block, NEW4_block, 5 }, { 0, 255, HANGAR1_AREA_block | NEW11_block | NEW12_block, NEW4_block, 6 }, { 0, 255, HANGAR1_AREA_block | NEW11_block | NEW12_block, NEW4_block, 7 }, { 0, 255, HANGAR1_AREA_block | NEW11_block | NEW12_block, NEW4_block, 8 }, { 0, 255, HANGAR1_AREA_block | NEW11_block | NEW12_block, NEW4_block, 9 }, { 0, 255, HANGAR1_AREA_block | NEW11_block | NEW12_block, NEW4_block, 10 }, { 0, 255, HANGAR1_AREA_block | NEW11_block | NEW12_block, NEW4_block, 11 }, { 0, 255, HANGAR1_AREA_block | NEW11_block | NEW12_block, NEW4_block, 0 }, { 0, 255, HANGAR1_AREA_block | NEW11_block | NEW12_block, NEW4_block, 1 }, { 0, 255, HANGAR1_AREA_block | NEW11_block | NEW12_block, NEW4_block, 2 }, { 0, 255, HANGAR1_AREA_block | NEW11_block | NEW12_block, NEW4_block, 3 }, { 0, TERM8, HANGAR1_AREA_block | NEW12_block, 0, 4 }, { 0, TERM9, HANGAR1_AREA_block | NEW12_block, 0, 4 }, { 0, TAKEOFF, HANGAR1_AREA_block | NEW12_block, CIRCLE_block, 4 }, { 0, 0, HANGAR1_AREA_block | NEW12_block, NEW4_block | CIRCLE_block, 4 }, 
+  { 1, HANGAR, NOTHING_block, 0, 5 }, { 1, 255, HANGAR2_AREA_block | NEW5_block, 0, 1 }, { 1, 255, HANGAR2_AREA_block | NEW4_block | NEW5_block, NEW2_block, 2 }, { 1, 255, HANGAR2_AREA_block | NEW4_block | NEW5_block, NEW2_block, 3 }, { 1, 255, HANGAR2_AREA_block | NEW4_block | NEW5_block, NEW2_block, 4 }, { 1, 255, HANGAR2_AREA_block | NEW4_block | NEW5_block, NEW2_block, 5 }, { 1, 255, HANGAR2_AREA_block | NEW4_block | NEW5_block, NEW2_block, 6 }, { 1, 255, HANGAR2_AREA_block | NEW4_block | NEW5_block, NEW2_block, 7 }, { 1, 255, HANGAR2_AREA_block | NEW4_block | NEW5_block, NEW2_block, 8 }, { 1, 255, HANGAR2_AREA_block | NEW4_block | NEW5_block, NEW2_block, 9 }, { 1, 255, HANGAR2_AREA_block | NEW4_block | NEW5_block, NEW2_block, 10 }, { 1, 255, HANGAR2_AREA_block | NEW4_block | NEW5_block, NEW2_block, 11 }, { 1, 255, HANGAR2_AREA_block | NEW4_block | NEW5_block, NEW2_block, 0 }, { 1, TERM3, HANGAR2_AREA_block | NEW5_block, 0, 5 }, { 1, TERM4, HANGAR2_AREA_block | NEW5_block, 0, 5 }, { 1, TAKEOFF, HANGAR2_AREA_block | NEW5_block, CIRCLE_block, 5 }, { 1, 0, HANGAR2_AREA_block | NEW5_block, NEW2_block | CIRCLE_block, 5 },
+  { 2, HANGAR, NOTHING_block, 0, 6 }, { 2, 255, NEW19_block, HANGAR1_AREA_block, 7 }, { 2, 255, NEW18_block | NEW19_block, HANGAR1_AREA_block | NEW6_block, 8 }, { 2, 255, NEW18_block | NEW19_block, HANGAR1_AREA_block | NEW6_block, 9 }, { 2, 255, NEW18_block | NEW19_block, HANGAR1_AREA_block | NEW6_block, 10 }, { 2, 255, NEW18_block | NEW19_block, HANGAR1_AREA_block | NEW6_block, 11 }, { 2, 255, NEW18_block | NEW19_block, HANGAR1_AREA_block | NEW6_block, 0 }, { 2, 255, NEW18_block | NEW19_block, HANGAR1_AREA_block | NEW6_block, 1 }, { 2, 255, NEW18_block | NEW19_block, HANGAR1_AREA_block | NEW6_block, 2 }, { 2, 255, NEW18_block | NEW19_block, HANGAR1_AREA_block | NEW6_block, 3 }, { 2, 255, NEW18_block | NEW19_block, HANGAR1_AREA_block | NEW6_block, 4 }, { 2, 255, NEW18_block | NEW19_block, HANGAR1_AREA_block | NEW6_block, 5 }, { 2, 255, NEW18_block | NEW19_block, HANGAR1_AREA_block | NEW6_block, 6 }, { 2, TERM13, NEW19_block, HANGAR1_AREA_block, 6 }, { 2, TERM14, NEW19_block, HANGAR1_AREA_block, 6 }, { 2, TAKEOFF, NEW19_block, HANGAR1_AREA_block | CIRCLE_block, 6 }, { 2, 0, NEW19_block, HANGAR1_AREA_block | NEW6_block | CIRCLE_block, 6 }, 
+  { 3, HANGAR, NOTHING_block, 0, 7 }, { 3, 255, TERM_GROUP2_EXIT2_block, HANGAR2_AREA_block, 10 }, { 3, 255, TERM_GROUP2_EXIT1_block | TERM_GROUP2_EXIT2_block, HANGAR2_AREA_block | NEW8_block, 11 }, { 3, 255, TERM_GROUP2_EXIT1_block | TERM_GROUP2_EXIT2_block, HANGAR2_AREA_block | NEW8_block, 0 }, { 3, 255, TERM_GROUP2_EXIT1_block | TERM_GROUP2_EXIT2_block, HANGAR2_AREA_block | NEW8_block, 1 }, { 3, 255, TERM_GROUP2_EXIT1_block | TERM_GROUP2_EXIT2_block, HANGAR2_AREA_block | NEW8_block, 2 }, { 3, 255, TERM_GROUP2_EXIT1_block | TERM_GROUP2_EXIT2_block, HANGAR2_AREA_block | NEW8_block, 3 }, { 3, 255, TERM_GROUP2_EXIT1_block | TERM_GROUP2_EXIT2_block, HANGAR2_AREA_block | NEW8_block, 4 }, { 3, 255, TERM_GROUP2_EXIT1_block | TERM_GROUP2_EXIT2_block, HANGAR2_AREA_block | NEW8_block, 5 }, { 3, 255, TERM_GROUP2_EXIT1_block | TERM_GROUP2_EXIT2_block, HANGAR2_AREA_block | NEW8_block, 6 }, { 3, 255, TERM_GROUP2_EXIT1_block | TERM_GROUP2_EXIT2_block, HANGAR2_AREA_block | NEW8_block, 7 }, { 3, 255, TERM_GROUP2_EXIT1_block | TERM_GROUP2_EXIT2_block, HANGAR2_AREA_block | NEW8_block, 8 }, { 3, 255, TERM_GROUP2_EXIT1_block | TERM_GROUP2_EXIT2_block, HANGAR2_AREA_block | NEW8_block, 9 }, { 3, TERM18, TERM_GROUP2_EXIT2_block, HANGAR2_AREA_block, 7 }, { 3, TERM19, TERM_GROUP2_EXIT2_block, HANGAR2_AREA_block, 7 }, { 3, TAKEOFF, TERM_GROUP2_EXIT2_block, HANGAR2_AREA_block | CIRCLE_block, 7 }, { 3, 0, TERM_GROUP2_EXIT2_block, HANGAR2_AREA_block | NEW8_block | CIRCLE_block, 7 }, 
+  { 4, 255, HANGAR1_AREA_block, 0, 0 }, { 4, HANGAR, 0, 0, 0 }, { 4, 0, NEW12_block, 0, 39 },   
+  { 5, 255, HANGAR2_AREA_block, 0, 0 }, { 5, HANGAR, 0, 0, 1 }, { 5, 0, NEW5_block, 0, 32 },   
+  { 6, 255, 0, HANGAR1_AREA_block, 0 }, { 6, HANGAR, 0, 0, 2 }, { 6, 0, NEW19_block, 0, 46 },   
+  { 7, 255, 0, HANGAR2_AREA_block, 0 }, { 7, HANGAR, 0, 0, 3 }, { 7, 0, TERM_GROUP2_EXIT2_block, 0, 53 },    
+  /* Terminals */
+  { 8, TERM1, TERM1_block, 0, 28 }, { 8, TAKEOFF, 0, 0, 28 }, { 8, 0, 0, 0, 29 },          
+	{ 9, TERM2, TERM2_block, 0, 30 },          
+	{ 10, TERM3, TERM3_block, 0, 31 }, { 10, HANGAR, 0, 0, 32 }, { 10, 0, 0, 0, 31 },          
+  { 11, TERM4, TERM4_block, 0, 33 }, { 11, HANGAR, 0, 0, 32 }, { 11, 0, 0, 0, 33 },        
+  { 12, TERM5, TERM5_block, 0, 34 },            
+  { 13, TERM6, TERM6_block, 0, 36 }, { 13, TAKEOFF, 0, 0, 35 }, { 13, 0, 0, 0, 36 },          
+  { 14, TERM7, TERM7_block, 0, 37 },          
+  { 15, TERM8, TERM8_block, 0, 38 }, { 15, HANGAR, 0, 0, 39 }, { 15, 0, 0, 0, 38 },           
+  { 16, TERM9, TERM9_block, 0, 40 }, { 16, HANGAR, 0, 0, 39 }, { 16, 0, 0, 0, 40 },            
+	{ 17, TERM10, TERM10_block, 0, 41 },        
+	{ 18, TERM11, TERM11_block, 0, 43 }, { 18, TAKEOFF, 0, 0, 42 }, { 18, 0, 0, 0, 43 },          
+  { 19, TERM12, TERM12_block, 0, 44 },         
+  { 20, TERM13, TERM13_block, 0, 45 }, { 20, HANGAR, 0, 0, 46 }, { 20, 0, 0, 0, 45 },          
+  { 21, TERM14, TERM14_block, 0, 47 }, { 21, HANGAR, 0, 0, 46 }, { 21, 0, 0, 0, 47 },         
+  { 22, TERM15, TERM15_block, 0, 48 },         
+  { 23, TERM16, TERM16_block, 0, 50 }, { 23, TAKEOFF, 0, 0, 49 }, { 23, 0, 0, 0, 50 },          
+  { 24, TERM17, TERM17_block, 0, 51 },          
+	{ 25, TERM18, TERM18_block, 0, 52 }, { 25, HANGAR, 0, 0, 53 }, { 25, 0, 0, 0, 52 },    
+	{ 26, TERM19, TERM19_block, 0, 54 }, { 26, HANGAR, 0, 0, 53 }, { 26, 0, 0, 0, 54 },        
+  { 27, TERM20, TERM20_block, 0, 55 },          
+  /* Terminals Taxi */
+  { 28, 255, NEW_block, CIRCLE_block, 0 }, { 28, TERM1, TERM1_block, 0, 8 }, { 28, 0, 0, CIRCLE_block, 56 },
+	{ 29, 255, NEW2_block, CIRCLE_block, 0 }, { 29, TERM1, TERM1_block, 0, 8 }, { 29, 0,0, CIRCLE_block, 30 },
+	{ 30, 255, NEW3_block, CIRCLE_block, 0 }, { 30, TERM2, TERM2_block, 0, 9 }, { 30, 0, 0, CIRCLE_block, 31 },
+  { 31, 255, NEW4_block, CIRCLE_block, 0 }, { 31, TERM3, TERM3_block, 0, 10 }, { 31, 0, 0, CIRCLE_block, 57 }, 
+  { 32, 255, NEW5_block, 0, 0 }, { 32, TERM3, TERM3_block, 0, 10 }, { 32, TERM4, TERM4_block, 0, 11 }, { 32, HANGAR, 0, 0, 5 }, { 32, TAKEOFF, 0, CIRCLE_block, 57 }, { 32, 0, 0, NEW2_block | CIRCLE_block, 57 }, 
+  { 33, 255, NEW6_block, CIRCLE_block, 0 }, { 33, TERM4, TERM4_block, 0, 11 }, { 33, 0, 0, CIRCLE_block, 34 }, 
+  { 34, 255, NEW7_block, CIRCLE_block, 0 }, { 34, TERM5, TERM5_block, 0, 12 }, { 34, TAKEOFF, NEW7_block, 0, 70 }, { 34, TAKEOFF, 0, CIRCLE_block, 35 }, { 34, 0, 0, CIRCLE_block, 35 },  
+  { 35, 255, NEW8_block, CIRCLE_block, 0 }, { 35, TERM6, TERM6_block, 0, 13 }, { 35, 0, 0, CIRCLE_block, 58},
+	{ 36, 255, NEW9_block, CIRCLE_block, 0 }, { 36, TERM6, TERM6_block, 0, 13 }, { 36, 0, 0, CIRCLE_block, 37 },
+	{ 37, 255, NEW10_block, CIRCLE_block, 0 }, { 37, TERM7, TERM7_block, 0, 14 }, { 37, 0, 0, CIRCLE_block, 38 },
+  { 38, 255, NEW11_block, CIRCLE_block, 0 }, { 38, TERM8, TERM8_block, 0, 15 }, { 38, 0 , 0, CIRCLE_block, 59 },
+  { 39, 255, NEW12_block, 0, 0 }, { 39, TERM8, TERM8_block, 0, 15 }, { 39, TERM9, TERM9_block, 0, 16 }, { 39, HANGAR, 0, 0, 4 }, { 39, TAKEOFF, 0, CIRCLE_block, 59 },  { 39, 0, 0, NEW4_block | CIRCLE_block, 59 }, 
+  { 40, 255, NEW13_block, CIRCLE_block, 0 }, { 40, TERM9, TERM9_block, 0, 16 }, { 40, 0, 0, CIRCLE_block, 41 }, 
+  { 41, 255, NEW14_block, CIRCLE_block, 0 }, { 41, TERM10, TERM10_block, 0, 17 }, { 41, TAKEOFF, NEW14_block, 0, 80 }, { 41, TAKEOFF, 0, CIRCLE_block, 42 }, { 41, 0, 0, CIRCLE_block, 42 },  
+  { 42, 255, NEW15_block, CIRCLE_block, 0 }, { 42, TERM11, TERM11_block, 0, 18 }, { 42, 0, 0, CIRCLE_block, 60},
+	{ 43, 255, NEW16_block, CIRCLE_block, 0 }, { 43, TERM11, TERM11_block, 0, 18 }, { 43, 0, 0, CIRCLE_block, 44 },
+	{ 44, 255, NEW17_block, CIRCLE_block, 0 }, { 44, TERM12, TERM12_block, 0, 19 }, { 44, 0, 0, CIRCLE_block, 45 },
+  { 45, 255, NEW18_block, CIRCLE_block, 0 }, { 45, TERM13, TERM13_block, 0, 20 }, { 45, 0, 0, CIRCLE_block, 61 }, 
+  { 46, 255, NEW19_block, 0, 0 }, { 46, TERM13, TERM13_block, 0, 20 }, { 46, TERM14, TERM14_block, 0, 21 }, { 46, HANGAR, 0, 0, 6 }, { 46, TAKEOFF, 0, CIRCLE_block, 61 }, { 46, 0, 0, NEW6_block | CIRCLE_block, 61 }, 
+  { 47, 255, NEW20_block, CIRCLE_block, 0 }, { 47, TERM14, TERM14_block, 0, 21 }, { 47, 0, 0, CIRCLE_block, 48 }, 
+  { 48, 255, TERM_GROUP1_block, CIRCLE_block, 0 }, { 48, TERM15, TERM15_block, 0, 22 }, { 48, TAKEOFF, TERM_GROUP1_block, 0, 90 }, { 48, TAKEOFF, 0, CIRCLE_block, 49 }, { 48, 0, 0, CIRCLE_block, 49 },  
+  { 49, 255, TERM_GROUP2_block, CIRCLE_block, 0 }, { 49, TERM16, TERM16_block, 0, 23 }, { 49, 0, 0, CIRCLE_block, 62}, 
+	{ 50, 255, TERM_GROUP2_ENTER1_block, CIRCLE_block, 0 }, { 50, TERM16, TERM16_block, 0, 23 }, { 50, 0, 0, CIRCLE_block, 51 },
+	{ 51, 255, TERM_GROUP2_ENTER2_block, CIRCLE_block, 0 }, { 51, TERM17, TERM17_block, 0, 24 }, { 51, 0, 0, CIRCLE_block, 52 },
+  { 52, 255, TERM_GROUP2_EXIT1_block, CIRCLE_block, 0 }, { 52, TERM18, TERM18_block, 0, 25 }, { 52, 0, 0, CIRCLE_block, 63 }, 
+  { 53, 255, TERM_GROUP2_EXIT2_block, 0, 0 }, { 53, TERM18, TERM18_block, 0, 25 }, { 53, TERM19, TERM19_block, 0, 26 }, { 53, HANGAR, 0, 0, 7 }, { 53, TAKEOFF, 0, CIRCLE_block, 63 }, { 53, 0, 0, NEW8_block | CIRCLE_block, 63 }, 
+  { 54, 255, PRE_HELIPAD_block, CIRCLE_block, 0 }, { 54, TERM19, TERM19_block, 0, 26 }, { 54, 0, 0, CIRCLE_block, 55 }, 
+  { 55, 255, HELIPAD_GROUP_block, CIRCLE_block, 0 }, { 55, TERM20, TERM20_block, 0, 27 }, { 55, TAKEOFF, HELIPAD_GROUP_block, 0, 100 }, { 55, TAKEOFF, 0, CIRCLE_block, 28 }, { 55, 0, 0, CIRCLE_block, 28 },  
+  /* Taxi circle 1*/
+  { 56, 255, 0, NEW_block | CIRCLE_block, 0 }, { 56, TAKEOFF, 0, NEW_block, 102 }, { 56, TAKEOFF, 0, CIRCLE_block, 29 },  { 56, HELITAKEOFF, 0, 0, 168 }, { 56, HELITAKEOFF, 0, CIRCLE_block, 29 }, { 56, 0, 0, CIRCLE_block, 29 }, 
+	{ 57, 255, 0, NEW2_block | CIRCLE_block, 0 }, { 57, TAKEOFF, 0, NEW2_block, 67 }, { 57, TAKEOFF, 0, CIRCLE_block, 33 }, { 57, HANGAR, 0, 0, 32 }, { 57, HANGAR, 0, CIRCLE_block, 33 }, { 57, 0, 0, CIRCLE_block, 33 },
+	{ 58, 255, 0, NEW3_block | CIRCLE_block, 0 }, { 58, TAKEOFF, 0, NEW3_block, 72 }, { 58, TAKEOFF, 0, CIRCLE_block, 36 }, { 58, HELITAKEOFF, 0, 0, 164 }, { 58, HELITAKEOFF, 0, CIRCLE_block, 36 }, { 58, 0, 0, CIRCLE_block, 36 },
+  { 59, 255, 0, NEW4_block | CIRCLE_block, 0 }, { 59, TAKEOFF, 0, NEW4_block, 77 }, { 59, TAKEOFF, 0, CIRCLE_block, 40 }, { 59, HANGAR, 0, 0, 39 }, { 59, HANGAR, 0, CIRCLE_block, 40 }, { 59, 0, 0, CIRCLE_block, 40 },
+  { 60, 255, 0, NEW5_block | CIRCLE_block, 0 }, { 60, TAKEOFF, 0, NEW5_block, 82 }, { 60, TAKEOFF, 0, CIRCLE_block, 43 }, { 60, HELITAKEOFF, 0, 0, 170 }, { 60, HELITAKEOFF, 0, CIRCLE_block, 43 }, { 60, 0, 0, CIRCLE_block, 43 }, 
+	{ 61, 255, 0, NEW6_block | CIRCLE_block, 0 }, { 61, TAKEOFF, 0, NEW6_block, 87 }, { 61, TAKEOFF, 0, CIRCLE_block, 47 }, { 61, HANGAR, 0, 0, 46 }, { 61, HANGAR, 0, CIRCLE_block, 47 }, { 61, 0, 0, CIRCLE_block, 47 }, 
+	{ 62, 255, 0, NEW7_block | CIRCLE_block, 0 }, { 62, TAKEOFF, 0, NEW7_block, 92 }, { 62, TAKEOFF, 0, CIRCLE_block, 50 }, { 62, HELITAKEOFF, 0, 0, 166 }, { 62, HELITAKEOFF, 0, CIRCLE_block, 50 }, { 62, 0, 0, CIRCLE_block, 50 },
+  { 63, 255, 0, NEW8_block | CIRCLE_block, 0 }, { 63, TAKEOFF, 0, NEW8_block, 97 }, { 63, TAKEOFF, 0, CIRCLE_block, 54 }, { 63, HANGAR, 0, 0, 53 }, { 63, HANGAR, 0, CIRCLE_block, 54 }, { 63, 0, 0, CIRCLE_block, 54 },
+  /* Taxi circle 2*/
+  { 64, 255, 0, NEW9_block, 0 }, { 64, 0, 0, NEW9_block, 65 },
+  { 65, 255, 0, NEW9_block | NEW_block | CIRCLE_block, 0 }, { 65, 0, 0, NEW_block | CIRCLE_block, 56 },
+  { 66, 0, 0, NEW10_block, 30 },
+  { 67, 255, 0, NEW2_block | NEW11_block, 0 }, { 67, 0, 0, NEW11_block, 68 },
+  { 68, 255, 0, NEW11_block, 0 }, { 68, 0, 0, NEW11_block, 69 }, 
+  { 69, 255, 0, TERM3_block | NEW11_block, 0 }, { 69, 0, 0, TERM3_block, 108 }, 
+  { 70, 255, NEW7_block, NEW12_block, 0 }, { 70, 0, 0, NEW12_block, 71 },
+  { 71, 0, 0, NEW12_block, 106 },  
+  { 72, 255, 0, NEW3_block | NEW13_block, 0 }, { 72, 0, 0, NEW13_block, 73 },
+  { 73, 0, 0, NEW13_block, 104 },   
+  { 74, 255, 0, NEW14_block, 0 }, { 74, 0, 0, NEW14_block, 75 },
+  { 75, 255, 0, NEW14_block | NEW3_block | CIRCLE_block, 0 }, { 75, 0, 0, NEW3_block | CIRCLE_block, 58 },
+  { 76, 0, 0, NEW15_block, 37 },
+  { 77, 255, 0, NEW4_block | NEW16_block, 0 }, { 77, 0, 0, NEW16_block, 78 },  
+  { 78, 255, 0, NEW16_block, 0 }, { 78, 0, 0,NEW16_block, 79 },  
+  { 79, 255, 0, NEW16_block | TERM7_block, 0 }, { 79, 0, 0, TERM7_block, 116 },
+  { 80, 255, NEW14_block, NEW17_block, 0 }, { 80, 0, 0, NEW17_block, 81 },
+  { 81, 0, 0, NEW17_block, 114 },  
+  { 82, 255, 0, NEW5_block | NEW18_block, 0 }, { 82, 0, 0, NEW18_block, 83 },
+  { 83, 0, 0, NEW18_block, 112 },   
+  { 84, 255, 0, NEW19_block, 0 }, { 84, 0, 0, NEW19_block, 85 },
+  { 85, 255, 0, NEW19_block | NEW5_block | CIRCLE_block, 0 }, { 85, 0, 0, NEW5_block | CIRCLE_block, 60 },
+  { 86, 0, 0, NEW20_block, 44 },
+  { 87, 255, 0, NEW6_block | TERM_GROUP1_block, 0 }, { 87, 0, 0, TERM_GROUP1_block, 88 },  
+  { 88, 255, 0, TERM_GROUP1_block, 0 }, { 88, 0, 0, TERM_GROUP1_block, 89 },  
+  { 89, 255, 0, TERM_GROUP1_block | TERM11_block, 0 }, { 89, 0, 0, TERM11_block, 124 },  
+  { 90, 255, TERM_GROUP1_block, TERM_GROUP2_block, 0 }, { 90, 0, 0, TERM_GROUP2_block, 91 },
+  { 91, 0, 0, TERM_GROUP2_block, 122 }, 
+  { 92, 255, 0, NEW7_block | TERM_GROUP2_ENTER1_block, 0 }, { 92, 0, 0, TERM_GROUP2_ENTER1_block, 93 },
+  { 93, 0, 0, TERM_GROUP2_ENTER1_block, 120 },  
+  { 94, 255, 0, TERM_GROUP2_ENTER2_block, 0 }, { 94, 0, 0, TERM_GROUP2_ENTER2_block, 95 },
+  { 95, 255, 0, TERM_GROUP2_ENTER2_block | NEW7_block | CIRCLE_block, 0 }, { 95, 0, 0, NEW7_block | CIRCLE_block, 62 },
+  { 96, 0, 0, TERM_GROUP2_EXIT1_block, 51 },
+  { 97, 255, 0, NEW8_block | TERM_GROUP2_EXIT2_block, 0 }, { 97, 0, 0, TERM_GROUP2_EXIT2_block, 98 },  
+  { 98, 255, 0, TERM_GROUP2_EXIT2_block, 0 },  { 98, 0, 0, TERM_GROUP2_EXIT2_block, 99 },  
+  { 99, 255, 0, TERM_GROUP2_EXIT2_block | TERM15_block, 0 }, { 99, 0, 0, TERM15_block, 132 },  
+  {100, 255, HELIPAD_GROUP_block, PRE_HELIPAD_block, 0 }, { 100, 0, 0, PRE_HELIPAD_block, 101 },
+  {101, 0, 0, PRE_HELIPAD_block, 130 },  
+  {102, 255, 0, NEW_block | HELIPAD_GROUP_block, 0 }, {102, 0, 0, HELIPAD_GROUP_block, 103 },
+  {103, 0, 0, HELIPAD_GROUP_block, 128 },   
+  /* Taxi circle 3*/
+  {104, 0, 0, TERM1_block, 105 },
+  {105, 0, 0, TERM1_block, 106 },
+  {106, 0, 0, TERM2_block, 107 },
+  {107, 0, 0, TERM2_block, 108 },
+  {108, 0, 0, TERM3_block, 136 },
+  {109, 255, RUNWAY_IN_block, TERM4_block, 0 }, {109, TERM1, 0, TERM4_block, 111 }, {109, 0, 0, TERM4_block, 110 },
+  {110, 0, 0, TERM4_block, 66 },
+  {111, 0, 0, TERM4_block, 64 },
+  {112, 0, 0, TERM5_block, 113 },
+  {113, 0, 0, TERM5_block, 114 },
+  {114, 0, 0, TERM6_block, 115 },
+  {115, 0, 0, TERM6_block, 116 },
+  {116, 0, 0, TERM7_block, 139 }, 
+  {117, 255, RUNWAY_IN2_block, TERM8_block, 0 }, {117, TERM6, 0, TERM8_block, 119 }, {117, 0, 0, TERM8_block, 118 },
+  {118, 0, 0, TERM8_block, 76 },
+  {119, 0, 0, TERM8_block, 74 },
+  {120, 0, 0, TERM9_block, 121 },
+  {121, 0, 0, TERM9_block, 122 },
+  {122, 0, 0, TERM10_block, 123 },
+  {123, 0, 0, TERM10_block, 124 },
+  {124, 0, 0, TERM11_block, 142 }, 
+  {125, 255, IN_WAY_block, TERM12_block, 0 }, {125, TERM11, 0, TERM12_block, 127 }, {125, 0, 0, TERM12_block, 126 },
+  {126, 0, 0, TERM12_block, 86 },
+  {127, 0, 0, TERM12_block, 84 },
+  {128, 0, 0, TERM13_block, 129 },
+  {129, 0, 0, TERM13_block, 130 },
+  {130, 0, 0, TERM14_block, 131 },
+  {131, 0, 0, TERM14_block, 132 },
+  {132, 0, 0, TERM15_block, 145 }, 
+  {133, 255, IN_WAY2_block, TERM16_block, 0 }, {133, TERM16, 0, TERM16_block, 135 }, {133, 0, 0, TERM16_block, 134 },
+  {134, 0, 0, TERM16_block, 96 },
+  {135, 0, 0, TERM16_block, 94 },
+  /* takeoff */
+	{ 136, TAKEOFF, RUNWAY_OUT_block, 0, 137 },
+	{ 137, STARTTAKEOFF, NOTHING_block, 0, 138 },
+	{ 138, ENDTAKEOFF, NOTHING_block, 0, 0 },
+	{ 139, TAKEOFF, OUT_WAY_block2, 0, 140 },
+	{ 140, STARTTAKEOFF, NOTHING_block, 0, 141 },
+	{ 141, ENDTAKEOFF, NOTHING_block, 0, 0 },
+	{ 142, TAKEOFF, OUT_WAY_block, 0, 143 },
+	{ 143, STARTTAKEOFF, NOTHING_block, 0, 144 },
+	{ 144, ENDTAKEOFF, NOTHING_block, 0, 0 },
+	{ 145, TAKEOFF, OUT_WAY2_block, 0, 146 },
+	{ 146, STARTTAKEOFF, NOTHING_block, 0, 147 },
+	{ 147, ENDTAKEOFF, NOTHING_block, 0, 0 },
+  /* landing */
+	{ 148, FLYING, NOTHING_block, 0, 161 },	{ 148, LANDING, 0, 0, 149 }, { 148, HELILANDING, 0, 0, 172 },
+	{ 149, LANDING, RUNWAY_IN_block, 0, 150 },
+	{ 150, ENDLANDING, RUNWAY_IN_block, 0, 0 }, { 150, 255, 0, 0, 0}, { 150, 255, 0, 0, 1}, { 150, 255, 0, 0, 2}, { 150, 255, 0, 0, 3}, { 150, 255, 0, 0, 4}, { 150, 255, 0, 0, 5}, { 150, 255, 0, 0, 6}, { 150, 255, 0, 0, 7}, { 150, 255, 0, 0, 8},{ 150, 255, 0, 0, 9}, { 150, 255, 0, 0, 10}, { 150, 255, 0, 0, 11}, { 150, 0, RUNWAY_IN_block, 0, 109 },
+	{ 151, FLYING, NOTHING_block, 0, 162 },	{ 151, LANDING, 0, 0, 152 },
+	{ 152, LANDING, RUNWAY_IN2_block, 0, 153 },
+	{ 153, ENDLANDING, RUNWAY_IN2_block, 0, 0 }, { 153, 255, 0, 0, 3}, { 153, 255, 0, 0, 4}, { 153, 255, 0, 0, 5}, { 153, 255, 0, 0, 6}, { 153, 255, 0, 0, 7}, { 153, 255, 0, 0, 8}, { 153, 255, 0, 0, 9}, { 153, 255, 0, 0, 10}, { 153, 255, 0, 0, 11}, { 153, 255, 0, 0, 0}, { 153, 255, 0, 0, 1}, { 153, 255, 0, 0, 2}, { 153, 0, RUNWAY_IN2_block, 0, 117 },
+	{ 154, FLYING, NOTHING_block, 0, 163 },	{ 154, LANDING, 0, 0, 155 }, { 154, HELILANDING, 0, 0, 174 },
+	{ 155, LANDING, IN_WAY_block, 0, 156 },
+	{ 156, ENDLANDING, IN_WAY_block, 0, 0 }, { 156, 255, 0, 0, 6},{ 156, 255, 0, 0, 7}, { 156, 255, 0, 0, 8}, { 156, 255, 0, 0, 9}, { 156, 255, 0, 0, 10}, { 156, 255, 0, 0, 11}, { 156, 255, 0, 0, 0}, { 156, 255, 0, 0, 1}, { 156, 255, 0, 0, 2}, { 156, 255, 0, 0, 3}, { 156, 255, 0, 0, 4}, { 156, 255, 0, 0, 5}, { 156, 0, IN_WAY_block, 0, 125 },
+	{ 157, FLYING, NOTHING_block, 0, 160 },	{ 157, LANDING, 0, 0, 158 },
+	{ 158, LANDING, IN_WAY2_block, 0, 159 },
+	{ 159, ENDLANDING, IN_WAY2_block, 0, 0 }, { 159, 255, 0, 0, 9}, { 159, 255, 0, 0, 10},{ 159, 255, 0, 0, 11}, { 159, 255, 0, 0, 0}, { 159, 255, 0, 0, 1}, { 159, 255, 0, 0, 2}, { 159, 255, 0, 0, 3}, { 159, 255, 0, 0, 4}, { 159, 255, 0, 0, 5}, { 159, 255, 0, 0, 6}, { 159, 255, 0, 0, 7}, { 159, 255, 0, 0, 8}, { 159, 0, IN_WAY2_block, 0, 133 },
+	/* In air */
+ 	{ 160, 0, NOTHING_block, 0, 148 },
+	{ 161, 0, NOTHING_block, 0, 151 },
+	{ 162, 0, NOTHING_block, 0, 154 },
+	{ 163, 0, NOTHING_block, 0, 157 },
+  /* Helitakeoff */
+ 	{ 164, 0, 0, TERM17_block, 165 },
+	{ 165, HELITAKEOFF, NOTHING_block, 0, 0 },
+	{ 166, 0, 0, TERM18_block, 167 },
+	{ 167, HELITAKEOFF, NOTHING_block, 0, 0 },
+ 	{ 168, 0, 0, TERM19_block, 169 },
+	{ 169, HELITAKEOFF, NOTHING_block, 0, 0 },
+	{ 170, 0, 0, TERM20_block, 171 },
+	{ 171, HELITAKEOFF, NOTHING_block, 0, 0 },
+  /* Helilanding */
+	{ 172, HELILANDING, 0, TERM19_block, 173 },
+	{ 173, HELIENDLANDING, 0, TERM19_block, 56 },{ 173, 255, 0, 0, 0}, { 173, 255, 0, 0, 1}, { 173, 255, 0, 0, 2}, { 173, 255, 0, 0, 3}, { 173, 255, 0, 0, 4}, { 173, 255, 0, 0, 5}, { 173, 255, 0, 0, 6}, { 173, 255, 0, 0, 7}, { 173, 255, 0, 0, 8},{ 173, 255, 0, 0, 9}, { 173, 255, 0, 0, 10}, { 173, 255, 0, 0, 11}, { 173, 0, 0, 0, 56 },
+	{ 174, HELILANDING, 0, TERM20_block, 175 },
+	{ 175, HELIENDLANDING, 0, TERM20_block, 60 }, { 175, 255, 0, 0, 6},{ 175, 255, 0, 0, 7}, { 175, 255, 0, 0, 8}, { 175, 255, 0, 0, 9}, { 175, 255, 0, 0, 10}, { 175, 255, 0, 0, 11}, { 175, 255, 0, 0, 0}, { 175, 255, 0, 0, 1}, { 175, 255, 0, 0, 2}, { 175, 255, 0, 0, 3}, { 175, 255, 0, 0, 4}, { 175, 255, 0, 0, 5}, { 175, 0, 0, 0, 60 },
+	{ MAX_ELEMENTS, 0, 0, 0, 0 } // end marker. DO NOT REMOVE
+}; 
+
 
 /* heliports, oilrigs don't have depots */
 static const byte _airport_entries_heliport[] = { 7, 7, 7, 7 };
 static const AirportFTAbuildup _airport_fta_heliport[] = {
-	{ 0, HELIPAD1, HELIPAD1_block, 1 },
-	{ 1, HELITAKEOFF, NOTHING_block, 0 }, // takeoff
-	{ 2, 255, AIRPORT_BUSY_block, 0 }, { 2, HELILANDING, 0, 3 }, { 2, HELITAKEOFF, 0, 1 },
-	{ 3, HELILANDING, AIRPORT_BUSY_block, 4 },
-	{ 4, HELIENDLANDING, AIRPORT_BUSY_block, 4 }, { 4, HELIPAD1, HELIPAD1_block, 0 }, { 4, HELITAKEOFF, 0, 2 },
+	{ 0, HELIPAD1, HELIPAD1_block, 0, 1 },
+	{ 1, HELITAKEOFF, NOTHING_block, 0, 0 }, // takeoff
+	{ 2, 255, AIRPORT_BUSY_block, 0, 0 }, { 2, HELILANDING, 0, 0, 3 }, { 2, HELITAKEOFF, 0, 0, 1 },
+	{ 3, HELILANDING, AIRPORT_BUSY_block, 0, 4 },
+	{ 4, HELIENDLANDING, AIRPORT_BUSY_block, 0, 4 }, { 4, HELIPAD1, HELIPAD1_block, 0, 0 }, { 4, HELITAKEOFF, 0, 0, 2 },
 	/* In Air */
-	{ 5, 0, NOTHING_block, 6 },
-	{ 6, 0, NOTHING_block, 7 },
-	{ 7, 0, NOTHING_block, 8 },
-	{ 8, FLYING, NOTHING_block, 5 }, { 8, HELILANDING, HELIPAD1_block, 2 }, // landing
-	{ MAX_ELEMENTS, 0, 0, 0 } // end marker. DO NOT REMOVE
+	{ 5, 0, NOTHING_block, 0, 6 },
+	{ 6, 0, NOTHING_block, 0, 7 },
+	{ 7, 0, NOTHING_block, 0, 8 },
+	{ 8, FLYING, NOTHING_block, 0, 5 }, { 8, HELILANDING, HELIPAD1_block, 0, 2 }, // landing
+	{ MAX_ELEMENTS, 0, 0, 0, 0 } // end marker. DO NOT REMOVE
 };
 #define _airport_entries_oilrig _airport_entries_heliport
 #define _airport_fta_oilrig _airport_fta_heliport
@@ -759,73 +1307,73 @@
 static const HangarTileTable _airport_depots_helidepot[] = { {{1, 0}, DIR_SE, 0} };
 static const byte _airport_entries_helidepot[] = { 4, 4, 4, 4 };
 static const AirportFTAbuildup _airport_fta_helidepot[] = {
-	{  0, HANGAR, NOTHING_block, 1 },
-	{  1, 255, HANGAR2_AREA_block, 0 }, { 1, HANGAR, 0, 0 }, { 1, HELIPAD1, HELIPAD1_block, 14 }, { 1, HELITAKEOFF, 0, 15 }, { 1, 0, 0, 0 },
-	{  2, FLYING, NOTHING_block, 3 }, { 2, HELILANDING, PRE_HELIPAD_block, 7 }, { 2, HANGAR, 0, 12 }, { 2, HELITAKEOFF, NOTHING_block, 16 },
+	{  0, HANGAR, NOTHING_block, 0, 1 },
+	{  1, 255, HANGAR2_AREA_block, 0, 0 }, { 1, HANGAR, 0, 0, 0 }, { 1, HELIPAD1, HELIPAD1_block, 0, 14 }, { 1, HELITAKEOFF, 0, 0, 15 }, { 1, 0, 0, 0, 0 },
+	{  2, FLYING, NOTHING_block, 0, 3 }, { 2, HELILANDING, PRE_HELIPAD_block, 0, 7 }, { 2, HANGAR, 0, 0, 12 }, { 2, HELITAKEOFF, NOTHING_block, 0, 16 },
 	/* In Air */
-	{  3, 0, NOTHING_block, 4 },
-	{  4, 0, NOTHING_block, 5 },
-	{  5, 0, NOTHING_block, 6 },
-	{  6, 0, NOTHING_block, 2 },
+	{  3, 0, NOTHING_block, 0, 4 },
+	{  4, 0, NOTHING_block, 0, 5 },
+	{  5, 0, NOTHING_block, 0, 6 },
+	{  6, 0, NOTHING_block, 0, 2 },
 	/* Helicopter -- stay in air in special place as a buffer to choose from helipads */
-	{  7, HELILANDING, PRE_HELIPAD_block, 8 },
-	{  8, HELIENDLANDING, PRE_HELIPAD_block, 8 }, { 8, HELIPAD1, 0, 9 }, { 8, HANGAR, 0, 12 }, { 8, 0, 0, 2 },
-	{  9, 0, NOTHING_block, 10 },
+	{  7, HELILANDING, PRE_HELIPAD_block, 0, 8 },
+	{  8, HELIENDLANDING, PRE_HELIPAD_block, 0, 8 }, { 8, HELIPAD1, 0, 0, 9 }, { 8, HANGAR, 0, 0, 12 }, { 8, 0, 0, 0, 2 },
+	{  9, 0, NOTHING_block, 0, 10 },
 	/* landing */
-	{ 10, 255, NOTHING_block, 10 }, { 10, HELIPAD1, HELIPAD1_block, 14 }, { 10, HANGAR, 0, 1 }, { 10, 0, 0, 14 },
+	{ 10, 255, NOTHING_block, 0, 10 }, { 10, HELIPAD1, HELIPAD1_block, 0, 14 }, { 10, HANGAR, 0, 0, 1 }, { 10, 0, 0, 0, 14 },
 	/* Helicopter -- takeoff */
-	{ 11, HELITAKEOFF, NOTHING_block, 0 },
-	{ 12, 0, HANGAR2_AREA_block, 13 }, // need to go to hangar when waiting in air
-	{ 13, 0, HANGAR2_AREA_block, 1 },
-	{ 14, HELIPAD1, HELIPAD1_block, 14 }, { 14, HANGAR, 0, 1 }, { 14, HELITAKEOFF, 0, 17 },
-	{ 15, HELITAKEOFF, NOTHING_block, 0 }, // takeoff outside depot
-	{ 16, HELITAKEOFF, 0, 14 },
-	{ 17, 0, NOTHING_block, 11 },
-	{ MAX_ELEMENTS, 0, 0, 0 } // end marker. DO NOT REMOVE
+	{ 11, HELITAKEOFF, NOTHING_block, 0, 0 },
+	{ 12, 0, HANGAR2_AREA_block, 0, 13 }, // need to go to hangar when waiting in air
+	{ 13, 0, HANGAR2_AREA_block, 0, 1 },
+	{ 14, HELIPAD1, HELIPAD1_block, 0, 14 }, { 14, HANGAR, 0, 0, 1 }, { 14, HELITAKEOFF, 0, 0, 17 },
+	{ 15, HELITAKEOFF, NOTHING_block, 0, 0 }, // takeoff outside depot
+	{ 16, HELITAKEOFF, 0, 0, 14 },
+	{ 17, 0, NOTHING_block, 0, 11 },
+	{ MAX_ELEMENTS, 0, 0, 0, 0 } // end marker. DO NOT REMOVE
 };
 
 /* helistation */
 static const HangarTileTable _airport_depots_helistation[] = { {{0, 0}, DIR_SE, 0} };
 static const byte _airport_entries_helistation[] = { 25, 25, 25, 25 };
 static const AirportFTAbuildup _airport_fta_helistation[] = {
-	{  0, HANGAR, NOTHING_block, 8 },    { 0, HELIPAD1, 0, 1 }, { 0, HELIPAD2, 0, 1 }, { 0, HELIPAD3, 0, 1 }, { 0, HELITAKEOFF, 0, 1 }, { 0, 0, 0, 0 },
-	{  1, 255, HANGAR2_AREA_block, 0 },  { 1, HANGAR, 0, 0 }, { 1, HELITAKEOFF, 0, 3 }, { 1, 0, 0, 4 },
+	{  0, HANGAR, NOTHING_block, 0, 8 },    { 0, HELIPAD1, 0, 0, 1 }, { 0, HELIPAD2, 0, 0, 1 }, { 0, HELIPAD3, 0, 0, 1 }, { 0, HELITAKEOFF, 0, 0, 1 }, { 0, 0, 0, 0, 0 },
+	{  1, 255, HANGAR2_AREA_block, 0, 0 },  { 1, HANGAR, 0, 0, 0 }, { 1, HELITAKEOFF, 0, 0, 3 }, { 1, 0, 0, 0, 4 },
 	/* landing */
-	{  2, FLYING, NOTHING_block, 28 },   { 2, HELILANDING, 0, 15 }, { 2, 0, 0, 28 },
+	{  2, FLYING, NOTHING_block, 0, 28 },   { 2, HELILANDING, 0, 0, 15 }, { 2, 0, 0, 0, 28 },
 	/* helicopter side */
-	{  3, HELITAKEOFF, NOTHING_block, 0 }, // helitakeoff outside hangar2
-	{  4, 255, TAXIWAY_BUSY_block, 0 },  { 4, HANGAR, HANGAR2_AREA_block, 1 }, { 4, HELITAKEOFF, 0, 1 }, { 4, 0, 0, 5 },
-	{  5, 255, TAXIWAY_BUSY_block, 0 },  { 5, HELIPAD1, HELIPAD1_block, 6 }, { 5, HELIPAD2, HELIPAD2_block, 7 }, { 5, HELIPAD3, HELIPAD3_block, 8 }, { 5, 0, 0, 4 },
-	{  6, HELIPAD1, HELIPAD1_block, 5 }, { 6, HANGAR, HANGAR2_AREA_block, 5 }, { 6, HELITAKEOFF, 0, 9 }, { 6, 0, 0, 6 },
-	{  7, HELIPAD2, HELIPAD2_block, 5 }, { 7, HANGAR, HANGAR2_AREA_block, 5 }, { 7, HELITAKEOFF, 0, 10 }, { 7, 0, 0, 7 },
-	{  8, HELIPAD3, HELIPAD3_block, 5 }, { 8, HANGAR, HANGAR2_AREA_block, 5 }, { 8, HELITAKEOFF, 0, 11 }, { 8, 0, 0, 8 },
-	{  9, 0, HELIPAD1_block, 12 },
-	{ 10, 0, HELIPAD2_block, 13 },
-	{ 11, 0, HELIPAD3_block, 14 },
-	{ 12, HELITAKEOFF, NOTHING_block, 0 },
-	{ 13, HELITAKEOFF, NOTHING_block, 0 },
-	{ 14, HELITAKEOFF, NOTHING_block, 0 },
+	{  3, HELITAKEOFF, NOTHING_block, 0, 0 }, // helitakeoff outside hangar2
+	{  4, 255, TAXIWAY_BUSY_block, 0, 0 },  { 4, HANGAR, HANGAR2_AREA_block, 0, 1 }, { 4, HELITAKEOFF, 0, 0, 1 }, { 4, 0, 0, 0, 5 },
+	{  5, 255, TAXIWAY_BUSY_block, 0, 0 },  { 5, HELIPAD1, HELIPAD1_block, 0, 6 }, { 5, HELIPAD2, HELIPAD2_block, 0, 7 }, { 5, HELIPAD3, HELIPAD3_block, 0, 8 }, { 5, 0, 0, 0, 4 },
+	{  6, HELIPAD1, HELIPAD1_block, 0, 5 }, { 6, HANGAR, HANGAR2_AREA_block, 0, 5 }, { 6, HELITAKEOFF, 0, 0, 9 }, { 6, 0, 0, 0, 6 },
+	{  7, HELIPAD2, HELIPAD2_block, 0, 5 }, { 7, HANGAR, HANGAR2_AREA_block, 0, 5 }, { 7, HELITAKEOFF, 0, 0, 10 }, { 7, 0, 0, 0, 7 },
+	{  8, HELIPAD3, HELIPAD3_block, 0, 5 }, { 8, HANGAR, HANGAR2_AREA_block, 0, 5 }, { 8, HELITAKEOFF, 0, 0, 11 }, { 8, 0, 0, 0, 8 },
+	{  9, 0, HELIPAD1_block, 0, 12 },
+	{ 10, 0, HELIPAD2_block, 0, 13 },
+	{ 11, 0, HELIPAD3_block, 0, 14 },
+	{ 12, HELITAKEOFF, NOTHING_block, 0, 0 },
+	{ 13, HELITAKEOFF, NOTHING_block, 0, 0 },
+	{ 14, HELITAKEOFF, NOTHING_block, 0, 0 },
 	/* heli - in flight moves */
-	{ 15, HELILANDING, PRE_HELIPAD_block, 16 },
-	{ 16, HELIENDLANDING, PRE_HELIPAD_block, 16 }, { 16, HELIPAD1, 0, 17 }, { 16, HELIPAD2, 0, 18 }, { 16, HELIPAD3, 0, 19 }, { 16, HANGAR, 0, 23 },
-	{ 17, 0, NOTHING_block, 20 },
-	{ 18, 0, NOTHING_block, 21 },
-	{ 19, 0, NOTHING_block, 22 },
+	{ 15, HELILANDING, PRE_HELIPAD_block, 0, 16 },
+	{ 16, HELIENDLANDING, PRE_HELIPAD_block, 0, 16 }, { 16, HELIPAD1, 0, 0, 17 }, { 16, HELIPAD2, 0, 0, 18 }, { 16, HELIPAD3, 0, 0, 19 }, { 16, HANGAR, 0, 0, 23 },
+	{ 17, 0, NOTHING_block, 0, 20 },
+	{ 18, 0, NOTHING_block, 0, 21 },
+	{ 19, 0, NOTHING_block, 0, 22 },
 	/* heli landing */
-	{ 20, 255, NOTHING_block, 0 }, { 20, HELIPAD1, HELIPAD1_block, 6 }, { 20, HANGAR, 0, 23 }, { 20, 0, 0, 6 },
-	{ 21, 255, NOTHING_block, 0 }, { 21, HELIPAD2, HELIPAD2_block, 7 }, { 21, HANGAR, 0, 23 }, { 21, 0, 0, 7 },
-	{ 22, 255, NOTHING_block, 0 }, { 22, HELIPAD3, HELIPAD3_block, 8 }, { 22, HANGAR, 0, 23 }, { 22, 0, 0, 8 },
-	{ 23, 0, HANGAR2_AREA_block, 24 }, // need to go to helihangar when waiting in air
-	{ 24, 0, HANGAR2_AREA_block, 1 },
-	{ 25, 0, NOTHING_block, 26 },
-	{ 26, 0, NOTHING_block, 27 },
-	{ 27, 0, NOTHING_block, 2 },
-	{ 28, 0, NOTHING_block, 29 },
-	{ 29, 0, NOTHING_block, 30 },
-	{ 30, 0, NOTHING_block, 31 },
-	{ 31, 0, NOTHING_block, 32 },
-	{ 32, 0, NOTHING_block, 25 },
-	{ MAX_ELEMENTS, 0, 0, 0 } // end marker. DO NOT REMOVE
+	{ 20, 255, NOTHING_block, 0, 0 }, { 20, HELIPAD1, HELIPAD1_block, 0, 6 }, { 20, HANGAR, 0, 0, 23 }, { 20, 0, 0, 0, 6 },
+	{ 21, 255, NOTHING_block, 0, 0 }, { 21, HELIPAD2, HELIPAD2_block, 0, 7 }, { 21, HANGAR, 0, 0, 23 }, { 21, 0, 0, 0, 7 },
+	{ 22, 255, NOTHING_block, 0, 0 }, { 22, HELIPAD3, HELIPAD3_block, 0, 8 }, { 22, HANGAR, 0, 0, 23 }, { 22, 0, 0, 0, 8 },
+	{ 23, 0, HANGAR2_AREA_block, 0, 24 }, // need to go to helihangar when waiting in air
+	{ 24, 0, HANGAR2_AREA_block, 0, 1 },
+	{ 25, 0, NOTHING_block, 0, 26 },
+	{ 26, 0, NOTHING_block, 0, 27 },
+	{ 27, 0, NOTHING_block, 0, 2 },
+	{ 28, 0, NOTHING_block, 0, 29 },
+	{ 29, 0, NOTHING_block, 0, 30 },
+	{ 30, 0, NOTHING_block, 0, 31 },
+	{ 31, 0, NOTHING_block, 0, 32 },
+	{ 32, 0, NOTHING_block, 0, 25 },
+	{ MAX_ELEMENTS, 0, 0, 0, 0 } // end marker. DO NOT REMOVE
 };
 
 #endif /* AIRPORT_MOVEMENT_H */
diff -urNad openttd-1.3.2/src/table/airporttile_ids.h openttd-1.3.2-DC3.0RC3/src/table/airporttile_ids.h
--- openttd-1.3.2/src/table/airporttile_ids.h	2013-07-27 17:09:31.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/table/airporttile_ids.h	2013-11-22 05:49:07.000000000 +0100
@@ -87,6 +87,39 @@
 	APT_APRON_HALF_EAST,
 	APT_APRON_HALF_WEST,
 	APT_GRASS_FENCE_NE_FLAG_2,
+  APT_NSRUNWAY_4,
+  APT_NSRUNWAY_4_SW,
+  APT_NSRUNWAY_4_NE,
+  APT_NSRUNWAY_END_FENCE_SW,
+  APT_NSRUNWAY_END_FENCE_NE,
+  APT_DEPOT_SW,
+  APT_DEPOT_NW,
+  APT_DEPOT_NE,
+  APT_NSRUNWAY_4_SE_SW,
+  APT_NSRUNWAY_4_NW_SW, 
+  APT_NSRUNWAY_4_NE_SE, 
+  APT_NSRUNWAY_4_NE_NW,
+  APT_NSRUNWAY_4_NE_SW,
+  APT_NSRUNWAY_END_NE_SE_SW,
+  APT_NSRUNWAY_END_NE_NW_SW,
+  APT_RUNWAY_2_NW_SE,
+  APT_RUNWAY_END_NW_SE_SW,
+  APT_RUNWAY_END_NE_NW_SE,
+  APT_NSRUNWAY_END_NE_SE,
+  APT_NSRUNWAY_END_NE_NW,
+  APT_NSRUNWAY_END_SE_SW,
+  APT_NSRUNWAY_END_NW_SW,
+  APT_APRON_HALF_NORTH,
+  APT_APRON_HALF_SOUTH,
+  APT_APRON_Q_NO_SE_0,
+  APT_APRON_Q_NO_SW_0,
+  APT_APRON_Q_NO_NW_0,
+  APT_APRON_Q_NO_NE_0,
+  APT_APRON_Q_NO_SE_1,
+  APT_APRON_Q_NO_SW_1,
+  APT_APRON_Q_NO_NW_1,
+  APT_APRON_Q_NO_NE_1,
+  APT_HELI_NO_FENCES,
 };
 
 #endif /* AIRPORTTILE_IDS_H */
diff -urNad openttd-1.3.2/src/table/airporttiles.h openttd-1.3.2-DC3.0RC3/src/table/airporttiles.h
--- openttd-1.3.2/src/table/airporttiles.h	2013-07-27 17:09:31.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/table/airporttiles.h	2013-11-22 05:49:07.000000000 +0100
@@ -104,6 +104,30 @@
 	AT_NOANIM,
 	AT_NOANIM,
 	AT(3, 1), // APT_GRASS_FENCE_NE_FLAG_2
+	AT_NOANIM,
+	AT_NOANIM,
+	AT_NOANIM,
+	AT_NOANIM,
+	AT_NOANIM,
+	AT_NOANIM,
+
+	AT_NOANIM,
+	AT_NOANIM,
+	AT_NOANIM,
+	AT_NOANIM,
+	AT_NOANIM,
+	AT_NOANIM,
+	AT_NOANIM,
+	AT_NOANIM,
+	AT_NOANIM,
+	AT_NOANIM,
+
+	AT_NOANIM,
+	AT_NOANIM,
+	AT_NOANIM,
+	AT_NOANIM,
+	AT_NOANIM,
+	AT_NOANIM,
 };
 
 assert_compile(NEW_AIRPORTTILE_OFFSET == lengthof(_origin_airporttile_specs));
diff -urNad openttd-1.3.2/src/table/build_industry.h openttd-1.3.2-DC3.0RC3/src/table/build_industry.h
--- openttd-1.3.2/src/table/build_industry.h	2013-07-27 17:09:31.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/table/build_industry.h	2013-11-22 05:49:07.000000000 +0100
@@ -1181,9 +1181,9 @@
  */
 
 #define MI(tbl, sndc, snd, d, pc, ai1, ai2, ai3, ai4, ag1, ag2, ag3, ag4, col, \
-			c1, c2, c3, proc, p1, r1, p2, r2, m, a1, im1, a2, im2, a3, im3, pr, clim, bev, in, intx, s1, s2, s3) \
+			c1, c2, c3, proc, p1, r1, p2, r2, m, a1, im1, a2, im2, a3, im3, pr, clim, bev, in, abb, intx, s1, s2, s3) \
 		{tbl, lengthof(tbl), d, 0, pc, {c1, c2, c3}, proc, {p1, p2}, {r1, r2}, m, \
-		{a1, a2, a3}, {{im1, 0}, {im2, 0}, {im3, 0}}, pr, clim, bev, col, in, intx, s1, s2, s3, STR_UNDEFINED, {ai1, ai2, ai3, ai4}, {ag1, ag2, ag3, ag4}, \
+		{a1, a2, a3}, {{im1, 0}, {im2, 0}, {im3, 0}}, pr, clim, bev, col, in, abb, intx, s1, s2, s3, STR_UNDEFINED, {ai1, ai2, ai3, ai4}, {ag1, ag2, ag3, ag4}, \
 		sndc, snd, 0, 0, true, GRFFileProps(INVALID_INDUSTRYTYPE)}
 	/* Format:
 	   tile table                              count and sounds table
@@ -1203,7 +1203,7 @@
 	   CT_INVALID,   256, CT_INVALID,     256, CT_INVALID,   256,
 	   INDUSTRYLIFE_EXTRACTIVE,                1 << LT_TEMPERATE | 1 << LT_ARCTIC,
 	   INDUSTRYBEH_CAN_SUBSIDENCE,
-	   STR_INDUSTRY_NAME_COAL_MINE,                     STR_NEWS_INDUSTRY_CONSTRUCTION,
+	   STR_INDUSTRY_NAME_COAL_MINE,          STR_ABBREV_COAL_MINE,                         STR_NEWS_INDUSTRY_CONSTRUCTION,
 	   STR_NEWS_INDUSTRY_CLOSURE_GENERAL,    STR_NEWS_INDUSTRY_PRODUCTION_INCREASE_COAL,   STR_NEWS_INDUSTRY_PRODUCTION_DECREASE_GENERAL),
 
 	MI(_tile_table_power_station,              0, NULL,
@@ -1213,7 +1213,7 @@
 	   CT_COAL,      256, CT_INVALID,     256, CT_INVALID,   256,
 	   INDUSTRYLIFE_BLACK_HOLE,                1 << LT_TEMPERATE | 1 << LT_ARCTIC,
 	   INDUSTRYBEH_NONE,
-	   STR_INDUSTRY_NAME_POWER_STATION,                 STR_NEWS_INDUSTRY_CONSTRUCTION,
+	   STR_INDUSTRY_NAME_POWER_STATION,      STR_ABBREV_POWER_STATION,                          STR_NEWS_INDUSTRY_CONSTRUCTION,
 	   STR_NEWS_INDUSTRY_CLOSURE_GENERAL,    STR_NEWS_INDUSTRY_PRODUCTION_INCREASE_GENERAL,     STR_NEWS_INDUSTRY_PRODUCTION_DECREASE_GENERAL),
 
 	MI(_tile_table_sawmill,                    1, _sawmill_sounds,
@@ -1223,7 +1223,7 @@
 	   CT_WOOD,      256, CT_INVALID,     256, CT_INVALID,   256,
 	   INDUSTRYLIFE_PROCESSING,                1 << LT_TEMPERATE,
 	   INDUSTRYBEH_NONE,
-	   STR_INDUSTRY_NAME_SAWMILL,                       STR_NEWS_INDUSTRY_CONSTRUCTION,
+	   STR_INDUSTRY_NAME_SAWMILL,                      STR_ABBREV_SAWMILL,                                STR_NEWS_INDUSTRY_CONSTRUCTION,
 	   STR_NEWS_INDUSTRY_CLOSURE_SUPPLY_PROBLEMS,      STR_NEWS_INDUSTRY_PRODUCTION_INCREASE_GENERAL,     STR_NEWS_INDUSTRY_PRODUCTION_DECREASE_GENERAL),
 
 	MI(_tile_table_forest,                     0, NULL,
@@ -1233,7 +1233,7 @@
 	   CT_INVALID,   256, CT_INVALID,     256, CT_INVALID,   256,
 	   INDUSTRYLIFE_ORGANIC,                   1 << LT_TEMPERATE | 1 << LT_ARCTIC,
 	   INDUSTRYBEH_NONE,
-	   STR_INDUSTRY_NAME_FOREST,                        STR_NEWS_INDUSTRY_PLANTED,
+	   STR_INDUSTRY_NAME_FOREST,             STR_ABBREV_FOREST,                                 STR_NEWS_INDUSTRY_PLANTED,
 	   STR_NEWS_INDUSTRY_CLOSURE_GENERAL,    STR_NEWS_INDUSTRY_PRODUCTION_INCREASE_GENERAL,     STR_NEWS_INDUSTRY_PRODUCTION_DECREASE_FARM),
 
 	MI(_tile_table_oil_refinery,               0, NULL,
@@ -1243,7 +1243,7 @@
 	   CT_OIL,       256, CT_INVALID,     256, CT_INVALID,   256,
 	   INDUSTRYLIFE_PROCESSING,                1 << LT_TEMPERATE | 1 << LT_ARCTIC | 1 << LT_TROPIC,
 	   INDUSTRYBEH_AIRPLANE_ATTACKS,
-	   STR_INDUSTRY_NAME_OIL_REFINERY,                  STR_NEWS_INDUSTRY_CONSTRUCTION,
+	   STR_INDUSTRY_NAME_OIL_REFINERY,                 STR_ABBREV_OIL_REFINERY,                           STR_NEWS_INDUSTRY_CONSTRUCTION,
 	   STR_NEWS_INDUSTRY_CLOSURE_SUPPLY_PROBLEMS,      STR_NEWS_INDUSTRY_PRODUCTION_INCREASE_GENERAL,     STR_NEWS_INDUSTRY_PRODUCTION_DECREASE_GENERAL),
 
 	MI(_tile_table_oil_rig,                    0, NULL,
@@ -1253,7 +1253,7 @@
 	   CT_INVALID,     0, CT_INVALID,       0, CT_INVALID,     0,
 	   INDUSTRYLIFE_EXTRACTIVE,                1 << LT_TEMPERATE,
 	   INDUSTRYBEH_BUILT_ONWATER | INDUSTRYBEH_AFTER_1960 | INDUSTRYBEH_AI_AIRSHIP_ROUTES,
-	   STR_INDUSTRY_NAME_OIL_RIG,                       STR_NEWS_INDUSTRY_CONSTRUCTION,
+	   STR_INDUSTRY_NAME_OIL_RIG,            STR_ABBREV_OIL_RIG,                          STR_NEWS_INDUSTRY_CONSTRUCTION,
 	   STR_NEWS_INDUSTRY_CLOSURE_GENERAL,    STR_NEWS_INDUSTRY_PRODUCTION_INCREASE_OIL,   STR_NEWS_INDUSTRY_PRODUCTION_DECREASE_GENERAL),
 
 	MI(_tile_table_factory,                    1, _factory_sounds,
@@ -1263,7 +1263,7 @@
 	   CT_LIVESTOCK, 256, CT_GRAIN,       256, CT_STEEL,    256,
 	   INDUSTRYLIFE_PROCESSING,                1 << LT_TEMPERATE,
 	   INDUSTRYBEH_CHOPPER_ATTACKS,
-	   STR_INDUSTRY_NAME_FACTORY,                       STR_NEWS_INDUSTRY_CONSTRUCTION,
+	   STR_INDUSTRY_NAME_FACTORY,                      STR_ABBREV_FACTORY,                                STR_NEWS_INDUSTRY_CONSTRUCTION,
 	   STR_NEWS_INDUSTRY_CLOSURE_SUPPLY_PROBLEMS,      STR_NEWS_INDUSTRY_PRODUCTION_INCREASE_GENERAL,     STR_NEWS_INDUSTRY_PRODUCTION_DECREASE_GENERAL),
 
 	MI(_tile_table_printing_works,             1, _factory_sounds,
@@ -1273,7 +1273,7 @@
 	   CT_PAPER,     256, CT_INVALID,     256, CT_INVALID,   256,
 	   INDUSTRYLIFE_PROCESSING,                1 << LT_ARCTIC,
 	   INDUSTRYBEH_NONE,
-	   STR_INDUSTRY_NAME_PRINTING_WORKS,                STR_NEWS_INDUSTRY_CONSTRUCTION,
+	   STR_INDUSTRY_NAME_PRINTING_WORKS,               STR_ABBREV_PRINTING_WORKS,                         STR_NEWS_INDUSTRY_CONSTRUCTION,
 	   STR_NEWS_INDUSTRY_CLOSURE_SUPPLY_PROBLEMS,      STR_NEWS_INDUSTRY_PRODUCTION_INCREASE_GENERAL,     STR_NEWS_INDUSTRY_PRODUCTION_DECREASE_GENERAL),
 
 	MI(_tile_table_steel_mill,                 0, NULL,
@@ -1283,7 +1283,7 @@
 	   CT_IRON_ORE,  256, CT_INVALID,     256, CT_INVALID,   256,
 	   INDUSTRYLIFE_PROCESSING,                1 << LT_TEMPERATE,
 	   INDUSTRYBEH_NONE,
-	   STR_INDUSTRY_NAME_STEEL_MILL,                    STR_NEWS_INDUSTRY_CONSTRUCTION,
+	   STR_INDUSTRY_NAME_STEEL_MILL,                   STR_ABBREV_STEEL_MILL,                             STR_NEWS_INDUSTRY_CONSTRUCTION,
 	   STR_NEWS_INDUSTRY_CLOSURE_SUPPLY_PROBLEMS,      STR_NEWS_INDUSTRY_PRODUCTION_INCREASE_GENERAL,     STR_NEWS_INDUSTRY_PRODUCTION_DECREASE_GENERAL),
 
 	MI(_tile_table_farm,                       3, _farm_sounds,
@@ -1293,7 +1293,7 @@
 	   CT_INVALID,   256, CT_INVALID,     256, CT_INVALID,   256,
 	   INDUSTRYLIFE_ORGANIC,                   1 << LT_TEMPERATE | 1 << LT_ARCTIC,
 	   INDUSTRYBEH_PLANT_FIELDS | INDUSTRYBEH_PLANT_ON_BUILT,
-	   STR_INDUSTRY_NAME_FARM,                          STR_NEWS_INDUSTRY_CONSTRUCTION,
+	   STR_INDUSTRY_NAME_FARM,               STR_ABBREV_FARM,                            STR_NEWS_INDUSTRY_CONSTRUCTION,
 	   STR_NEWS_INDUSTRY_CLOSURE_GENERAL,    STR_NEWS_INDUSTRY_PRODUCTION_INCREASE_FARM, STR_NEWS_INDUSTRY_PRODUCTION_DECREASE_FARM),
 
 	MI(_tile_table_copper_mine,                0, NULL,
@@ -1303,7 +1303,7 @@
 	   CT_INVALID,   256, CT_INVALID,     256, CT_INVALID,   256,
 	   INDUSTRYLIFE_EXTRACTIVE,                1 << LT_TROPIC,
 	   INDUSTRYBEH_NONE,
-	   STR_INDUSTRY_NAME_COPPER_ORE_MINE,               STR_NEWS_INDUSTRY_CONSTRUCTION,
+	   STR_INDUSTRY_NAME_COPPER_ORE_MINE,    STR_ABBREV_COPPER_ORE_MINE,                        STR_NEWS_INDUSTRY_CONSTRUCTION,
 	   STR_NEWS_INDUSTRY_CLOSURE_GENERAL,    STR_NEWS_INDUSTRY_PRODUCTION_INCREASE_GENERAL,     STR_NEWS_INDUSTRY_PRODUCTION_DECREASE_GENERAL),
 
 	MI(_tile_table_oil_well,                   0, NULL,
@@ -1313,7 +1313,7 @@
 	   CT_INVALID,   256, CT_INVALID,     256, CT_INVALID,   256,
 	   INDUSTRYLIFE_EXTRACTIVE,                1 << LT_TEMPERATE | 1 << LT_ARCTIC | 1 << LT_TROPIC,
 	   INDUSTRYBEH_DONT_INCR_PROD | INDUSTRYBEH_BEFORE_1950,
-	   STR_INDUSTRY_NAME_OIL_WELLS,                     STR_NEWS_INDUSTRY_CONSTRUCTION,
+	   STR_INDUSTRY_NAME_OIL_WELLS,          STR_ABBREV_OIL_WELLS,                        STR_NEWS_INDUSTRY_CONSTRUCTION,
 	   STR_NEWS_INDUSTRY_CLOSURE_GENERAL,    STR_NEWS_INDUSTRY_PRODUCTION_INCREASE_OIL,   STR_NEWS_INDUSTRY_PRODUCTION_DECREASE_GENERAL),
 
 	MI(_tile_table_bank,                       0, NULL,
@@ -1323,7 +1323,7 @@
 	   CT_VALUABLES,   0, CT_INVALID,       0, CT_INVALID,     0,
 	   INDUSTRYLIFE_BLACK_HOLE,                1 << LT_TEMPERATE,
 	   INDUSTRYBEH_TOWN1200_MORE,
-	   STR_INDUSTRY_NAME_BANK,                          STR_NEWS_INDUSTRY_CONSTRUCTION,
+	   STR_INDUSTRY_NAME_BANK,               STR_ABBREV_BANK,                                   STR_NEWS_INDUSTRY_CONSTRUCTION,
 	   STR_NEWS_INDUSTRY_CLOSURE_GENERAL,    STR_NEWS_INDUSTRY_PRODUCTION_INCREASE_GENERAL,     STR_NEWS_INDUSTRY_PRODUCTION_DECREASE_GENERAL),
 
 	MI(_tile_table_food_process,               0, NULL,
@@ -1333,7 +1333,7 @@
 	   CT_FRUIT,     256, CT_MAIZE,       256, CT_INVALID,   256,
 	   INDUSTRYLIFE_PROCESSING,                1 << LT_ARCTIC | 1 << LT_TROPIC,
 	   INDUSTRYBEH_NONE,
-	   STR_INDUSTRY_NAME_FOOD_PROCESSING_PLANT,         STR_NEWS_INDUSTRY_CONSTRUCTION,
+	   STR_INDUSTRY_NAME_FOOD_PROCESSING_PLANT,        STR_ABBREV_FOOD_PROCESSING_PLANT,                  STR_NEWS_INDUSTRY_CONSTRUCTION,
 	   STR_NEWS_INDUSTRY_CLOSURE_SUPPLY_PROBLEMS,      STR_NEWS_INDUSTRY_PRODUCTION_INCREASE_GENERAL,     STR_NEWS_INDUSTRY_PRODUCTION_DECREASE_GENERAL),
 
 	MI(_tile_table_paper_mill,                 1, _sawmill_sounds,
@@ -1343,7 +1343,7 @@
 	   CT_WOOD,      256, CT_INVALID,     256, CT_INVALID,   256,
 	   INDUSTRYLIFE_PROCESSING,                1 << LT_ARCTIC,
 	   INDUSTRYBEH_NONE,
-	   STR_INDUSTRY_NAME_PAPER_MILL,                    STR_NEWS_INDUSTRY_CONSTRUCTION,
+	   STR_INDUSTRY_NAME_PAPER_MILL,                   STR_ABBREV_PAPER_MILL,                             STR_NEWS_INDUSTRY_CONSTRUCTION,
 	   STR_NEWS_INDUSTRY_CLOSURE_SUPPLY_PROBLEMS,      STR_NEWS_INDUSTRY_PRODUCTION_INCREASE_GENERAL,     STR_NEWS_INDUSTRY_PRODUCTION_DECREASE_GENERAL),
 
 	MI(_tile_table_gold_mine,                  0, NULL,
@@ -1353,7 +1353,7 @@
 	   CT_INVALID,   256, CT_INVALID,     256, CT_INVALID,   256,
 	   INDUSTRYLIFE_EXTRACTIVE,                1 << LT_ARCTIC,
 	   INDUSTRYBEH_NONE,
-	   STR_INDUSTRY_NAME_GOLD_MINE,                     STR_NEWS_INDUSTRY_CONSTRUCTION,
+	   STR_INDUSTRY_NAME_GOLD_MINE,          STR_ABBREV_GOLD_MINE,                              STR_NEWS_INDUSTRY_CONSTRUCTION,
 	   STR_NEWS_INDUSTRY_CLOSURE_GENERAL,    STR_NEWS_INDUSTRY_PRODUCTION_INCREASE_GENERAL,     STR_NEWS_INDUSTRY_PRODUCTION_DECREASE_GENERAL),
 
 	MI(_tile_table_bank2,                      0, NULL,
@@ -1363,7 +1363,7 @@
 	   CT_GOLD,      256, CT_INVALID,     256, CT_INVALID,   256,
 	   INDUSTRYLIFE_BLACK_HOLE,                1 << LT_ARCTIC | 1 << LT_TROPIC,
 	   INDUSTRYBEH_ONLY_INTOWN,
-	   STR_INDUSTRY_NAME_BANK_TROPIC_ARCTIC,                          STR_NEWS_INDUSTRY_CONSTRUCTION,
+	   STR_INDUSTRY_NAME_BANK_TROPIC_ARCTIC, STR_ABBREV_BANK_TROPIC_ARCTIC,                     STR_NEWS_INDUSTRY_CONSTRUCTION,
 	   STR_NEWS_INDUSTRY_CLOSURE_GENERAL,    STR_NEWS_INDUSTRY_PRODUCTION_INCREASE_GENERAL,     STR_NEWS_INDUSTRY_PRODUCTION_DECREASE_GENERAL),
 
 	MI(_tile_table_diamond_mine,               0, NULL,
@@ -1373,7 +1373,7 @@
 	   CT_INVALID,   256, CT_INVALID,     256, CT_INVALID,   256,
 	   INDUSTRYLIFE_EXTRACTIVE,                1 << LT_TROPIC,
 	   INDUSTRYBEH_NONE,
-	   STR_INDUSTRY_NAME_DIAMOND_MINE,                  STR_NEWS_INDUSTRY_CONSTRUCTION,
+	   STR_INDUSTRY_NAME_DIAMOND_MINE,       STR_ABBREV_DIAMOND_MINE,                           STR_NEWS_INDUSTRY_CONSTRUCTION,
 	   STR_NEWS_INDUSTRY_CLOSURE_GENERAL,    STR_NEWS_INDUSTRY_PRODUCTION_INCREASE_GENERAL,     STR_NEWS_INDUSTRY_PRODUCTION_DECREASE_GENERAL),
 
 	MI(_tile_table_iron_mine,                  0, NULL,
@@ -1383,7 +1383,7 @@
 	   CT_INVALID,   256, CT_INVALID,     256, CT_INVALID,   256,
 	   INDUSTRYLIFE_EXTRACTIVE,                1 << LT_TEMPERATE,
 	   INDUSTRYBEH_NONE,
-	   STR_INDUSTRY_NAME_IRON_ORE_MINE,                 STR_NEWS_INDUSTRY_CONSTRUCTION,
+	   STR_INDUSTRY_NAME_IRON_ORE_MINE,      STR_ABBREV_IRON_ORE_MINE,                          STR_NEWS_INDUSTRY_CONSTRUCTION,
 	   STR_NEWS_INDUSTRY_CLOSURE_GENERAL,    STR_NEWS_INDUSTRY_PRODUCTION_INCREASE_GENERAL,     STR_NEWS_INDUSTRY_PRODUCTION_DECREASE_GENERAL),
 
 	MI(_tile_table_fruit_plantation,           0, NULL,
@@ -1393,7 +1393,7 @@
 	   CT_INVALID,   256, CT_INVALID,     256, CT_INVALID,   256,
 	   INDUSTRYLIFE_ORGANIC,                   1 << LT_TROPIC,
 	   INDUSTRYBEH_NONE,
-	   STR_INDUSTRY_NAME_FRUIT_PLANTATION,              STR_NEWS_INDUSTRY_PLANTED,
+	   STR_INDUSTRY_NAME_FRUIT_PLANTATION,   STR_ABBREV_FRUIT_PLANTATION,                STR_NEWS_INDUSTRY_PLANTED,
 	   STR_NEWS_INDUSTRY_CLOSURE_GENERAL,    STR_NEWS_INDUSTRY_PRODUCTION_INCREASE_FARM, STR_NEWS_INDUSTRY_PRODUCTION_DECREASE_FARM),
 
 	MI(_tile_table_rubber_plantation,          0, NULL,
@@ -1403,7 +1403,7 @@
 	   CT_INVALID,   256, CT_INVALID,     256, CT_INVALID,   256,
 	   INDUSTRYLIFE_ORGANIC,                   1 << LT_TROPIC,
 	   INDUSTRYBEH_NONE,
-	   STR_INDUSTRY_NAME_RUBBER_PLANTATION,             STR_NEWS_INDUSTRY_PLANTED,
+	   STR_INDUSTRY_NAME_RUBBER_PLANTATION,  STR_ABBREV_RUBBER_PLANTATION,               STR_NEWS_INDUSTRY_PLANTED,
 	   STR_NEWS_INDUSTRY_CLOSURE_GENERAL,    STR_NEWS_INDUSTRY_PRODUCTION_INCREASE_FARM, STR_NEWS_INDUSTRY_PRODUCTION_DECREASE_FARM),
 
 	MI(_tile_table_water_supply,               0, NULL,
@@ -1413,7 +1413,7 @@
 	   CT_INVALID,   256, CT_INVALID,     256, CT_INVALID,   256,
 	   INDUSTRYLIFE_EXTRACTIVE,                1 << LT_TROPIC,
 	   INDUSTRYBEH_NONE,
-	   STR_INDUSTRY_NAME_WATER_SUPPLY,                  STR_NEWS_INDUSTRY_CONSTRUCTION,
+	   STR_INDUSTRY_NAME_WATER_SUPPLY,       STR_ABBREV_WATER_SUPPLY,                           STR_NEWS_INDUSTRY_CONSTRUCTION,
 	   STR_NEWS_INDUSTRY_CLOSURE_GENERAL,    STR_NEWS_INDUSTRY_PRODUCTION_INCREASE_GENERAL,     STR_NEWS_INDUSTRY_PRODUCTION_DECREASE_GENERAL),
 
 	MI(_tile_table_water_tower,                0, NULL,
@@ -1423,7 +1423,7 @@
 	   CT_WATER,     256, CT_INVALID,     256, CT_INVALID,   256,
 	   INDUSTRYLIFE_BLACK_HOLE,                1 << LT_TROPIC,
 	   INDUSTRYBEH_ONLY_INTOWN,
-	   STR_INDUSTRY_NAME_WATER_TOWER,                   STR_NEWS_INDUSTRY_CONSTRUCTION,
+	   STR_INDUSTRY_NAME_WATER_TOWER,        STR_ABBREV_WATER_TOWER,                            STR_NEWS_INDUSTRY_CONSTRUCTION,
 	   STR_NEWS_INDUSTRY_CLOSURE_GENERAL,    STR_NEWS_INDUSTRY_PRODUCTION_INCREASE_GENERAL,     STR_NEWS_INDUSTRY_PRODUCTION_DECREASE_GENERAL),
 
 	MI(_tile_table_factory2,                   1, _factory_sounds,
@@ -1433,7 +1433,7 @@
 	   CT_RUBBER,    256, CT_COPPER_ORE,  256, CT_WOOD,      256,
 	   INDUSTRYLIFE_PROCESSING,                1 << LT_TROPIC,
 	   INDUSTRYBEH_NONE,
-	   STR_INDUSTRY_NAME_FACTORY_2,                       STR_NEWS_INDUSTRY_CONSTRUCTION,
+	   STR_INDUSTRY_NAME_FACTORY_2,                    STR_ABBREV_FACTORY_2,                              STR_NEWS_INDUSTRY_CONSTRUCTION,
 	   STR_NEWS_INDUSTRY_CLOSURE_SUPPLY_PROBLEMS,      STR_NEWS_INDUSTRY_PRODUCTION_INCREASE_GENERAL,     STR_NEWS_INDUSTRY_PRODUCTION_DECREASE_GENERAL),
 
 	MI(_tile_table_farm2,                      0, NULL,
@@ -1443,7 +1443,7 @@
 	   CT_INVALID,   256, CT_INVALID,     256, CT_INVALID,   256,
 	   INDUSTRYLIFE_ORGANIC,                   1 << LT_TROPIC,
 	   INDUSTRYBEH_PLANT_FIELDS | INDUSTRYBEH_PLANT_ON_BUILT,
-	   STR_INDUSTRY_NAME_FARM_2,                          STR_NEWS_INDUSTRY_CONSTRUCTION,
+	   STR_INDUSTRY_NAME_FARM_2,             STR_ABBREV_FARM_2,                          STR_NEWS_INDUSTRY_CONSTRUCTION,
 	   STR_NEWS_INDUSTRY_CLOSURE_GENERAL,    STR_NEWS_INDUSTRY_PRODUCTION_INCREASE_FARM, STR_NEWS_INDUSTRY_PRODUCTION_DECREASE_FARM),
 
 	MI(_tile_table_lumber_mill,                0, NULL,
@@ -1453,7 +1453,7 @@
 	   CT_INVALID,   256, CT_INVALID,     256, CT_INVALID,   256,
 	   INDUSTRYLIFE_PROCESSING,                1 << LT_TROPIC,
 	   INDUSTRYBEH_CUT_TREES,
-	   STR_INDUSTRY_NAME_LUMBER_MILL,                   STR_NEWS_INDUSTRY_CONSTRUCTION,
+	   STR_INDUSTRY_NAME_LUMBER_MILL,             STR_ABBREV_LUMBER_MILL,                            STR_NEWS_INDUSTRY_CONSTRUCTION,
 	   STR_NEWS_INDUSTRY_CLOSURE_LACK_OF_TREES,   STR_NEWS_INDUSTRY_PRODUCTION_INCREASE_GENERAL,     STR_NEWS_INDUSTRY_PRODUCTION_DECREASE_GENERAL),
 
 	MI(_tile_table_cotton_candy,               0, NULL,
@@ -1463,8 +1463,8 @@
 	   CT_INVALID,   256, CT_INVALID,     256, CT_INVALID,   256,
 	   INDUSTRYLIFE_ORGANIC,                   1 << LT_TOYLAND,
 	   INDUSTRYBEH_NONE,
-	   STR_INDUSTRY_NAME_COTTON_CANDY_FOREST,           STR_NEWS_INDUSTRY_PLANTED,
-	   STR_NEWS_INDUSTRY_CLOSURE_GENERAL,    STR_NEWS_INDUSTRY_PRODUCTION_INCREASE_FARM, STR_NEWS_INDUSTRY_PRODUCTION_DECREASE_GENERAL),
+	   STR_INDUSTRY_NAME_COTTON_CANDY_FOREST, STR_ABBREV_COTTON_CANDY_FOREST,             STR_NEWS_INDUSTRY_PLANTED,
+	   STR_NEWS_INDUSTRY_CLOSURE_GENERAL,     STR_NEWS_INDUSTRY_PRODUCTION_INCREASE_FARM, STR_NEWS_INDUSTRY_PRODUCTION_DECREASE_GENERAL),
 
 	MI(_tile_table_candy_factory,              0, NULL,
 	   206,  0xFFFFFFFF,                       0, 0, 0, 3,    0, 0, 0, 5,        174,
@@ -1473,7 +1473,7 @@
 	   CT_SUGAR,     256, CT_TOFFEE,      256, CT_COTTON_CANDY, 256,
 	   INDUSTRYLIFE_PROCESSING,                1 << LT_TOYLAND,
 	   INDUSTRYBEH_NONE,
-	   STR_INDUSTRY_NAME_CANDY_FACTORY,                 STR_NEWS_INDUSTRY_CONSTRUCTION,
+	   STR_INDUSTRY_NAME_CANDY_FACTORY,                STR_ABBREV_CANDY_FACTORY,                          STR_NEWS_INDUSTRY_CONSTRUCTION,
 	   STR_NEWS_INDUSTRY_CLOSURE_SUPPLY_PROBLEMS,      STR_NEWS_INDUSTRY_PRODUCTION_INCREASE_GENERAL,     STR_NEWS_INDUSTRY_PRODUCTION_DECREASE_GENERAL),
 
 	MI(_tile_table_battery_farm,               0, NULL,
@@ -1483,7 +1483,7 @@
 	   CT_INVALID,   256, CT_INVALID,     256, CT_INVALID,   256,
 	   INDUSTRYLIFE_ORGANIC,                   1 << LT_TOYLAND,
 	   INDUSTRYBEH_NONE,
-	   STR_INDUSTRY_NAME_BATTERY_FARM,                  STR_NEWS_INDUSTRY_CONSTRUCTION,
+	   STR_INDUSTRY_NAME_BATTERY_FARM,       STR_ABBREV_BATTERY_FARM,                    STR_NEWS_INDUSTRY_CONSTRUCTION,
 	   STR_NEWS_INDUSTRY_CLOSURE_GENERAL,    STR_NEWS_INDUSTRY_PRODUCTION_INCREASE_FARM, STR_NEWS_INDUSTRY_PRODUCTION_DECREASE_FARM),
 
 	MI(_tile_table_cola_wells,                 0, NULL,
@@ -1493,7 +1493,7 @@
 	   CT_INVALID,   256, CT_INVALID,     256, CT_INVALID,   256,
 	   INDUSTRYLIFE_EXTRACTIVE,                1 << LT_TOYLAND,
 	   INDUSTRYBEH_NONE,
-	   STR_INDUSTRY_NAME_COLA_WELLS,                    STR_NEWS_INDUSTRY_CONSTRUCTION,
+	   STR_INDUSTRY_NAME_COLA_WELLS,         STR_ABBREV_COLA_WELLS,                             STR_NEWS_INDUSTRY_CONSTRUCTION,
 	   STR_NEWS_INDUSTRY_CLOSURE_GENERAL,    STR_NEWS_INDUSTRY_PRODUCTION_INCREASE_GENERAL,     STR_NEWS_INDUSTRY_PRODUCTION_DECREASE_GENERAL),
 
 	MI(_tile_table_toy_shop,                   0, NULL,
@@ -1503,7 +1503,7 @@
 	   CT_TOYS,      256, CT_INVALID,     256, CT_INVALID,   256,
 	   INDUSTRYLIFE_BLACK_HOLE,                1 << LT_TOYLAND,
 	   INDUSTRYBEH_ONLY_NEARTOWN,
-	   STR_INDUSTRY_NAME_TOY_SHOP,                      STR_NEWS_INDUSTRY_CONSTRUCTION,
+	   STR_INDUSTRY_NAME_TOY_SHOP,                     STR_ABBREV_TOY_SHOP,                               STR_NEWS_INDUSTRY_CONSTRUCTION,
 	   STR_NEWS_INDUSTRY_CLOSURE_SUPPLY_PROBLEMS,      STR_NEWS_INDUSTRY_PRODUCTION_INCREASE_GENERAL,     STR_NEWS_INDUSTRY_PRODUCTION_DECREASE_GENERAL),
 
 	MI(_tile_table_toy_factory,                0, NULL,
@@ -1513,7 +1513,7 @@
 	   CT_PLASTIC,   256, CT_BATTERIES,   256, CT_INVALID,   256,
 	   INDUSTRYLIFE_PROCESSING,                1 << LT_TOYLAND,
 	   INDUSTRYBEH_NONE,
-	   STR_INDUSTRY_NAME_TOY_FACTORY,                   STR_NEWS_INDUSTRY_CONSTRUCTION,
+	   STR_INDUSTRY_NAME_TOY_FACTORY,                  STR_ABBREV_TOY_FACTORY,                            STR_NEWS_INDUSTRY_CONSTRUCTION,
 	   STR_NEWS_INDUSTRY_CLOSURE_SUPPLY_PROBLEMS,      STR_NEWS_INDUSTRY_PRODUCTION_INCREASE_GENERAL,     STR_NEWS_INDUSTRY_PRODUCTION_DECREASE_GENERAL),
 
 	MI(_tile_table_plastic_fountain,           1, _plastic_mine_sounds,
@@ -1523,7 +1523,7 @@
 	   CT_INVALID,   256, CT_INVALID,     256, CT_INVALID,   256,
 	   INDUSTRYLIFE_EXTRACTIVE,                1 << LT_TOYLAND,
 	   INDUSTRYBEH_NONE,
-	   STR_INDUSTRY_NAME_PLASTIC_FOUNTAINS,             STR_NEWS_INDUSTRY_CONSTRUCTION,
+	   STR_INDUSTRY_NAME_PLASTIC_FOUNTAINS,  STR_ABBREV_PLASTIC_FOUNTAINS,                      STR_NEWS_INDUSTRY_CONSTRUCTION,
 	   STR_NEWS_INDUSTRY_CLOSURE_GENERAL,    STR_NEWS_INDUSTRY_PRODUCTION_INCREASE_GENERAL,     STR_NEWS_INDUSTRY_PRODUCTION_DECREASE_GENERAL),
 
 	MI(_tile_table_fizzy_drink,                0, NULL,
@@ -1533,7 +1533,7 @@
 	   CT_COLA,       256, CT_BUBBLES,    256, CT_INVALID,   256,
 	   INDUSTRYLIFE_PROCESSING,                1 << LT_TOYLAND,
 	   INDUSTRYBEH_NONE,
-	   STR_INDUSTRY_NAME_FIZZY_DRINK_FACTORY,           STR_NEWS_INDUSTRY_CONSTRUCTION,
+	   STR_INDUSTRY_NAME_FIZZY_DRINK_FACTORY,          STR_ABBREV_FIZZY_DRINK_FACTORY,                    STR_NEWS_INDUSTRY_CONSTRUCTION,
 	   STR_NEWS_INDUSTRY_CLOSURE_SUPPLY_PROBLEMS,      STR_NEWS_INDUSTRY_PRODUCTION_INCREASE_GENERAL,     STR_NEWS_INDUSTRY_PRODUCTION_DECREASE_GENERAL),
 
 	MI(_tile_table_bubble_generator,           0, NULL,
@@ -1543,7 +1543,7 @@
 	   CT_INVALID,   256, CT_INVALID,     256, CT_INVALID,   256,
 	   INDUSTRYLIFE_EXTRACTIVE,                1 << LT_TOYLAND,
 	   INDUSTRYBEH_NONE,
-	   STR_INDUSTRY_NAME_BUBBLE_GENERATOR,              STR_NEWS_INDUSTRY_CONSTRUCTION,
+	   STR_INDUSTRY_NAME_BUBBLE_GENERATOR,   STR_ABBREV_BUBBLE_GENERATOR,                       STR_NEWS_INDUSTRY_CONSTRUCTION,
 	   STR_NEWS_INDUSTRY_CLOSURE_GENERAL,    STR_NEWS_INDUSTRY_PRODUCTION_INCREASE_GENERAL,     STR_NEWS_INDUSTRY_PRODUCTION_DECREASE_GENERAL),
 
 	MI(_tile_table_toffee_quarry,              0, NULL,
@@ -1553,7 +1553,7 @@
 	   CT_INVALID,   256, CT_INVALID,     256, CT_INVALID,   256,
 	   INDUSTRYLIFE_EXTRACTIVE,                1 << LT_TOYLAND,
 	   INDUSTRYBEH_NONE,
-	   STR_INDUSTRY_NAME_TOFFEE_QUARRY,                 STR_NEWS_INDUSTRY_CONSTRUCTION,
+	   STR_INDUSTRY_NAME_TOFFEE_QUARRY,      STR_ABBREV_TOFFEE_QUARRY,                          STR_NEWS_INDUSTRY_CONSTRUCTION,
 	   STR_NEWS_INDUSTRY_CLOSURE_GENERAL,    STR_NEWS_INDUSTRY_PRODUCTION_INCREASE_GENERAL,     STR_NEWS_INDUSTRY_PRODUCTION_DECREASE_GENERAL),
 
 	MI(_tile_table_sugar_mine,                 0, NULL,
@@ -1563,7 +1563,7 @@
 	   CT_INVALID,   256, CT_INVALID,     256, CT_INVALID,   256,
 	   INDUSTRYLIFE_EXTRACTIVE,                1 << LT_TOYLAND,
 	   INDUSTRYBEH_NONE,
-	   STR_INDUSTRY_NAME_SUGAR_MINE,                    STR_NEWS_INDUSTRY_CONSTRUCTION,
+	   STR_INDUSTRY_NAME_SUGAR_MINE,         STR_ABBREV_SUGAR_MINE,                             STR_NEWS_INDUSTRY_CONSTRUCTION,
 	   STR_NEWS_INDUSTRY_CLOSURE_GENERAL,    STR_NEWS_INDUSTRY_PRODUCTION_INCREASE_GENERAL,     STR_NEWS_INDUSTRY_PRODUCTION_DECREASE_GENERAL),
 };
 #undef MI
diff -urNad openttd-1.3.2/src/table/control_codes.h openttd-1.3.2-DC3.0RC3/src/table/control_codes.h
--- openttd-1.3.2/src/table/control_codes.h	2013-07-27 17:09:31.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/table/control_codes.h	2013-11-22 05:49:07.000000000 +0100
@@ -66,6 +66,10 @@
 	SCC_DATE_SHORT,
 	SCC_DATE_LONG,
 	SCC_DATE_ISO,
+	SCC_DATE_WALLCLOCK_TINY,
+	SCC_DATE_WALLCLOCK_SHORT,
+	SCC_DATE_WALLCLOCK_LONG,
+	SCC_DATE_WALLCLOCK_ISO,
 
 	/* Must be consecutive */
 	SCC_STRING1,
diff -urNad openttd-1.3.2/src/table/misc_settings.ini openttd-1.3.2-DC3.0RC3/src/table/misc_settings.ini
--- openttd-1.3.2/src/table/misc_settings.ini	2013-07-27 17:09:31.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/table/misc_settings.ini	2013-11-22 06:20:49.000000000 +0100
@@ -39,8 +39,8 @@
 name     = ""display_opt""
 type     = SLE_UINT8
 var      = _display_opt
-def      = (1 << DO_SHOW_TOWN_NAMES | 1 << DO_SHOW_STATION_NAMES | 1 << DO_SHOW_SIGNS | 1 << DO_FULL_ANIMATION | 1 << DO_FULL_DETAIL | 1 << DO_SHOW_WAYPOINT_NAMES | 1 << DO_SHOW_COMPETITOR_SIGNS)
-full     = ""SHOW_TOWN_NAMES|SHOW_STATION_NAMES|SHOW_SIGNS|FULL_ANIMATION||FULL_DETAIL|WAYPOINTS|SHOW_COMPETITOR_SIGNS""
+def      = (1 << DO_SHOW_TOWN_NAMES | 1 << DO_SHOW_STATION_NAMES | 1 << DO_SHOW_SIGNS | 1 << DO_FULL_ANIMATION | 1 << DO_RAIL_FENCES | 1 << DO_FULL_DETAIL | 1 << DO_SHOW_WAYPOINT_NAMES | 1 << DO_SHOW_COMPETITOR_SIGNS)
+full     = ""SHOW_TOWN_NAMES|SHOW_STATION_NAMES|SHOW_SIGNS|FULL_ANIMATION|FULL_DETAIL|WAYPOINTS|SHOW_COMPETITOR_SIGNS""
 
 [SDTG_BOOL]
 name     = ""fullscreen""
@@ -243,7 +243,7 @@
 var      = _transparency_opt
 def      = 0
 min      = 0
-max      = 0x1FF
+max      = 0x3FF
 cat      = SC_BASIC
 
 [SDTG_VAR]
@@ -252,7 +252,7 @@
 var      = _transparency_lock
 def      = 0
 min      = 0
-max      = 0x1FF
+max      = 0x3FF
 cat      = SC_BASIC
 
 [SDTG_VAR]
diff -urNad openttd-1.3.2/src/table/settings.ini openttd-1.3.2-DC3.0RC3/src/table/settings.ini
--- openttd-1.3.2/src/table/settings.ini	2013-07-27 17:09:31.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/table/settings.ini	2013-11-22 05:49:07.000000000 +0100
@@ -8,6 +8,7 @@
 
 [pre-amble]
 /* Begin - Callback Functions for the various settings */
+static bool AfterChangeOfMaxHeightlevel(int32 p1);
 static bool v_PositionMainToolbar(int32 p1);
 static bool v_PositionStatusbar(int32 p1);
 static bool PopulationInLabelActive(int32 p1);
@@ -25,6 +26,9 @@
 static bool RoadVehSlopeSteepnessChanged(int32 p1);
 static bool DragSignalsDensityChanged(int32);
 static bool TownFoundingChanged(int32 p1);
+static bool UpdateAllCosts(int32 p1);
+static bool CheckDayLengthBalance(int32 p1);
+static bool InvalidateIndustryWindow(int32 p1);
 static bool DifficultyNoiseChange(int32 i);
 static bool MaxNoAIsChange(int32 i);
 static bool CheckRoadSide(int p1);
@@ -40,12 +44,18 @@
 static bool InvalidateCompanyInfrastructureWindow(int32 p1);
 static bool InvalidateCompanyWindow(int32 p1);
 static bool ZoomMinMaxChanged(int32 p1);
+static bool TLSettingChanged(int32 p1);
+bool CargodestModeChanged(int32 p1);
 
 #ifdef ENABLE_NETWORK
 static bool UpdateClientName(int32 p1);
 static bool UpdateServerPassword(int32 p1);
 static bool UpdateRconPassword(int32 p1);
 static bool UpdateClientConfigValues(int32 p1);
+static bool CheckSharingRail(int32 p1);
+static bool CheckSharingRoad(int32 p1);
+static bool CheckSharingWater(int32 p1);
+static bool CheckSharingAir(int32 p1);
 #endif /* ENABLE_NETWORK */
 /* End - Callback Functions for the various settings */
 
@@ -70,6 +80,7 @@
 SDTC_STR   =   SDTC_STR(       $var, $type, $flags, $guiflags, $def,                              $str, $strhelp, $strval, $proc, $from, $to,        $cat),
 SDTC_VAR   =   SDTC_VAR(       $var, $type, $flags, $guiflags, $def,       $min, $max, $interval, $str, $strhelp, $strval, $proc, $from, $to,        $cat),
 SDT_BOOL   =   SDT_BOOL($base, $var,        $flags, $guiflags, $def,                              $str, $strhelp, $strval, $proc, $from, $to,        $cat),
+SDT_LIST   =   SDT_LIST($base, $var, $type, $flags, $guiflags, "$def",                            $str, $strhelp, $strval, $proc, $from, $to,        $cat),
 SDT_OMANY  =  SDT_OMANY($base, $var, $type, $flags, $guiflags, $def,             $max, $full,     $str, $strhelp, $strval, $proc, $from, $to, $load, $cat),
 SDT_STR    =    SDT_STR($base, $var, $type, $flags, $guiflags, $def,                              $str, $strhelp, $strval, $proc, $from, $to,        $cat),
 SDT_VAR    =    SDT_VAR($base, $var, $type, $flags, $guiflags, $def,       $min, $max, $interval, $str, $strhelp, $strval, $proc, $from, $to,        $cat),
@@ -248,8 +259,9 @@
 [SDT_VAR]
 base     = GameSettings
 var      = difficulty.terrain_type
-type     = SLE_UINT8
+type     = SLE_FILE_U8 | SLE_VAR_U8
 from     = 97
+to	 = MORE_HEIGHTLEVEL_SAVEGAME_VERSION - 1
 guiflags = SGF_NEWGAME_ONLY
 def      = 1
 min      = 0
@@ -260,6 +272,19 @@
 
 [SDT_VAR]
 base     = GameSettings
+var      = difficulty.terrain_type
+type     = SLE_UINT8
+from     = MORE_HEIGHTLEVEL_SAVEGAME_VERSION
+guiflags = SGF_NEWGAME_ONLY
+def      = 1
+min      = 0
+max      = 6
+interval = 1
+strval   = STR_TERRAIN_TYPE_EXTREMELY_FLAT
+cat      = SC_BASIC
+
+[SDT_VAR]
+base     = GameSettings
 var      = difficulty.quantity_sea_lakes
 type     = SLE_UINT8
 from     = 97
@@ -281,6 +306,22 @@
 
 [SDT_BOOL]
 base     = GameSettings
+var      = economy.yearly_tax
+from     = 200
+def      = false
+str      = STR_CONFIG_SETTING_TAXES
+strhelp  = STR_CONFIG_SETTING_TAXES_HELPTEXT
+
+[SDT_BOOL]
+base     = GameSettings
+var      = economy.lost_cargo
+from     = 181
+def      = true
+str      = STR_CONFIG_SETTING_LOST_CARGO
+strhelp  = STR_CONFIG_SETTING_LOST_CARGO_HELPTEXT
+
+[SDT_BOOL]
+base     = GameSettings
 var      = difficulty.line_reverse_mode
 from     = 97
 def      = false
@@ -367,6 +408,19 @@
 
 ; Construction
 
+[SDT_VAR]
+base     = GameSettings
+var      = construction.max_heightlevel
+type     = SLE_UINT8
+from     = MORE_HEIGHTLEVEL_SAVEGAME_VERSION
+guiflags = SGF_NEWGAME_ONLY | SGF_NO_NETWORK
+def      = DEF_MAX_HEIGHTLEVEL
+min      = MIN_MAX_HEIGHTLEVEL
+max      = MAX_MAX_HEIGHTLEVEL
+str      = STR_CONFIG_SETTING_MAX_HEIGHTLEVEL
+strval   = STR_JUST_INT
+proc     = AfterChangeOfMaxHeightlevel
+
 [SDT_BOOL]
 base     = GameSettings
 var      = construction.build_on_slopes
@@ -392,6 +446,20 @@
 
 [SDT_VAR]
 base     = GameSettings
+var      = construction.clipboard_capacity
+type     = SLE_UINT8
+flags    = SLF_NOT_IN_SAVE
+guiflags = SGF_NEWGAME_ONLY
+def      = 63
+min      = 1
+max      = 63
+interval = 1
+str      = STR_CONFIG_SETTING_CLIPBOARD_CAPACITY
+strhelp  = STR_CONFIG_SETTING_CLIPBOARD_CAPACITY_HELPTEXT
+strval   = STR_CONFIG_SETTING_CLIPBOARD_CAPACITY_VALUE
+
+[SDT_VAR]
+base     = GameSettings
 var      = construction.terraform_per_64k_frames
 type     = SLE_UINT32
 from     = 156
@@ -467,11 +535,44 @@
 
 [SDT_BOOL]
 base     = GameSettings
+var      = construction.enable_land_buying
+from     = 201
+def      = true
+str      = STR_CONFIG_SETTING_ENABLE_LAND_BUYING
+
+[SDT_BOOL]
+base     = GameSettings
+var      = construction.enable_restrictive_land_buying
+from     = 201
+def      = false
+str      = STR_CONFIG_SETTING_ENABLE_RESTRICTIVE_LAND_BUYING
+
+[SDT_VAR]
+base     = GameSettings
+var      = construction.drag_drop_land_buying_limit
+type     = SLE_UINT8
+from     = 201
+min      = 1
+max      = 64
+interval = 1
+def      = 8
+str      = STR_CONFIG_SETTING_DRAG_DROP_LAND_BUYING_LIMIT
+strval   = STR_JUST_COMMA
+
+[SDT_BOOL]
+base     = GameSettings
 var      = construction.extra_dynamite
 def      = true
 str      = STR_CONFIG_SETTING_EXTRADYNAMITE
 strhelp  = STR_CONFIG_SETTING_EXTRADYNAMITE_HELPTEXT
 
+[SDT_BOOL]
+base     = GameSettings
+var      = construction.snow_in_temperate
+from     = 181
+def      = true
+str      = STR_CONFIG_SETTING_SNOW_IN_TEMPERATE
+
 [SDT_VAR]
 base     = GameSettings
 var      = construction.max_bridge_length
@@ -553,6 +654,20 @@
 
 [SDT_VAR]
 base     = GameSettings
+var      = economy.random_road_construction
+type     = SLE_UINT8
+from     = 181
+def      = 7
+min      = 0
+max      = 100
+interval = 1
+str      = STR_CONFIG_PATCHES_RANDOM_ROAD_CONSTRUCTION
+strhelp  = STR_CONFIG_PATCHES_RANDOM_ROAD_CONSTRUCTION_HELP
+strval   = STR_JUST_INT
+cat      = SC_EXPERT
+
+[SDT_VAR]
+base     = GameSettings
 var      = economy.found_town
 type     = SLE_UINT8
 from     = 128
@@ -567,6 +682,99 @@
 proc     = TownFoundingChanged
 cat      = SC_BASIC
 
+[SDT_VAR]
+base     = GameSettings
+var      = economy.day_length_factor
+type     = SLE_UINT8
+from     = 181
+def      = 1
+min      = 1
+max      = 50
+interval = 1
+str      = STR_CONFIG_SETTING_DAY_LENGTH_FACTOR
+strval   = STR_JUST_COMMA
+proc     = UpdateAllCosts
+cat      = SC_BASIC
+
+[SDT_VAR]
+base     = GameSettings
+var      = economy.day_length_balance_type
+type     = SLE_UINT8
+from     = 181
+guiflags = SGF_MULTISTRING
+def      = DBT_RUN_COST
+min      = DBT_NONE
+max      = DBT_NUM - 1
+interval = 1
+str      = STR_CONFIG_SETTING_DAY_LENGTH_BALANCE
+strval   = STR_CONFIG_SETTING_DAY_LENGTH_BALANCE_NONE
+proc     = UpdateAllCosts
+cat      = SC_BASIC
+
+[SDT_VAR]
+base     = GameSettings
+var      = economy.day_length_balance_factor
+type     = SLE_UINT8
+from     = 181
+def      = 1
+min      = 1
+max      = 50
+interval = 1
+str      = STR_CONFIG_SETTING_DAY_LENGTH_BAL_FACTOR
+strval   = STR_JUST_COMMA
+proc     = UpdateAllCosts
+cat      = SC_BASIC
+
+[SDT_BOOL]
+base     = GameSettings
+var      = economy.include_prop_main_to_run
+from     = 181
+def      = true
+str      = STR_CONFIG_SETTING_INCL_PROP_MAIN_TO_RUN
+
+[SDT_BOOL]
+base     = GameSettings
+var      = economy.include_loan_int_to_run
+from     = 181
+def      = true
+str      = STR_CONFIG_SETTING_INCL_LOAN_INT_TO_RUN
+
+[SDT_BOOL]
+base     = GameSettings
+var      = economy.slow_down_veh_rel_drop_down
+from     = 181
+def      = true
+str      = STR_CONFIG_SETTING_SLOW_DOWN_VEH_REL_DROP
+
+[SDT_BOOL]
+base     = GameSettings
+var      = economy.slow_down_town_growth
+from     = 181
+def      = true
+str      = STR_CONFIG_SETTING_SLOW_DOWN_TOWN_GROWTH
+
+[SDT_BOOL]
+base     = GameSettings
+var      = economy.show_orig_productions
+from     = 181
+def      = true
+str      = STR_CONFIG_SETTING_SHOW_ORIG_PRODUCTION
+proc     = InvalidateIndustryWindow
+
+[SDT_VAR]
+base     = GameSettings
+var      = economy.slow_down_production
+type     = SLE_UINT8
+from     = 181
+def      = 1
+min      = 1
+max      = 50
+interval = 1
+str      = STR_CONFIG_SETTING_SLOW_DOWN_PROD
+strhelp  = STR_CONFIG_SETTING_SLOW_DOWN_PROD_HELPTEXT
+strval   = STR_JUST_COMMA
+cat      = SC_BASIC
+
 [SDT_BOOL]
 base     = GameSettings
 var      = economy.allow_town_level_crossings
@@ -576,6 +784,18 @@
 str      = STR_CONFIG_SETTING_ALLOW_TOWN_LEVEL_CROSSINGS
 strhelp  = STR_CONFIG_SETTING_ALLOW_TOWN_LEVEL_CROSSINGS_HELPTEXT
 
+[SDT_VAR]
+base     = GameSettings
+var      = economy.town_cargo_factor
+type     = SLE_INT8
+from     = 181
+def      = 0
+min      = -16
+max      = +8
+interval = 1
+str      = STR_CONFIG_SETTING_TOWN_CARGO_FACTOR
+strval	 = STR_JUST_INT
+
 ; Vehicles
 
 [SDT_VAR]
@@ -777,6 +997,14 @@
 str      = STR_CONFIG_SETTING_NEVER_EXPIRE_VEHICLES
 strhelp  = STR_CONFIG_SETTING_NEVER_EXPIRE_VEHICLES_HELPTEXT
 
+[SDT_BOOL]
+base     = GameSettings
+var      = vehicle.repair_cost
+from     = 181
+def      = false
+str      = STR_CONFIG_SETTING_REPAIR_COST
+strhelp  = STR_CONFIG_SETTING_REPAIR_COST_HELPTEXT
+
 [SDT_VAR]
 base     = GameSettings
 var      = vehicle.max_trains
@@ -948,6 +1176,99 @@
 proc     = ChangeDynamicEngines
 cat      = SC_EXPERT
 
+[SDT_BOOL]
+base     = GameSettings
+var      = vehicle.limit_vehicle_speed_in_towns
+from     = 181
+def      = true
+str      = STR_CONFIG_SETTING_LIMITVEHSPEED_IN
+strhelp  = STR_CONFIG_SETTING_LIMITVEHSPEED_IN_HELPTEXT
+
+[SDT_VAR]
+base     = GameSettings
+var      = vehicle.max_veh_speed_in_towns_two_way
+type     = SLE_UINT16
+from     = 181
+def      = 50
+min      = 3
+max      = 250
+interval = 1
+str      = STR_CONFIG_SETTING_SET_LIMITVEHSPEED_IN_TNEW
+strval   = STR_JUST_INT
+cat      = SC_EXPERT
+
+[SDT_VAR]
+base     = GameSettings
+var      = vehicle.max_veh_speed_in_towns_one_way
+type     = SLE_UINT16
+from     = 181
+def      = 70
+min      = 3
+max      = 250
+interval = 1
+str      = STR_CONFIG_SETTING_SET_LIMITVEHSPEED_IN_OWOW
+strval   = STR_JUST_INT
+cat      = SC_EXPERT
+
+[SDT_BOOL]
+base     = GameSettings
+var      = vehicle.limit_vehicle_speed_outside_towns
+from     = 181
+def      = false
+str      = STR_CONFIG_SETTING_LIMITVEHSPEED_OUT
+
+[SDT_VAR]
+base     = GameSettings
+var      = vehicle.max_veh_speed_out_towns_two_way
+type     = SLE_UINT16
+from     = 181
+def      = 90
+min      = 3
+max      = 250
+interval = 1
+str      = STR_CONFIG_SETTING_SET_LIMITVEHSPEED_OUT_TNEW
+strval   = STR_JUST_INT
+cat      = SC_EXPERT
+
+[SDT_VAR]
+base     = GameSettings
+var      = vehicle.max_veh_speed_out_towns_one_way
+type     = SLE_UINT16
+from     = 181
+def      = 130
+min      = 3
+max      = 250
+interval = 1
+str      = STR_CONFIG_SETTING_SET_LIMITVEHSPEED_OUT_OWOW
+strval   = STR_JUST_INT
+
+[SDT_BOOL]
+base     = GameSettings
+var      = vehicle.limit_vehicle_speed_tunnel_bridge
+from     = 181
+def      = false
+str      = STR_CONFIG_SETTING_LIMITVEHSPEED_WORMHOLE
+
+[SDT_VAR]
+base     = GameSettings
+var      = vehicle.max_veh_speed_tunnel_bridge
+type     = SLE_UINT16
+from     = 181
+def      = 90
+min      = 3
+max      = 250
+interval = 1
+str      = STR_CONFIG_SETTING_SET_LIMITVEHSPEED_WORMHOLE
+strval   = STR_JUST_INT
+cat      = SC_EXPERT
+
+[SDT_BOOL]
+base     = GameSettings
+var      = vehicle.limit_vehicle_speed_in_curves
+from     = 181
+def      = true
+str      = STR_CONFIG_SETTING_LIMITVEHSPEED_CURVE
+
 [SDT_VAR]
 base     = GameSettings
 var      = vehicle.plane_crashes
@@ -968,6 +1289,14 @@
 length   = 1
 to       = 158
 
+[SDT_BOOL]
+base     = GameSettings
+var      = order.automatic_timetable_separation
+from     = SL_TTSEP_VER
+def      = true
+str      = STR_CONFIG_SETTING_TIMETABLE_ENABLE_SEPARATION
+strhelp  = STR_CONFIG_SETTING_TIMETABLE_ENABLE_SEPARATION_HELPTEXT
+
 [SDTC_BOOL]
 var      = gui.sg_full_load_any
 from     = 22
@@ -1024,6 +1353,15 @@
 
 [SDT_BOOL]
 base     = GameSettings
+var      = station.advanced_control
+from     = 181
+def      = false
+str      = STR_CONFIG_SETTING_STATION_ADVANCED
+strhelp  = STR_CONFIG_SETTING_STATION_ADVANCED_HELPTEXT
+cat      = SC_EXPERT
+
+[SDT_BOOL]
+base     = GameSettings
 var      = station.modified_catchment
 def      = true
 str      = STR_CONFIG_SETTING_CATCHMENT
@@ -1292,10 +1630,243 @@
 strhelp  = STR_CONFIG_SETTING_MODIFIED_ROAD_REBUILD_HELPTEXT
 cat      = SC_EXPERT
 
-; previously ai-new setting.
-[SDT_NULL]
-length   = 1
-to       = 106
+[SDT_VAR]
+base     = GameSettings
+var      = economy.cargodest.mode_pax_mail
+type     = SLE_UINT8
+from     = 181
+guiflags = SGF_MULTISTRING
+def      = 1
+min      = 0
+max      = 1
+interval = 1
+str      = STR_CONFIG_SETTING_CARGODEST_PAX
+strhelp  = STR_CONFIG_SETTING_CARGODEST_PAX_HELPTEXT
+strval   = STR_CONFIG_SETTING_CARGODEST_MODE_OFF
+proc     = CargodestModeChanged
+cat      = SC_BASIC
+
+[SDT_VAR]
+base     = GameSettings
+var      = economy.cargodest.mode_town_cargo
+type     = SLE_UINT8
+from     = 181
+guiflags = SGF_MULTISTRING
+def      = 0
+min      = 0
+max      = 1
+interval = 1
+str      = STR_CONFIG_SETTING_CARGODEST_TOWN
+strhelp  = STR_CONFIG_SETTING_CARGODEST_TOWN_HELPTEXT
+strval   = STR_CONFIG_SETTING_CARGODEST_MODE_OFF
+proc     = CargodestModeChanged
+cat      = SC_BASIC
+
+[SDT_VAR]
+base     = GameSettings
+var      = economy.cargodest.mode_others
+type     = SLE_UINT8
+from     = 181
+guiflags = SGF_MULTISTRING
+def      = 0
+min      = 0
+max      = 1
+interval = 1
+str      = STR_CONFIG_SETTING_CARGODEST_OTHER
+strhelp  = STR_CONFIG_SETTING_CARGODEST_OTHER_HELPTEXT
+strval   = STR_CONFIG_SETTING_CARGODEST_MODE_OFF
+proc     = CargodestModeChanged
+cat      = SC_BASIC
+
+[SDT_LIST]
+base     = GameSettings
+var      = economy.cargodest.base_town_links
+type     = SLE_UINT8
+from     = 181
+def      = 3,3
+cat      = SC_EXPERT
+
+[SDT_LIST]
+base     = GameSettings
+var      = economy.cargodest.base_ind_links
+type     = SLE_UINT8
+from     = 181
+def      = 2,4,1
+cat      = SC_EXPERT
+
+[SDT_VAR]
+base     = GameSettings
+var      = economy.cargodest.city_town_links
+type     = SLE_UINT8
+from     = 181
+def      = 8
+min      = 0
+max      = 255
+cat      = SC_EXPERT
+
+[SDT_LIST]
+base     = GameSettings
+var      = economy.cargodest.town_chances_town
+type     = SLE_UINT8
+from     = 181
+def      = 100,100,100,100
+cat      = SC_EXPERT
+
+[SDT_LIST]
+base     = GameSettings
+var      = economy.cargodest.town_chances_city
+type     = SLE_UINT8
+from     = 181
+def      = 70,100,100,100
+cat      = SC_EXPERT
+
+[SDT_LIST]
+base     = GameSettings
+var      = economy.cargodest.ind_chances
+type     = SLE_UINT8
+from     = 181
+def      = 90,95,100
+cat      = SC_EXPERT
+
+[SDT_VAR]
+base     = GameSettings
+var      = economy.cargodest.random_dest_chance
+type     = SLE_UINT8
+from     = 181
+def      = 5
+min      = 0
+max      = 99
+cat      = SC_EXPERT
+
+[SDT_LIST]
+base     = GameSettings
+var      = economy.cargodest.big_town_pop
+type     = SLE_UINT32
+from     = 181
+def      = 500,2000
+cat      = SC_EXPERT
+
+[SDT_LIST]
+base     = GameSettings
+var      = economy.cargodest.pop_scale_town
+type     = SLE_UINT16
+from     = 181
+def      = 100,180,200,1000
+cat      = SC_EXPERT
+
+[SDT_LIST]
+base     = GameSettings
+var      = economy.cargodest.cargo_scale_ind
+type     = SLE_UINT16
+from     = 181
+def      = 250,200
+cat      = SC_EXPERT
+
+[SDT_LIST]
+base     = GameSettings
+var      = economy.cargodest.min_weight_town
+type     = SLE_UINT16
+from     = 181
+def      = 5,5
+cat      = SC_EXPERT
+
+[SDT_VAR]
+base     = GameSettings
+var      = economy.cargodest.min_weight_ind
+type     = SLE_UINT16
+from     = 181
+def      = 10
+min      = 0
+max      = 1000
+cat      = SC_EXPERT
+
+[SDT_LIST]
+base     = GameSettings
+var      = economy.cargodest.weight_scale_town
+type     = SLE_UINT16
+from     = 181
+def      = 10,40,20,80
+cat      = SC_EXPERT
+
+[SDT_LIST]
+base     = GameSettings
+var      = economy.cargodest.weight_scale_ind
+type     = SLE_UINT16
+from     = 181
+def      = 20,50
+cat      = SC_EXPERT
+
+[SDT_VAR]
+base     = GameSettings
+var      = economy.cargodest.town_nearby_dist
+type     = SLE_UINT32
+from     = 181
+def      = 48*48
+min      = 1
+max      = UINT32_MAX
+cat      = SC_EXPERT
+
+[SDT_VAR]
+base     = GameSettings
+var      = economy.cargodest.ind_nearby_dist
+type     = SLE_UINT32
+from     = 181
+def      = 64*64
+min      = 1
+max      = UINT32_MAX
+cat      = SC_EXPERT
+
+[SDT_VAR]
+base     = GameSettings
+var      = economy.cargodest.max_route_age
+type     = SLE_UINT16
+from     = 181
+def      = 2*DAYS_IN_YEAR
+min      = 0
+max      = UINT16_MAX
+cat      = SC_EXPERT
+
+[SDT_VAR]
+base     = GameSettings
+var      = economy.cargodest.route_recalc_delay
+type     = SLE_UINT16
+from     = 181
+def      = 20
+min      = 0
+max      = UINT16_MAX
+cat      = SC_EXPERT
+
+[SDT_VAR]
+base     = GameSettings
+var      = economy.cargodest.route_recalc_chunk
+type     = SLE_UINT16
+from     = 181
+def      = 15
+min      = 0
+max      = UINT16_MAX
+cat      = SC_EXPERT
+
+[SDT_VAR]
+base     = GameSettings
+var      = economy.cargodest.max_route_penalty[0]
+type     = SLE_UINT16
+from     = 181
+def      = 200
+min      = 0
+max      = UINT16_MAX
+cat      = SC_EXPERT
+
+[SDT_VAR]
+base     = GameSettings
+var      = economy.cargodest.max_route_penalty[1]
+type     = SLE_UINT16
+from     = 181
+def      = 150
+min      = 0
+max      = UINT16_MAX
+cat      = SC_EXPERT
+
+#	SDT_CONDBOOL(GameSettings, economy.mod_road_rebuild,                        77, SL_MAX_VERSION, 0, 0,  true,                    STR_CONFIG_SETTING_MODIFIED_ROAD_REBUILD,  NULL),
 
 [SDT_OMANY]
 base     = GameSettings
@@ -1312,6 +1883,107 @@
 strval   = STR_CONFIG_SETTING_AI_PROFILE_EASY
 cat      = SC_BASIC
 
+
+	
+[SDT_BOOL]
+base     = GameSettings
+var      = economy.infrastructure_sharing[0]
+from     = 200
+def      = false
+str      = STR_CONFIG_SETTING_SHARING_RAIL
+proc     = CheckSharingRail
+
+[SDT_BOOL]
+base     = GameSettings
+var      = economy.infrastructure_sharing[1]
+from     = 200
+def      = false
+str      = STR_CONFIG_SETTING_SHARING_ROAD
+proc     = CheckSharingRoad
+
+[SDT_BOOL]
+base     = GameSettings
+var      = economy.infrastructure_sharing[2]
+from     = 200
+def      = false
+str      = STR_CONFIG_SETTING_SHARING_WATER
+proc     = CheckSharingWater
+
+[SDT_BOOL]
+base     = GameSettings
+var      = economy.infrastructure_sharing[3]
+from     = 200
+def      = false
+str      = STR_CONFIG_SETTING_SHARING_AIR
+proc     = CheckSharingAir
+
+[SDT_VAR]
+base     = GameSettings
+var      = economy.sharing_fee[0]
+type     = SLE_UINT
+from     = 200
+def      = 100
+min      = 0
+max      = 1000000
+interval = 10
+strval   = STR_JUST_INT
+str      = STR_CONFIG_SETTING_SHARING_FEE_RAIL
+
+[SDT_VAR]
+base     = GameSettings
+var      = economy.sharing_fee[1]
+type     = SLE_UINT
+from     = 200
+def      = 100
+min      = 0
+max      = 1000000
+interval = 10
+strval   = STR_JUST_INT
+str      = STR_CONFIG_SETTING_SHARING_FEE_ROAD
+
+[SDT_VAR]
+base     = GameSettings
+var      = economy.sharing_fee[2]
+type     = SLE_UINT
+from     = 200
+def      = 100
+min      = 0
+max      = 1000000
+interval = 10
+strval   = STR_JUST_INT
+str      = STR_CONFIG_SETTING_SHARING_FEE_ROAD
+
+[SDT_VAR]
+base     = GameSettings
+var      = economy.sharing_fee[3]
+type     = SLE_UINT
+from     = 200
+def      = 100
+min      = 0
+max      = 1000000
+interval = 10
+strval   = STR_JUST_INT
+str      = STR_CONFIG_SETTING_SHARING_FEE_AIR
+
+[SDT_BOOL]
+base     = GameSettings
+var      = economy.sharing_payment_in_debt
+from     = 200
+def      = false
+str      = STR_CONFIG_SETTING_SHARING_PAYMENT_IN_DEBT
+
+[SDT_BOOL]
+base     = GameSettings
+var      = economy.town_construction_cost
+from     = SL_IBC
+def      = true
+str      = STR_CONFIG_SETTING_TOWN_CONSTRUCTION_COST
+
+; previously ai-new setting.
+[SDT_NULL]
+length   = 1
+to       = 106
+
 [SDT_BOOL]
 base     = GameSettings
 var      = ai.ai_in_multiplayer
@@ -1363,6 +2035,68 @@
 strval   = STR_JUST_COMMA
 cat      = SC_EXPERT
 
+[SDT_BOOL]
+base     = GameSettings
+var      = construction.traffic_lights
+from     = 200
+def      = true
+str      = STR_CONFIG_SETTING_TRAFFIC_LIGHTS
+strhelp  = STR_CONFIG_SETTING_TRAFFIC_LIGHTS_HELPTEXT
+proc     = TLSettingChanged
+
+[SDT_BOOL]
+base     = GameSettings
+var      = construction.towns_build_traffic_lights
+from     = 200
+def      = true
+str      = STR_CONFIG_SETTING_TOWNS_BUILD_TRAFFIC_LIGHTS
+strhelp  = STR_CONFIG_SETTING_TOWNS_BUILD_TRAFFIC_LIGHTS_HELPTEXT
+
+[SDT_BOOL]
+base     = GameSettings
+var      = construction.allow_building_tls_in_towns
+from     = 200
+def      = false
+str      = STR_CONFIG_SETTING_ALLOW_BUILDING_TLS_ON_TOWN_ROADS
+strhelp  = STR_CONFIG_SETTING_ALLOW_BUILDING_TLS_ON_TOWN_ROADS_HELPTEXT
+
+[SDT_VAR]
+base     = GameSettings
+var      = construction.traffic_lights_green_phase
+type     = SLE_UINT8
+from     = 200
+def      = 2
+min      = 1
+max      = 16
+str      = STR_CONFIG_SETTING_TRAFFIC_LIGHTS_GREEN_PHASE
+strhelp  = STR_CONFIG_SETTING_TRAFFIC_LIGHTS_GREEN_PHASE_HELPTEXT
+strval   = STR_JUST_INT
+
+[SDT_VAR]
+base     = GameSettings
+var      = construction.max_tlc_size
+type     = SLE_UINT8
+from     = 200
+guiflags = SGF_0ISDISABLED
+def      = 4
+min      = 1
+max      = 32
+str      = STR_CONFIG_SETTING_MAX_TRAFFIC_LIGHT_CONSIST_SIZE
+strhelp  = STR_CONFIG_SETTING_MAX_TRAFFIC_LIGHT_CONSIST_SIZE_HELPTEXT
+strval   = STR_JUST_INT
+
+[SDT_VAR]
+base     = GameSettings
+var      = construction.max_tlc_distance
+type     = SLE_UINT8
+from     = 200
+def      = 1
+min      = 0
+max      = 4
+str      = STR_CONFIG_SETTING_MAX_TRAFFIC_LIGHT_CONSIST_DISTANCE
+strhelp  = STR_CONFIG_SETTING_MAX_TRAFFIC_LIGHT_CONSIST_DISTANCE_HELPTEXT
+strval   = STR_CONFIG_SETTING_TILE_LENGTH
+
 ##
 [SDT_VAR]
 base     = GameSettings
@@ -1636,6 +2370,26 @@
 
 [SDT_VAR]
 base     = GameSettings
+var      = pf.npf.npf_road_trafficlight_penalty
+type     = SLE_UINT
+from     = 200
+def      = 2 * NPF_TILE_LENGTH
+min      = 0
+max      = 100000
+str      = STR_NULL
+
+[SDT_VAR]
+base     = GameSettings
+var      = pf.npf.npf_road_two_way_penalty
+type     = SLE_UINT
+from     = 181
+def      = (NPF_TILE_LENGTH / 2)
+min      = 0
+max      = 100000
+cat      = SC_EXPERT
+
+[SDT_VAR]
+base     = GameSettings
 var      = pf.npf.npf_road_dt_occupied_penalty
 type     = SLE_UINT
 from     = 130
@@ -1941,6 +2695,15 @@
 
 [SDT_VAR]
 base     = GameSettings
+var      = pf.yapf.road_trafficlight_penalty
+type     = SLE_UINT
+from     = 200
+def      = 2 * YAPF_TILE_LENGTH
+min      = 0
+max      = 1000000
+
+[SDT_VAR]
+base     = GameSettings
 var      = pf.yapf.road_stop_penalty
 type     = SLE_UINT
 from     = 47
@@ -1951,6 +2714,16 @@
 
 [SDT_VAR]
 base     = GameSettings
+var      = pf.yapf.road_two_way_penalty
+type     = SLE_UINT
+from     = 181
+def      = 1 * YAPF_TILE_LENGTH
+min      = 0
+max      = 1000000
+cat      = SC_EXPERT
+
+[SDT_VAR]
+base     = GameSettings
 var      = pf.yapf.road_stop_occupied_penalty
 type     = SLE_UINT
 from     = 130
@@ -1979,6 +2752,74 @@
 max      = 1000000
 cat      = SC_EXPERT
 
+[SDT_VAR]
+base     = GameSettings
+var      = pf.yapf.route_transfer_cost
+type     = SLE_UINT
+from     = 181
+def      = 500
+min      = 0
+max      = 1000000
+cat      = SC_EXPERT
+
+[SDT_VAR]
+base     = GameSettings
+var      = pf.yapf.route_max_transfers
+type     = SLE_UINT16
+from     = 181
+def      = 5
+min      = 0
+max      = 100000
+cat      = SC_EXPERT
+
+[SDT_VAR]
+base     = GameSettings
+var      = pf.yapf.route_distance_factor
+type     = SLE_UINT16
+from     = 181
+def      = 8
+min      = 0
+max      = 1000
+cat      = SC_EXPERT
+
+[SDT_VAR]
+base     = GameSettings
+var      = pf.yapf.route_travel_time_factor
+type     = SLE_UINT16
+from     = 181
+def      = 32
+min      = 0
+max      = UINT16_MAX
+cat      = SC_EXPERT
+
+[SDT_VAR]
+base     = GameSettings
+var      = pf.yapf.route_station_last_veh_factor
+type     = SLE_UINT16
+from     = 181
+def      = 64
+min      = 0
+max      = UINT16_MAX
+cat      = SC_EXPERT
+
+[SDT_VAR]
+base     = GameSettings
+var      = pf.yapf.route_station_waiting_factor
+type     = SLE_UINT16
+from     = 181
+def      = 128
+min      = 0
+max      = UINT16_MAX
+cat      = SC_EXPERT
+
+[SDT_LIST]
+base     = GameSettings
+var      = pf.yapf.route_mode_cost_factor
+type     = SLE_UINT8
+from     = 181
+def      = 4,2,1,8
+cat      = SC_EXPERT
+
 ##
 [SDT_VAR]
 base     = GameSettings
@@ -2007,8 +2848,9 @@
 [SDT_VAR]
 base     = GameSettings
 var      = game_creation.tgen_smoothness
-type     = SLE_UINT8
+type     = SLE_FILE_U8 | SLE_VAR_U8
 from     = 30
+to       = MORE_HEIGHTLEVEL_SAVEGAME_VERSION - 1 
 guiflags = SGF_MULTISTRING
 def      = 1
 min      = 0
@@ -2019,6 +2861,18 @@
 
 [SDT_VAR]
 base     = GameSettings
+var      = game_creation.tgen_smoothness
+type     = SLE_UINT8
+from     = MORE_HEIGHTLEVEL_SAVEGAME_VERSION
+guiflags = SGF_MULTISTRING
+def      = 1
+min      = 0
+max      = 6
+str      = STR_CONFIG_SETTING_ROUGHNESS_OF_TERRAIN
+strval   = STR_CONFIG_SETTING_ROUGHNESS_OF_TERRAIN_VERY_SMOOTH
+
+[SDT_VAR]
+base     = GameSettings
 var      = game_creation.variety
 type     = SLE_UINT8
 flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
@@ -2139,6 +2993,20 @@
 
 [SDT_VAR]
 base     = GameSettings
+var      = construction.tree_growth_rate
+type     = SLE_UINT8
+from     = 200
+guiflags = SGF_MULTISTRING
+def      = 1
+min      = 0
+max      = 3
+str      = STR_CONFIG_SETTING_TREE_GROWTH
+strhelp  = STR_CONFIG_SETTING_TREE_GROWTH_HELPTEXT
+strval   = STR_CONFIG_SETTING_TREE_GROWTH_NORMAL
+cat      = SC_BASIC
+
+[SDT_VAR]
+base     = GameSettings
 var      = game_creation.custom_sea_level
 type     = SLE_UINT8
 from     = 149
@@ -2442,6 +3310,12 @@
 proc     = PopulationInLabelActive
 
 [SDTC_BOOL]
+var      = gui.forecast_display
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+def      = true
+str      = STR_CONFIG_SETTING_FORECAST_DISPLAY
+
+[SDTC_BOOL]
 var      = gui.link_terraform_toolbar
 flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
 def      = false
@@ -2538,6 +3412,59 @@
 cat      = SC_EXPERT
 
 [SDTC_BOOL]
+var      = gui.time_in_minutes
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+def      = false
+str      = STR_CONFIG_SETTING_TIME_IN_MINUTES
+strhelp  = STR_CONFIG_SETTING_TIME_IN_MINUTES_HELPTEXT
+proc     = InvalidateVehTimetableWindow
+
+[SDTC_BOOL]
+var      = gui.timetable_start_text_entry
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+def      = false
+str      = STR_CONFIG_SETTING_TIMETABLE_START_TEXT_ENTRY
+strhelp  = STR_CONFIG_SETTING_TIMETABLE_START_TEXT_ENTRY_HELPTEXT
+
+[SDTC_VAR]
+var      = gui.ticks_per_minute
+type     = SLE_UINT8
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+strval   = STR_JUST_INT
+def      = 74
+min      = 1
+max      = 255
+str      = STR_CONFIG_SETTING_TICKS_PER_MINUTE
+strhelp  = STR_CONFIG_SETTING_TICKS_PER_MINUTE_HELPTEXT
+proc     = RedrawScreen
+
+[SDTC_VAR]
+var      = gui.date_with_time
+type     = SLE_UINT8
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+guiflags = SGF_MULTISTRING
+def      = 0
+min      = 0
+max      = 3
+str      = STR_CONFIG_SETTING_DATE_WITH_TIME
+strval   = STR_CONFIG_SETTING_DATE_WITH_TIME_NONE
+strhelp  = STR_CONFIG_SETTING_DATE_WITH_TIME_HELPTEXT
+proc     = RedrawScreen
+
+[SDTC_VAR]
+var      = gui.clock_offset
+type     = SLE_UINT16
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+strval   = STR_JUST_INT
+def      = 0
+min      = 0
+max      = 1439
+interval = 60
+str      = STR_CONFIG_SETTING_CLOCK_OFFSET
+strhelp  = STR_CONFIG_SETTING_CLOCK_OFFSET_HELPTEXT
+proc     = RedrawScreen
+
+[SDTC_BOOL]
 var      = gui.timetable_arrival_departure
 flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
 def      = true
@@ -2545,6 +3472,139 @@
 strhelp  = STR_CONFIG_SETTING_TIMETABLE_SHOW_ARRIVAL_DEPARTURE_HELPTEXT
 proc     = InvalidateVehTimetableWindow
 
+[SDTC_VAR]
+var      = gui.max_departures
+type     = SLE_UINT8
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+strval   = STR_JUST_INT
+def      = 10
+min      = 1
+max      = 30
+interval = 1
+str      = STR_CONFIG_MAX_DEPARTURES
+strhelp  = STR_CONFIG_MAX_DEPARTURES_HELPTEXT
+
+[SDTC_VAR]
+var      = gui.max_departure_time
+type     = SLE_UINT16
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+strval   = STR_JUST_INT
+def      = 120
+min      = 30
+max      = 240
+interval = 1
+str      = STR_CONFIG_MAX_DEPARTURE_TIME
+strhelp  = STR_CONFIG_MAX_DEPARTURE_TIME_HELPTEXT
+
+[SDTC_VAR]
+var      = gui.departure_calc_frequency
+type     = SLE_UINT16
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+strval   = STR_JUST_INT
+def      = 10
+min      = 1
+max      = 120
+interval = 1
+str      = STR_CONFIG_DEPARTURE_CALC_FREQUENCY
+strhelp  = STR_CONFIG_DEPARTURE_CALC_FREQUENCY_HELPTEXT
+
+[SDTC_BOOL]
+var      = gui.departure_show_vehicle
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+def      = false
+str      = STR_CONFIG_DEPARTURE_VEHICLE_NAME
+strhelp  = STR_CONFIG_DEPARTURE_VEHICLE_NAME_HELPTEXT
+
+[SDTC_BOOL]
+var      = gui.departure_show_group
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+def      = false
+str      = STR_CONFIG_DEPARTURE_GROUP_NAME
+strhelp  = STR_CONFIG_DEPARTURE_GROUP_NAME_HELPTEXT
+
+[SDTC_BOOL]
+var      = gui.departure_show_company
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+def      = false
+str      = STR_CONFIG_DEPARTURE_COMPANY_NAME
+strhelp  = STR_CONFIG_DEPARTURE_COMPANY_NAME_HELPTEXT
+
+[SDTC_BOOL]
+var      = gui.departure_show_vehicle_type
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+def      = false
+str      = STR_CONFIG_DEPARTURE_VEHICLE_TYPE
+strhelp  = STR_CONFIG_DEPARTURE_VEHICLE_TYPE_HELPTEXT
+
+[SDTC_BOOL]
+var      = gui.departure_show_vehicle_color
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+def      = false
+str      = STR_CONFIG_DEPARTURE_VEHICLE_COLOR
+strhelp  = STR_CONFIG_DEPARTURE_VEHICLE_COLOR_HELPTEXT
+
+[SDTC_BOOL]
+var      = gui.departure_larger_font
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+def      = false
+str      = STR_CONFIG_DEPARTURE_LARGER_FONT
+strhelp  = STR_CONFIG_DEPARTURE_LARGER_FONT_HELPTEXT
+
+[SDTC_BOOL]
+var      = gui.departure_destination_type
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+def      = false
+str      = STR_CONFIG_DEPARTURE_DESTINATION_TYPE
+strhelp  = STR_CONFIG_DEPARTURE_DESTINATION_TYPE_HELPTEXT
+
+[SDTC_BOOL]
+var      = gui.departure_show_both
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+def      = false
+str      = STR_CONFIG_DEPARTURE_SHOW_BOTH
+strhelp  = STR_CONFIG_DEPARTURE_SHOW_BOTH_HELPTEXT
+
+[SDTC_BOOL]
+var      = gui.departure_only_passengers
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+def      = false
+str      = STR_CONFIG_DEPARTURE_ONLY_PASSENGERS
+strhelp  = STR_CONFIG_DEPARTURE_ONLY_PASSENGERS_HELPTEXT
+
+[SDTC_BOOL]
+var      = gui.departure_smart_terminus
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+def      = false
+str      = STR_CONFIG_DEPARTURE_SMART_TERMINUS
+strhelp  = STR_CONFIG_DEPARTURE_SMART_TERMINUS_HELPTEXT
+
+[SDTC_BOOL]
+var      = gui.departure_show_all_stops
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+def      = false
+str      = STR_CONFIG_DEPARTURE_SHOW_ALL_STOPS
+strhelp  = STR_CONFIG_DEPARTURE_SHOW_ALL_STOPS_HELPTEXT
+
+[SDTC_BOOL]
+var      = gui.departure_merge_identical
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+def      = false
+str      = STR_CONFIG_DEPARTURE_MERGE_IDENTICAL
+strhelp  = STR_CONFIG_DEPARTURE_MERGE_IDENTICAL_HELPTEXT
+
+[SDTC_VAR]
+var      = gui.departure_conditionals
+type     = SLE_UINT8
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+guiflags = SGF_MULTISTRING
+def      = 0
+min      = 0
+max      = 2
+str      = STR_CONFIG_DEPARTURE_CONDITIONALS
+strval   = STR_CONFIG_DEPARTURE_CONDITIONALS_1
+strhelp  = STR_CONFIG_DEPARTURE_CONDITIONALS_HELPTEXT
+proc     = RedrawScreen
+
 [SDTC_BOOL]
 var      = gui.quick_goto
 flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
@@ -2673,6 +3733,21 @@
 proc     = RedrawScreen
 cat      = SC_EXPERT
 
+[SDTC_VAR]
+var      = gui.specific_group_name
+type     = SLE_UINT8
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+guiflags = SGF_MULTISTRING
+from     = 181
+def      = 1
+min      = 0
+max      = 1
+interval = 1
+str      = STR_CONFIG_SETTING_SPECIFIC_GROUP_NAME
+strhelp  = STR_CONFIG_SETTING_SPECIFIC_GROUP_NAME_HELPTEXT
+strval   = STR_CONFIG_SETTING_SPECIFIC_GROUP_NAME_TOWN
+cat      = SC_BASIC
+
 [SDTC_BOOL]
 var      = gui.new_nonstop
 flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
@@ -2780,6 +3855,19 @@
 max      = 7
 cat      = SC_BASIC
 
+[SDTC_VAR]
+var      = gui.show_vehicle_route_path
+type     = SLE_UINT32
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+guiflags = SGF_MULTISTRING
+def      = 1
+min      = 0
+max      = 1
+interval = 1
+str      = STR_CONFIG_SETTING_VIEWPORT_MAP_SHOW_VEHICLE_ROUTE_PATH
+strval   = STR_CONFIG_SETTING_VIEWPORT_MAP_SHOW_VEHICLE_ROUTE_PATH_NO
+proc     = RedrawScreen
+
 [SDTC_BOOL]
 var      = gui.station_dragdrop
 flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
@@ -2829,6 +3917,13 @@
 strval   = STR_JUST_COMMA
 proc     = RedrawScreen
 
+[SDTC_BOOL]
+var      = gui.show_vehicle_route_stopovers
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+def      = true
+str      = STR_CONFIG_SETTING_VIEWPORT_MAP_SHOW_VEHICLE_ROUTE_STOPOVERS
+proc     = RedrawScreen
+
 ; For the dedicated build we'll enable dates in logs by default.
 [SDTC_BOOL]
 ifdef    = DEDICATED
@@ -2971,6 +4066,13 @@
 str      = STR_CONFIG_SETTING_SOUND_AMBIENT
 strhelp  = STR_CONFIG_SETTING_SOUND_AMBIENT_HELPTEXT
 
+[SDTC_BOOL]
+var      = sound.cashtill
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+def      = true
+str      = STR_CONFIG_SETTING_SOUND_CASHTILL
+strhelp  = STR_CONFIG_SETTING_SOUND_CASHTILL_HELPTEXT
+
 [SDTC_VAR]
 var      = music.playlist
 type     = SLE_UINT8
@@ -3636,4 +4738,3 @@
 cat      = SC_BASIC
 
 [SDT_END]
-
diff -urNad openttd-1.3.2/src/table/sprites.h openttd-1.3.2-DC3.0RC3/src/table/sprites.h
--- openttd-1.3.2/src/table/sprites.h	2013-07-27 17:09:31.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/table/sprites.h	2013-11-22 05:49:07.000000000 +0100
@@ -56,7 +56,9 @@
 
 /** Extra graphic spritenumbers */
 static const SpriteID SPR_OPENTTD_BASE   = 4896;
-static const uint16 OPENTTD_SPRITE_COUNT = 168;
+//static const uint16 OPENTTD_SPRITE_COUNT = 168;
+//static const uint16 OPENTTD_SPRITE_COUNT = 187;
+static const uint16 OPENTTD_SPRITE_COUNT = 193;
 
 /* Halftile-selection sprites */
 static const SpriteID SPR_HALFTILE_SELECTION_FLAT = SPR_OPENTTD_BASE;
@@ -157,7 +159,10 @@
 static const SpriteID SPR_IMG_DELETE_LEFT            = SPR_OPENTTD_BASE + 166;
 static const SpriteID SPR_IMG_DELETE_RIGHT           = SPR_OPENTTD_BASE + 167;
 
-static const SpriteID SPR_SIGNALS_BASE  = SPR_OPENTTD_BASE + OPENTTD_SPRITE_COUNT;
+static const SpriteID SPR_CLIPBOARD_BASE  = SPR_OPENTTD_BASE + OPENTTD_SPRITE_COUNT;
+static const SpriteID CLIPBOARD_SPRITE_COUNT = 25;
+
+static const SpriteID SPR_SIGNALS_BASE  = SPR_CLIPBOARD_BASE + CLIPBOARD_SPRITE_COUNT;
 static const uint16 PRESIGNAL_SPRITE_COUNT                   =  48;
 static const uint16 PRESIGNAL_AND_SEMAPHORE_SPRITE_COUNT     = 112;
 static const uint16 PRESIGNAL_SEMAPHORE_AND_PBS_SPRITE_COUNT = 240;
@@ -200,7 +205,10 @@
 static const SpriteID SPR_ELRAIL_BASE   = SPR_AUTORAIL_BASE + AUTORAIL_SPRITE_COUNT;
 static const uint16 ELRAIL_SPRITE_COUNT = 48;
 
-static const SpriteID SPR_2CCMAP_BASE   = SPR_ELRAIL_BASE + ELRAIL_SPRITE_COUNT;
+static const SpriteID SPR_TRAFFICLIGHTS_BASE   = SPR_ELRAIL_BASE + ELRAIL_SPRITE_COUNT;
+static const uint16 TRAFFICLIGHTS_SPRITE_COUNT = 22;
+
+static const SpriteID SPR_2CCMAP_BASE   = SPR_TRAFFICLIGHTS_BASE + TRAFFICLIGHTS_SPRITE_COUNT;
 static const uint16 TWOCCMAP_SPRITE_COUNT = 256;
 
 /** shore tiles - action 05-0D */
@@ -286,6 +294,9 @@
 static const SpriteID SPR_EMPTY_BOUNDING_BOX = SPR_RAILTYPE_TUNNEL_BASE + RAILTYPE_TUNNEL_BASE_COUNT;
 static const uint16 EMPTY_BOUNDING_BOX_SPRITE_COUNT = 1;
 
+//static const uint16 SPR_FLAT_BLACKTILES_COUNT = 19;
+//static const SpriteID SPR_FLAT_BLACKTILES = SPR_EMPTY_BOUNDING_BOX + EMPTY_BOUNDING_BOX_SPRITE_COUNT;
+
 /* From where can we start putting NewGRFs? */
 static const SpriteID SPR_NEWGRFS_BASE = SPR_EMPTY_BOUNDING_BOX + EMPTY_BOUNDING_BOX_SPRITE_COUNT;
 
@@ -563,6 +574,8 @@
 static const SpriteID SPR_FLAT_2_QUART_SNOW_DESERT_TILE = 4512;
 static const SpriteID SPR_FLAT_3_QUART_SNOW_DESERT_TILE = 4531;
 static const SpriteID SPR_FLAT_SNOW_DESERT_TILE         = 4550;
+/* Blacktiles all slopes. */
+static const SpriteID SPR_FLAT_BLACKTILES               = SPR_OPENTTD_BASE + 174;
 
 /* Hedge, Farmland-fence sprites */
 static const SpriteID SPR_HEDGE_BUSHES            = 4090;
@@ -1087,6 +1100,34 @@
 static const SpriteID SPR_IMG_SIGN            = 4082;
 static const SpriteID SPR_IMG_BUY_LAND        = 4791;
 
+/* Traffic lights */
+static const SpriteID SPR_IMG_TRAFFIC_LIGHT     = SPR_TRAFFICLIGHTS_BASE;
+static const SpriteID SPR_CURSOR_TRAFFIC_LIGHT  = SPR_TRAFFICLIGHTS_BASE + 1;
+
+static const SpriteID SPR_TL_SW_RED             = SPR_TRAFFICLIGHTS_BASE + 2;
+static const SpriteID SPR_TL_SW_RED_YELLOW      = SPR_TRAFFICLIGHTS_BASE + 3;
+static const SpriteID SPR_TL_SW_GREEN           = SPR_TRAFFICLIGHTS_BASE + 4;
+static const SpriteID SPR_TL_SW_YELLOW          = SPR_TRAFFICLIGHTS_BASE + 5;
+static const SpriteID SPR_TL_SW_NONE            = SPR_TRAFFICLIGHTS_BASE + 6;
+
+static const SpriteID SPR_TL_SE_RED             = SPR_TRAFFICLIGHTS_BASE + 7;
+static const SpriteID SPR_TL_SE_RED_YELLOW      = SPR_TRAFFICLIGHTS_BASE + 8;
+static const SpriteID SPR_TL_SE_GREEN           = SPR_TRAFFICLIGHTS_BASE + 9;
+static const SpriteID SPR_TL_SE_YELLOW          = SPR_TRAFFICLIGHTS_BASE + 10;
+static const SpriteID SPR_TL_SE_NONE            = SPR_TRAFFICLIGHTS_BASE + 11;
+
+static const SpriteID SPR_TL_NW_RED             = SPR_TRAFFICLIGHTS_BASE + 12;
+static const SpriteID SPR_TL_NW_RED_YELLOW      = SPR_TRAFFICLIGHTS_BASE + 13;
+static const SpriteID SPR_TL_NW_GREEN           = SPR_TRAFFICLIGHTS_BASE + 14;
+static const SpriteID SPR_TL_NW_YELLOW          = SPR_TRAFFICLIGHTS_BASE + 15;
+static const SpriteID SPR_TL_NW_NONE            = SPR_TRAFFICLIGHTS_BASE + 16;
+
+static const SpriteID SPR_TL_NE_RED             = SPR_TRAFFICLIGHTS_BASE + 17;
+static const SpriteID SPR_TL_NE_RED_YELLOW      = SPR_TRAFFICLIGHTS_BASE + 18;
+static const SpriteID SPR_TL_NE_GREEN           = SPR_TRAFFICLIGHTS_BASE + 19;
+static const SpriteID SPR_TL_NE_YELLOW          = SPR_TRAFFICLIGHTS_BASE + 20;
+static const SpriteID SPR_TL_NE_NONE            = SPR_TRAFFICLIGHTS_BASE + 21;
+
 /* OpenTTD in gamescreen */
 static const SpriteID SPR_OTTD_O                = 4842;
 static const SpriteID SPR_OTTD_P                = 4841;
@@ -1315,6 +1356,30 @@
 static const SpriteID SPR_IMG_CONVERT_MONO   = SPR_OPENTTD_BASE + 65;
 static const SpriteID SPR_IMG_CONVERT_MAGLEV = SPR_OPENTTD_BASE + 71;
 
+/* clipboard_gui.cpp */
+static const SpriteID SPR_IMG_CLIPBOARD                    = SPR_CLIPBOARD_BASE + 0;
+static const SpriteID SPR_IMG_CLIPBOARD_COPY               = SPR_CLIPBOARD_BASE + 1;
+static const SpriteID SPR_IMG_CLIPBOARD_PASTE              = SPR_CLIPBOARD_BASE + 2;
+static const SpriteID SPR_IMG_CLIPBOARD_SELECT_COPY_AREA   = SPR_CLIPBOARD_BASE + 3;
+static const SpriteID SPR_IMG_CLIPBOARD_INSTANT_COPY_PASTE = SPR_CLIPBOARD_BASE + 4;
+static const SpriteID SPR_IMG_CLIPBOARD_NO_RAIL_CONVERTION = SPR_CLIPBOARD_BASE + 5;
+static const SpriteID SPR_IMG_CLIPBOARD_MIRROR_SIGNALS_OFF = SPR_CLIPBOARD_BASE + 6;
+static const SpriteID SPR_IMG_CLIPBOARD_MIRROR_SIGNALS_ON  = SPR_CLIPBOARD_BASE + 7;
+static const SpriteID SPR_IMG_CLIPBOARD_UPGRADE_BRIDGES    = SPR_CLIPBOARD_BASE + 8;
+static const SpriteID SPR_IMG_CLIPBOARD_ROTATE_LEFT        = SPR_CLIPBOARD_BASE + 9;
+static const SpriteID SPR_IMG_CLIPBOARD_ROTATE_RIGHT       = SPR_CLIPBOARD_BASE + 10;
+static const SpriteID SPR_IMG_CLIPBOARD_REFLECT_NE_SW      = SPR_CLIPBOARD_BASE + 11;
+static const SpriteID SPR_IMG_CLIPBOARD_REFLECT_NW_SE      = SPR_CLIPBOARD_BASE + 12;
+static const SpriteID SPR_IMG_TRANFORMATION_IDENTITY       = SPR_CLIPBOARD_BASE + 13;
+static const SpriteID SPR_IMG_TRANFORMATION_ROT_90_R       = SPR_CLIPBOARD_BASE + 14;
+static const SpriteID SPR_IMG_TRANFORMATION_ROT_180        = SPR_CLIPBOARD_BASE + 15;
+static const SpriteID SPR_IMG_TRANFORMATION_ROT_90_L       = SPR_CLIPBOARD_BASE + 16;
+static const SpriteID SPR_IMG_TRANFORMATION_REF_NE_SW      = SPR_CLIPBOARD_BASE + 17;
+static const SpriteID SPR_IMG_TRANFORMATION_REF_W_E        = SPR_CLIPBOARD_BASE + 18;
+static const SpriteID SPR_IMG_TRANFORMATION_REF_NW_SE      = SPR_CLIPBOARD_BASE + 19;
+static const SpriteID SPR_IMG_TRANFORMATION_REF_N_S        = SPR_CLIPBOARD_BASE + 20;
+static const SpriteID SPR_IMG_CLIPBOARD_HEIGHT_PANEL       = SPR_CLIPBOARD_BASE + 21;
+
 /* intro_gui.cpp, genworld_gui.cpp */
 static const SpriteID SPR_SELECT_TEMPERATE           = 4882;
 static const SpriteID SPR_SELECT_TEMPERATE_PUSHED    = 4883;
@@ -1423,6 +1488,11 @@
 static const CursorID SPR_CURSOR_CLONE_SHIP     = SPR_OPENTTD_BASE + 112;
 static const CursorID SPR_CURSOR_CLONE_AIRPLANE = SPR_OPENTTD_BASE + 113;
 
+/* Clipboard cursors */
+static const CursorID SPR_CURSOR_COPY           = SPR_CLIPBOARD_BASE + 22;
+static const CursorID SPR_CURSOR_PASTE          = SPR_CLIPBOARD_BASE + 23;
+static const CursorID SPR_CURSOR_ADJUST_HEIGHT  = SPR_CLIPBOARD_BASE + 24;
+
 /** Animation macro in table/animcursors.h (_animcursors[]) */
 
 static const CursorID SPR_CURSOR_DEMOLISH_FIRST = 704;
diff -urNad openttd-1.3.2/src/table/station_land.h openttd-1.3.2-DC3.0RC3/src/table/station_land.h
--- openttd-1.3.2/src/table/station_land.h	2013-07-27 17:09:31.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/table/station_land.h	2013-11-22 05:49:07.000000000 +0100
@@ -507,6 +507,45 @@
 	TILE_SEQ_END()
 };
 
+/* asphalt tile with fences in north and south and west*/
+static const DrawTileSeqStruct _station_display_fence_ne_nw_sw[] = {
+	TILE_SEQ_GROUND( 0,  0,  0,  SPR_AIRPORT_FENCE_X | (1U << PALETTE_MODIFIER_COLOUR))
+	TILE_SEQ_GROUND( 0,  0,  0,  SPR_AIRPORT_FENCE_Y | (1U << PALETTE_MODIFIER_COLOUR))
+	TILE_SEQ_GROUND(15,  0,  0,  SPR_AIRPORT_FENCE_Y | (1U << PALETTE_MODIFIER_COLOUR))
+	TILE_SEQ_END()
+};
+
+/* asphalt tile with fences in north and south and east */
+static const DrawTileSeqStruct _station_display_fence_ne_se_sw[] = {
+	TILE_SEQ_GROUND( 0,  15,  0,  SPR_AIRPORT_FENCE_X | (1U << PALETTE_MODIFIER_COLOUR))
+	TILE_SEQ_GROUND( 0,  0,  0,  SPR_AIRPORT_FENCE_Y | (1U << PALETTE_MODIFIER_COLOUR))
+	TILE_SEQ_GROUND(15,  0,  0,  SPR_AIRPORT_FENCE_Y | (1U << PALETTE_MODIFIER_COLOUR))
+	TILE_SEQ_END()
+};
+
+/* asphalt tile with fences in east and west */
+static const DrawTileSeqStruct _station_display_fence_nw_se[] = {
+	TILE_SEQ_GROUND( 0,  0,  0,  SPR_AIRPORT_FENCE_X | (1U << PALETTE_MODIFIER_COLOUR))
+	TILE_SEQ_GROUND( 0, 15,  0,  SPR_AIRPORT_FENCE_X | (1U << PALETTE_MODIFIER_COLOUR))
+	TILE_SEQ_END()
+};
+
+/* asphalt tile with fences in east and west and south*/
+static const DrawTileSeqStruct _station_display_fence_nw_se_sw[] = {
+	TILE_SEQ_GROUND( 0,  0,  0,  SPR_AIRPORT_FENCE_X | (1U << PALETTE_MODIFIER_COLOUR))
+	TILE_SEQ_GROUND( 0, 15,  0,  SPR_AIRPORT_FENCE_X | (1U << PALETTE_MODIFIER_COLOUR))
+	TILE_SEQ_GROUND(15,  0,  0, SPR_AIRPORT_FENCE_Y  | (1U << PALETTE_MODIFIER_COLOUR))
+	TILE_SEQ_END()
+};
+
+/* asphalt tile with fences in east and west and north*/
+static const DrawTileSeqStruct _station_display_fence_ne_nw_se[] = {
+	TILE_SEQ_GROUND( 0,  0,  0,  SPR_AIRPORT_FENCE_X | (1U << PALETTE_MODIFIER_COLOUR))
+	TILE_SEQ_GROUND( 0, 15,  0,  SPR_AIRPORT_FENCE_X | (1U << PALETTE_MODIFIER_COLOUR))
+	TILE_SEQ_GROUND( 0,  0,  0,  SPR_AIRPORT_FENCE_Y | (1U << PALETTE_MODIFIER_COLOUR))
+	TILE_SEQ_END()
+};
+
 /* runway tiles with 2 corner fences */
 static const DrawTileSeqStruct _station_display_fence_nw_sw[] = {
 	TILE_SEQ_GROUND( 0,  0,  0, SPR_AIRPORT_FENCE_X | (1U << PALETTE_MODIFIER_COLOUR)) // fences north
@@ -877,6 +916,28 @@
 	TILE_SPRITE_LINE(SPR_AIRPORT_APRON,              _station_display_grass_west) // APT_APRON_HALF_EAST
 	TILE_SPRITE_LINE(SPR_AIRPORT_APRON,              _station_display_grass_east) // APT_APRON_HALF_WEST
 	TILE_SPRITE_NULL() // APT_GRASS_FENCE_NE_FLAG_2
+	TILE_SPRITE_LINE(SPR_NSRUNWAY4,                   _station_display_nothing) // APT_NSRUNWAY_4
+	TILE_SPRITE_LINE(SPR_NSRUNWAY4,                   _station_display_fence_sw) // APT_NSRUNWAY_4_SW 
+  TILE_SPRITE_LINE(SPR_NSRUNWAY4,                   _station_display_fence_ne) // APT_NSRUNWAY_4_NE 
+  TILE_SPRITE_LINE(SPR_NSRUNWAY_END,                _station_display_fence_sw) // APT_NSRUNWAY_END_FENCE_SW  
+  TILE_SPRITE_LINE(SPR_NSRUNWAY_END,                _station_display_fence_ne) // APT_NSRUNWAY_END_FENCE_NE 
+	TILE_SPRITE_LINE(SPR_AIRPORT_APRON,               _station_display_hangar_sw) // APT_DEPOT_SW
+	TILE_SPRITE_LINE(SPR_AIRPORT_APRON,               _station_display_hangar_nw) // APT_DEPOT_NW
+	TILE_SPRITE_LINE(SPR_AIRPORT_APRON,               _station_display_hangar_ne) // APT_DEPOT_NE 
+	TILE_SPRITE_LINE(SPR_NSRUNWAY4,                   _station_display_fence_se_sw) // APT_NSRUNWAY_4_SE_SW
+	TILE_SPRITE_LINE(SPR_NSRUNWAY4,                   _station_display_fence_nw_sw) // APT_NSRUNWAY_4_NW_SW 
+  TILE_SPRITE_LINE(SPR_NSRUNWAY4,                   _station_display_fence_ne_se) // APT_NSRUNWAY_4_NE_SE  
+  TILE_SPRITE_LINE(SPR_NSRUNWAY4,                   _station_display_fence_ne_nw) // APT_NSRUNWAY_4_NE_NW 
+  TILE_SPRITE_LINE(SPR_NSRUNWAY4,                   _station_display_fence_ne_sw) // APT_NSRUNWAY_4_NE_SW 
+  TILE_SPRITE_LINE(SPR_NSRUNWAY_END,                _station_display_fence_ne_se_sw) // APT_NSRUNWAY_END_NE_SE_SW 
+  TILE_SPRITE_LINE(SPR_NSRUNWAY_END,                _station_display_fence_ne_nw_sw) // APT_NSRUNWAY_END_NE_NW_SW 
+	TILE_SPRITE_LINE(SPR_AIRPORT_RUNWAY_EXIT_B,       _station_display_fence_nw_se) // APT_RUNWAY_2_NW_SE   
+	TILE_SPRITE_LINE(SPR_AIRPORT_RUNWAY_END,          _station_display_fence_nw_se_sw) // APT_RUNWAY_END_NW_SE_SW    
+	TILE_SPRITE_LINE(SPR_AIRPORT_RUNWAY_END,          _station_display_fence_ne_nw_se) // APT_RUNWAY_END_NE_NW_SE 
+  TILE_SPRITE_LINE(SPR_NSRUNWAY_END,                _station_display_fence_ne_se) // APT_NSRUNWAY_END_NE_SE
+  TILE_SPRITE_LINE(SPR_NSRUNWAY_END,                _station_display_fence_ne_nw) // APT_NSRUNWAY_END_NE_NW
+  TILE_SPRITE_LINE(SPR_NSRUNWAY_END,                _station_display_fence_se_sw) // APT_NSRUNWAY_END_SE_SW 
+  TILE_SPRITE_LINE(SPR_NSRUNWAY_END,                _station_display_fence_nw_sw) // APT_NSRUNWAY_END_NW_SW   
 };
 
 static const DrawTileSprites _station_display_datas_airport_radar_grass_fence_sw[] = {
diff -urNad openttd-1.3.2/src/table/strgen_tables.h openttd-1.3.2-DC3.0RC3/src/table/strgen_tables.h
--- openttd-1.3.2/src/table/strgen_tables.h	2013-07-27 17:09:31.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/table/strgen_tables.h	2013-11-22 05:49:07.000000000 +0100
@@ -90,6 +90,10 @@
 	{"DATE_SHORT",        EmitSingleChar, SCC_DATE_SHORT,         1, C_CASE},
 	{"DATE_LONG",         EmitSingleChar, SCC_DATE_LONG,          1, C_CASE},
 	{"DATE_ISO",          EmitSingleChar, SCC_DATE_ISO,           1, C_NONE},
+	{"DATE_WALLCLOCK_TINY",       EmitSingleChar, SCC_DATE_WALLCLOCK_TINY,          1, C_NONE},
+	{"DATE_WALLCLOCK_SHORT",      EmitSingleChar, SCC_DATE_WALLCLOCK_SHORT,         1, C_NONE},
+	{"DATE_WALLCLOCK_LONG",       EmitSingleChar, SCC_DATE_WALLCLOCK_LONG,          1, C_NONE},
+	{"DATE_WALLCLOCK_ISO",        EmitSingleChar, SCC_DATE_WALLCLOCK_ISO,           1, C_NONE},
 
 	{"STRING",            EmitSingleChar, SCC_STRING,             1, C_CASE | C_GENDER},
 	{"RAW_STRING",        EmitSingleChar, SCC_RAW_STRING_POINTER, 1, C_NONE | C_GENDER},
diff -urNad openttd-1.3.2/src/terraform_cmd.cpp openttd-1.3.2-DC3.0RC3/src/terraform_cmd.cpp
--- openttd-1.3.2/src/terraform_cmd.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/terraform_cmd.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -10,7 +10,9 @@
 /** @file terraform_cmd.cpp Commands related to terraforming. */
 
 #include "stdafx.h"
+#include "core/geometry_func.hpp"
 #include "command_func.h"
+#include "copypaste_cmd.h"
 #include "tunnel_map.h"
 #include "bridge_map.h"
 #include "viewport_func.h"
@@ -18,41 +20,18 @@
 #include "object_base.h"
 #include "company_base.h"
 #include "company_func.h"
+#include "strings_func.h"
+#include "tunnelbridge.h"
 
 #include "table/strings.h"
 
-/*
- * In one terraforming command all four corners of a initial tile can be raised/lowered (though this is not available to the player).
- * The maximal amount of height modifications is achieved when raising a complete flat land from sea level to MAX_TILE_HEIGHT or vice versa.
- * This affects all corners with a manhatten distance smaller than MAX_TILE_HEIGHT to one of the initial 4 corners.
- * Their maximal amount is computed to 4 * \sum_{i=1}^{h_max} i  =  2 * h_max * (h_max + 1).
- */
-static const int TERRAFORMER_MODHEIGHT_SIZE = 2 * MAX_TILE_HEIGHT * (MAX_TILE_HEIGHT + 1);
-
-/*
- * The maximal amount of affected tiles (i.e. the tiles that incident with one of the corners above, is computed similar to
- * 1 + 4 * \sum_{i=1}^{h_max} (i+1)  =  1 + 2 * h_max + (h_max + 3).
- */
-static const int TERRAFORMER_TILE_TABLE_SIZE = 1 + 2 * MAX_TILE_HEIGHT * (MAX_TILE_HEIGHT + 3);
-
-struct TerraformerHeightMod {
-	TileIndex tile;   ///< Referenced tile.
-	byte height;      ///< New TileHeight (height of north corner) of the tile.
-};
+#include <map>
+#include <set>
 
 struct TerraformerState {
-	int modheight_count;  ///< amount of entries in "modheight".
-	int tile_table_count; ///< amount of entries in "tile_table".
+       std::set<TileIndex> dirty_tiles;
 
-	/**
-	 * Dirty tiles, i.e.\ at least one corner changed.
-	 *
-	 * This array contains the tiles which are or will be marked as dirty.
-	 *
-	 * @ingroup dirty
-	 */
-	TileIndex tile_table[TERRAFORMER_TILE_TABLE_SIZE];
-	TerraformerHeightMod modheight[TERRAFORMER_MODHEIGHT_SIZE];  ///< Height modifications.
+       std::map<TileIndex, int> tile_to_new_height;
 };
 
 TileIndex _terraform_err_tile; ///< first tile we couldn't terraform
@@ -64,16 +43,13 @@
  * @param tile Tile.
  * @return TileHeight.
  */
-static int TerraformGetHeightOfTile(const TerraformerState *ts, TileIndex tile)
+static int TerraformGetHeightOfTile(TerraformerState *ts, TileIndex tile)
 {
-	const TerraformerHeightMod *mod = ts->modheight;
-
-	for (int count = ts->modheight_count; count != 0; count--, mod++) {
-		if (mod->tile == tile) return mod->height;
+	if (ts->tile_to_new_height.find(tile) != ts->tile_to_new_height.end()) {
+		return ts->tile_to_new_height[tile];
+	} else {
+		return TileHeight(tile);
 	}
-
-	/* TileHeight unchanged so far, read value from map. */
-	return TileHeight(tile);
 }
 
 /**
@@ -85,26 +61,7 @@
  */
 static void TerraformSetHeightOfTile(TerraformerState *ts, TileIndex tile, int height)
 {
-	/* Find tile in the "modheight" table.
-	 * Note: In a normal user-terraform command the tile will not be found in the "modheight" table.
-	 *       But during house- or industry-construction multiple corners can be terraformed at once. */
-	TerraformerHeightMod *mod = ts->modheight;
-	int count = ts->modheight_count;
-
-	while ((count > 0) && (mod->tile != tile)) {
-		mod++;
-		count--;
-	}
-
-	/* New entry? */
-	if (count == 0) {
-		assert(ts->modheight_count < TERRAFORMER_MODHEIGHT_SIZE);
-		ts->modheight_count++;
-	}
-
-	/* Finally store the new value */
-	mod->tile = tile;
-	mod->height = (byte)height;
+	ts->tile_to_new_height[tile] = height;
 }
 
 /**
@@ -116,15 +73,7 @@
  */
 static void TerraformAddDirtyTile(TerraformerState *ts, TileIndex tile)
 {
-	int count = ts->tile_table_count;
-
-	for (TileIndex *t = ts->tile_table; count != 0; count--, t++) {
-		if (*t == tile) return;
-	}
-
-	assert(ts->tile_table_count < TERRAFORMER_TILE_TABLE_SIZE);
-
-	ts->tile_table[ts->tile_table_count++] = tile;
+	ts->dirty_tiles.insert(tile);
 }
 
 /**
@@ -143,6 +92,92 @@
 	TerraformAddDirtyTile(ts, tile);
 }
 
+static void MarkTilesDirty(TerraformerState &ts)
+{
+	for (std::set<TileIndex>::const_iterator it = ts.dirty_tiles.begin(); it != ts.dirty_tiles.end(); it++) {
+		TileIndex ti = *it;
+		MarkTileDirtyByTile(ti);
+
+		int height = TerraformGetHeightOfTile(&ts, ti);
+
+		/* Now, if we alter the height of the map edge, we need to take care
+		 * about repainting the affected areas outside map as well.
+		 * Remember:
+		 * Outside map, we assume that our landscape descends to
+		 * height zero as fast as possible.
+		 * Those simulated tiles (they don't exist as datastructure,
+		 * only as concept in code) need to be repainted properly,
+		 * otherwise we will get ugly glitches.
+		 *
+		 * Furthermore, note that we have to take care about the possibility,
+		 * that landscape was higher before the change,
+		 * so also tiles a bit outside need to be repainted. */
+		int x = TileX(ti);
+		int y = TileY(ti);
+		if (x == 0) {
+			if (y == 0) {
+				/* Height of the northern corner is altered. */
+				for (int cx = 0; cx >= -height - 1; cx--) {
+					for (int cy = 0; cy >= -height - 1; cy--) {
+						/* This means, tiles in the sector north of that
+						 * corner need to be repainted. */
+						if (cx + cy >= -height - 2) {
+							/* But only tiles that actually might have changed. */
+							MarkTileDirtyByTileOutsideMap(cx, cy);
+						}
+					}
+				}
+			} else if (y < (int)MapMaxY()) {
+				for (int cx = 0; cx >= -height - 1; cx--) {
+					MarkTileDirtyByTileOutsideMap(cx, y);
+				}
+			} else {
+				for (int cx = 0; cx >= -height - 1; cx--) {
+					for (int cy = (int)MapMaxY(); cy <= (int)MapMaxY() + height + 1; cy++) {
+						if (cx + ((int)MapMaxY() - cy) >= -height - 2) {
+							MarkTileDirtyByTileOutsideMap(cx, cy);
+						}
+					}
+				}
+			}
+		} else if (x < (int)MapMaxX()) {
+			if (y == 0) {
+				for (int cy = 0; cy >= -height - 1; cy--) {
+					MarkTileDirtyByTileOutsideMap(x, cy);
+				}
+			} else if (y < (int)MapMaxY()) {
+				/* Nothing to be done here, we are inside the map. */
+			} else {
+				for (int cy = (int)MapMaxY(); cy <= (int)MapMaxY() + height + 1; cy++) {
+					MarkTileDirtyByTileOutsideMap(x, cy);
+				}
+			}
+		} else {
+			if (y == 0) {
+				for (int cx = (int)MapMaxX(); cx <= (int)MapMaxX() + height + 1; cx++) {
+					for (int cy = 0; cy >= -height - 1; cy--) {
+						if (((int)MapMaxX() - cx) + cy >= -height - 2) {
+							MarkTileDirtyByTileOutsideMap(cx, cy);
+						}
+					}
+				}
+			} else if (y < (int)MapMaxY()) {
+				for (int cx = (int)MapMaxX(); cx <= (int)MapMaxX() + height + 1; cx++) {
+					MarkTileDirtyByTileOutsideMap(cx, y);
+				}
+			} else {
+				for (int cx = (int)MapMaxX(); cx <= (int)MapMaxX() + height + 1; cx++) {
+					for (int cy = (int)MapMaxY(); cy <= (int)MapMaxY() + height + 1; cy++) {
+						if (((int)MapMaxX() - cx) + ((int)MapMaxY() - cy) >= -height - 2) {
+							MarkTileDirtyByTileOutsideMap(cx, cy);
+						}
+					}
+				}
+			}
+		}
+	}
+}
+
 /**
  * Terraform the north corner of a tile to a specific height.
  *
@@ -157,7 +192,7 @@
 
 	/* Check range of destination height */
 	if (height < 0) return_cmd_error(STR_ERROR_ALREADY_AT_SEA_LEVEL);
-	if (height > (int)MAX_TILE_HEIGHT) return_cmd_error(STR_ERROR_TOO_HIGH);
+	if (height > _settings_game.construction.max_heightlevel) return_cmd_error(STR_ERROR_TOO_HIGH);
 
 	/*
 	 * Check if the terraforming has any effect.
@@ -245,8 +280,6 @@
 	int direction = (p2 != 0 ? 1 : -1);
 	TerraformerState ts;
 
-	ts.modheight_count = ts.tile_table_count = 0;
-
 	/* Compute the costs and the terraforming result in a model of the landscape */
 	if ((p1 & SLOPE_W) != 0 && tile + TileDiffXY(1, 0) < MapSize()) {
 		TileIndex t = tile + TileDiffXY(1, 0);
@@ -280,10 +313,8 @@
 	 * Pass == 0: Collect tileareas which are caused to be auto-cleared.
 	 * Pass == 1: Collect the actual cost. */
 	for (int pass = 0; pass < 2; pass++) {
-		TileIndex *ti = ts.tile_table;
-
-		for (int count = ts.tile_table_count; count != 0; count--, ti++) {
-			TileIndex tile = *ti;
+		for (std::set<TileIndex>::const_iterator it = ts.dirty_tiles.begin(); it != ts.dirty_tiles.end(); it++) {
+			TileIndex tile = *it;
 
 			assert(tile < MapSize());
 			/* MP_VOID tiles can be terraformed but as tunnels and bridges
@@ -309,10 +340,21 @@
 
 			if (pass == 0) {
 				/* Check if bridge would take damage */
-				if (direction == 1 && MayHaveBridgeAbove(tile) && IsBridgeAbove(tile) &&
-						GetBridgeHeight(GetSouthernBridgeEnd(tile)) <= z_max) {
-					_terraform_err_tile = tile; // highlight the tile under the bridge
-					return_cmd_error(STR_ERROR_MUST_DEMOLISH_BRIDGE_FIRST);
+				if (MayHaveBridgeAbove(tile) && IsBridgeAbove(tile)) {
+					int bridge_height = GetBridgeHeight(GetSouthernBridgeEnd(tile));
+
+					/* Check if bridge would take damage. */
+					if (direction == 1 && bridge_height <= z_max) {
+						_terraform_err_tile = tile; ///< highlight the tile under the bridge
+						return_cmd_error(STR_ERROR_MUST_DEMOLISH_BRIDGE_FIRST);
+					}
+
+					/* Is the bridge above not too high afterwards?
+					 * @see tunnelbridge.h for a detailed discussion. */
+					if (direction == -1 && bridge_height > (z_min + MAX_BRIDGE_HEIGHT)) {
+						_terraform_err_tile = tile;
+						return_cmd_error(STR_ERROR_BRIDGE_TOO_HIGH_AFTER_LOWER_LAND);
+					}
 				}
 				/* Check if tunnel would take damage */
 				if (direction == -1 && IsTunnelInWay(tile, z_min)) {
@@ -349,38 +391,148 @@
 	}
 
 	Company *c = Company::GetIfValid(_current_company);
-	if (c != NULL && (int)GB(c->terraform_limit, 16, 16) < ts.modheight_count) {
+	if (c != NULL && (int)GB(c->terraform_limit, 16, 16) < ts.tile_to_new_height.size()) {
 		return_cmd_error(STR_ERROR_TERRAFORM_LIMIT_REACHED);
 	}
 
+
 	if (flags & DC_EXEC) {
 		/* change the height */
 		{
-			int count;
-			TerraformerHeightMod *mod;
-
-			mod = ts.modheight;
-			for (count = ts.modheight_count; count != 0; count--, mod++) {
-				TileIndex til = mod->tile;
+			for (std::map<TileIndex, int>::const_iterator it = ts.tile_to_new_height.begin();
+					it != ts.tile_to_new_height.end(); it++) {
+				TileIndex tile = it->first;
+				int height = it->second;
 
-				SetTileHeight(til, mod->height);
+				SetTileHeight(tile, (uint)height);
 			}
 		}
 
 		/* finally mark the dirty tiles dirty */
 		{
-			int count;
-			TileIndex *ti = ts.tile_table;
-			for (count = ts.tile_table_count; count != 0; count--, ti++) {
-				MarkTileDirtyByTile(*ti);
-			}
+			MarkTilesDirty(ts);
 		}
 
-		if (c != NULL) c->terraform_limit -= ts.modheight_count << 16;
+		if (c != NULL) c->terraform_limit -= ts.tile_to_new_height.size() << 16;
 	}
 	return total_cost;
 }
 
+/** Tile iterator for terraforming purposes. */
+class TerraformingIterator : public TileIterator {
+public:
+	TerraformingIterator(TileIndex tile) : TileIterator(tile) { }
+
+	/*
+	 * Get the target height of currently iterated tile.
+	 * @return target height for the tile
+	 */
+	virtual int GetTileTargetHeight() const = 0;
+
+	virtual TerraformingIterator *Clone() const { NOT_REACHED(); /* not implemented */ };
+};
+
+/** Terraforming iterator for leveling an area. */
+class LandLevelingIterator : public TerraformingIterator {
+public:
+	int target_height;
+
+	LandLevelingIterator(TileIndex tile, int target_height)
+		: TerraformingIterator(tile), target_height(target_height)
+	{
+	}
+
+	virtual int GetTileTargetHeight() const
+	{
+		return this->target_height;
+	}
+};
+
+/** Orthogonal variant of a #LandLevelingIterator. */
+class OrthogonalLandLevelingIterator : public LandLevelingIterator, protected OrthogonalTileIteratorController {
+public:
+	OrthogonalLandLevelingIterator(const TileArea &ta, int target_height) : LandLevelingIterator(ta.tile, target_height)
+	{
+		this->Init(this->MyIndex(), ta.w, ta.h);
+	}
+
+	TileIterator &operator ++ ()
+	{
+		this->Advance(this->MyIndex(), this->MyMap());
+		return *this;
+	}
+};
+
+/** Diagonal variant of a #LandLevelingIterator. */
+class DiagonalLandLevelingIterator : public LandLevelingIterator, protected DiagonalTileIteratorController {
+public:
+	DiagonalLandLevelingIterator(TileIndex begin, TileIndex end, int target_height) : LandLevelingIterator(begin, target_height)
+	{
+		this->Init(this->MyIndex(), end, this->MyMap());
+	}
+
+	TileIterator &operator ++ ()
+	{
+		this->Advance(this->MyIndex(), this->MyMap());
+		return *this;
+	}
+};
+
+/** Terraforming iterator for leveling an area for pasting purposes. */
+class PasteLandLevelingIterator : public OrthogonalLandLevelingIterator {
+protected:
+	CopyPasteLevelVariant variant;
+
+public:
+	PasteLandLevelingIterator(const TileArea &ta, int target_height, CopyPasteLevelVariant variant)
+		: OrthogonalLandLevelingIterator(ta, target_height), variant(variant)
+	{
+	}
+
+	virtual int GetTileTargetHeight() const
+	{
+		uint ret = this->target_height;
+		switch (this->variant) {
+			case CPLV_LEVEL_ABOVE: ret = min(ret, TileHeight(*this)); break;
+			case CPLV_LEVEL_BELOW: ret = max(ret, TileHeight(*this)); break;
+		}
+		return ret;
+	}
+};
+
+/** Terraforming iterator for copy-pasting tile heights. */
+class HeightsCopyPastingIterator : public TerraformingIterator, protected TransformationTileIteratorController {
+protected:
+	GenericTileIndex src_tile; ///< Current tile of the source area.
+	int height_delta;          ///< Amount of units to add to each height
+
+public:
+	HeightsCopyPastingIterator(const GenericTileArea &src_area, TileIndex transformed_north, DirTransformation transformation, int height_delta)
+		: TerraformingIterator(transformed_north), src_tile(src_area.tile), height_delta(height_delta)
+	{
+		this->Init(&IndexOf(this->src_tile), this->MyIndex(), src_area.w, src_area.h, transformation);
+	}
+
+	virtual TileIterator &operator ++()
+	{
+		this->Advance(&IndexOf(this->src_tile), MapOf(this->src_tile), this->MyIndex(), this->MyMap());
+		return *this;
+	}
+
+	virtual int GetTileTargetHeight() const
+	{
+		return TileHeight(this->src_tile) + this->height_delta;
+	}
+};
+
+/** Compound result of a terraform process. */
+struct TerraformTilesResult {
+	Money    cost;       ///< Overal cost.
+	bool had_success;    ///< Whether any success occured.
+	StringID last_error; ///< Last error, STR_NULL if there were no errors.
+};
+
+static TerraformTilesResult TerraformTiles(TerraformingIterator *iter, DoCommandFlag flags, Money available_money = GetAvailableMoneyForCommand());
 
 /**
  * Levels a selected (rectangle) area of land
@@ -397,42 +549,146 @@
 {
 	if (p1 >= MapSize()) return CMD_ERROR;
 
-	_terraform_err_tile = INVALID_TILE;
-
-	/* remember level height */
-	uint oldh = TileHeight(p1);
-
 	/* compute new height */
-	uint h = oldh;
-	LevelMode lm = (LevelMode)GB(p2, 1, 2);
-	switch (lm) {
+	int h = TileHeight(p1);
+	switch ((LevelMode)GB(p2, 1, 2)) {
 		case LM_LEVEL: break;
 		case LM_RAISE: h++; break;
 		case LM_LOWER: h--; break;
 		default: return CMD_ERROR;
 	}
 
-	/* Check range of destination height */
-	if (h > MAX_TILE_HEIGHT) return_cmd_error((oldh == 0) ? STR_ERROR_ALREADY_AT_SEA_LEVEL : STR_ERROR_TOO_HIGH);
+	TerraformTilesResult ret;
+	if (HasBit(p2, 0)) {
+		DiagonalLandLevelingIterator iter(tile, p1, h);
+		ret = TerraformTiles(&iter, flags);
+	} else {
+		OrthogonalLandLevelingIterator iter(TileArea(tile, p1), h);
+		ret = TerraformTiles(&iter, flags);
+	}
 
-	Money money = GetAvailableMoneyForCommand();
-	CommandCost cost(EXPENSES_CONSTRUCTION);
-	CommandCost last_error(lm == LM_LEVEL ? STR_ERROR_ALREADY_LEVELLED : INVALID_STRING_ID);
-	bool had_success = false;
+	/* If there were only errors then fail with the last one. */
+	if (!ret.had_success && ret.last_error != STR_NULL) return_cmd_error(ret.last_error);
+	/* Return overal cost. */
+	return CommandCost(EXPENSES_CONSTRUCTION, ret.cost);
+}
+
+/**
+ * Terraform tiles as a part of a pasting process.
+ * @param iter iterator to use when terraforming
+ */
+static void TerraformPasteTiles(TerraformingIterator *iter)
+{
+	TileIndex start_tile = *iter;
+
+	/* Do actual terraforming. */
+	TerraformTilesResult ret = TerraformTiles(iter, _current_pasting->dc_flags | DC_ALL_TILES, _current_pasting->GetAvailableMoney());
+
+	/* When copy-pasting, we want to higlight error tiles more frequently. TerraformTiles
+	 * doesn't always set the _terraform_err_tile (on some errors it's just INVALID_TILE).
+	 * We will assume the start tile in these cases. This will give a better overview on
+	 * what area failed to paste. */
+	if (_terraform_err_tile == INVALID_TILE) _terraform_err_tile = start_tile;
+
+	/* Collect overal cost of the operation. */
+	if (ret.had_success) {
+		_current_pasting->CollectCost(CommandCost(EXPENSES_CONSTRUCTION, ret.cost), _terraform_err_tile, STR_ERROR_CAN_T_LEVEL_LAND_HERE);
+	}
+
+	/* Handle _additional_cash_required */
+	if ((_current_pasting->dc_flags & DC_EXEC) && _additional_cash_required > 0) {
+		SetDParam(0, _additional_cash_required);
+		_current_pasting->CollectError(_terraform_err_tile, STR_ERROR_NOT_ENOUGH_CASH_REQUIRES_CURRENCY, STR_ERROR_CAN_T_LEVEL_LAND_HERE);
+	}
+
+	/* Collect last error, if any. */
+	if (ret.last_error != STR_NULL) {
+		_current_pasting->CollectError(_terraform_err_tile, ret.last_error, STR_ERROR_CAN_T_LEVEL_LAND_HERE);
+	}
+}
+
+/**
+ * Level land (as a part of a pasting process).
+ *
+ * @param ta Area of tiles corners to level.
+ * @param height Desired height.
+ * @param variant Leveling variant.
+ */
+void LevelPasteLand(const TileArea &ta, uint height, CopyPasteLevelVariant variant)
+{
+	PasteLandLevelingIterator iter(ta, height, variant);
+	TerraformPasteTiles(&iter);
+}
+
+/**
+ * Copy and paste heights from one map to another.
+ *
+ * @param src_area Area to read heights from. It consists of tiles, not of tile corners
+ *                  e.g. if you pass a single tile area then 4 corners will be terraformed.
+ * @param dst_area_north Norhern tile of the area to write heigths at.
+ * @param transformation Transformation to perform on tile indices.
+ * @param height_delta Offset, number of units to add to each height.
+ */
+void CopyPasteHeights(const GenericTileArea &src_area, GenericTileIndex dst_area_north, DirTransformation transformation, int height_delta)
+{
+	/* include also corners at SW and SE edges */
+	GenericTileArea src_corners(src_area.tile, src_area.w + 1, src_area.h + 1);
+	/* transform the most northern corner */
+	GenericTileIndex transformed_north_corner = src_corners.TransformedNorth(dst_area_north, transformation);
+
+#ifdef WITH_ASSERT
+	{
+		assert(IsValidTileIndex(dst_area_north));
+		uint x = TileX(dst_area_north);
+		uint y = TileY(dst_area_north);
+		assert(!IsMainMapTile(dst_area_north) || !_settings_game.construction.freeform_edges || (x > 0 && y > 0));
+		Dimension dst_dim = { src_corners.w, src_corners.h };
+		dst_dim = TransformDimension(dst_dim, transformation);
+		assert(x + dst_dim.width <= MapSizeX(MapOf(dst_area_north)) && y + dst_dim.height <= MapSizeY(MapOf(dst_area_north)));
+	}
+#endif /* WITH_ASSERT */
+
+	if (IsMainMapTile(dst_area_north)) {
+		HeightsCopyPastingIterator iter(src_corners, AsMainMapTile(transformed_north_corner), transformation, height_delta);
+		TerraformPasteTiles(&iter);
+	} else {
+		for (TransformationTileIteratorT<true, true> iter(src_corners, transformed_north_corner, transformation); IsValidTileIndex(iter); ++iter) {
+			SetTileHeight(iter.DstTile(), TileHeight(iter.SrcTile()));
+		}
+	}
+}
+
+/**
+ * Terraform multiple tiles.
+ *
+ * @param iter Iterator pointing tiles to terraform and their target heights.
+ * @return The cost of all successfull operations and the last error.
+ *
+ * @note _terraform_err_tile will be set to the tile where the last error occured
+ *
+ * @warning Note non-standard return behaviour - booth the cost \b and the error combined.
+ */
+static TerraformTilesResult TerraformTiles(TerraformingIterator *iter, DoCommandFlag flags, Money available_money)
+{
+	TerraformTilesResult result = {
+		0,       // cost
+		false,   // had_success
+		STR_NULL // last_error
+	};
+	TileIndex last_err_tile = INVALID_TILE;
 
 	const Company *c = Company::GetIfValid(_current_company);
 	int limit = (c == NULL ? INT32_MAX : GB(c->terraform_limit, 16, 16));
-	if (limit == 0) return_cmd_error(STR_ERROR_TERRAFORM_LIMIT_REACHED);
+	if (limit == 0) result.last_error = STR_ERROR_TERRAFORM_LIMIT_REACHED;
 
-	TileArea ta(tile, p1);
-	TileIterator *iter = HasBit(p2, 0) ? (TileIterator *)new DiagonalTileIterator(tile, p1) : new OrthogonalTileIterator(ta);
-	for (; *iter != INVALID_TILE; ++(*iter)) {
+	for (; *iter != INVALID_TILE && limit > 0; ++(*iter)) {
+		int h = iter->GetTileTargetHeight();
 		TileIndex t = *iter;
-		uint curh = TileHeight(t);
-		while (curh != h) {
+		for (int curh = TileHeight(t); curh != h; curh += (curh > h) ? -1 : 1) {
 			CommandCost ret = DoCommand(t, SLOPE_N, (curh > h) ? 0 : 1, flags & ~DC_EXEC, CMD_TERRAFORM_LAND);
 			if (ret.Failed()) {
-				last_error = ret;
+				result.last_error = ret.GetErrorMessage();
+				last_err_tile = _terraform_err_tile;
 
 				/* Did we reach the limit? */
 				if (ret.GetErrorMessage() == STR_ERROR_TERRAFORM_LIMIT_REACHED) limit = 0;
@@ -440,11 +696,11 @@
 			}
 
 			if (flags & DC_EXEC) {
-				money -= ret.GetCost();
-				if (money < 0) {
+				available_money -= ret.GetCost();
+				if (available_money < 0) {
 					_additional_cash_required = ret.GetCost();
-					delete iter;
-					return cost;
+					_terraform_err_tile = t;
+					return result;
 				}
 				DoCommand(t, SLOPE_N, (curh > h) ? 0 : 1, flags, CMD_TERRAFORM_LAND);
 			} else {
@@ -453,20 +709,22 @@
 				 * when it's near the terraforming limit. Even then, the estimation is
 				 * completely off due to it basically counting terraforming double, so it being
 				 * cut off earlier might even give a better estimate in some cases. */
-				if (--limit <= 0) {
-					had_success = true;
+				if (--limit <= 0)  {
+					result.had_success = true;
 					break;
 				}
 			}
 
-			cost.AddCost(ret);
-			curh += (curh > h) ? -1 : 1;
-			had_success = true;
+			result.cost += ret.GetCost();
+			result.had_success = true;
 		}
+	}
 
-		if (limit <= 0) break;
+	if (!result.had_success && result.last_error == STR_NULL) {
+		result.last_error = STR_ERROR_ALREADY_LEVELLED;
+		last_err_tile = INVALID_TILE;
 	}
 
-	delete iter;
-	return had_success ? cost : last_error;
+	_terraform_err_tile = last_err_tile;
+	return result;
 }
diff -urNad openttd-1.3.2/src/terraform_gui.cpp openttd-1.3.2-DC3.0RC3/src/terraform_gui.cpp
--- openttd-1.3.2/src/terraform_gui.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/terraform_gui.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -121,6 +121,9 @@
 		case DDSP_LEVEL_AREA:
 			DoCommandP(end_tile, start_tile, LM_LEVEL << 1 | (_ctrl_pressed ? 1 : 0), CMD_LEVEL_LAND | CMD_MSG(STR_ERROR_CAN_T_LEVEL_LAND_HERE), CcTerraform);
 			break;
+		case DDSP_BUY_LAND:
+			DoCommandP(end_tile, start_tile, _ctrl_pressed ? 1 : 0, CMD_BUY_LAND | CMD_MSG(STR_ERROR_CAN_T_PURCHASE_THIS_LAND), CcPlaySound1E);
+			break;
 		case DDSP_CREATE_ROCKS:
 			GenerateRockyArea(end_tile, start_tile);
 			break;
@@ -142,6 +145,32 @@
 {
 	VpStartPlaceSizing(tile, VPM_X_AND_Y, DDSP_DEMOLISH_AREA);
 }
+/**
+ * Start a drag for buying an area.
+ * @param tile Position of the starting corner.
+ */
+void PlaceProc_BuyLand(TileIndex tile)
+{
+	if (_settings_game.construction.enable_land_buying)
+	{
+		if (_settings_game.construction.enable_restrictive_land_buying)
+		{
+			if (_settings_game.construction.drag_drop_land_buying_limit == 1) // 1x1, we don't need to bother with dragging and dropping, just execute the command like normal
+			{
+				DoCommandP(tile, OBJECT_OWNED_LAND, 0, CMD_BUILD_OBJECT | CMD_MSG(STR_ERROR_CAN_T_PURCHASE_THIS_LAND), CcPlaySound1E);
+			}
+			else
+			{
+				VpStartPlaceSizing(tile, VPM_X_AND_Y_LIMITED, DDSP_BUY_LAND);
+				VpSetPlaceSizingLimit(_settings_game.construction.drag_drop_land_buying_limit);
+			}
+		}
+		else //no limit
+		{
+			VpStartPlaceSizing(tile, VPM_X_AND_Y, DDSP_BUY_LAND);
+		}
+	}
+}
 
 /** Terra form toolbar managing class. */
 struct TerraformToolbarWindow : Window {
@@ -164,6 +193,7 @@
 		/* Don't show the place object button when there are no objects to place. */
 		NWidgetStacked *show_object = this->GetWidget<NWidgetStacked>(WID_TT_SHOW_PLACE_OBJECT);
 		show_object->SetDisplayedPlane(ObjectClass::GetUIClassCount() != 0 ? 0 : SZSP_NONE);
+		this->SetWidgetDisabledState(WID_TT_BUY_LAND, _settings_game.construction.enable_land_buying ? false : true);
 	}
 
 	virtual void OnClick(Point pt, int widget, int click_count)
@@ -186,13 +216,19 @@
 				this->last_user_action = widget;
 				break;
 
+			case WID_TT_CLIPBOARD: // Show the clipboard toolbar
+				/* This button is NOT a place-push-button, so don't treat it as such */
+				this->HandleButtonClick(WID_TT_CLIPBOARD);
+				ShowClipboardToolbar();
+				break;
+
 			case WID_TT_DEMOLISH: // Demolish aka dynamite button
 				HandlePlacePushButton(this, WID_TT_DEMOLISH, ANIMCURSOR_DEMOLISH, HT_RECT | HT_DIAGONAL);
 				this->last_user_action = widget;
 				break;
 
 			case WID_TT_BUY_LAND: // Buy land button
-				HandlePlacePushButton(this, WID_TT_BUY_LAND, SPR_CURSOR_BUY_LAND, HT_RECT);
+				HandlePlacePushButton(this, WID_TT_BUY_LAND, SPR_CURSOR_BUY_LAND, HT_RECT | HT_DIAGONAL);
 				this->last_user_action = widget;
 				break;
 
@@ -246,7 +282,7 @@
 				break;
 
 			case WID_TT_BUY_LAND: // Buy land button
-				DoCommandP(tile, OBJECT_OWNED_LAND, 0, CMD_BUILD_OBJECT | CMD_MSG(STR_ERROR_CAN_T_PURCHASE_THIS_LAND), CcPlaySound1E);
+				PlaceProc_BuyLand(tile);
 				break;
 
 			case WID_TT_PLACE_SIGN: // Place sign button
@@ -282,6 +318,7 @@
 				case DDSP_RAISE_AND_LEVEL_AREA:
 				case DDSP_LOWER_AND_LEVEL_AREA:
 				case DDSP_LEVEL_AREA:
+				case DDSP_BUY_LAND:
 					GUIPlaceProcDragXY(select_proc, start_tile, end_tile);
 					break;
 			}
@@ -293,6 +330,11 @@
 		DeleteWindowById(WC_BUILD_OBJECT, 0);
 		this->RaiseButtons();
 	}
+	
+	virtual void OnHundredthTick()
+	{
+		this->SetWidgetDisabledState(WID_TT_BUY_LAND, _settings_game.construction.enable_land_buying ? false : true);
+	}
 
 	static Hotkey<TerraformToolbarWindow> terraform_hotkeys[];
 };
@@ -326,6 +368,8 @@
 
 		NWidget(WWT_PANEL, COLOUR_DARK_GREEN), SetMinimalSize(4, 22), EndContainer(),
 
+		NWidget(WWT_PUSHIMGBTN, COLOUR_DARK_GREEN, WID_TT_CLIPBOARD), SetMinimalSize(22, 22),
+								SetFill(0, 1), SetDataTip(SPR_IMG_CLIPBOARD, STR_LANDSCAPING_TOOLTIP_SHOW_CLIPBOARD_TOOLBAR),
 		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_TT_DEMOLISH), SetMinimalSize(22, 22),
 								SetFill(0, 1), SetDataTip(SPR_IMG_DYNAMITE, STR_TOOLTIP_DEMOLISH_BUILDINGS_ETC),
 		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_TT_BUY_LAND), SetMinimalSize(22, 22),
diff -urNad openttd-1.3.2/src/tgp.cpp openttd-1.3.2-DC3.0RC3/src/tgp.cpp
--- openttd-1.3.2/src/tgp.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/tgp.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -16,6 +16,8 @@
 #include "genworld.h"
 #include "core/random_func.hpp"
 #include "landscape_type.h"
+#include "tgp.h"
+#include "debug.h"
 
 /*
  *
@@ -200,34 +202,77 @@
 /** Walk through all items of _height_map.h */
 #define FOR_ALL_TILES_IN_HEIGHT(h) for (h = _height_map.h; h < &_height_map.h[_height_map.total_size]; h++)
 
-/** Maximum index into array of noise amplitudes */
-static const int TGP_FREQUENCY_MAX = 6;
-
 /**
- * Noise amplitudes (multiplied by 1024)
- * - indexed by "smoothness setting" and log2(frequency)
+ * Noise amplitudes(multiplied by 1024).
+ * Indexed by "smoothness setting" and log2(frequency).
+ *
+ * @note TGP_FREQUENCY_MAX + 1 values as the first value is the scale.
+ * @see HeightMapGenerate()
  */
-static const amplitude_t _amplitudes_by_smoothness_and_frequency[4][TGP_FREQUENCY_MAX + 1] = {
-	/* lowest frequncy....  ...highest (every corner) */
+static const amplitude_t _amplitudes_by_smoothness_and_frequency[7][TGP_FREQUENCY_MAX + 1] = {
+	/* lowest frequency....  ...highest (every corner) */
 	/* Very smooth */
-	{16000,  5600,  1968,   688,   240,    16,    16},
+	{ 2143, 27832, 51429, 51657, 41657, 51429, 1597, 233, 37, 16},
 	/* Smooth */
-	{16000, 16000,  6448,  3200,  1024,   128,    16},
+	{ 6448, 911, 27832, 31131, 16511, 1427, 1597, 233, 29, 8},
 	/* Rough */
-	{16000, 19200, 12800,  8000,  3200,   256,    64},
+	{17657, 29832, 36832, 51429, 16511, 51429, 233, 1597, 1301, 16},
 	/* Very Rough */
-	{24000, 16000, 19200, 16000,  8000,   512,   320},
+	{17657, 6448, 36832, 51429, 16511, 17657, 233, 1597, 1301, 16},
+	/* Cereally rough -bonus- */
+	{ 17657, 31832, 39832, 29832, 16511, 43429, 233, 2597, 37, 16},
+	/* CommutorZ -bonus- */
+	{25000, 10000, 8000, 24000, 12000, 2500, 250, 100, 80, 25},
+	/* Flowing -bonus- */
+	{13511, 22739, 51429, 253, 421, 21131, 137, 7, 37, 261}
+};
+
+/**
+ * Array holding some extra smoothing parameters that are applied after _amplitudes_and_frequency.
+ * They represent in order of appearance :
+ * { smoothing radius, power of smoothing (1= smoothest, 10 = almost unsmoothed), min. smoothing step size }
+ *
+ * @see Smooth()
+ */
+static const int _smoothing_parameters[7][3] = {
+	{3, 3, 8}, ///< Very  smooth
+	{4, 3, 8}, ///< Smooth
+	{2, 7, 8}, ///< Rough
+	{2, 4, 8}, ///< Very rough
+	{2, 5, 8}, ///< Cereally rough - bonus -
+	{2, 6, 8}, ///< CommutorZ - bonus -
+	{2, 5, 4}  ///< Flowing - bonus -
 };
 
 /** Desired water percentage (100% == 1024) - indexed by _settings_game.difficulty.quantity_sea_lakes */
-static const amplitude_t _water_percent[4] = {20, 80, 250, 400};
+static const amplitude_t _water_percent[4] = {70, 170, 270, 420};
 
-/** Desired maximum height - indexed by _settings_game.difficulty.terrain_type */
-static const int8 _max_height[4] = {
-	6,       ///< Very flat
-	9,       ///< Flat
-	12,      ///< Hilly
-	15,      ///< Mountainous
+/**
+ * Desired maximum height - indexed by _settings_game.difficulty.terrain_type and the map size.
+ *
+ * Sense of indexing by mapsize too:
+ * Below, h_max_new is calculated as min(map_size_x, map_size_y) / the constant defined here.
+ * Later, for calculating the height of some individual tile, the formula:
+ *  h_max_new * (h - h_waterlevel) / (h_max - h_waterlevel), where h_max is the maximal heightlevel
+ * existing anywhere on the map at the time of that computation step.
+ * So, to summarize:
+ * For mapsize 64x64, the above division gives 1. And, h - h_waterlevel is always
+ * smaller than h_max - h_waterlevel. So, the result is a map consisting just of water 
+ * - i.e. at heightlevel 0 :-/.
+ * My conclusion was: 
+ * Indexing this setting by the mapsize is a good thing, as one gains much more
+ * control on the heightlevel distribution of maps now and small maps work at all. 
+ * The n-th value of the second component is for log(min(map_size_x, map_size_y)) - 6, so
+ * index 0 is for map size 64, whereas index 8 is for map size 8192.
+ */
+static const int _max_height[7][9] = {   
+	{32, 48, 72, 170, 340, 680, 1360, 2720, 5440}, ///< Extremely flat
+	{21, 40, 50,  64, 128, 380,  760, 1520, 3040}, ///< Very flat
+	{16, 27, 38,  51, 102, 204,  408,  916, 1832}, ///< Flat
+	{12, 21, 30,  39,  60, 120,  240,  480,  960}, ///< Bumpy
+	{10, 13, 17,  20,  33,  66,  132,  264,  528}, ///< Hilly
+	{9,  10, 11,  12,  13,  24,   48,   96,  192}, ///< Mountainous
+	{5,   6,  7,   7,   7,  12,   24,   48,   96}  ///< Alpinist
 };
 
 /**
@@ -307,8 +352,8 @@
 static bool ApplyNoise(uint log_frequency, amplitude_t amplitude)
 {
 	uint size_min = min(_height_map.size_x, _height_map.size_y);
-	uint step = size_min >> log_frequency;
-	uint x, y;
+	int step = size_min >> log_frequency;
+	int x, y;
 
 	/* Trying to apply noise to uninitialized height map */
 	assert(_height_map.h != NULL);
@@ -318,8 +363,8 @@
 
 	if (log_frequency == 0) {
 		/* This is first round, we need to establish base heights with step = size_min */
-		for (y = 0; y <= _height_map.size_y; y += step) {
-			for (x = 0; x <= _height_map.size_x; x += step) {
+		for (y = 0; y <= (int)_height_map.size_y; y += step) {
+			for (x = 0; x <= (int)_height_map.size_x; x += step) {
 				height_t height = (amplitude > 0) ? RandomHeight(amplitude) : 0;
 				_height_map.height(x, y) = height;
 			}
@@ -329,8 +374,8 @@
 
 	/* It is regular iteration round.
 	 * Interpolate height values at odd x, even y tiles */
-	for (y = 0; y <= _height_map.size_y; y += 2 * step) {
-		for (x = 0; x < _height_map.size_x; x += 2 * step) {
+	for (y = 0; y <= (int)_height_map.size_y; y += 2 * step) {
+		for (x = 0; x < (int)_height_map.size_x; x += 2 * step) {
 			height_t h00 = _height_map.height(x + 0 * step, y);
 			height_t h02 = _height_map.height(x + 2 * step, y);
 			height_t h01 = (h00 + h02) / 2;
@@ -339,8 +384,8 @@
 	}
 
 	/* Interpolate height values at odd y tiles */
-	for (y = 0; y < _height_map.size_y; y += 2 * step) {
-		for (x = 0; x <= _height_map.size_x; x += step) {
+	for (y = 0; y < (int)_height_map.size_y; y += 2 * step) {
+		for (x = 0; x <= (int)_height_map.size_x; x += step) {
 			height_t h00 = _height_map.height(x, y + 0 * step);
 			height_t h20 = _height_map.height(x, y + 2 * step);
 			height_t h10 = (h00 + h20) / 2;
@@ -349,8 +394,8 @@
 	}
 
 	/* Add noise for next higher frequency (smaller steps) */
-	for (y = 0; y <= _height_map.size_y; y += step) {
-		for (x = 0; x <= _height_map.size_x; x += step) {
+	for (y = 0; y <= (int)_height_map.size_y; y += step) {
+		for (x = 0; x <= (int)_height_map.size_x; x += step) {
 			_height_map.height(x, y) += RandomHeight(amplitude);
 		}
 	}
@@ -358,6 +403,60 @@
 	return (step > 1);
 }
 
+/**
+ * This function prevents inverted pyramids on map generation by applying some extra smoothing.
+ *
+ * @param log_frequency what round of mapgeneration are we in?
+ * @param radius   The radius to use for the extra smoothing.
+ * @param weakness The strongness / weakness  for the extra smoothing.
+ * @param min_step The step in tiles before I apply the extra smoothing again.
+ * @see HeightMapGenerate()
+ */
+void Smooth(uint log_frequency, int radius, int weakness, int min_step)
+{
+	uint size_min = min(_height_map.size_x, _height_map.size_y);
+	int step = size_min >> log_frequency;
+
+	if(step < min_step) {
+		return;
+	} else {
+		if(step < min_step * 2) {
+			weakness += 4;
+		}
+	}
+
+	height_t* temp_height_map;
+	temp_height_map = CallocT<height_t>(_height_map.total_size);
+
+	for (uint y = 0; y <= _height_map.size_y; y += step) {
+		for (uint x = 0; x <= _height_map.size_x; x += step) {
+			temp_height_map[x + y * _height_map.size_x] = _height_map.height(x, y);
+		}
+	}
+
+	for (uint y = 0; y <= _height_map.size_y; y += step) {
+		for (uint x = 0; x <= _height_map.size_x; x += step) {
+			height_t current = temp_height_map[x + y * _height_map.size_x];
+			int sum = current * 100 * weakness;
+			int weights = 100 * weakness; // the inmost tile has the highest weight
+
+			for(int i = -radius; i <= radius; i++){
+				for(int j = -radius; j <= radius; j++){
+					if((i != 0 || j != 0) && x + i * step <= _height_map.size_x
+							&& x + i * step > 0 && y + j * step <= _height_map.size_y
+							&& y + j * step > 0) {
+						int square = (int) sqrt((double)(i * i + j * j));
+						sum += temp_height_map[x + i * step + (y + j * step) * _height_map.size_x] * 100 / square;
+						weights += 100 / square;
+					}
+				}
+			}
+
+			_height_map.height(x, y) = sum / weights;
+		}
+	}
+}
+
 /** Base Perlin noise generator - fills height map with raw Perlin noise */
 static void HeightMapGenerate()
 {
@@ -387,9 +486,24 @@
 			amplitude = 0;
 		}
 		continue_iteration = ApplyNoise(iteration_round, amplitude);
+
+		if(amplitude > 0) {
+			/* Apply some extra parameters to prevent inverted pyramids. */
+			Smooth(iteration_round, _smoothing_parameters[_settings_game.game_creation.tgen_smoothness][0],
+					_smoothing_parameters[_settings_game.game_creation.tgen_smoothness][1],
+					_smoothing_parameters[_settings_game.game_creation.tgen_smoothness][2]);
+		}
+
 		iteration_round++;
 	} while (continue_iteration);
-	assert(log_frequency == TGP_FREQUENCY_MAX);
+
+	/* commented out the assert to allow smaller maps than 256 * 256, while TGP_FREQUENCY_MAX is set to 8 or higher.
+	 * Read IMPORTANT NOTICE in header near TGP_FREQUENCY_MAX declaration. */
+	// assert(log_frequency == TGP_FREQUENCY_MAX);
+	if (log_frequency != TGP_FREQUENCY_MAX) {
+		DEBUG(map, 0, "Frequency wrong: log_frequency = %i, TGP_FREQUENCY_MAX = %i",
+				log_frequency, TGP_FREQUENCY_MAX);
+	}
 }
 
 /** Returns min, max and average height from height map */
@@ -433,6 +547,12 @@
 /** Applies sine wave redistribution onto height map */
 static void HeightMapSineTransform(height_t h_min, height_t h_max)
 {
+	if ((_settings_game.game_creation.tgen_smoothness == SMOOTHNESS_VERY_ROUGH)
+			|| (_settings_game.game_creation.tgen_smoothness == SMOOTHNESS_CEREALLY_ROUGH)) {
+		/* Make the map really rough for very rough and cereally rough settings, skip this function. */
+		return;
+	}
+
 	height_t *h;
 
 	FOR_ALL_TILES_IN_HEIGHT(h) {
@@ -557,89 +677,49 @@
 	{ lengthof(_curve_map_4), _curve_map_4 },
 };
 
-static void HeightMapCurves(uint level)
-{
-	height_t ht[lengthof(_curve_maps)];
-
-	/* Set up a grid to choose curve maps based on location */
-	uint sx = Clamp(1 << level, 2, 32);
-	uint sy = Clamp(1 << level, 2, 32);
-	byte *c = (byte *)alloca(sx * sy);
-
-	for (uint i = 0; i < sx * sy; i++) {
-		c[i] = Random() % lengthof(_curve_maps);
-	}
-
-	/* Apply curves */
-	for (uint x = 0; x < _height_map.size_x; x++) {
-
-		/* Get our X grid positions and bi-linear ratio */
-		float fx = (float)(sx * x) / _height_map.size_x + 0.5f;
-		uint x1 = (uint)fx;
-		uint x2 = x1;
-		float xr = 2.0f * (fx - x1) - 1.0f;
-		xr = sin(xr * M_PI_2);
-		xr = sin(xr * M_PI_2);
-		xr = 0.5f * (xr + 1.0f);
-		float xri = 1.0f - xr;
-
-		if (x1 > 0) {
-			x1--;
-			if (x2 >= sx) x2--;
-		}
-
-		for (uint y = 0; y < _height_map.size_y; y++) {
-
-			/* Get our Y grid position and bi-linear ratio */
-			float fy = (float)(sy * y) / _height_map.size_y + 0.5f;
-			uint y1 = (uint)fy;
-			uint y2 = y1;
-			float yr = 2.0f * (fy - y1) - 1.0f;
-			yr = sin(yr * M_PI_2);
-			yr = sin(yr * M_PI_2);
-			yr = 0.5f * (yr + 1.0f);
-			float yri = 1.0f - yr;
-
-			if (y1 > 0) {
-				y1--;
-				if (y2 >= sy) y2--;
-			}
-
-			uint corner_a = c[x1 + sx * y1];
-			uint corner_b = c[x1 + sx * y2];
-			uint corner_c = c[x2 + sx * y1];
-			uint corner_d = c[x2 + sx * y2];
+/**
+ * Applies variation to the map if AllowMoreHeightlevels()is true and the variety setting is not set to none.
+ *
+ * @note for the moment there is only one variation for all settings
+ * @note It would be nice to have a few more variation options if AllowMoreHeigtlevels() is true.
+ */
+struct MHScontrol_point_t {
+	height_t x;
+	height_t y;
+};
 
-			/* Bitmask of which curve maps are chosen, so that we do not bother
-			 * calculating a curve which won't be used. */
-			uint corner_bits = 0;
-			corner_bits |= 1 << corner_a;
-			corner_bits |= 1 << corner_b;
-			corner_bits |= 1 << corner_c;
-			corner_bits |= 1 << corner_d;
+static const MHScontrol_point_t _curve_map[] = {
+	{ 0, 0 }, { 48, 48 }, { 96, 72 }, { 160, 128 }, { 192, 160 }, { 240, 255}, { 255, 255 }
+};
 
-			height_t *h = &_height_map.height(x, y);
+static void HeightMapCurves()
+{
+	height_t h_min, h_max, h_avg, h_diff;
+	HeightMapGetMinMaxAvg(&h_min, &h_max, &h_avg);
+	h_diff = h_max - h_min;
 
-			/* Apply all curve maps that are used on this tile. */
-			for (uint t = 0; t < lengthof(_curve_maps); t++) {
-				if (!HasBit(corner_bits, t)) continue;
+	/* "Normalize" the control points to the height map data */
+	MHScontrol_point_t *cm = MallocT<MHScontrol_point_t>(lengthof(_curve_map));
+	for (uint i = 0; i < lengthof(_curve_map); i++) {
+		cm[i].x = _curve_map[i].x * h_diff / 255 + h_min;
+		cm[i].y = _curve_map[i].y * h_diff / 255 + h_min;
+	}
 
-				const control_point_t *cm = _curve_maps[t].list;
-				for (uint i = 0; i < _curve_maps[t].length - 1; i++) {
-					const control_point_t &p1 = cm[i];
-					const control_point_t &p2 = cm[i + 1];
+	/* Apply curve */
+	height_t *h;
+	FOR_ALL_TILES_IN_HEIGHT(h) {
+		for (uint i = 0; i < lengthof(_curve_map) - 1; i++) {
+			MHScontrol_point_t &p1 = cm[i];
+			MHScontrol_point_t &p2 = cm[i + 1];
 
-					if (*h >= p1.x && *h < p2.x) {
-						ht[t] = p1.y + (*h - p1.x) * (p2.y - p1.y) / (p2.x - p1.x);
-						break;
-					}
-				}
+			if (*h >= p1.x && *h <= p2.x) {
+				*h = p1.y + (*h - p1.x) * (p2.y - p1.y) / (p2.x - p1.x);
+				break;
 			}
-
-			/* Apply interpolation of curve map results. */
-			*h = (height_t)((ht[corner_a] * yri + ht[corner_b] * yr) * xri + (ht[corner_c] * yri + ht[corner_d] * yr) * xr);
 		}
 	}
+
+	free(cm);
 }
 
 /** Adjusts heights in height map to contain required amount of water tiles */
@@ -669,8 +749,8 @@
 	/* We now have the proper water level value.
 	 * Transform the height map into new (normalized) height map:
 	 *   values from range: h_min..h_water_level will become negative so it will be clamped to 0
-	 *   values from range: h_water_level..h_max are transformed into 0..h_max_new
-	 *   where h_max_new is 4, 8, 12 or 16 depending on terrain type (very flat, flat, hilly, mountains)
+	 *   values from range: h_water_level..h_max are transformed into 0..h_max_new,
+	 *   where h_max_new is dependant on _settings_game.difficulty.terrain_type. (_max_height)
 	 */
 	FOR_ALL_TILES_IN_HEIGHT(h) {
 		/* Transform height from range h_water_level..h_max into 0..h_max_new range */
@@ -718,7 +798,7 @@
 		if (HasBit(water_borders, BORDER_NE)) {
 			/* Top right */
 			max_x = abs((perlin_coast_noise_2D(_height_map.size_y - y, y, 0.9, 53) + 0.25) * 5 + (perlin_coast_noise_2D(y, y, 0.35, 179) + 1) * 12);
-			max_x = max((smallest_size * smallest_size / 16) + max_x, (smallest_size * smallest_size / 16) + margin - max_x);
+			max_x = max((smallest_size * smallest_size / 64) + max_x, (smallest_size * smallest_size / 64) + margin - max_x);
 			if (smallest_size < 8 && max_x > 5) max_x /= 1.5;
 			for (x = 0; x < max_x; x++) {
 				_height_map.height(x, y) = 0;
@@ -728,7 +808,7 @@
 		if (HasBit(water_borders, BORDER_SW)) {
 			/* Bottom left */
 			max_x = abs((perlin_coast_noise_2D(_height_map.size_y - y, y, 0.85, 101) + 0.3) * 6 + (perlin_coast_noise_2D(y, y, 0.45,  67) + 0.75) * 8);
-			max_x = max((smallest_size * smallest_size / 16) + max_x, (smallest_size * smallest_size / 16) + margin - max_x);
+			max_x = max((smallest_size * smallest_size / 64) + max_x, (smallest_size * smallest_size / 64) + margin - max_x);
 			if (smallest_size < 8 && max_x > 5) max_x /= 1.5;
 			for (x = _height_map.size_x; x > (_height_map.size_x - 1 - max_x); x--) {
 				_height_map.height(x, y) = 0;
@@ -741,7 +821,7 @@
 		if (HasBit(water_borders, BORDER_NW)) {
 			/* Top left */
 			max_y = abs((perlin_coast_noise_2D(x, _height_map.size_y / 2, 0.9, 167) + 0.4) * 5 + (perlin_coast_noise_2D(x, _height_map.size_y / 3, 0.4, 211) + 0.7) * 9);
-			max_y = max((smallest_size * smallest_size / 16) + max_y, (smallest_size * smallest_size / 16) + margin - max_y);
+			max_y = max((smallest_size * smallest_size / 64) + max_y, (smallest_size * smallest_size / 64) + margin - max_y);
 			if (smallest_size < 8 && max_y > 5) max_y /= 1.5;
 			for (y = 0; y < max_y; y++) {
 				_height_map.height(x, y) = 0;
@@ -751,7 +831,7 @@
 		if (HasBit(water_borders, BORDER_SE)) {
 			/* Bottom right */
 			max_y = abs((perlin_coast_noise_2D(x, _height_map.size_y / 3, 0.85, 71) + 0.25) * 6 + (perlin_coast_noise_2D(x, _height_map.size_y / 3, 0.35, 193) + 0.75) * 12);
-			max_y = max((smallest_size * smallest_size / 16) + max_y, (smallest_size * smallest_size / 16) + margin - max_y);
+			max_y = max((smallest_size * smallest_size / 64) + max_y, (smallest_size * smallest_size / 64) + margin - max_y);
 			if (smallest_size < 8 && max_y > 5) max_y /= 1.5;
 			for (y = _height_map.size_y; y > (_height_map.size_y - 1 - max_y); y--) {
 				_height_map.height(x, y) = 0;
@@ -763,6 +843,12 @@
 /** Start at given point, move in given direction, find and Smooth coast in that direction */
 static void HeightMapSmoothCoastInDirection(int org_x, int org_y, int dir_x, int dir_y)
 {
+ 	if ((_settings_game.game_creation.tgen_smoothness == SMOOTHNESS_VERY_ROUGH)
+ 			|| (_settings_game.game_creation.tgen_smoothness == SMOOTHNESS_CEREALLY_ROUGH)) {
+ 		/* Make the map really rough for very rough and cereally rough settings, skip this function. */
+ 		return;
+ 	}
+
 	const int max_coast_dist_from_edge = 35;
 	const int max_coast_Smooth_depth = 35;
 
@@ -770,7 +856,7 @@
 	int ed; // coast distance from edge
 	int depth;
 
-	height_t h_prev = 16;
+	height_t h_prev = min(_height_map.size_x + 1, _height_map.size_y + 1) / TGP_HEIGHT_FACTOR;
 	height_t h;
 
 	assert(IsValidXY(org_x, org_y));
@@ -778,7 +864,7 @@
 	/* Search for the coast (first non-water tile) */
 	for (x = org_x, y = org_y, ed = 0; IsValidXY(x, y) && ed < max_coast_dist_from_edge; x += dir_x, y += dir_y, ed++) {
 		/* Coast found? */
-		if (_height_map.height(x, y) > 15) break;
+		if (_height_map.height(x, y) > (int)(min(_height_map.size_x + 1, _height_map.size_y + 1) / TGP_HEIGHT_FACTOR - 1)) break;
 
 		/* Coast found in the neighborhood? */
 		if (IsValidXY(x + dir_y, y + dir_x) && _height_map.height(x + dir_y, y + dir_x) > 0) break;
@@ -838,6 +924,21 @@
 }
 
 /**
+ * Gets the maximum allowed height while generating a map
+ * based on mapsize, terraintype, and the setting to allow moreheightlevels.
+ */
+static int TGPGetMaxAllowedHeight()
+{
+	/* Subtract 6 because the value for map size 64 = 2^6
+	 * is stored at index 0 in the array.
+	 * @See discussion at the definition of _max_height */
+	const int map_size_index_in_mh = min(MapLogX(), MapLogY()) - 6;
+	const int mh = _max_height[_settings_game.difficulty.terrain_type][map_size_index_in_mh];
+	const int retValue = I2H(min((min(_height_map.size_x + 1, _height_map.size_y + 1)) / mh, _settings_game.construction.max_heightlevel));
+	return retValue;
+}
+
+/**
  * Height map terraform post processing:
  *  - water level adjusting
  *  - coast Smoothing
@@ -848,7 +949,7 @@
 {
 	int sea_level_setting = _settings_game.difficulty.quantity_sea_lakes;
 	const amplitude_t water_percent = sea_level_setting != (int)CUSTOM_SEA_LEVEL_NUMBER_DIFFICULTY ? _water_percent[sea_level_setting] : _settings_game.game_creation.custom_sea_level * 1024 / 100;
-	const height_t h_max_new = I2H(_max_height[_settings_game.difficulty.terrain_type]);
+	const height_t h_max_new = TGPGetMaxAllowedHeight();
 	const height_t roughness = 7 + 3 * _settings_game.game_creation.tgen_smoothness;
 
 	HeightMapAdjustWaterLevel(water_percent, h_max_new);
@@ -864,8 +965,8 @@
 
 	HeightMapSineTransform(12, h_max_new);
 
-	if (_settings_game.game_creation.variety > 0) {
-		HeightMapCurves(_settings_game.game_creation.variety);
+	if ((_settings_game.game_creation.variety > 0) && (_settings_game.game_creation.landscape == 1)) {
+		HeightMapCurves();
 	}
 
 	HeightMapSmoothSlopes(16);
@@ -984,12 +1085,25 @@
 		for (x = 0; x < _height_map.size_x;     x++) MakeVoid(x);
 	}
 
+	const int mh = H2I(TGPGetMaxAllowedHeight());
+
 	/* Transfer height map into OTTD map */
 	for (y = 0; y < _height_map.size_y; y++) {
 		for (x = 0; x < _height_map.size_x; x++) {
 			int height = H2I(_height_map.height(x, y));
-			if (height < 0) height = 0;
-			if (height > 15) height = 15;
+
+			if (height < 0) {
+				height = 0;
+			}
+
+			if (height > mh - 1) {
+				height = mh - 1;
+			}
+
+			if (height > (int)MAX_TILE_HEIGHT) {
+				height = MAX_TILE_HEIGHT;
+			}
+
 			TgenSetTileHeight(TileXY(x, y), height);
 		}
 	}
diff -urNad openttd-1.3.2/src/tgp.h openttd-1.3.2-DC3.0RC3/src/tgp.h
--- openttd-1.3.2/src/tgp.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/tgp.h	2013-11-22 05:49:07.000000000 +0100
@@ -12,6 +12,23 @@
 #ifndef TGP_H
 #define TGP_H
 
+static const uint TGP_HEIGHT_FACTOR = 8;
+
+/**
+ * Maximum index into array of noise amplitudes.
+ */
+static const int TGP_FREQUENCY_MAX = 9;
+
+enum Smoothness {
+	SMOOTHNESS_VERY_SMOOTH      = 0,
+	SMOOTHNESS_SMOOTH           = 1,
+	SMOOTHNESS_ROUGH            = 2,
+	SMOOTHNESS_VERY_ROUGH       = 3,
+	SMOOTHNESS_CEREALLY_ROUGH   = 4,
+	SMOOTHNESS_COMMUTORZ        = 5,
+	SMOOTHNESS_FLOWING          = 6,
+};
+
 void GenerateTerrainPerlin();
 
 #endif /* TGP_H */
diff -urNad openttd-1.3.2/src/tilearea.cpp openttd-1.3.2-DC3.0RC3/src/tilearea.cpp
--- openttd-1.3.2/src/tilearea.cpp	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/tilearea.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -11,6 +11,7 @@
 
 #include "stdafx.h"
 
+#include "core/geometry_func.hpp"
 #include "tilearea_type.h"
 
 /**
@@ -18,8 +19,11 @@
  * @param start the start of the area
  * @param end   the end of the area
  */
-TileArea::TileArea(TileIndex start, TileIndex end)
+template <bool Tgeneric>
+TileAreaT<Tgeneric>::TileAreaT(TileIndexType start, TileIndexType end)
 {
+	assert(IsSameMap(start, end));
+
 	uint sx = TileX(start);
 	uint sy = TileY(start);
 	uint ex = TileX(end);
@@ -28,7 +32,7 @@
 	if (sx > ex) Swap(sx, ex);
 	if (sy > ey) Swap(sy, ey);
 
-	this->tile = TileXY(sx, sy);
+	this->tile = TileXY<Tgeneric>(sx, sy, MapOf(start));
 	this->w    = ex - sx + 1;
 	this->h    = ey - sy + 1;
 }
@@ -37,9 +41,10 @@
  * Add a single tile to a tile area; enlarge if needed.
  * @param to_add The tile to add
  */
-void TileArea::Add(TileIndex to_add)
+template <bool Tgeneric>
+void TileAreaT<Tgeneric>::Add(TileIndexType to_add)
 {
-	if (this->tile == INVALID_TILE) {
+	if (!IsValidTileIndex(this->tile)) {
 		this->tile = to_add;
 		this->w = 1;
 		this->h = 1;
@@ -59,7 +64,7 @@
 	ex = max(ax, ex);
 	ey = max(ay, ey);
 
-	this->tile = TileXY(sx, sy);
+	this->tile = TileXY<Tgeneric>(sx, sy, MapOf(to_add));
 	this->w    = ex - sx + 1;
 	this->h    = ey - sy + 1;
 }
@@ -69,11 +74,13 @@
  * @param ta the other tile area to check against.
  * @return true if they intersect.
  */
-bool TileArea::Intersects(const TileArea &ta) const
+template <bool Tgeneric>
+bool TileAreaT<Tgeneric>::Intersects(const TileAreaT<Tgeneric> &ta) const
 {
 	if (ta.w == 0 || this->w == 0) return false;
 
 	assert(ta.w != 0 && ta.h != 0 && this->w != 0 && this->h != 0);
+	assert(IsSameMap(this->tile, ta.tile));
 
 	uint left1   = TileX(this->tile);
 	uint top1    = TileY(this->tile);
@@ -94,15 +101,47 @@
 }
 
 /**
+ * Does this tile area contains another?
+ * @param ta the other tile area to check against.
+ * @return true if the other area is fully contained.
+ */
+template <bool Tgeneric>
+bool TileAreaT<Tgeneric>::Contains(const TileAreaT<Tgeneric> &ta) const
+{
+	if (ta.w == 0 || this->w == 0) return false;
+
+	assert(ta.w != 0 && ta.h != 0 && this->w != 0 && this->h != 0);
+	assert(IsSameMap(this->tile, ta.tile));
+
+	uint left1   = TileX(this->tile);
+	uint top1    = TileY(this->tile);
+	uint right1  = left1 + this->w - 1;
+	uint bottom1 = top1  + this->h - 1;
+
+	uint left2   = TileX(ta.tile);
+	uint top2    = TileY(ta.tile);
+	uint right2  = left2 + ta.w - 1;
+	uint bottom2 = top2  + ta.h - 1;
+
+	return
+			left2   >= left1  &&
+			right2  <= right1 &&
+			top2    >= top1   &&
+			bottom2 <= bottom1;
+}
+
+/**
  * Does this tile area contain a tile?
  * @param tile Tile to test for.
  * @return True if the tile is inside the area.
  */
-bool TileArea::Contains(TileIndex tile) const
+template <bool Tgeneric>
+bool TileAreaT<Tgeneric>::Contains(TileIndexType tile) const
 {
 	if (this->w == 0) return false;
 
 	assert(this->w != 0 && this->h != 0);
+	assert(IsSameMap(this->tile, tile));
 
 	uint left   = TileX(this->tile);
 	uint top    = TileY(this->tile);
@@ -115,25 +154,81 @@
 /**
  * Clamp the tile area to map borders.
  */
-void TileArea::ClampToMap()
+template <bool Tgeneric>
+void TileAreaT<Tgeneric>::ClampToMap()
 {
-	assert(this->tile < MapSize());
-	this->w = min(this->w, MapSizeX() - TileX(this->tile));
-	this->h = min(this->h, MapSizeY() - TileY(this->tile));
+	assert(IsValidTileIndex(this->tile));
+	this->w = min(this->w, MapSizeX(MapOf(this->tile)) - TileX(this->tile));
+	this->h = min(this->h, MapSizeY(MapOf(this->tile)) - TileY(this->tile));
 }
 
 /**
- * Construct the iterator.
- * @param corner1 Tile from where to begin iterating.
- * @param corner2 Tile where to end the iterating.
+ * Get coordinates of transformed nothern tile of this area relative to the
+ * northern tile of transformed area.
+ *
+ * When transforming this area into another, the northern tile becomes some other
+ * tile in the transformed area. The function returns coordinates of this other tile
+ * relative to the transformed area.
+ *
+ * Note that calculation are independent from desired position of the transformed area.
+ *
+ * @param transformation transformation to perform
+ * @return the distance
  */
-DiagonalTileIterator::DiagonalTileIterator(TileIndex corner1, TileIndex corner2) : TileIterator(corner2), base_x(TileX(corner2)), base_y(TileY(corner2)), a_cur(0), b_cur(0)
+template <bool Tgeneric>
+TileIndexDiffC TileAreaT<Tgeneric>::TransformedNorthOffset(DirTransformation transformation) const
 {
-	assert(corner1 < MapSize());
-	assert(corner2 < MapSize());
+	Dimension distance = { this->w - 1, this->h - 1 };
+	distance = TransformDimension(distance, transformation);
+	TileIndexDiffC ret = TransformedNorthCornerDiffC(transformation);
+	ret.x *= distance.width;
+	ret.y *= distance.height;
+	return ret;
+}
 
-	int dist_x = TileX(corner1) - TileX(corner2);
-	int dist_y = TileY(corner1) - TileY(corner2);
+/**
+ * Get coordinates of a transformed tile of this area relative to the transformed
+ * northern tile of this area.
+ *
+ * The function takes x/y coordinates of a tile relative to this area and performs
+ * a transformation on them.
+ *
+ * Note that calculation are independent from desired position of the transformed area.
+ *
+ * @param tile the tile to transform
+ * @param transformation transformation to perform
+ * @return the distance
+ */
+template <bool Tgeneric>
+TileIndexDiffC TileAreaT<Tgeneric>::TransformedTileOffset(typename TileAreaT<Tgeneric>::TileIndexType tile, DirTransformation transformation) const
+{
+	assert(IsSameMap(this->tile, tile));
+
+	/* calculate coordinates of the tile relative to the northern tile of the area */
+	Point coords = { TileX(tile) - TileX(this->tile), TileY(tile) - TileY(this->tile) };
+	/* transform coordinates, now they will be relative to the transformed northern tile of the area */
+	coords = TransformPoint(coords, transformation);
+	TileIndexDiffC ret = { (uint16)coords.x, (uint16)coords.y };
+	return ret;
+}
+
+/**
+ * Initialize iteration.
+ * @param my_index Pointer to the tile index of the iterator. The index must be set to the first corner of the iteration before you call Init.
+ * @param opposite_corner Second (opposite) corner of the iteration.
+ * @param my_map The map that iterator iterates through.
+ */
+void DiagonalTileIteratorController::Init(RawTileIndex *my_index, RawTileIndex opposite_corner, Map *my_map)
+{
+	assert(IsValidTileIndex(GenericTileIndex(*my_index, my_map)));
+	assert(IsValidTileIndex(GenericTileIndex(opposite_corner, my_map)));
+
+	this->base_x = TileX(GenericTileIndex(*my_index, my_map));
+	this->base_y = TileY(GenericTileIndex(*my_index, my_map));
+	this->a_cur = 0;
+	this->b_cur = 0;
+	int dist_x = TileX(GenericTileIndex(opposite_corner, my_map)) - this->base_x;
+	int dist_y = TileY(GenericTileIndex(opposite_corner, my_map)) - this->base_y;
 	this->a_max = dist_x + dist_y;
 	this->b_max = dist_y - dist_x;
 
@@ -159,11 +254,13 @@
 }
 
 /**
- * Move ourselves to the next tile in the rectangle on the map.
+ * Perform single iteration step.
+ * @param my_index Pointer to the tile index of the iterator.
+ * @param my_map The map that iterator iterates through.
  */
-TileIterator &DiagonalTileIterator::operator++()
+void DiagonalTileIteratorController::Advance(RawTileIndex *my_index, Map *my_map)
 {
-	assert(this->tile != INVALID_TILE);
+	assert(*my_index != INVALID_TILE_INDEX);
 
 	/* Determine the next tile, while clipping at map borders */
 	bool new_line = false;
@@ -204,9 +301,53 @@
 		uint x = this->base_x + (this->a_cur - this->b_cur) / 2;
 		uint y = this->base_y + (this->b_cur + this->a_cur) / 2;
 		/* Prevent wrapping around the map's borders. */
-		this->tile = x >= MapSizeX() || y >= MapSizeY() ? INVALID_TILE : TileXY(x, y);
-	} while (this->tile > MapSize() && this->b_max != this->b_cur);
+		*my_index = x >= MapSizeX(my_map) || y >= MapSizeY(my_map) ? INVALID_TILE_INDEX : TileXY<true>(x, y, my_map).index;
+	} while (!IsValidTileIndex(GenericTileIndex(*my_index, my_map)) && this->b_max != this->b_cur);
 
-	if (this->b_max == this->b_cur) this->tile = INVALID_TILE;
-	return *this;
+	if (this->b_max == this->b_cur) *my_index = INVALID_TILE_INDEX;
+}
+
+/**
+ * Initialize iteration.
+ * @param src_index Pointer to the source tile index of the iterator. The index must be set to the northern tile of the source area before you call Init.
+ * @param dst_index Pointer to the destination tile index of the iterator. The index must be set to the transformed northern tile of the source area before you call Init.
+ * @param src_w The width of the source area.
+ * @param src_h The height of the source area.
+ * @param transformation Transformation to perform.
+ */
+void TransformationTileIteratorController::Init(RawTileIndex *src_index, RawTileIndex *dst_index, uint16 src_w, uint16 src_h, DirTransformation transformation)
+{
+	assert((*src_index != INVALID_TILE_INDEX) == (*dst_index != INVALID_TILE_INDEX));
+
+	this->OrthogonalTileIteratorController::Init(src_index, src_w, src_h);
+	this->transformation = transformation;
+}
+
+/**
+ * Perform single iteration step.
+ * @param src_index Pointer to the source tile index of the iterator.
+ * @param src_map The source map that iterator iterates through.
+ * @param dst_index Pointer to the destination tile index of the iterator.
+ * @param dst_map The destination map that iterator iterates through.
+ */
+void TransformationTileIteratorController::Advance(RawTileIndex *src_index, Map *src_map, RawTileIndex *dst_index, Map *dst_map)
+{
+	assert(*src_index != INVALID_TILE_INDEX);
+
+	if (--this->x > 0) {
+		++*src_index;
+		*dst_index += ToTileIndexDiff<true>(TileIndexDiffCByDiagDir(TransformDiagDir(DIAGDIR_SW, this->transformation)), dst_map);
+	} else if (--this->y > 0) {
+		this->x = this->w;
+		*src_index += TileDiffXY(1, 1, src_map) - this->w;
+		*dst_index -= ToTileIndexDiff<true>(TileIndexDiffCByDiagDir(TransformDiagDir(DIAGDIR_SW, this->transformation)), dst_map) * (this->w - 1);
+		*dst_index += ToTileIndexDiff<true>(TileIndexDiffCByDiagDir(TransformDiagDir(DIAGDIR_SE, this->transformation)), dst_map);
+	} else {
+		*src_index = INVALID_TILE_INDEX;
+		*dst_index = INVALID_TILE_INDEX;
+	}
 }
+
+/* instantiate */
+template struct TileAreaT<false>;
+template struct TileAreaT<true>;
diff -urNad openttd-1.3.2/src/tilearea_func.h openttd-1.3.2-DC3.0RC3/src/tilearea_func.h
--- openttd-1.3.2/src/tilearea_func.h	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/tilearea_func.h	2013-11-22 05:49:07.000000000 +0100
@@ -0,0 +1,42 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file tilearea_type.h Functions related to tile areas. */
+
+#ifndef TILEAREA_FUNC_H
+#define TILEAREA_FUNC_H
+
+#include "core/math_func.hpp"
+#include "direction_func.h"
+#include "tilearea_type.h"
+
+/**
+ * Transform a tile area.
+ * @param trackdir The area to transform.
+ * @param transformation Transformation to perform.
+ * @return The transformed area.
+ */
+template <bool TgenericSrc, bool TgenericDst>
+static TileAreaT<TgenericDst> TransformTileArea(const TileAreaT<TgenericSrc> &ta, typename TileIndexT<TgenericDst>::T dst_area_north, DirTransformation transformation)
+{
+	TileAreaT<TgenericDst> ret(dst_area_north, ta.w, ta.h);
+	if (TransformAxis(AXIS_X, transformation) != AXIS_X) Swap(ret.w, ret.h);
+	return ret;
+}
+
+/** @copydoc TransformTileArea<bool, bool> */
+static inline TileArea        TransformTileArea(const TileArea        &ta, TileIndex        dst_area_north, DirTransformation transformation) { return TransformTileArea<false, false>(ta, dst_area_north, transformation); }
+/** @copydoc TransformTileArea<bool, bool> */
+static inline GenericTileArea TransformTileArea(const TileArea        &ta, GenericTileIndex dst_area_north, DirTransformation transformation) { return TransformTileArea<false, true>(ta, dst_area_north, transformation); }
+/** @copydoc TransformTileArea<bool, bool> */
+static inline TileArea        TransformTileArea(const GenericTileArea &ta, TileIndex        dst_area_north, DirTransformation transformation) { return TransformTileArea<true, false>(ta, dst_area_north, transformation); }
+/** @copydoc TransformTileArea<bool, bool> */
+static inline GenericTileArea TransformTileArea(const GenericTileArea &ta, GenericTileIndex dst_area_north, DirTransformation transformation) { return TransformTileArea<true, true>(ta, dst_area_north, transformation); }
+
+#endif /* TILEAREA_FUNC_H */
diff -urNad openttd-1.3.2/src/tilearea_type.h openttd-1.3.2-DC3.0RC3/src/tilearea_type.h
--- openttd-1.3.2/src/tilearea_type.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/tilearea_type.h	2013-11-22 05:49:07.000000000 +0100
@@ -9,19 +9,83 @@
 
 /** @file tilearea_type.h Type for storing the 'area' of something uses on the map. */
 
+/**
+ * @defgroup TileIndexTransformations Tile index transformations
+ *
+ * @image html tile_index_transformations.svg
+ */
+
 #ifndef TILEAREA_TYPE_H
 #define TILEAREA_TYPE_H
 
 #include "map_func.h"
+#include "direction_type.h"
 
-/** Represents the covered area of e.g. a rail station */
-struct TileArea {
-	TileIndex tile; ///< The base tile of the area
-	uint16 w;       ///< The width of the area
-	uint16 h;       ///< The height of the area
+template <bool Tgeneric>
+struct TileAreaT;
+
+/**
+ * Set of coordinates representing rectangular piece of a tile map.
+ *
+ * This "raw" area does not point to any map. These are pure coordinates. Unless
+ * we bound them to a cartain map we cannot make most of calculations.
+ *
+ * @see RawTileIndex
+ * @see TileAreaT
+ */
+struct RawTileArea {
+	RawTileIndex tile; ///< The base (northern) tile of the area
+	uint16 w;          ///< The width of the area
+	uint16 h;          ///< The height of the area
+};
+
+/**
+ * Set of coordinates representing rectangular piece of a tile map.
+ *
+ * This tile area, based on template args, can represent a part of either the main map
+ * or any chosen map.
+ *
+ * @tparam Tgeneric If \c false, this area will represent tiles on the main map.
+ *                  If \c true, this area will be able to represent tiles on any map chosen on a run-tim.
+ *
+ * @note To use a specific overload there are TileArea and GenericTileArea to your
+ *       disposition. Use TileAreaT type directly only if you work with templates.
+ *
+ * @see TileArea
+ * @see GenericTileArea
+ * @see RawTileArea
+ * @see TileIndexT
+ */
+template <bool Tgeneric>
+struct TileAreaT {
+	typedef typename TileIndexT<Tgeneric>::T TileIndexType; ///< The type of tile indices, TileIndex or GenericTileIndex.
+
+	TileIndexType tile; ///< The base (northern) tile of the area
+	uint16 w;           ///< The width of the area
+	uint16 h;           ///< The height of the area
 
 	/** Just construct this tile area */
-	TileArea() {}
+	TileAreaT() {}
+
+	/**
+	 * Make a copy of a given tile area
+	 * @param ta the area to copy
+	 */
+	template <bool TotherGeneric>
+	TileAreaT(const TileAreaT<TotherGeneric> &ta)
+		: tile(MakeTileIndex<Tgeneric>(IndexOf(ta.tile), MapOf(ta.tile))), w(ta.w), h(ta.h)
+	{
+	}
+
+	/**
+	 * Construct this tile area from a "raw" tile area and a given tile map
+	 * @param ta the "raw" tile area
+	 * @param map the map
+	 */
+	inline TileAreaT(const RawTileArea &ta, Map *map)
+		: tile(MakeTileIndex<Tgeneric>(ta.tile, map)), w(ta.w), h(ta.h)
+	{
+	}
 
 	/**
 	 * Construct this tile area with some set values
@@ -29,26 +93,28 @@
 	 * @param w the width
 	 * @param h the height
 	 */
-	TileArea(TileIndex tile, uint8 w, uint8 h) : tile(tile), w(w), h(h) {}
+	TileAreaT(TileIndexType tile, uint8 w, uint8 h) : tile(tile), w(w), h(h) {}
 
-	TileArea(TileIndex start, TileIndex end);
+	TileAreaT(TileIndexType start, TileIndexType end);
 
 
-	void Add(TileIndex to_add);
+	void Add(TileIndexType to_add);
 
 	/**
 	 * Clears the 'tile area', i.e. make the tile invalid.
 	 */
 	void Clear()
 	{
-		this->tile = INVALID_TILE;
+		IndexOf(this->tile) = INVALID_TILE_INDEX;
 		this->w    = 0;
 		this->h    = 0;
 	}
 
-	bool Intersects(const TileArea &ta) const;
+	bool Intersects(const TileAreaT<Tgeneric> &ta) const;
 
-	bool Contains(TileIndex tile) const;
+	bool Contains(const TileAreaT<Tgeneric> &ta) const;
+
+	bool Contains(TileIndexType tile) const;
 
 	void ClampToMap();
 
@@ -56,36 +122,171 @@
 	 * Get the center tile.
 	 * @return The tile at the center, or just north of it.
 	 */
-	TileIndex GetCenterTile() const
+	TileIndexType GetCenterTile() const
 	{
 		return TILE_ADDXY(this->tile, this->w / 2, this->h / 2);
 	}
+
+	TileIndexDiffC TransformedNorthOffset(DirTransformation transformation) const;
+	TileIndexDiffC TransformedTileOffset(TileIndexType tile, DirTransformation transformation) const;
+
+	/**
+	 * Transform northern tile of this area based on a given northern tile of transformed area.
+	 *
+	 * @param dst_area_north Point of reference, the northern tile of the transformed area.
+	 * @param transformation Transformation to perform.
+	 * @return Northern tile of this area after transformation.
+	 *
+	 * @see TileIndexTransformations
+	 *
+	 * @ingroup TileIndexTransformations
+	 */
+	template <bool TgenericDst>
+	typename TileIndexT<TgenericDst>::T TransformedNorth(typename TileIndexT<TgenericDst>::T dst_area_north, DirTransformation transformation) const
+	{
+		TileIndexDiffC offs = this->TransformedNorthOffset(transformation);
+		return TILE_ADDXY(dst_area_north, offs.x, offs.y);
+	}
+	/** @copydoc TileAreaT::TransformedNorth(TileIndexT<TgenericDst>::T,DirTransformation) */
+	inline TileIndex TransformedNorth(TileIndex dst_area_north, DirTransformation transformation) const { return this->TransformedNorth<false>(dst_area_north, transformation); }
+	/** @copydoc TileAreaT::TransformedNorth(TileIndexT<TgenericDst>::T,DirTransformation) */
+	inline GenericTileIndex TransformedNorth(GenericTileIndex dst_area_north, DirTransformation transformation) const { return this->TransformedNorth<true>(dst_area_north, transformation); }
+
+	/**
+	 * Calculate northern tile of transformed area based on transformed northern tile of this area.
+	 *
+	 * @param transformed_north Point of reference, northern tile of this area after transformation.
+	 * @param transformation The transformation.
+	 * @return Northern tile of the transformed area.
+	 *
+	 * @see TileIndexTransformations
+	 *
+	 * @ingroup TileIndexTransformations
+	 */
+	template <bool TgenericDst>
+	typename TileIndexT<TgenericDst>::T ReverseTransformedNorth(typename TileIndexT<TgenericDst>::T transformed_north, DirTransformation transformation) const
+	{
+		TileIndexDiffC offs = this->TransformedNorthOffset(transformation);
+		return TILE_ADDXY(transformed_north, -offs.x, -offs.y);
+	}
+	/** @copydoc TileAreaT::ReverseTransformedNorth(TileIndexT<TgenericDst>::T,DirTransformation) */
+	inline TileIndex ReverseTransformedNorth(TileIndex transformed_north, DirTransformation transformation) const { return this->ReverseTransformedNorth<false>(transformed_north, transformation); }
+	/** @copydoc TileAreaT::ReverseTransformedNorth(TileIndexT<TgenericDst>::T,DirTransformation) */
+	inline GenericTileIndex ReverseTransformedNorth(GenericTileIndex transformed_north, DirTransformation transformation) const { return this->ReverseTransformedNorth<true>(transformed_north, transformation); }
+
+	/**
+	 * Transform a given tile within this area.
+	 *
+	 * @param tile The tile to transform.
+	 * @param transformed_north Point of reference, northern tile of this area after transformation.
+	 * @param transformation Transformation to perform.
+	 * @return Transformed tile.
+	 *
+	 * @see TileIndexTransformations
+	 *
+	 * @ingroup TileIndexTransformations
+	 */
+	template <bool TgenericDst>
+	typename TileIndexT<TgenericDst>::T TransformTile(TileIndexType tile, typename TileIndexT<TgenericDst>::T transformed_north, DirTransformation transformation) const
+	{
+		TileIndexDiffC offs = this->TransformedTileOffset(tile, transformation);
+		return TILE_ADDXY(transformed_north, offs.x, offs.y);
+	}
+	/** @copydoc TileAreaT::TransformTile(TileIndexType,TileIndexT<TgenericDst>::T,DirTransformation) */
+	inline TileIndex TransformTile(TileIndexType tile, TileIndex transformed_north, DirTransformation transformation) const { return this->TransformTile<false>(tile, transformed_north, transformation); }
+	/** @copydoc TileAreaT::TransformTile(TileIndexType,TileIndexT<TgenericDst>::T,DirTransformation) */
+	inline GenericTileIndex TransformTile(TileIndexType tile, GenericTileIndex transformed_north, DirTransformation transformation) const { return this->TransformTile<true>(tile, transformed_north, transformation); }
+
+	/**
+	 * Get the point of reference of a transfomation based on a given tile before and after transformation.
+	 *
+	 * @param tile The tile before transformation.
+	 * @param transformed_tile The tile after transformation.
+	 * @param transformation The transformation.
+	 * @return The point of reference (northern tile of this area after transformation).
+	 *
+	 * @see TileIndexTransformations
+	 *
+	 * @ingroup TileIndexTransformations
+	 */
+	template <bool TgenericDst>
+	typename TileIndexT<TgenericDst>::T ReverseTransformTile(TileIndexType source_tile, typename TileIndexT<TgenericDst>::T transformed_tile, DirTransformation transformation) const
+	{
+		TileIndexDiffC offs = this->TransformedTileOffset(source_tile, transformation);
+		return TILE_ADDXY(transformed_tile, -offs.x, -offs.y);
+	}
+	/** @copydoc TileAreaT::ReverseTransformTile(TileIndexType,TileIndexT<TgenericDst>::T,DirTransformation) */
+	inline TileIndex ReverseTransformTile(TileIndexType source_tile, TileIndex transformed_tile, DirTransformation transformation) const { return this->ReverseTransformTile<false>(source_tile, transformed_tile, transformation); }
+	/** @copydoc TileAreaT::ReverseTransformTile(TileIndexType,TileIndexT<TgenericDst>::T,DirTransformation) */
+	inline GenericTileIndex ReverseTransformTile(TileIndexType source_tile, GenericTileIndex transformed_tile, DirTransformation transformation) const { return this->ReverseTransformTile<true>(source_tile, transformed_tile, transformation); }
 };
 
+/**
+ * Set of coordinates representing rectangular piece of the main tile map.
+ *
+ * This is the most common type of tile area. It represents tiles on the main tile array.
+ *
+ * @see TileIndex
+ * @see GenericTileArea
+ */
+typedef TileAreaT<false> TileArea;
+
+/**
+ * Set of coordinates representing rectangular piece of a tile map.
+ *
+ * This "generic" tile area is able to represent part of any map chosen on a run-time.
+ *
+ * @see GenericTileIndex
+ * @see TileArea
+ */
+typedef TileAreaT<true> GenericTileArea;
+
 /** Base class for tile iterators. */
-class TileIterator {
+template <bool Tgeneric>
+class TileIteratorT {
+public:
+	typedef typename TileIndexT<Tgeneric>::T TileIndexType; ///< The type of tile indices, TileIndex or GenericTileIndex.
+
 protected:
-	TileIndex tile; ///< The current tile we are at.
+	TileIndexType tile; ///< The current tile we are at.
 
 	/**
 	 * Initialise the iterator starting at this tile.
 	 * @param tile The tile we start iterating from.
 	 */
-	TileIterator(TileIndex tile) : tile(tile)
+	TileIteratorT(TileIndexType tile) : tile(tile)
 	{
 	}
 
+	/**
+	 * Get the raw tile index of this iterator.
+	 * @return Pointer to the index.
+	 */
+	inline RawTileIndex *MyIndex()
+	{
+		return &IndexOf(this->tile);
+	}
+
+	/**
+	 * Get the map of this iterator.
+	 * @return The map that this iterator iterates through.
+	 */
+	inline Map *MyMap() const
+	{
+		return MapOf(this->tile);
+	}
+
 public:
 	/** Some compilers really like this. */
-	virtual ~TileIterator()
+	virtual ~TileIteratorT()
 	{
 	}
 
 	/**
 	 * Get the tile we are currently at.
-	 * @return The tile we are at, or INVALID_TILE when we're done.
+	 * @return The tile we are at, or "invalid" tile when we're done.
 	 */
-	inline operator TileIndex () const
+	inline operator TileIndexType () const
 	{
 		return this->tile;
 	}
@@ -93,57 +294,94 @@
 	/**
 	 * Move ourselves to the next tile in the rectangle on the map.
 	 */
-	virtual TileIterator& operator ++() = 0;
+	virtual TileIteratorT<Tgeneric>& operator ++() = 0;
 
 	/**
 	 * Allocate a new iterator that is a copy of this one.
 	 */
-	virtual TileIterator *Clone() const = 0;
+	virtual TileIteratorT<Tgeneric> *Clone() const = 0;
 };
 
-/** Iterator to iterate over a tile area (rectangle) of the map. */
-class OrthogonalTileIterator : public TileIterator {
-private:
-	int w;          ///< The width of the iterated area.
-	int x;          ///< The current 'x' position in the rectangle.
-	int y;          ///< The current 'y' position in the rectangle.
+/** Base class for tile iterators of the main map. */
+typedef TileIteratorT<false> TileIterator;
 
+/** Helper class to build diagonal tile iterators. */
+class OrthogonalTileIteratorController {
 public:
+	int w; ///< The width of the iterated area.
+	int x; ///< The current 'x' position in the rectangle.
+	int y; ///< The current 'y' position in the rectangle.
+
 	/**
-	 * Construct the iterator.
-	 * @param ta Area, i.e. begin point and width/height of to-be-iterated area.
+	 * Initialize iteration.
+	 * @param my_index Pointer to the tile index of the iterator. The index must be set to the first tile of the iteration before you call Init.
+	 * @param w The width of the iterated area.
+	 * @param h The height of the iterated area.
 	 */
-	OrthogonalTileIterator(const TileArea &ta) : TileIterator(ta.w == 0 || ta.h == 0 ? INVALID_TILE : ta.tile), w(ta.w), x(ta.w), y(ta.h)
+	void Init(RawTileIndex *my_index, uint w, uint h)
 	{
+		this->w = w;
+		this->x = w;
+		this->y = h;
+		if (w == 0 || h == 0) *my_index = INVALID_TILE_INDEX;
 	}
 
 	/**
-	 * Move ourselves to the next tile in the rectangle on the map.
+	 * Perform single iteration step.
+	 * @param my_index Pointer to the tile index of the iterator.
+	 * @param my_map The map that iterator iterates through.
 	 */
-	inline TileIterator& operator ++()
+	inline void Advance(RawTileIndex *my_index, Map *my_map)
 	{
-		assert(this->tile != INVALID_TILE);
+		assert(*my_index != INVALID_TILE_INDEX);
 
 		if (--this->x > 0) {
-			this->tile++;
+			++*my_index;
 		} else if (--this->y > 0) {
 			this->x = this->w;
-			this->tile += TileDiffXY(1, 1) - this->w;
+			*my_index += TileDiffXY(1, 1, my_map) - this->w;
 		} else {
-			this->tile = INVALID_TILE;
+			*my_index = INVALID_TILE_INDEX;
 		}
+	}
+};
+
+/** Iterator to iterate over a tile area (rectangle) of a map. */
+template <bool Tgeneric>
+class OrthogonalTileIteratorT : public TileIteratorT<Tgeneric>, protected OrthogonalTileIteratorController {
+public:
+	typedef typename TileIteratorT<Tgeneric>::TileIndexType TileIndexType;
+
+	/**
+	 * Construct the iterator.
+	 * @param ta Area, i.e. begin point and width/height of to-be-iterated area.
+	 */
+	OrthogonalTileIteratorT(const TileAreaT<Tgeneric> &ta) : TileIteratorT<Tgeneric>(ta.tile)
+	{
+		this->Init(this->MyIndex(), ta.w, ta.h);
+	}
+
+	/**
+	 * Move ourselves to the next tile in the rectangle on the map.
+	 */
+	inline TileIteratorT<Tgeneric> &operator ++ ()
+	{
+		this->Advance(this->MyIndex(), this->MyMap());
 		return *this;
 	}
 
-	virtual TileIterator *Clone() const
+	virtual TileIteratorT<Tgeneric> *Clone() const
 	{
-		return new OrthogonalTileIterator(*this);
+		return new OrthogonalTileIteratorT<Tgeneric>(*this);
 	}
 };
 
-/** Iterator to iterate over a diagonal area of the map. */
-class DiagonalTileIterator : public TileIterator {
-private:
+/** Iterator to iterate over a tile area (rectangle) of the main map. */
+typedef OrthogonalTileIteratorT<false> OrthogonalTileIterator;
+
+/** Helper class to build diagonal tile iterators. */
+class DiagonalTileIteratorController {
+public:
 	uint base_x; ///< The base tile x coordinate from where the iterating happens.
 	uint base_y; ///< The base tile y coordinate from where the iterating happens.
 	int a_cur;   ///< The current (rotated) x coordinate of the iteration.
@@ -151,17 +389,111 @@
 	int a_max;   ///< The (rotated) x coordinate of the end of the iteration.
 	int b_max;   ///< The (rotated) y coordinate of the end of the iteration.
 
+	void Init(RawTileIndex *my_index, RawTileIndex opposite_corner, Map *my_map);
+	void Advance(RawTileIndex *my_index, Map *my_map);
+};
+
+/** Iterator to iterate over a diagonal area of a map. */
+template <bool Tgeneric>
+class DiagonalTileIteratorT : public TileIteratorT<Tgeneric>, protected DiagonalTileIteratorController {
 public:
-	DiagonalTileIterator(TileIndex begin, TileIndex end);
+	typedef typename TileIteratorT<Tgeneric>::TileIndexType TileIndexType;
 
-	TileIterator& operator ++();
+	/**
+	 * Construct the iterator.
+	 * @param begin The first corner of the to-be-itarted area.
+	 * @param end The second (opposite) corner of the to-be-itarted area.
+	 */
+	DiagonalTileIteratorT(TileIndexType begin, TileIndexType end) : TileIteratorT<Tgeneric>(begin)
+	{
+		assert(IsSameMap(begin, end));
+		this->Init(this->MyIndex(), end, this->MyMap());
+	}
 
-	virtual TileIterator *Clone() const
+	TileIteratorT<Tgeneric> &operator ++ ()
 	{
-		return new DiagonalTileIterator(*this);
+		this->Advance(this->MyIndex(), this->MyMap());
+		return *this;
+	}
+
+	virtual TileIteratorT<Tgeneric> *Clone() const
+	{
+		return new DiagonalTileIteratorT<Tgeneric>(*this);
 	}
 };
 
+/** Iterator to iterate over a diagonal area of the main map. */
+typedef DiagonalTileIteratorT<false> DiagonalTileIterator;
+
+/** Helper class to build transformative tile iterators. */
+class TransformationTileIteratorController : public OrthogonalTileIteratorController {
+public:
+	DirTransformation transformation; ///< Transformation to perform.
+
+	void Init(RawTileIndex *src_index, RawTileIndex *dst_index, uint16 src_w, uint16 src_h, DirTransformation transformation);
+	void Advance(RawTileIndex *src_index, Map *src_map, RawTileIndex *dst_index, Map *dst_map);
+};
+
+/**
+ * Iterator to iterate over a diagonal area of a map performing transformation on tile indices.
+ *
+ * Iterator will iterate over source area in the same way OrthogonalTileIteratorT do, additionally
+ * performing transformation on tile indices. You can call SrcTile or DstTile to get the tile before
+ * and after transformation.
+ *
+ * The tile of this iterator (it's base) is the transformed one.
+ */
+template <bool TgenericSrc, bool TgenericDst>
+class TransformationTileIteratorT : public TileIteratorT<TgenericDst>, protected TransformationTileIteratorController {
+public:
+	typedef typename TileIteratorT<TgenericDst>::TileIndexType TileIndexType;
+	typedef typename TileIndexT<TgenericDst>::T DstTileIndexType;
+	typedef typename TileIndexT<TgenericSrc>::T SrcTileIndexType;
+
+protected:
+	SrcTileIndexType src_tile; ///< Current tile of the source area.
+
+public:
+	/**
+	 * Create a TransformationTileIteratorT.
+	 *
+	 * @param src_area Source area to be transformed and iterated over.
+	 * @param transformed_north Transformed northern tile of the source area.
+	 * @param transformation Transformation to perform.
+	 */
+	TransformationTileIteratorT(const TileAreaT<TgenericSrc> &src_area, DstTileIndexType transformed_north, DirTransformation transformation)
+		: TileIteratorT<TgenericDst>(transformed_north), src_tile(src_area.tile)
+	{
+		this->Init(&IndexOf(this->src_tile), this->MyIndex(), src_area.w, src_area.h, transformation);
+	}
+
+	/**
+	 * The source tile of the transformation.
+	 * @return Tile before transformation.
+	 */
+	inline const SrcTileIndexType &SrcTile() const { return this->src_tile; }
+
+	/**
+	 * The destination tile of the transformation (the tile of this iterator).
+	 * @return Tile after transformation.
+	 */
+	inline const DstTileIndexType &DstTile() const { return this->tile; }
+
+	virtual TileIteratorT<TgenericDst> &operator ++ ()
+	{
+		this->Advance(&IndexOf(this->src_tile), MapOf(this->src_tile), this->MyIndex(), this->MyMap());
+		return *this;
+	}
+
+	virtual TileIteratorT<TgenericDst> *Clone() const
+	{
+		return new TransformationTileIteratorT<TgenericSrc, TgenericDst>(*this);
+	}
+};
+
+/** Iterator to iterate over a diagonal area of the main map performing transformation on tile indices. */
+typedef TransformationTileIteratorT<false, false> TransformationTileIterator;
+
 /**
  * A loop which iterates over the tiles of a TileArea.
  * @param var The name of the variable which contains the current tile.
@@ -170,4 +502,12 @@
  */
 #define TILE_AREA_LOOP(var, ta) for (OrthogonalTileIterator var(ta); var != INVALID_TILE; ++var)
 
+/**
+ * A loop which iterates over the tiles of a GenericTileArea.
+ * @param var The name of the variable which contains the current tile.
+ *            This variable will be allocated in this \c for of this loop.
+ * @param ta  The tile area to search over.
+ */
+#define GENERIC_TILE_AREA_LOOP(var, ta) for (OrthogonalTileIteratorT<true> var(ta); IsValidTileIndex<true>(var); ++var)
+
 #endif /* TILEAREA_TYPE_H */
diff -urNad openttd-1.3.2/src/tile_cmd.h openttd-1.3.2-DC3.0RC3/src/tile_cmd.h
--- openttd-1.3.2/src/tile_cmd.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/tile_cmd.h	2013-11-22 05:49:07.000000000 +0100
@@ -18,6 +18,8 @@
 #include "track_type.h"
 #include "tile_map.h"
 
+struct CopyPasteParams;
+
 /** The returned bits of VehicleEnterTile. */
 enum VehicleEnterTileStatus {
 	VETS_ENTERED_STATION  = 1, ///< The vehicle entered a station
@@ -136,6 +138,17 @@
 typedef CommandCost TerraformTileProc(TileIndex tile, DoCommandFlag flags, int z_new, Slope tileh_new);
 
 /**
+ * Tile callback function signature for copy-pasting tile content.
+ *
+ * @param src_tile   Tile to copy content from.
+ * @param dst_tile   Tile where to paste the content.
+ * @param copy_paste What, where and how we are copying.
+ * @param flags      Command flags passed to the copy-paste command.
+ */
+typedef void CopyPasteTileProc(GenericTileIndex src_tile, GenericTileIndex dst_tile, const CopyPasteParams &copy_paste);
+
+
+/**
  * Set of callback functions for performing tile operations of a given tile type.
  * @see TileType
  */
@@ -154,6 +167,7 @@
 	VehicleEnterTileProc *vehicle_enter_tile_proc; ///< Called when a vehicle enters a tile
 	GetFoundationProc *get_foundation_proc;
 	TerraformTileProc *terraform_tile_proc;        ///< Called when a terraforming operation is about to take place
+	CopyPasteTileProc *copy_paste_tile_proc;       ///< Called to copy-paste content of a tile
 };
 
 extern const TileTypeProcs * const _tile_type_procs[16];
diff -urNad openttd-1.3.2/src/tilehighlight_func.h openttd-1.3.2-DC3.0RC3/src/tilehighlight_func.h
--- openttd-1.3.2/src/tilehighlight_func.h	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/tilehighlight_func.h	2013-11-22 05:49:07.000000000 +0100
@@ -14,6 +14,7 @@
 
 #include "gfx_type.h"
 #include "tilehighlight_type.h"
+#include "track_type.h"
 
 void PlaceProc_DemolishArea(TileIndex tile);
 bool GUIPlaceProcDragXY(ViewportDragDropSelectionProcess proc, TileIndex start_tile, TileIndex end_tile);
@@ -29,6 +30,13 @@
 void VpSetPlaceSizingLimit(int limit);
 
 void UpdateTileSelection();
+void StoreRailPlacementEndpoints(TileIndex start_tile, TileIndex end_tile, Track start_track, bool bidirectional = true);
+
+/** Clear all rail track endpoints stored for highlighting purposes. @see StoreRailPlacementEndpoints */
+static inline void ClearRailPlacementEndpoints()
+{
+	StoreRailPlacementEndpoints(INVALID_TILE, INVALID_TILE, TRACK_BEGIN, false);
+}
 
 extern TileHighlightData _thd;
 
diff -urNad openttd-1.3.2/src/tilehighlight_type.h openttd-1.3.2-DC3.0RC3/src/tilehighlight_type.h
--- openttd-1.3.2/src/tilehighlight_type.h	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/tilehighlight_type.h	2013-11-22 05:49:07.000000000 +0100
@@ -28,6 +28,8 @@
 	HT_RAIL      = 0x080, ///< autorail (one piece), lower bits: direction
 	HT_VEHICLE   = 0x100, ///< vehicle is accepted as target as well (bitmask)
 	HT_DIAGONAL  = 0x200, ///< Also allow 'diagonal rectangles'. Only usable in combination with #HT_RECT or #HT_POINT.
+	HT_POLY      = 0x400, ///< polyline mode; connect highlighted track with previous one
+	HT_PASTE_PREVIEW = 0x400, ///< Preview of a paste result. Only usable in combination with #HT_POINT.
 	HT_DRAG_MASK = 0x0F8, ///< Mask for the tile drag-type modes.
 
 	/* lower bits (used with HT_LINE and HT_RAIL):
diff -urNad openttd-1.3.2/src/tile_map.cpp openttd-1.3.2-DC3.0RC3/src/tile_map.cpp
--- openttd-1.3.2/src/tile_map.cpp	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/tile_map.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -12,86 +12,166 @@
 #include "stdafx.h"
 #include "tile_map.h"
 
+static Slope GetTileSlopeGivenHeight(int hnorth, int hwest, int heast, int hsouth, int *h) {
+
+	/* Due to the fact that tiles must connect with each other without leaving gaps, the
+	 * biggest difference in height between any corner and 'min' is between 0, 1, or 2.
+	 *
+	 * Also, there is at most 1 corner with height difference of 2. */
+
+	int hminnw = min(hnorth, hwest);
+	int hmines = min(heast, hsouth);
+	int hmin = min(hminnw, hmines);
+
+	int hmaxnw = max(hnorth, hwest);
+	int hmaxes = max(heast, hsouth);
+	int hmax = max(hmaxnw, hmaxes);
+
+	uint r = SLOPE_FLAT; ///< Computed slope of the tile.
+
+	if (hnorth != hmin) {
+		r += SLOPE_N;
+	}
+	if (hwest != hmin) {
+		r += SLOPE_W;
+	}
+	if (heast != hmin) {
+		r += SLOPE_E;
+	}
+	if (hsouth != hmin) {
+		r += SLOPE_S;
+	}
+	if (hmax - hmin == 2) {
+		r += SLOPE_STEEP;
+	}
+
+	if (h != NULL) *h = hmin;
+
+	return (Slope)r;
+}
+
 /**
- * Return the slope of a given tile
+ * Return the slope of a given tile inside the map.
  * @param tile Tile to compute slope of
  * @param h    If not \c NULL, pointer to storage of z height
  * @return Slope of the tile, except for the HALFTILE part
  */
-Slope GetTileSlope(TileIndex tile, int *h)
+template <bool Tgeneric>
+Slope GetTileSlope(typename TileIndexT<Tgeneric>::T tile, int *h)
 {
-	assert(tile < MapSize());
+	assert(IsValidTileIndex(tile));
 
 	uint x = TileX(tile);
 	uint y = TileY(tile);
 
-	if (x == MapMaxX() || y == MapMaxY() ||
-			((x == 0 || y == 0) && _settings_game.construction.freeform_edges)) {
+	if (x == MapMaxX(MapOf(tile)) || y == MapMaxY(MapOf(tile)) ||
+			((x == 0 || y == 0) && IsMainMapTile(tile) && _settings_game.construction.freeform_edges)) {
 		if (h != NULL) *h = TileHeight(tile);
 		return SLOPE_FLAT;
 	}
 
-	int a = TileHeight(tile); // Height of the N corner
-	int min = a; // Minimal height of all corners examined so far
-	int b = TileHeight(tile + TileDiffXY(1, 0)); // Height of the W corner
-	if (min > b) min = b;
-	int c = TileHeight(tile + TileDiffXY(0, 1)); // Height of the E corner
-	if (min > c) min = c;
-	int d = TileHeight(tile + TileDiffXY(1, 1)); // Height of the S corner
-	if (min > d) min = d;
-
-	/* Due to the fact that tiles must connect with each other without leaving gaps, the
-	 * biggest difference in height between any corner and 'min' is between 0, 1, or 2.
-	 *
-	 * Also, there is at most 1 corner with height difference of 2.
-	 */
-
-	uint r = SLOPE_FLAT; // Computed slope of the tile
+       int hnorth = TileHeight(tile);                    // Height of the North corner.
+       int hwest = TileHeight(tile + TileDiffXY(1, 0));  // Height of the West corner.
+       int heast = TileHeight(tile + TileDiffXY(0, 1));  // Height of the East corner.
+       int hsouth = TileHeight(tile + TileDiffXY(1, 1)); // Height of the South corner.
 
-	/* For each corner if not equal to minimum height:
-	 *  - set the SLOPE_STEEP flag if the difference is 2
-	 *  - add the corresponding SLOPE_X constant to the computed slope
-	 */
-	if ((a -= min) != 0) r += (--a << 4) + SLOPE_N;
-	if ((c -= min) != 0) r += (--c << 4) + SLOPE_E;
-	if ((d -= min) != 0) r += (--d << 4) + SLOPE_S;
-	if ((b -= min) != 0) r += (--b << 4) + SLOPE_W;
+       return GetTileSlopeGivenHeight(hnorth, hwest, heast, hsouth, h);
+}
 
-	if (h != NULL) *h = min;
+/**
+ * Return the slope of a given tile outside the map.
+ *
+ * @param tile Tile outside the map to compute slope of.
+ * @param h    If not \c NULL, pointer to storage of z height.
+ * @return Slope of the tile outside map, except for the HALFTILE part. */
+Slope GetTilePixelSlopeOutsideMap(int x, int y, int *h)
+{
+       int hnorth = TileHeightOutsideMap(x, y);         // N corner.
+       int hwest = TileHeightOutsideMap(x + 1, y);      // W corner.
+       int heast = TileHeightOutsideMap(x, y + 1);      // E corner.
+       int hsouth = TileHeightOutsideMap(x + 1, y + 1); // S corner.
 
-	return (Slope)r;
+       Slope s = GetTileSlopeGivenHeight(hnorth, hwest, heast, hsouth, h);
+       if (h != NULL) *h *= TILE_HEIGHT;
+       return s;
 }
+/* instantiate */
+template Slope GetTileSlope<false>(TileIndex tile, int *h);
+template Slope GetTileSlope<true>(GenericTileIndex tile, int *h);
 
 /**
  * Get bottom height of the tile
  * @param tile Tile to compute height of
  * @return Minimum height of the tile
  */
-int GetTileZ(TileIndex tile)
+template <bool Tgeneric>
+int GetTileZ(typename TileIndexT<Tgeneric>::T tile)
 {
-	if (TileX(tile) == MapMaxX() || TileY(tile) == MapMaxY()) return 0;
+	if (TileX(tile) == MapMaxX(MapOf(tile)) || TileY(tile) == MapMaxY(MapOf(tile))) return 0;
 
 	int h = TileHeight(tile); // N corner
-	h = min(h, TileHeight(tile + TileDiffXY(1, 0))); // W corner
-	h = min(h, TileHeight(tile + TileDiffXY(0, 1))); // E corner
-	h = min(h, TileHeight(tile + TileDiffXY(1, 1))); // S corner
+	h = min(h, TileHeight(tile + TileDiffXY(1, 0, MapOf(tile)))); // W corner
+	h = min(h, TileHeight(tile + TileDiffXY(0, 1, MapOf(tile)))); // E corner
+	h = min(h, TileHeight(tile + TileDiffXY(1, 1, MapOf(tile)))); // S corner
 
 	return h;
 }
+/* instantiate */
+template int GetTileZ<false>(TileIndex tile);
+template int GetTileZ<true>(GenericTileIndex tile);
+
+ /**
+ * Get bottom height of the tile outside map.
+ *
+ * @param tile Tile outside the map to compute height of.
+ * @return Minimum height of the tile outside the map. */
+int GetTilePixelZOutsideMap(int x, int y)
+{
+       uint h = TileHeightOutsideMap(x, y);            // N corner.
+       h = min(h, TileHeightOutsideMap(x + 1, y));     // W corner.
+       h = min(h, TileHeightOutsideMap(x, y + 1));     // E corner.
+       h = min(h, TileHeightOutsideMap(x + 1, y + 1)); // S corner
+
+       return h * TILE_HEIGHT;
+}
 
 /**
  * Get top height of the tile
  * @param t Tile to compute height of
  * @return Maximum height of the tile
  */
-int GetTileMaxZ(TileIndex t)
+template <bool Tgeneric>
+int GetTileMaxZ(typename TileIndexT<Tgeneric>::T t)
 {
-	if (TileX(t) == MapMaxX() || TileY(t) == MapMaxY()) return 0;
+	if (TileX(t) == MapMaxX(MapOf(t)) || TileY(t) == MapMaxY(MapOf(t))) return TileHeightOutsideMap(TileX(t), TileY(t));
 
 	int h = TileHeight(t); // N corner
-	h = max<int>(h, TileHeight(t + TileDiffXY(1, 0))); // W corner
-	h = max<int>(h, TileHeight(t + TileDiffXY(0, 1))); // E corner
-	h = max<int>(h, TileHeight(t + TileDiffXY(1, 1))); // S corner
+	h = max<int>(h, TileHeight(t + TileDiffXY(1, 0, MapOf(t)))); // W corner
+	h = max<int>(h, TileHeight(t + TileDiffXY(0, 1, MapOf(t)))); // E corner
+	h = max<int>(h, TileHeight(t + TileDiffXY(1, 1, MapOf(t)))); // S corner
 
 	return h;
 }
+/* instantiate */
+template int GetTileMaxZ<false>(TileIndex t);
+template int GetTileMaxZ<true>(GenericTileIndex t);
+
+
+/**
+ * Get top height of the tile outside the map.
+ *
+ * @see Detailed description in header.
+ *
+ * @param tile Tile outside to compute height of.
+ * @return Maximum height of the tile.
+ */
+int GetTileMaxPixelZOutsideMap(int x, int y)
+{
+       uint h = TileHeightOutsideMap(x, y);
+       h = max(h, TileHeightOutsideMap(x + 1, y));
+       h = max(h, TileHeightOutsideMap(x, y + 1));
+       h = max(h, TileHeightOutsideMap(x + 1, y + 1));
+
+       return h * TILE_HEIGHT;
+}
+
diff -urNad openttd-1.3.2/src/tile_map.h openttd-1.3.2-DC3.0RC3/src/tile_map.h
--- openttd-1.3.2/src/tile_map.h	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/tile_map.h	2013-11-22 05:49:07.000000000 +0100
@@ -15,12 +15,11 @@
 #include "slope_type.h"
 #include "map_func.h"
 #include "core/bitmath_func.hpp"
+#include "core/math_func.hpp"
 #include "settings_type.h"
 
 /**
- * Returns the height of a tile
- *
- * This function returns the height of the northern corner of a tile.
+ * This function returns the height of the northern corner of a tile based on AllowMoreHeightlevels().
  * This is saved in the global map-array. It does not take affect by
  * any slope-data of the tile.
  *
@@ -28,11 +27,66 @@
  * @return the height of the tile
  * @pre tile < MapSize()
  */
-static inline uint TileHeight(TileIndex tile)
+template <bool Tgeneric>
+static inline uint TileHeight(typename TileIndexT<Tgeneric>::T tile)
 {
-	assert(tile < MapSize());
-	return GB(_m[tile].type_height, 0, 4);
+	assert(IsValidTileIndex(tile));
+//	return GB(GetTile(tile)->type_height, 0, 4);
+	return GetTile(tile)->height;
 }
+/** @copydoc TileHeight(TileIndexT<Tgeneric>::T) */
+static inline uint TileHeight(TileIndex tile) { return TileHeight<false>(tile); }
+/** @copydoc TileHeight(TileIndexT<Tgeneric>::T) */
+static inline uint TileHeight(GenericTileIndex tile) { return TileHeight<true>(tile); }
+
+/** Returns the tile height for a coordinate outside map.  Such a height is
+ *  needed for painting the area outside map using completely black tiles.
+ *  The idea is descending to heightlevel 0 as fast as possible.
+ */
+static inline uint TileHeightOutsideMap(int x, int y)
+{
+       /* In all cases: Descend to heightlevel 0 as fast as possible.
+        * So: If we are at the 0-side of the map (x<0 or y<0), we must
+        * subtract the distance to coordinate 0 from the heightlevel at
+        * coordinate 0.
+        * In other words: Subtract e.g. -x. If we are at the MapMax
+        * side of the map, we also need to subtract the distance to
+        * the edge of map, e.g. MapMaxX - x.
+        *
+        * NOTE: Assuming constant heightlevel outside map would be
+        * simpler here. However, then we run into painting problems,
+        * since whenever a heightlevel change at the map border occurs,
+        * we would need to repaint anything outside map.
+        * In contrast, by doing it this way, we can localize this change,
+        * which means we may assume constant heightlevel for all tiles
+        * at more than <heightlevel at map border> distance from the
+        * map border. */
+       if (x < 0) {
+               if (y < 0) {
+                       return max((int)TileHeight(TileXY(0, 0)) - (-x) - (-y), 0);
+               } else if (y < (int)MapMaxY()) {
+                       return max((int)TileHeight(TileXY(0, y)) - (-x), 0);
+               } else {
+                       return max((int)TileHeight(TileXY(0, (int)MapMaxY())) - (-x) - (y - (int)MapMaxY()), 0);
+               }
+       } else if (x < (int)MapMaxX()) {
+               if (y < 0) {
+                       return max((int)TileHeight(TileXY(x, 0)) - (-y), 0);
+               } else if (y < (int)MapMaxY()) {
+                       return TileHeight(TileXY(x, y));
+               } else {
+                       return max((int)TileHeight(TileXY(x, (int)MapMaxY())) - (y - (int)MapMaxY()), 0);
+               }
+       } else {
+               if (y < 0) {
+                       return max((int)TileHeight(TileXY((int)MapMaxX(), 0)) - (x - (int)MapMaxX()) - (-y), 0);
+               } else if (y < (int)MapMaxY()) {
+                       return max((int)TileHeight(TileXY((int)MapMaxX(), y)) - (x - (int)MapMaxX()), 0);
+               } else {
+                       return max((int)TileHeight(TileXY((int)MapMaxX(), (int)MapMaxY())) - (x - (int)MapMaxX()) - (y - (int)MapMaxY()), 0);
+               }
+       }
+ }
 
 /**
  * Sets the height of a tile.
@@ -44,12 +98,18 @@
  * @pre tile < MapSize()
  * @pre heigth <= MAX_TILE_HEIGHT
  */
-static inline void SetTileHeight(TileIndex tile, uint height)
+template <bool Tgeneric>
+static inline void SetTileHeight(typename TileIndexT<Tgeneric>::T tile, uint height)
 {
-	assert(tile < MapSize());
+	assert(IsValidTileIndex(tile));
 	assert(height <= MAX_TILE_HEIGHT);
-	SB(_m[tile].type_height, 0, 4, height);
+//	SB(GetTile(tile)->type_height, 0, 4, height);
+       GetTile(tile)->height = (byte)height;
 }
+/** @copydoc SetTileHeight(TileIndexT<Tgeneric>::T,uint) */
+static inline void SetTileHeight(TileIndex tile, uint height) { SetTileHeight<false>(tile, height); }
+/** @copydoc SetTileHeight(TileIndexT<Tgeneric>::T,uint) */
+static inline void SetTileHeight(GenericTileIndex tile, uint height) { SetTileHeight<true>(tile, height); }
 
 /**
  * Returns the height of a tile in pixels.
@@ -59,10 +119,15 @@
  * @param tile The tile to get the height
  * @return The height of the tile in pixel
  */
-static inline uint TilePixelHeight(TileIndex tile)
+template <bool Tgeneric>
+static inline uint TilePixelHeight(typename TileIndexT<Tgeneric>::T tile)
 {
 	return TileHeight(tile) * TILE_HEIGHT;
 }
+/** @copydoc TilePixelHeight(TileIndexT<Tgeneric>::T) */
+static inline uint TilePixelHeight(TileIndex tile) { return TilePixelHeight<false>(tile); }
+/** @copydoc TilePixelHeight(TileIndexT<Tgeneric>::T) */
+static inline uint TilePixelHeight(GenericTileIndex tile) { return TilePixelHeight<true>(tile); }
 
 /**
  * Get the tiletype of a given tile.
@@ -71,11 +136,16 @@
  * @return The tiletype of the tile
  * @pre tile < MapSize()
  */
-static inline TileType GetTileType(TileIndex tile)
+template <bool Tgeneric>
+static inline TileType GetTileType(typename TileIndexT<Tgeneric>::T tile)
 {
-	assert(tile < MapSize());
-	return (TileType)GB(_m[tile].type_height, 4, 4);
+	assert(IsValidTileIndex(tile));
+	return (TileType)GB(GetTile(tile)->type, 4, 4);
 }
+/** @copydoc GetTileType(TileIndexT<Tgeneric>::T) */
+static inline TileType GetTileType(TileIndex tile) { return GetTileType<false>(tile); }
+/** @copydoc GetTileType(TileIndexT<Tgeneric>::T) */
+static inline TileType GetTileType(GenericTileIndex tile) { return GetTileType<true>(tile); }
 
 /**
  * Set the type of a tile
@@ -89,16 +159,41 @@
  * @pre tile < MapSize()
  * @pre type MP_VOID <=> tile is on the south-east or south-west edge.
  */
-static inline void SetTileType(TileIndex tile, TileType type)
+template <bool Tgeneric>
+static inline void SetTileType(typename TileIndexT<Tgeneric>::T tile, TileType type);
+
+template <>
+inline void SetTileType<false>(TileIndex tile, TileType type)
 {
-	assert(tile < MapSize());
-	/* VOID tiles (and no others) are exactly allowed at the lower left and right
-	 * edges of the map. If _settings_game.construction.freeform_edges is true,
-	 * the upper edges of the map are also VOID tiles. */
-	assert((TileX(tile) == MapMaxX() || TileY(tile) == MapMaxY() || (_settings_game.construction.freeform_edges && (TileX(tile) == 0 || TileY(tile) == 0))) == (type == MP_VOID));
-	SB(_m[tile].type_height, 4, 4, type);
+	assert(IsValidTileIndex(tile));
+
+	/* VOID tiles (and no others) are exactly allowed at the lower left and right edges of the
+	 * map. If _settings_game.construction.freeform_edges is true, the upper edges of the map are also VOID tiles. */
+	assert((TileX(tile) == MapMaxX(MapOf(tile)) || TileY(tile) == MapMaxY(MapOf(tile)) ||
+			(_settings_game.construction.freeform_edges && (TileX(tile) == 0 || TileY(tile) == 0))) == (type == MP_VOID));
+
+	SB(GetTile(tile)->type, 4, 4, type);
+}
+
+template <>
+inline void SetTileType<true>(GenericTileIndex tile, TileType type)
+{
+	assert(IsValidTileIndex(tile));
+
+	/* VOID tiles (and no others) are exactly allowed at the lower left and right edges of the
+	 * map. If _settings_game.construction.freeform_edges is true, the upper edges of the main map
+	 * are also VOID tiles. */
+	assert((TileX(tile) == MapMaxX(MapOf(tile)) || TileY(tile) == MapMaxY(MapOf(tile)) ||
+			(IsMainMapTile(tile) && _settings_game.construction.freeform_edges && (TileX(tile) == 0 || TileY(tile) == 0))) == (type == MP_VOID));
+
+	SB(GetTile(tile)->type, 4, 4, type);
 }
 
+/** @copydoc SetTileType(TileIndexT<Tgeneric>::T,TileType) */
+static inline void SetTileType(TileIndex tile, TileType type) { SetTileType<false>(tile, type); }
+/** @copydoc SetTileType(TileIndexT<Tgeneric>::T,TileType) */
+static inline void SetTileType(GenericTileIndex tile, TileType type) { SetTileType<true>(tile, type); }
+
 /**
  * Checks if a tile is a give tiletype.
  *
@@ -108,10 +203,15 @@
  * @param type The type to check against
  * @return true If the type matches against the type of the tile
  */
-static inline bool IsTileType(TileIndex tile, TileType type)
+template <bool Tgeneric>
+static inline bool IsTileType(typename TileIndexT<Tgeneric>::T tile, TileType type)
 {
 	return GetTileType(tile) == type;
 }
+/** @copydoc IsTileType(TileIndexT<Tgeneric>::T,TileType) */
+static inline bool IsTileType(TileIndex tile, TileType type) { return IsTileType<false>(tile, type); }
+/** @copydoc IsTileType(TileIndexT<Tgeneric>::T,TileType) */
+static inline bool IsTileType(GenericTileIndex tile, TileType type) { return IsTileType<true>(tile, type); }
 
 /**
  * Checks if a tile is valid
@@ -119,10 +219,15 @@
  * @param tile The tile to check
  * @return True if the tile is on the map and not one of MP_VOID.
  */
-static inline bool IsValidTile(TileIndex tile)
+template <bool Tgeneric>
+static inline bool IsValidTile(typename TileIndexT<Tgeneric>::T tile)
 {
-	return tile < MapSize() && !IsTileType(tile, MP_VOID);
+	return IsValidTileIndex(tile) && !IsTileType(tile, MP_VOID);
 }
+/** @copydoc IsValidTile(TileIndexT<Tgeneric>::T) */
+static inline bool IsValidTile(TileIndex tile) { return IsValidTile<false>(tile); }
+/** @copydoc IsValidTile(TileIndexT<Tgeneric>::T) */
+static inline bool IsValidTile(GenericTileIndex tile) { return IsValidTile<true>(tile); }
 
 /**
  * Returns the owner of a tile
@@ -136,14 +241,19 @@
  * @pre IsValidTile(tile)
  * @pre The type of the tile must not be MP_HOUSE and MP_INDUSTRY
  */
-static inline Owner GetTileOwner(TileIndex tile)
+template <bool Tgeneric>
+static inline Owner GetTileOwner(typename TileIndexT<Tgeneric>::T tile)
 {
 	assert(IsValidTile(tile));
 	assert(!IsTileType(tile, MP_HOUSE));
 	assert(!IsTileType(tile, MP_INDUSTRY));
 
-	return (Owner)GB(_m[tile].m1, 0, 5);
+	return (Owner)GB(GetTile(tile)->m1, 0, 5);
 }
+/** @copydoc GetTileOwner(TileIndexT<Tgeneric>::T) */
+static inline Owner GetTileOwner(TileIndex tile) { return GetTileOwner<false>(tile); }
+/** @copydoc GetTileOwner(TileIndexT<Tgeneric>::T) */
+static inline Owner GetTileOwner(GenericTileIndex tile) { return GetTileOwner<true>(tile); }
 
 /**
  * Sets the owner of a tile
@@ -156,14 +266,19 @@
  * @pre IsValidTile(tile)
  * @pre The type of the tile must not be MP_HOUSE and MP_INDUSTRY
  */
-static inline void SetTileOwner(TileIndex tile, Owner owner)
+template <bool Tgeneric>
+static inline void SetTileOwner(typename TileIndexT<Tgeneric>::T tile, Owner owner)
 {
 	assert(IsValidTile(tile));
 	assert(!IsTileType(tile, MP_HOUSE));
 	assert(!IsTileType(tile, MP_INDUSTRY));
 
-	SB(_m[tile].m1, 0, 5, owner);
+	SB(GetTile(tile)->m1, 0, 5, owner);
 }
+/** @copydoc SetTileOwner(TileIndexT<Tgeneric>::T,Owner) */
+static inline void SetTileOwner(TileIndex tile, Owner owner) { SetTileOwner<false>(tile, owner); }
+/** @copydoc SetTileOwner(TileIndexT<Tgeneric>::T,Owner) */
+static inline void SetTileOwner(GenericTileIndex tile, Owner owner) { SetTileOwner<true>(tile, owner); }
 
 /**
  * Checks if a tile belongs to the given owner
@@ -172,10 +287,17 @@
  * @param owner The owner to check against
  * @return True if a tile belongs the the given owner
  */
-static inline bool IsTileOwner(TileIndex tile, Owner owner)
+template <bool Tgeneric>
+static inline bool IsTileOwner(typename TileIndexT<Tgeneric>::T tile, Owner owner)
 {
 	return GetTileOwner(tile) == owner;
 }
+/** @copydoc IsTileOwner(TileIndexT<Tgeneric>::T,Owner) */
+static inline bool IsTileOwner(TileIndex tile, Owner owner) { return IsTileOwner<false>(tile, owner); }
+/** @copydoc IsTileOwner(TileIndexT<Tgeneric>::T,Owner) */
+static inline bool IsTileOwner(GenericTileIndex tile, Owner owner) { return IsTileOwner<true>(tile, owner); }
+
+Slope GetTilePixelSlopeOutsideMap(int x, int y, int *h);
 
 /**
  * Set the tropic zone
@@ -187,9 +309,11 @@
 {
 	assert(tile < MapSize());
 	assert(!IsTileType(tile, MP_VOID) || type == TROPICZONE_NORMAL);
-	SB(_m[tile].m6, 0, 2, type);
+	SB(GetTileEx(tile)->m6, 0, 2, type);
 }
 
+int GetTilePixelZOutsideMap(int x, int y);
+
 /**
  * Get the tropic zone
  * @param tile the tile to get the zone of
@@ -199,7 +323,7 @@
 static inline TropicZone GetTropicZone(TileIndex tile)
 {
 	assert(tile < MapSize());
-	return (TropicZone)GB(_m[tile].m6, 0, 2);
+	return (TropicZone)GB(GetTileEx(tile)->m6, 0, 2);
 }
 
 /**
@@ -211,7 +335,7 @@
 static inline byte GetAnimationFrame(TileIndex t)
 {
 	assert(IsTileType(t, MP_HOUSE) || IsTileType(t, MP_OBJECT) || IsTileType(t, MP_INDUSTRY) ||IsTileType(t, MP_STATION));
-	return _me[t].m7;
+	return GetTileEx(t)->m7;
 }
 
 /**
@@ -223,12 +347,29 @@
 static inline void SetAnimationFrame(TileIndex t, byte frame)
 {
 	assert(IsTileType(t, MP_HOUSE) || IsTileType(t, MP_OBJECT) || IsTileType(t, MP_INDUSTRY) ||IsTileType(t, MP_STATION));
-	_me[t].m7 = frame;
+	GetTileEx(t)->m7 = frame;
 }
 
-Slope GetTileSlope(TileIndex tile, int *h = NULL);
-int GetTileZ(TileIndex tile);
-int GetTileMaxZ(TileIndex tile);
+template <bool Tgeneric>
+Slope GetTileSlope(typename TileIndexT<Tgeneric>::T tile, int *h = NULL);
+/** @copydoc GetTileSlope(TileIndexT<Tgeneric>::T,int*) */
+static inline Slope GetTileSlope(TileIndex tile, int *h = NULL) { return GetTileSlope<false>(tile, h); }
+/** @copydoc GetTileSlope(TileIndexT<Tgeneric>::T,int*) */
+static inline Slope GetTileSlope(GenericTileIndex tile, int *h = NULL) { return GetTileSlope<true>(tile, h); }
+
+template <bool Tgeneric>
+int GetTileZ(typename TileIndexT<Tgeneric>::T tile);
+/** @copydoc GetTileZ(TileIndexT<Tgeneric>::T) */
+static inline int GetTileZ(TileIndex tile) { return GetTileZ<false>(tile); }
+/** @copydoc GetTileZ(TileIndexT<Tgeneric>::T) */
+static inline int GetTileZ(GenericTileIndex tile) { return GetTileZ<true>(tile); }
+
+template <bool Tgeneric>
+int GetTileMaxZ(typename TileIndexT<Tgeneric>::T tile);
+/** @copydoc GetTileMaxZ(TileIndexT<Tgeneric>::T) */
+static inline int GetTileMaxZ(TileIndex tile) { return GetTileMaxZ<false>(tile); }
+/** @copydoc GetTileMaxZ(TileIndexT<Tgeneric>::T) */
+static inline int GetTileMaxZ(GenericTileIndex tile) { return GetTileMaxZ<true>(tile); }
 
 /**
  * Return the slope of a given tile
@@ -236,32 +377,49 @@
  * @param h    If not \c NULL, pointer to storage of z height
  * @return Slope of the tile, except for the HALFTILE part
  */
-static inline Slope GetTilePixelSlope(TileIndex tile, int *h)
+template <bool Tgeneric>
+static inline Slope GetTilePixelSlope(typename TileIndexT<Tgeneric>::T tile, int *h)
 {
 	Slope s = GetTileSlope(tile, h);
 	if (h != NULL) *h *= TILE_HEIGHT;
 	return s;
 }
+/** @copydoc GetTilePixelSlope(TileIndexT<Tgeneric>::T,int*) */
+static inline Slope GetTilePixelSlope(TileIndex tile, int *h) { return GetTilePixelSlope<false>(tile, h); }
+/** @copydoc GetTilePixelSlope(TileIndexT<Tgeneric>::T,int*) */
+static inline Slope GetTilePixelSlope(GenericTileIndex tile, int *h) { return GetTilePixelSlope<true>(tile, h); }
 
 /**
  * Get bottom height of the tile
  * @param tile Tile to compute height of
  * @return Minimum height of the tile
  */
-static inline int GetTilePixelZ(TileIndex tile)
+template <bool Tgeneric>
+static inline int GetTilePixelZ(typename TileIndexT<Tgeneric>::T tile)
 {
 	return GetTileZ(tile) * TILE_HEIGHT;
 }
+/** @copydoc GetTilePixelZ(TileIndexT<Tgeneric>::T) */
+static inline int GetTilePixelZ(TileIndex tile) { return GetTilePixelZ<false>(tile); }
+/** @copydoc GetTilePixelZ(TileIndexT<Tgeneric>::T) */
+static inline int GetTilePixelZ(GenericTileIndex tile) { return GetTilePixelZ<true>(tile); }
 
 /**
  * Get top height of the tile
  * @param t Tile to compute height of
  * @return Maximum height of the tile
  */
-static inline int GetTileMaxPixelZ(TileIndex tile)
+template <bool Tgeneric>
+static inline int GetTileMaxPixelZ(typename TileIndexT<Tgeneric>::T tile)
 {
 	return GetTileMaxZ(tile) * TILE_HEIGHT;
 }
+/** @copydoc GetTileMaxPixelZ(TileIndexT<Tgeneric>::T) */
+static inline int GetTileMaxPixelZ(TileIndex tile) { return GetTileMaxPixelZ<false>(tile); }
+/** @copydoc GetTileMaxPixelZ(TileIndexT<Tgeneric>::T) */
+static inline int GetTileMaxPixelZ(GenericTileIndex tile) { return GetTileMaxPixelZ<true>(tile); }
+
+int GetTileMaxPixelZOutsideMap(int x, int y);
 
 
 /**
diff -urNad openttd-1.3.2/src/tile_type.h openttd-1.3.2-DC3.0RC3/src/tile_type.h
--- openttd-1.3.2/src/tile_type.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/tile_type.h	2013-11-22 05:49:07.000000000 +0100
@@ -12,16 +12,22 @@
 #ifndef TILE_TYPE_H
 #define TILE_TYPE_H
 
+#include "map_type.h"
+
 static const uint TILE_SIZE      = 16;            ///< Tiles are 16x16 "units" in size
 static const uint TILE_UNIT_MASK = TILE_SIZE - 1; ///< For masking in/out the inner-tile units.
 static const uint TILE_PIXELS    = 32;            ///< a tile is 32x32 pixels
 static const uint TILE_HEIGHT    =  8;            ///< The standard height-difference between tiles on two levels is 8 (z-diff 8)
 
-static const uint MAX_TILE_HEIGHT     = 15;                    ///< Maximum allowed tile height
+static const uint MAX_TILE_HEIGHT     = 255;                    ///< Maximum allowed tile height
 
-static const uint MIN_SNOWLINE_HEIGHT = 2;                     ///< Minimum snowline height
-static const uint DEF_SNOWLINE_HEIGHT = 7;                     ///< Default snowline height
-static const uint MAX_SNOWLINE_HEIGHT = (MAX_TILE_HEIGHT - 2); ///< Maximum allowed snowline height
+static const uint MIN_MAX_HEIGHTLEVEL = 15;                     ///< Lower bound of maximal allowed heightlevel (in the construction settings)
+static const uint DEF_MAX_HEIGHTLEVEL = 30;                     ///< Default maximal allowed heightlevel (in the construction settings)
+static const uint MAX_MAX_HEIGHTLEVEL = 255;                    ///< Upper bound of maximal allowed heightlevel (in the construction settings)
+
+static const uint MIN_SNOWLINE_HEIGHT = 2;   ///< Minimum snowline height
+static const uint DEF_SNOWLINE_HEIGHT = 24;   ///< Default snowline height
+static const uint MAX_SNOWLINE_HEIGHT = 253;  ///< Maximum allowed snowline height
 
 
 /**
@@ -66,14 +72,91 @@
 	TROPICZONE_RAINFOREST = 2,      ///< Rainforest tile
 };
 
+typedef uint32 RawTileIndex; ///< general purpose tile index, not bounded to any map
+static const RawTileIndex INVALID_TILE_INDEX = (RawTileIndex)-1;
+
 /**
- * The index/ID of a Tile.
+ * The index/ID of a Tile on the main map.
+ *
+ * While this is just another name for RawTileIndex type, it should be used
+ * in context of tiles of the main tile array.
  */
-typedef uint32 TileIndex;
+typedef RawTileIndex TileIndex;
 
 /**
  * The very nice invalid tile marker
  */
 static const TileIndex INVALID_TILE = (TileIndex)-1;
 
+/** The index/ID of a tile bounded to a given map. */
+struct GenericTileIndex {
+	RawTileIndex index; ///< position of the tile in array
+	Map *map;           ///< the map that this index is bounded to
+
+	inline GenericTileIndex() : map(NULL) { }
+	inline GenericTileIndex(const GenericTileIndex &tile) : index(tile.index), map(tile.map) { }
+	inline GenericTileIndex(RawTileIndex index, Map *map) : index(index), map(map) { }
+
+	inline explicit GenericTileIndex(const TileIndex &tile) : index(tile)
+	{
+		extern MainMap _main_map;
+		this->map = &_main_map;
+	}
+
+	inline GenericTileIndex &operator += (TileIndexDiff diff) { return this->index += diff, *this; }
+	inline GenericTileIndex &operator -= (TileIndexDiff diff) { return this->index -= diff, *this; }
+	inline GenericTileIndex operator + (TileIndexDiff diff) const { return GenericTileIndex(this->index + diff, this->map); }
+	inline GenericTileIndex operator - (TileIndexDiff diff) const { return GenericTileIndex(this->index - diff, this->map); }
+
+	inline GenericTileIndex &operator ++ () { return ++this->index, *this; }
+	inline GenericTileIndex &operator -- () { return --this->index, *this; }
+	inline GenericTileIndex operator ++ (int) { return GenericTileIndex(this->index++, this->map); }
+	inline GenericTileIndex operator -- (int) { return GenericTileIndex(this->index--, this->map); }
+
+	inline bool operator == (const GenericTileIndex &tile) const { return this->index == tile.index && this->map == tile.map; }
+	inline bool operator != (const GenericTileIndex &tile) const { return this->index != tile.index || this->map != tile.map; }
+
+	inline bool operator <= (const GenericTileIndex &tile) const
+	{
+		assert(this->map == tile.map);
+		return this->index <= tile.index;
+	}
+
+	inline bool operator >= (const GenericTileIndex &tile) const
+	{
+		assert(this->map == tile.map);
+		return this->index >= tile.index;
+	}
+
+	inline bool operator < (const GenericTileIndex &tile) const
+	{
+		assert(this->map == tile.map);
+		return this->index < tile.index;
+	}
+
+	inline bool operator > (const GenericTileIndex &tile) const
+	{
+		assert(this->map == tile.map);
+		return this->index > tile.index;
+	}
+
+};
+
+/**
+ * Helper class to construct templatized functions operating on different
+ * types of tile indices.
+ */
+template <bool Tgeneric>
+struct TileIndexT;
+
+template <>
+struct TileIndexT<false> {
+	typedef TileIndex T;
+};
+
+template <>
+struct TileIndexT<true> {
+	typedef GenericTileIndex T;
+};
+
 #endif /* TILE_TYPE_H */
diff -urNad openttd-1.3.2/src/timetable_cmd.cpp openttd-1.3.2-DC3.0RC3/src/timetable_cmd.cpp
--- openttd-1.3.2/src/timetable_cmd.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/timetable_cmd.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -16,6 +16,7 @@
 #include "window_func.h"
 #include "vehicle_base.h"
 #include "cmd_helper.h"
+#include "settings_type.h"
 
 #include "table/strings.h"
 
@@ -69,6 +70,7 @@
 				default:
 					NOT_REACHED();
 			}
+			v->MarkSeparationInvalid();
 		}
 		SetWindowDirty(WC_VEHICLE_TIMETABLE, v->index);
 	}
@@ -195,11 +197,16 @@
 	CommandCost ret = CheckOwnership(v->owner);
 	if (ret.Failed()) return ret;
 
+	DateTicks start_date = (Date)p2 / DAY_TICKS_DAY_LENGTH;
+
+#if WALLCLOCK_NETWORK_COMPATIBLE
 	/* Don't let a timetable start more than 15 years into the future or 1 year in the past. */
-	Date start_date = (Date)p2;
 	if (start_date < 0 || start_date > MAX_DAY) return CMD_ERROR;
 	if (start_date - _date > 15 * DAYS_IN_LEAP_YEAR) return CMD_ERROR;
 	if (_date - start_date > DAYS_IN_LEAP_YEAR) return CMD_ERROR;
+#else
+	start_date = ((DateTicks)_date * DAY_TICKS_DAY_LENGTH) + _date_fract + (DateTicks)(int32)p2;
+#endif
 
 	if (flags & DC_EXEC) {
 		v->lateness_counter = 0;
@@ -268,6 +275,33 @@
 }
 
 /**
+ * Set new separation parameters
+ * @param tile  Not used.
+ * @param flags Operation to perform.
+ * @param p1    Order lit id.
+ * @param p2
+ *   - p2 = (bit 0-1)  - Separation mode (@see TTSepMode)
+ *   - p2 = (bit 2-31) - Separation parameter (Unused if #TTS_MODE_OFF | #TTS_MODE_AUTO,
+ *                       Number of vehicles if #TTS_MODE_MAN_N, separation delay in ticks if #TTS_MODE_MAN_T).
+ * @param text  Not used.
+ * @return      The error or cost of the operation.
+ */
+CommandCost CmdReinitSeparation(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
+{
+	Vehicle *v = Vehicle::GetIfValid(GB(p1, 0, 20));
+	if (v == NULL || !v->IsPrimaryVehicle()) return CMD_ERROR;
+
+	CommandCost ret = CheckOwnership(v->owner);
+	if (ret.Failed()) return ret;
+
+	if (flags & DC_EXEC) {
+		v->SetSepSettings((TTSepMode)GB(p2, 0, 3), GB(p2, 3, 28));
+	}
+
+	return CommandCost();
+}
+
+/**
  * Update the timetable for the vehicle.
  * @param v The vehicle to update the timetable for.
  * @param travelling Whether we just travelled or waited at a station.
@@ -290,6 +324,7 @@
 
 	/* This vehicle is arriving at the first destination in the timetable. */
 	if (v->cur_real_order_index == first_manual_order && travelling) {
+		v->trip_history.NewRound();
 		/* If the start date hasn't been set, or it was set automatically when
 		 * the vehicle last arrived at the first destination, update it to the
 		 * current time. Otherwise set the late counter appropriately to when
@@ -297,7 +332,11 @@
 		just_started = !HasBit(v->vehicle_flags, VF_TIMETABLE_STARTED);
 
 		if (v->timetable_start != 0) {
-			v->lateness_counter = (_date - v->timetable_start) * DAY_TICKS + _date_fract;
+#if WALLCLOCK_NETWORK_COMPATIBLE
+			v->lateness_counter = (_date - v->timetable_start) * DAY_TICKS_DAY_LENGTH + _date_fract;
+#else
+			v->lateness_counter = (_date * DAY_TICKS_DAY_LENGTH) + _date_fract - v->timetable_start;
+#endif
 			v->timetable_start = 0;
 		}
 
@@ -327,7 +366,7 @@
 			 * the timetable entry like is done for road vehicles/ships.
 			 * Thus always make sure at least one tick is used between the
 			 * processing of different orders when filling the timetable. */
-			time_taken = CeilDiv(max(time_taken, 1U), DAY_TICKS) * DAY_TICKS;
+			time_taken = CeilDiv(max(time_taken, 1U), DATE_UNIT_SIZE) * DATE_UNIT_SIZE;
 
 			ChangeTimetable(v, v->cur_real_order_index, time_taken, travelling ? MTF_TRAVEL_TIME : MTF_WAIT_TIME);
 		}
diff -urNad openttd-1.3.2/src/timetable_gui.cpp openttd-1.3.2-DC3.0RC3/src/timetable_gui.cpp
--- openttd-1.3.2/src/timetable_gui.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/timetable_gui.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -24,11 +24,24 @@
 #include "date_gui.h"
 #include "vehicle_gui.h"
 #include "settings_type.h"
+#include "viewport_func.h"
 
 #include "widgets/timetable_widget.h"
 
 #include "table/sprites.h"
 #include "table/strings.h"
+#include "widgets/dropdown_func.h"
+
+
+/** Entries for mode selection dropdown list. Order must be identical to the one in #TTSepMode */
+static const StringID TimetableSeparationDropdownOptions[6] = {
+	STR_TTSEPARATION_AUTO,
+	STR_TTSEPARATION_OFF,
+	STR_TTSEPARATION_MAN_TIME,
+	STR_TTSEPARATION_MAN_NUM,
+	STR_TTSEPARATION_BUFFERED_AUTO,
+	INVALID_STRING_ID,
+};
 
 /** Container for the arrival/departure dates of a vehicle */
 struct TimetableArrivalDeparture {
@@ -45,11 +58,14 @@
 void SetTimetableParams(int param1, int param2, Ticks ticks)
 {
 	if (_settings_client.gui.timetable_in_ticks) {
-		SetDParam(param1, STR_TIMETABLE_TICKS);
 		SetDParam(param2, ticks);
+		SetDParam(param1, STR_TIMETABLE_TICKS);
+	} else if (_settings_client.gui.time_in_minutes) {
+		SetDParam(param2, ticks / DATE_UNIT_SIZE);
+		SetDParam(param1, STR_TIMETABLE_MINUTES);
 	} else {
+		SetDParam(param2, ticks / DATE_UNIT_SIZE);
 		SetDParam(param1, STR_TIMETABLE_DAYS);
-		SetDParam(param2, ticks / DAY_TICKS);
 	}
 }
 
@@ -61,8 +77,18 @@
  */
 static void SetArrivalDepartParams(int param1, int param2, Ticks ticks)
 {
-	SetDParam(param1, STR_JUST_DATE_TINY);
-	SetDParam(param2, _date + (ticks / DAY_TICKS));
+	SetDParam(param1, STR_JUST_DATE_WALLCLOCK_TINY);
+	SetDParam(param2, ((DateTicks)_date * DAY_TICKS_DAY_LENGTH) + ticks);
+}
+
+/**
+ * Check whether the order's time can be changed manually.
+ * @param order the order to check
+ * @return true if the order's time can be changed.
+ */
+static bool CanChangeTime(const Order *order)
+{
+	return !(order == NULL || ((!order->IsType(OT_GOTO_STATION) || (order->GetNonStopType() & ONSF_NO_STOP_AT_DESTINATION_STATION)) && !order->IsType(OT_CONDITIONAL)));
 }
 
 /**
@@ -149,20 +175,28 @@
  * @param window the window related to the setting of the date
  * @param date the actually chosen date
  */
-static void ChangeTimetableStartCallback(const Window *w, Date date)
+static void ChangeTimetableStartCallback(const Window *w, DateTicks date)
 {
-	DoCommandP(0, w->window_number, date, CMD_SET_TIMETABLE_START | CMD_MSG(STR_ERROR_CAN_T_TIMETABLE_VEHICLE));
+#if WALLCLOCK_NETWORK_COMPATIBLE
+	DoCommandP(0, w->window_number, (Date)(date / DAY_TICKS_DAY_LENGTH), CMD_SET_TIMETABLE_START | CMD_MSG(STR_ERROR_CAN_T_TIMETABLE_VEHICLE));
+#else
+	DoCommandP(0, w->window_number, (Ticks)(date - (((DateTicks)_date * DAY_TICKS_DAY_LENGTH) + _date_fract)), CMD_SET_TIMETABLE_START | CMD_MSG(STR_ERROR_CAN_T_TIMETABLE_VEHICLE));
+#endif
 }
 
 
 struct TimetableWindow : Window {
 	int sel_index;
-	const Vehicle *vehicle; ///< Vehicle monitored by the window.
-	bool show_expected;     ///< Whether we show expected arrival or scheduled
-	uint deparr_time_width; ///< The width of the departure/arrival time
-	uint deparr_abbr_width; ///< The width of the departure/arrival abbreviation
+       const Vehicle *vehicle;               ///< Vehicle monitored by the window.
+       bool show_expected;                   ///< Whether we show expected arrival or scheduled
+       uint deparr_time_width;               ///< The width of the departure/arrival time
+       uint deparr_abbr_width;               ///< The width of the departure/arrival abbreviation
+	int ctrl_pressed;       // We need this to influence the ShowQueryString result.
+	int clicked_widget;     ///< The widget that was clicked (used to determine what to do in OnQueryTextFinished)
 	Scrollbar *vscroll;
 	bool query_is_speed_query; ///< The currently open query window is a speed query and not a time query.
+       TTSepSettings new_sep_settings;       ///< Contains new separation settings.
+       VehicleTimetableWidgets query_widget; ///< Required to determinate source of input query
 
 	TimetableWindow(const WindowDesc *desc, WindowNumber window_number) :
 			Window(),
@@ -170,6 +204,7 @@
 			vehicle(Vehicle::Get(window_number)),
 			show_expected(true)
 	{
+               this->new_sep_settings = (vehicle->orders.list != NULL) ? vehicle->orders.list->GetSepSettings() : TTSepSettings();
 		this->CreateNestedTree(desc);
 		this->vscroll = this->GetScrollbar(WID_VT_SCROLLBAR);
 		this->UpdateSelectionStates();
@@ -178,6 +213,12 @@
 		this->owner = this->vehicle->owner;
 	}
 
+	~TimetableWindow()
+	{
+		MarkAllRouteStopoversDirty(this->vehicle);
+		FocusWindowById(WC_VEHICLE_VIEW, this->window_number);
+	}
+
 	/**
 	 * Build the arrival-departure list for a given vehicle
 	 * @param v the vehicle to make the list for
@@ -200,8 +241,8 @@
 	{
 		switch (widget) {
 			case WID_VT_ARRIVAL_DEPARTURE_PANEL:
-				SetDParamMaxValue(0, MAX_YEAR * DAYS_IN_YEAR, 0, FS_SMALL);
-				this->deparr_time_width = GetStringBoundingBox(STR_JUST_DATE_TINY).width;
+                               SetDParamMaxValue(0, _settings_client.gui.time_in_minutes ? 0 : MAX_YEAR * DAYS_IN_YEAR);
+                               this->deparr_time_width = GetStringBoundingBox(STR_JUST_DATE_WALLCLOCK_TINY).width + 4;
 				this->deparr_abbr_width = max(GetStringBoundingBox(STR_TIMETABLE_ARRIVAL_ABBREVIATION).width, GetStringBoundingBox(STR_TIMETABLE_DEPARTURE_ABBREVIATION).width);
 				size->width = WD_FRAMERECT_LEFT + this->deparr_abbr_width + 10 + this->deparr_time_width + WD_FRAMERECT_RIGHT;
 				/* FALL THROUGH */
@@ -309,6 +350,7 @@
 		int selected = this->sel_index;
 
 		this->vscroll->SetCount(v->GetNumOrders() * 2);
+		this->new_sep_settings = (vehicle->orders.list != NULL) ? vehicle->orders.list->GetSepSettings() : TTSepSettings();
 
 		if (v->owner == _local_company) {
 			bool disable = true;
@@ -317,7 +359,7 @@
 				if (selected % 2 == 1) {
 					disable = order != NULL && (order->IsType(OT_CONDITIONAL) || order->IsType(OT_IMPLICIT));
 				} else {
-					disable = order == NULL || ((!order->IsType(OT_GOTO_STATION) || (order->GetNonStopType() & ONSF_NO_STOP_AT_DESTINATION_STATION)) && !order->IsType(OT_CONDITIONAL));
+					disable = !CanChangeTime(order);
 				}
 			}
 			bool disable_speed = disable || selected % 2 != 1 || v->type == VEH_AIRCRAFT;
@@ -344,6 +386,20 @@
 
 		this->SetWidgetLoweredState(WID_VT_AUTOFILL, HasBit(v->vehicle_flags, VF_AUTOFILL_TIMETABLE));
 
+		bool b;
+
+		if(this->vehicle->orders.list != NULL) {
+			b = !(_settings_game.order.automatic_timetable_separation && this->vehicle->orders.list->IsCompleteTimetable());
+		} else {
+			b = false;
+		}
+		this->SetWidgetsDisabledState(b, WID_VT_TTSEP_SET_PARAMETER, WID_VT_TTSEP_MODE_DROPDOWN, WIDGET_LIST_END);
+
+		/* We can only set parameters if we're in one of the manual modes. */
+		bool enabled_state = (this->new_sep_settings.mode == TTS_MODE_MAN_N) || (this->new_sep_settings.mode == TTS_MODE_MAN_T);
+
+		this->SetWidgetDisabledState(WID_VT_TTSEP_SET_PARAMETER, !enabled_state);
+
 		this->DrawWidgets();
 	}
 
@@ -352,6 +408,8 @@
 		switch (widget) {
 			case WID_VT_CAPTION: SetDParam(0, this->vehicle->index); break;
 			case WID_VT_EXPECTED: SetDParam(0, this->show_expected ? STR_TIMETABLE_EXPECTED : STR_TIMETABLE_SCHEDULED); break;
+			case WID_VT_TTSEP_MODE_DROPDOWN: SetDParam(0, TimetableSeparationDropdownOptions[this->new_sep_settings.mode]); break;
+			case WID_VT_TTSEP_SET_PARAMETER: SetDParam(0, (this->new_sep_settings.mode == TTS_MODE_MAN_N) ? STR_TTSEPARATION_SET_NUM : STR_TTSEPARATION_SET_TIME); break;
 		}
 	}
 
@@ -430,7 +488,7 @@
 
 				int y = r.top + WD_FRAMERECT_TOP;
 
-				bool show_late = this->show_expected && v->lateness_counter > DAY_TICKS;
+				bool show_late = this->show_expected && v->lateness_counter > DATE_UNIT_SIZE;
 				Ticks offset = show_late ? 0 : -v->lateness_counter;
 
 				bool rtl = _current_text_dir == TD_RTL;
@@ -479,14 +537,18 @@
 				if (v->timetable_start != 0) {
 					/* We are running towards the first station so we can start the
 					 * timetable at the given time. */
-					SetDParam(0, STR_JUST_DATE_TINY);
+					SetDParam(0, STR_JUST_DATE_WALLCLOCK_TINY);
+#if WALLCLOCK_NETWORK_COMPATIBLE
+					SetDParam(1, v->timetable_start * DAY_TICKS_DAY_LENGTH);
+#else
 					SetDParam(1, v->timetable_start);
+#endif
 					DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, y, STR_TIMETABLE_STATUS_START_AT);
 				} else if (!HasBit(v->vehicle_flags, VF_TIMETABLE_STARTED)) {
 					/* We aren't running on a timetable yet, so how can we be "on time"
 					 * when we aren't even "on service"/"on duty"? */
 					DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, y, STR_TIMETABLE_STATUS_NOT_STARTED);
-				} else if (v->lateness_counter == 0 || (!_settings_client.gui.timetable_in_ticks && v->lateness_counter / DAY_TICKS == 0)) {
+				} else if (v->lateness_counter == 0 || (!_settings_client.gui.timetable_in_ticks && v->lateness_counter / DATE_UNIT_SIZE == 0)) {
 					DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, y, STR_TIMETABLE_STATUS_ON_TIME);
 				} else {
 					SetTimetableParams(0, 1, abs(v->lateness_counter));
@@ -494,6 +556,79 @@
 				}
 				break;
 			}
+
+			case WID_VT_TTSEP_PANEL_TEXT: {
+				int       y            = r.top + WD_FRAMERECT_TOP;     // Represents the current vertical position
+				const int left_border  = r.left + WD_FRAMERECT_LEFT;   // Represents the left border of the separation display frame
+				const int right_border = r.right - WD_FRAMERECT_RIGHT; // Represents the right border of the separation display frame.
+
+				/* If separation is inactive, we can stop here. */
+				if (!_settings_game.order.automatic_timetable_separation || (this->vehicle->orders.list == NULL))
+					break;
+
+				/* If the new mode is OFF... */
+				if (this->new_sep_settings.mode == TTS_MODE_OFF) {
+					/* ... skip description lines. */
+					int offset = _settings_client.gui.timetable_in_ticks ? GetStringBoundingBox(STR_TTSEPARATION_REQ_TIME_DESC_TICKS).height
+					 : GetStringBoundingBox(STR_TTSEPARATION_REQ_TIME_DESC_DAYS).height;
+
+					y = y + GetStringBoundingBox(STR_TTSEPARATION_REQ_NUM_DESC).height + offset;
+
+				} else if (this->vehicle->orders.list->IsCompleteTimetable()) {
+					/* If separation hasn't just been switched off, we need to draw various description lines.
+					 * The first line is the amount of separation which is either saved in the stuct or must
+					 * be calculated on the fly.
+					 */
+					uint64 par;
+					if (this->new_sep_settings.mode == TTS_MODE_MAN_T || this->new_sep_settings.mode == TTS_MODE_AUTO) {
+						par = this->new_sep_settings.sep_ticks;
+					} else {
+						par = this->vehicle->orders.list->GetTimetableTotalDuration() / this->new_sep_settings.num_veh;
+					}
+
+					/* Depending on the setting for time displays, set up and draw either tick or days string. */
+					if (_settings_client.gui.timetable_in_ticks) {
+						SetDParam(0, par);
+						DrawString(left_border, right_border, y, STR_TTSEPARATION_REQ_TIME_DESC_TICKS, TC_BLACK);
+						y += GetStringBoundingBox(STR_TTSEPARATION_REQ_TIME_DESC_TICKS).height;
+					} else if (_settings_client.gui.time_in_minutes) {
+						SetDParam(0, par / _settings_client.gui.ticks_per_minute);
+						DrawString(left_border, right_border, y, STR_TTSEPARATION_REQ_TIME_DESC_MINUTES, TC_BLACK);
+						y += GetStringBoundingBox(STR_TTSEPARATION_REQ_TIME_DESC_MINUTES).height;
+					} else {
+						SetDParam(0, par / DAY_TICKS_DAY_LENGTH);
+						DrawString(left_border, right_border, y, STR_TTSEPARATION_REQ_TIME_DESC_DAYS, TC_BLACK);
+						y += GetStringBoundingBox(STR_TTSEPARATION_REQ_TIME_DESC_DAYS).height;
+					}
+
+					/* Print either the chosen amount of vehicles (when in MAN_N mode) or the calculated result... */
+					if (this->new_sep_settings.mode == TTS_MODE_MAN_N || this->new_sep_settings.mode == TTS_MODE_AUTO) {
+						par = this->new_sep_settings.num_veh;
+					} else {
+						par = this->vehicle->orders.list->GetTimetableTotalDuration() / this->new_sep_settings.sep_ticks;
+					}
+
+					SetDParam(0, par);
+					DrawString(left_border, right_border, y, STR_TTSEPARATION_REQ_NUM_DESC, TC_BLACK);
+
+					y += GetStringBoundingBox(STR_TTSEPARATION_REQ_NUM_DESC).height;
+				}
+
+				/* If the timetable isn't completely filled in... */
+				if (!this->vehicle->orders.list->IsCompleteTimetable()) {
+					SetDParam(0, STR_TTSEPARATION_STATUS_INCOMPLETE);
+				/* If separation is switched on at all... */
+				} else if (this->vehicle->orders.list->IsSeparationOn()) {
+					/* ... set displayed status to either "Running" or "Initializing" */
+					SetDParam(0, (this->vehicle->orders.list->IsSeparationValid()) ? STR_TTSEPARATION_STATUS_RUNNING : STR_TTSEPARATION_STATUS_INIT);
+				} else {
+					/* If separation is switched off, show this instead. */
+					SetDParam(0, STR_TTSEPARATION_STATUS_OFF);
+				}
+
+				/* Print status description. */
+				DrawStringMultiLine(left_border, right_border, y, r.bottom - WD_FRAMERECT_BOTTOM, STR_TTSEPARATION_STATUS_DESC);
+			}
 		}
 	}
 
@@ -510,6 +645,9 @@
 	virtual void OnClick(Point pt, int widget, int click_count)
 	{
 		const Vehicle *v = this->vehicle;
+		ctrl_pressed = _ctrl_pressed;
+
+        this->clicked_widget = widget;
 
 		switch (widget) {
 			case WID_VT_ORDER_VIEW: // Order view button
@@ -518,14 +656,24 @@
 
 			case WID_VT_TIMETABLE_PANEL: { // Main panel.
 				int selected = GetOrderFromTimetableWndPt(pt.y, v);
-
 				this->DeleteChildWindows();
 				this->sel_index = (selected == INVALID_ORDER || selected == this->sel_index) ? -1 : selected;
 				break;
 			}
 
 			case WID_VT_START_DATE: // Change the date that the timetable starts.
-				ShowSetDateWindow(this, v->index, _date, _cur_year, _cur_year + 15, ChangeTimetableStartCallback);
+                if (_settings_client.gui.time_in_minutes && _settings_client.gui.timetable_start_text_entry) {
+                    StringID str = STR_JUST_INT;
+                    uint64 time = ((DateTicks)_date * DAY_TICKS_DAY_LENGTH) + _date_fract;
+                    time /= _settings_client.gui.ticks_per_minute;
+                    time += _settings_client.gui.clock_offset;
+                    time %= 24*60;
+                    time = (time % 60) + (((time / 60) % 24) * 100);
+                    SetDParam(0, time);
+                    ShowQueryString(str, STR_TIMETABLE_STARTING_DATE, 31, this, CS_NUMERAL, QSF_ACCEPT_UNCHANGED);
+                } else {
+                    ShowSetDateWindow(this, v->index, ((DateTicks)_date * DAY_TICKS_DAY_LENGTH) + _date_fract, _cur_year, _cur_year + 15, ChangeTimetableStartCallback);
+                }
 				break;
 
 			case WID_VT_CHANGE_TIME: { // "Wait For" button.
@@ -539,7 +687,7 @@
 
 				if (order != NULL) {
 					uint time = (selected % 2 == 1) ? order->travel_time : order->wait_time;
-					if (!_settings_client.gui.timetable_in_ticks) time /= DAY_TICKS;
+					if (!_settings_client.gui.timetable_in_ticks) time /= DATE_UNIT_SIZE;
 
 					if (time != 0) {
 						SetDParam(0, time);
@@ -547,6 +695,7 @@
 					}
 				}
 
+				this->query_widget = WID_VT_CHANGE_TIME;
 				this->query_is_speed_query = false;
 				ShowQueryString(current, STR_TIMETABLE_CHANGE_TIME, 31, this, CS_NUMERAL, QSF_NONE);
 				break;
@@ -603,31 +752,130 @@
 			case WID_VT_SHARED_ORDER_LIST:
 				ShowVehicleListWindow(v);
 				break;
+
+			case WID_VT_TTSEP_MODE_DROPDOWN: {
+				ShowDropDownMenu(this, TimetableSeparationDropdownOptions, this->new_sep_settings.mode, WID_VT_TTSEP_MODE_DROPDOWN, 0, 0);
+				break;
+			}
+
+			case WID_VT_TTSEP_SET_PARAMETER: {
+				this->query_widget = WID_VT_TTSEP_SET_PARAMETER;
+				SetDParam(0, (this->new_sep_settings.mode == TTS_MODE_MAN_N) ? this->new_sep_settings.num_veh : this->new_sep_settings.sep_ticks);
+				ShowQueryString(STR_JUST_INT, STR_TIMETABLE_CHANGE_TIME, 31, this, CS_NUMERAL, QSF_NONE);
+				break;
+			}
 		}
 
 		this->SetDirty();
 	}
 
-	virtual void OnQueryTextFinished(char *str)
+	virtual void OnDropdownSelect(int widget, int index)
 	{
-		if (str == NULL) return;
+		assert(widget == WID_VT_TTSEP_MODE_DROPDOWN);
 
-		const Vehicle *v = this->vehicle;
+		this->new_sep_settings = this->vehicle->orders.list->GetSepSettings();
+		this->new_sep_settings.mode = (TTSepMode)index;
+		this->vehicle->orders.list->SetSepSettings(this->new_sep_settings);
+		this->InvalidateData();
+	}
 
-		uint32 p1 = PackTimetableArgs(v, this->sel_index, this->query_is_speed_query);
+	virtual void OnQueryTextFinished(char *str)
+	{
+		if(str == NULL || StrEmpty(str))
+			return;
+
+		switch(this->query_widget) {
+		case WID_VT_CHANGE_TIME: {
+			const Vehicle *v = this->vehicle;
 
 		uint64 val = StrEmpty(str) ? 0 : strtoul(str, NULL, 10);
-		if (this->query_is_speed_query) {
-			val = ConvertDisplaySpeedToKmhishSpeed(val);
-		} else {
-			if (!_settings_client.gui.timetable_in_ticks) val *= DAY_TICKS;
-		}
 
-		uint32 p2 = minu(val, UINT16_MAX);
+        switch (this->clicked_widget) {
+            default: NOT_REACHED();
 
-		DoCommandP(0, p1, p2, CMD_CHANGE_TIMETABLE | CMD_MSG(STR_ERROR_CAN_T_TIMETABLE_VEHICLE));
+            case WID_VT_CHANGE_SPEED:
+            case WID_VT_CHANGE_TIME: {
+                uint32 p1 = PackTimetableArgs(v, this->sel_index, this->query_is_speed_query);
+
+                uint64 val = StrEmpty(str) ? 0 : strtoul(str, NULL, 10);
+                if (this->query_is_speed_query) {
+                    val = ConvertDisplaySpeedToKmhishSpeed(val);
+                } else {
+                    if (!_settings_client.gui.timetable_in_ticks) val *= DATE_UNIT_SIZE;
+                }
+
+                uint32 p2 = minu(val, UINT16_MAX);
+
+               if (! ctrl_pressed) {
+                       /* Do a normal update. */
+                       uint32 p1 = PackTimetableArgs(v, this->sel_index, this->query_is_speed_query);
+                       DoCommandP(0, p1, p2, CMD_CHANGE_TIMETABLE | CMD_MSG(STR_ERROR_CAN_T_TIMETABLE_VEHICLE));
+               } else {
+                       /* Update all valid stations. */
+                       for (int i = 0, num_orders=v->GetNumOrders(); i < num_orders; ++i) {
+                               const Order *order = v->GetOrder(i);
+
+                               if (CanChangeTime(order)) {
+                                       uint32 p1 = PackTimetableArgs(v, i*2, this->query_is_speed_query);
+                                       DoCommandP(0, p1, p2, CMD_CHANGE_TIMETABLE | CMD_MSG(STR_ERROR_CAN_T_TIMETABLE_VEHICLE));
+                               }
+                       }
+               }
+                       break;
+                }
+
+
+            case WID_VT_START_DATE: {
+                if (val > 0) {
+                    uint minutes = (val % 100) % 60;
+                    uint hours = (val / 100) % 24;
+                    val = MINUTES_DATE(MINUTES_DAY(CURRENT_MINUTE), hours, minutes);
+                    val -= _settings_client.gui.clock_offset;
+
+                    if (val < (CURRENT_MINUTE - 60)) val += 60 * 24;
+                    val *= DATE_UNIT_SIZE;
+                    ChangeTimetableStartCallback(this, val);
+                }
+                break;
+            }
+        }
+                break;
+            }
+               case WID_VT_TTSEP_SET_PARAMETER: {
+                       int value = atoi(str);
+
+                       switch (this->new_sep_settings.mode)
+                       {
+                               case TTS_MODE_AUTO:
+                               case TTS_MODE_BUFFERED_AUTO:
+                               case TTS_MODE_OFF:
+                                       break;
+
+                               case TTS_MODE_MAN_N:
+                                       this->new_sep_settings.num_veh = Clamp(value, 1, 65535);
+                                       break;
+
+                               case TTS_MODE_MAN_T:
+                                       this->new_sep_settings.sep_ticks = Clamp(value, 1, 65535);
+                                       break;
+
+                               default:
+                                       NOT_REACHED();
+                                       break;
+                       }
+                       this->vehicle->orders.list->SetSepSettings(this->new_sep_settings);
+                       this->InvalidateData();
+                       break;
+               }
+                default:
+                        NOT_REACHED();
+                        break;
+                }
 	}
 
+//		 DoCommandP(0, p1, p2, CMD_CHANGE_TIMETABLE | CMD_MSG(STR_ERROR_CAN_T_TIMETABLE_VEHICLE));
+//	}
+
 	virtual void OnResize()
 	{
 		/* Update the scroll bar */
@@ -642,6 +890,23 @@
 		this->GetWidget<NWidgetStacked>(WID_VT_ARRIVAL_DEPARTURE_SELECTION)->SetDisplayedPlane(_settings_client.gui.timetable_arrival_departure ? 0 : SZSP_NONE);
 		this->GetWidget<NWidgetStacked>(WID_VT_EXPECTED_SELECTION)->SetDisplayedPlane(_settings_client.gui.timetable_arrival_departure ? 0 : 1);
 	}
+
+	virtual void OnFocus()
+	{
+		MarkAllRoutePathsDirty(this->vehicle);
+		MarkAllRouteStopoversDirty(this->vehicle);
+	}
+
+	virtual void OnFocusLost()
+	{
+		MarkAllRoutePathsDirty(this->vehicle);
+		MarkAllRouteStopoversDirty(this->vehicle);
+	}
+
+	const Vehicle *GetVehicle()
+	{
+		return this->vehicle;
+	}
 };
 
 static const NWidgetPart _nested_timetable_widgets[] = {
@@ -658,6 +923,13 @@
 			NWidget(WWT_PANEL, COLOUR_GREY, WID_VT_ARRIVAL_DEPARTURE_PANEL), SetMinimalSize(110, 0), SetFill(0, 1), SetDataTip(STR_NULL, STR_TIMETABLE_TOOLTIP), SetScrollbar(WID_VT_SCROLLBAR), EndContainer(),
 		EndContainer(),
 		NWidget(NWID_VSCROLLBAR, COLOUR_GREY, WID_VT_SCROLLBAR),
+		NWidget(WWT_PANEL, COLOUR_GREY),
+			NWidget(WWT_FRAME, COLOUR_GREY), SetDataTip(STR_TTSEPARATION_SETTINGS_DESC, STR_NULL), SetPadding(3),
+				NWidget(WWT_DROPDOWN, COLOUR_GREY, WID_VT_TTSEP_MODE_DROPDOWN), SetDataTip(STR_JUST_STRING, STR_TIMETABLE_TOOLTIP),
+				NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_VT_TTSEP_SET_PARAMETER), SetFill(1, 0), SetDataTip(STR_TTSEPARATION_SET_XX, STR_TIMETABLE_TOOLTIP),
+				NWidget(WWT_PANEL,COLOUR_GREY, WID_VT_TTSEP_PANEL_TEXT), SetFill(1,1), SetResize(0,1), SetMinimalSize(0,44), EndContainer(),
+			EndContainer(),
+		EndContainer(),
 	EndContainer(),
 	NWidget(WWT_PANEL, COLOUR_GREY, WID_VT_SUMMARY_PANEL), SetMinimalSize(400, 22), SetResize(1, 0), EndContainer(),
 	NWidget(NWID_HORIZONTAL),
diff -urNad openttd-1.3.2/src/timetable.h openttd-1.3.2-DC3.0RC3/src/timetable.h
--- openttd-1.3.2/src/timetable.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/timetable.h	2013-11-22 05:49:07.000000000 +0100
@@ -15,6 +15,8 @@
 #include "date_type.h"
 #include "vehicle_type.h"
 
+#define WALLCLOCK_NETWORK_COMPATIBLE 0 ///< Whether wallclock should preserve network compatibility. If so, then timetable start dates cannot be set exactly using minutes.
+
 void ShowTimetableWindow(const Vehicle *v);
 void UpdateVehicleTimetable(Vehicle *v, bool travelling);
 void SetTimetableParams(int param1, int param2, Ticks ticks);
diff -urNad openttd-1.3.2/src/toolbar_gui.cpp openttd-1.3.2-DC3.0RC3/src/toolbar_gui.cpp
--- openttd-1.3.2/src/toolbar_gui.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/toolbar_gui.cpp	2013-11-22 06:03:25.000000000 +0100
@@ -40,6 +40,7 @@
 #include "textbuf_gui.h"
 #include "newgrf_debug.h"
 #include "hotkeys.h"
+#include "watch_gui.h"
 #include "engine_base.h"
 #include "highscore.h"
 
@@ -258,6 +259,7 @@
 	OME_SHOW_SIGNS,
 	OME_SHOW_COMPETITOR_SIGNS,
 	OME_FULL_ANIMATION,
+	OME_RAIL_FENCES,
 	OME_FULL_DETAILS,
 	OME_TRANSPARENTBUILDINGS,
 	OME_SHOW_STATIONSIGNS,
@@ -287,6 +289,7 @@
 	list->push_back(new DropDownListCheckedItem(STR_SETTINGS_MENU_SIGNS_DISPLAYED,         OME_SHOW_SIGNS, false, HasBit(_display_opt, DO_SHOW_SIGNS)));
 	list->push_back(new DropDownListCheckedItem(STR_SETTINGS_MENU_SHOW_COMPETITOR_SIGNS,   OME_SHOW_COMPETITOR_SIGNS, false, HasBit(_display_opt, DO_SHOW_COMPETITOR_SIGNS)));
 	list->push_back(new DropDownListCheckedItem(STR_SETTINGS_MENU_FULL_ANIMATION,          OME_FULL_ANIMATION, false, HasBit(_display_opt, DO_FULL_ANIMATION)));
+	list->push_back(new DropDownListCheckedItem(STR_SETTINGS_MENU_RAIL_FENCES,             OME_RAIL_FENCES, false, HasBit(_display_opt, DO_RAIL_FENCES)));
 	list->push_back(new DropDownListCheckedItem(STR_SETTINGS_MENU_FULL_DETAIL,             OME_FULL_DETAILS, false, HasBit(_display_opt, DO_FULL_DETAIL)));
 	list->push_back(new DropDownListCheckedItem(STR_SETTINGS_MENU_TRANSPARENT_BUILDINGS,   OME_TRANSPARENTBUILDINGS, false, IsTransparencySet(TO_HOUSES)));
 	list->push_back(new DropDownListCheckedItem(STR_SETTINGS_MENU_TRANSPARENT_SIGNS,       OME_SHOW_STATIONSIGNS, false, IsTransparencySet(TO_SIGNS)));
@@ -320,6 +323,7 @@
 			InvalidateWindowClassesData(WC_SIGN_LIST, -1);
 			break;
 		case OME_FULL_ANIMATION:       ToggleBit(_display_opt, DO_FULL_ANIMATION);      break;
+		case OME_RAIL_FENCES:          ToggleBit(_display_opt, DO_RAIL_FENCES);         break;
 		case OME_FULL_DETAILS:         ToggleBit(_display_opt, DO_FULL_DETAIL);         break;
 		case OME_TRANSPARENTBUILDINGS: ToggleTransparency(TO_HOUSES);                   break;
 		case OME_SHOW_STATIONSIGNS:    ToggleTransparency(TO_SIGNS);                    break;
@@ -410,9 +414,10 @@
 	MME_SHOW_SMALLMAP        = 0,
 	MME_SHOW_EXTRAVIEWPORTS,
 	MME_SHOW_SIGNLISTS,
+	MME_WATCH_COMPANY,
 	MME_SHOW_TOWNDIRECTORY,    ///< This entry is only used in Editor mode
-	MME_MENUCOUNT_NORMAL     = 3,
-	MME_MENUCOUNT_EDITOR     = 4,
+	MME_MENUCOUNT_NORMAL     = 4,
+	MME_MENUCOUNT_EDITOR     = 5,
 };
 
 static CallBackFunction ToolbarMapClick(Window *w)
@@ -440,6 +445,7 @@
 		case MME_SHOW_EXTRAVIEWPORTS: ShowExtraViewPortWindow(); break;
 		case MME_SHOW_SIGNLISTS:      ShowSignList();            break;
 		case MME_SHOW_TOWNDIRECTORY:  if (_game_mode == GM_EDITOR) ShowTownDirectory(); break;
+		case MME_WATCH_COMPANY:       ShowWatchWindow( INVALID_COMPANY );
 	}
 	return CBF_NONE;
 }
@@ -874,7 +880,7 @@
 
 static CallBackFunction ToolbarForestClick(Window *w)
 {
-	PopupMainToolbMenu(w, WID_TN_LANDSCAPE, STR_LANDSCAPING_MENU_LANDSCAPING, 3);
+	PopupMainToolbMenu(w, WID_TN_LANDSCAPE, STR_LANDSCAPING_MENU_LANDSCAPING, 4);
 	return CBF_NONE;
 }
 
@@ -888,8 +894,9 @@
 {
 	switch (index) {
 		case 0: ShowTerraformToolbar();  break;
-		case 1: ShowBuildTreesToolbar(); break;
-		case 2: return SelectSignTool();
+		case 1: ShowClipboardToolbar();  break;
+		case 2: ShowBuildTreesToolbar(); break;
+		case 3: return SelectSignTool();
 	}
 	return CBF_NONE;
 }
diff -urNad openttd-1.3.2/src/town_cmd.cpp openttd-1.3.2-DC3.0RC3/src/town_cmd.cpp
--- openttd-1.3.2/src/town_cmd.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/town_cmd.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -137,17 +137,36 @@
 }
 
 /**
- * Return a random valid town.
- * @return random town, NULL if there are no towns
+ * Return a random town that statisfies some criteria specified
+ * with a callback function.
+ *
+ * @param enum_proc Callback function. Return true for a matching town and false to continue iterating.
+ * @param skip Skip over this town id when searching.
+ * @param data Optional data passed to the callback function.
+ * @return A town satisfying the search criteria or NULL if no such town exists.
  */
-/* static */ Town *Town::GetRandom()
+/* static */ Town *Town::GetRandom(EnumTownProc enum_proc, TownID skip, void *data)
 {
-	if (Town::GetNumItems() == 0) return NULL;
-	int num = RandomRange((uint16)Town::GetNumItems());
-	size_t index = MAX_UVALUE(size_t);
+	assert(skip == INVALID_TOWN || Town::IsValidID(skip));
 
-	while (num >= 0) {
-		num--;
+	uint16 max_num = 0;
+	if (enum_proc != NULL) {
+		/* A callback was given, count all matching towns. */
+		Town *t;
+		FOR_ALL_TOWNS(t) {
+			if (t->index != skip && enum_proc(t, data)) max_num++;
+		}
+	} else {
+		max_num = (uint16)Town::GetNumItems();
+		/* Subtract one if a town to skip was given. max_num is at least
+		 * one here as otherwise skip could not be valid. */
+		if (skip != INVALID_TOWN) max_num--;
+	}
+	if (max_num == 0) return NULL;
+
+	uint num = RandomRange(max_num) + 1;
+	size_t index = MAX_UVALUE(size_t);
+	do {
 		index++;
 
 		/* Make sure we have a valid town */
@@ -155,12 +174,34 @@
 			index++;
 			assert(index < Town::GetPoolSize());
 		}
-	}
+
+		if (index != skip && (enum_proc == NULL || enum_proc(Town::Get(index), data))) num--;
+	} while (num > 0);
 
 	return Town::Get(index);
 }
 
 /**
+ * Updates the town label of the town after changes in rating. The colour scheme is:
+ * Red: Appalling and Very poor ratings.
+ * Orange: Poor and mediocre ratings.
+ * Yellow: Good rating.
+ * White: Very good rating (standard).
+ * Green: Excellent and outstanding ratings.
+ */
+void Town::UpdateLabel()
+{
+	if (!(_game_mode == GM_EDITOR) && (_local_company < MAX_COMPANIES)) {
+		int r = this->ratings[_local_company];
+		(this->town_label = 0, r <= RATING_VERYPOOR)  || // Appalling and Very Poor
+		(this->town_label++,   r <= RATING_MEDIOCRE)  || // Poor and Mediocre
+		(this->town_label++,   r <= RATING_GOOD)      || // Good
+		(this->town_label++,   r <= RATING_VERYGOOD)  || // Very Good
+		(this->town_label++,   true);                    // Excellent and Outstanding
+	}
+}
+
+/**
  * Get the cost for removing this house
  * @return the cost (inflation corrected etc)
  */
@@ -228,6 +269,8 @@
 
 	if (ti->tileh != SLOPE_FLAT) DrawFoundation(ti, FOUNDATION_LEVELED);
 
+	DrawOverlay(ti, MP_HOUSE);
+
 	DrawGroundSprite(dcts->ground.sprite, dcts->ground.pal);
 
 	/* If houses are invisible, do not draw the upper part */
@@ -353,11 +396,11 @@
  */
 void Town::UpdateVirtCoord()
 {
+	this->UpdateLabel();
 	Point pt = RemapCoords2(TileX(this->xy) * TILE_SIZE, TileY(this->xy) * TILE_SIZE);
 	SetDParam(0, this->index);
 	SetDParam(1, this->cache.population);
-	this->cache.sign.UpdatePosition(pt.x, pt.y - 24 * ZOOM_LVL_BASE,
-		_settings_client.gui.population_in_label ? STR_VIEWPORT_TOWN_POP : STR_VIEWPORT_TOWN);
+	this->cache.sign.UpdatePosition(pt.x, pt.y - 24 * ZOOM_LVL_BASE, this->Label());
 
 	SetWindowDirty(WC_TOWN_VIEW, this->index);
 }
@@ -437,6 +480,61 @@
 }
 
 /**
+ * Generate cargo for a town (house).
+ *
+ * The amount of cargo should be and will be greater than zero.
+ *
+ * @param t current town
+ * @param ct type of cargo to generate, usually CT_PASSENGERS or CT_MAIL
+ * @param amount how many units of cargo
+ * @param stations available stations for this house
+ */
+static void TownGenerateCargo (Town *t, CargoID ct, uint amount, StationFinder &stations, TileIndex tile)
+{
+	// custom cargo generation factor
+	int cf = _settings_game.economy.town_cargo_factor;
+
+	// when the economy flunctuates, everyone wants to stay at home
+	if (EconomyIsInRecession()) {
+		amount = (amount + 1) >> 1; 
+	}
+	
+	// apply custom factor?
+	if (cf < 0) {
+		// approx (amount / 2^cf)
+		// adjust with a constant offset of {(2 ^ cf) - 1} (i.e. add cf * 1-bits) before dividing to ensure that it doesn't become zero
+		// this skews the curve a little so that isn't entirely exponential, but will still decrease
+		amount = (amount + ((1 << -cf) - 1)) >> -cf;
+	}
+
+	else if (cf > 0) {
+		// approx (amount * 2^cf)
+		// XXX: overflow?
+		amount = amount << cf;
+	}
+	
+	// with the adjustments above, this should never happen
+	assert(amount > 0);
+	
+	// calculate for town stats
+	const CargoSpec *cs = CargoSpec::Get(ct);
+	switch (cs->town_effect) {
+		case TE_PASSENGERS:
+			t->supplied[CT_PASSENGERS].new_max += amount;
+			t->supplied[CT_PASSENGERS].new_act += MoveGoodsToStation(CT_PASSENGERS, amount, ST_TOWN, t->index, stations.GetStations(), tile);
+			break;
+
+		case TE_MAIL:
+			t->supplied[CT_MAIL].new_max += amount;
+			t->supplied[CT_MAIL].new_act += MoveGoodsToStation(CT_MAIL, amount, ST_TOWN, t->index, stations.GetStations(), tile);
+			break;
+
+		default:
+			break;
+	}
+}
+
+/**
  * Tile callback function.
  *
  * Periodic tic handler for houses and town
@@ -483,27 +581,31 @@
 			uint amt = GB(callback, 0, 8);
 			if (amt == 0) continue;
 
-			uint moved = MoveGoodsToStation(cargo, amt, ST_TOWN, t->index, stations.GetStations());
+//			uint moved = MoveGoodsToStation(cargo, amt, ST_TOWN, t->index, stations.GetStations(), tile);
 
-			const CargoSpec *cs = CargoSpec::Get(cargo);
-			t->supplied[cs->Index()].new_max += amt;
-			t->supplied[cs->Index()].new_act += moved;
+//			const CargoSpec *cs = CargoSpec::Get(cargo);
+//			t->supplied[cs->Index()].new_max += amt;
+//			t->supplied[cs->Index()].new_act += moved;
+                       // XXX: no economy flunctuation for GRF cargos?
+                       TownGenerateCargo(t, cargo, amt, stations, tile);
 		}
 	} else {
 		if (GB(r, 0, 8) < hs->population) {
 			uint amt = GB(r, 0, 8) / 8 + 1;
 
-			if (EconomyIsInRecession()) amt = (amt + 1) >> 1;
-			t->supplied[CT_PASSENGERS].new_max += amt;
-			t->supplied[CT_PASSENGERS].new_act += MoveGoodsToStation(CT_PASSENGERS, amt, ST_TOWN, t->index, stations.GetStations());
+//			if (EconomyIsInRecession()) amt = (amt + 1) >> 1;
+//			t->supplied[CT_PASSENGERS].new_max += amt;
+//			t->supplied[CT_PASSENGERS].new_act += MoveGoodsToStation(CT_PASSENGERS, amt, ST_TOWN, t->index, stations.GetStations(), tile);
+                       TownGenerateCargo(t, CT_PASSENGERS, amt, stations, tile);
 		}
 
 		if (GB(r, 8, 8) < hs->mail_generation) {
 			uint amt = GB(r, 8, 8) / 8 + 1;
 
-			if (EconomyIsInRecession()) amt = (amt + 1) >> 1;
-			t->supplied[CT_MAIL].new_max += amt;
-			t->supplied[CT_MAIL].new_act += MoveGoodsToStation(CT_MAIL, amt, ST_TOWN, t->index, stations.GetStations());
+//			if (EconomyIsInRecession()) amt = (amt + 1) >> 1;
+//			t->supplied[CT_MAIL].new_max += amt;
+//			t->supplied[CT_MAIL].new_act += MoveGoodsToStation(CT_MAIL, amt, ST_TOWN, t->index, stations.GetStations(), tile);
+                       TownGenerateCargo(t, CT_MAIL, amt, stations, tile);
 		}
 	}
 
@@ -680,17 +782,33 @@
 void UpdateTownCargoTotal(Town *t)
 {
 	t->cargo_accepted_total = 0;
+	MemSetT(t->cargo_accepted_weights, 0, lengthof(t->cargo_accepted_weights));
 
+	/* Calculate the maximum weight based on the grid square furthest
+	 * from the town centre. The maximum weight is two times the L-inf
+	 * norm plus 1 so that max weight - furthest square weight == 1. */
 	const TileArea &area = t->cargo_accepted.GetArea();
+	uint max_dist = max(DistanceMax(t->xy_aligned, area.tile), DistanceMax(t->xy_aligned, TILE_ADDXY(area.tile, area.w - 1, area.h - 1))) / AcceptanceMatrix::GRID;
+	t->cargo_accepted_max_weight = max_dist * 2 + 1;
+
+	/* Collect acceptance from all grid squares. */
 	TILE_AREA_LOOP(tile, area) {
 		if (TileX(tile) % AcceptanceMatrix::GRID == 0 && TileY(tile) % AcceptanceMatrix::GRID == 0) {
-			t->cargo_accepted_total |= t->cargo_accepted[tile];
+			uint32 acc = t->cargo_accepted[tile];
+			t->cargo_accepted_total |= acc;
+
+			CargoID cid;
+			FOR_EACH_SET_CARGO_ID(cid, acc) {
+				/* For each accepted cargo, the grid square weight is the maximum weight
+				 * minus two times the L-inf norm between this square and the centre square. */
+				t->cargo_accepted_weights[cid] += t->cargo_accepted_max_weight - (DistanceMax(t->xy_aligned, tile) / AcceptanceMatrix::GRID) * 2;
+			}
 		}
 	}
 }
 
 /**
- * Update accepted town cargoes around a specific tile.
+ * Update accepted and produced town cargoes around a specific tile.
  * @param t The town to update.
  * @param start Update the values around this tile.
  * @param update_total Set to true if the total cargo acceptance should be updated.
@@ -700,7 +818,7 @@
 	CargoArray accepted, produced;
 	uint32 dummy;
 
-	/* Gather acceptance for all houses in an area around the start tile.
+	/* Gather acceptance and production for all houses in an area around the start tile.
 	 * The area is composed of the square the tile is in, extended one square in all
 	 * directions as the coverage area of a single station is bigger than just one square. */
 	TileArea area = AcceptanceMatrix::GetAreaForTile(start, 1);
@@ -763,6 +881,11 @@
 		if (i < 0) {
 			if (GrowTown(t)) {
 				i = t->growth_rate & (~TOWN_GROW_RATE_CUSTOM);
+                               /* If we want same speed of town growth per game year */
+                               if (_settings_game.economy.slow_down_town_growth) {
+                                       i *= _settings_game.economy.day_length_factor;
+                               }
+
 			} else {
 				i = 0;
 			}
@@ -1537,6 +1660,11 @@
 
 	t->larger_town = city;
 
+	/* Cache the aligned tile index of the centre tile. */
+	uint town_x = (TileX(t->xy) / AcceptanceMatrix::GRID) * AcceptanceMatrix::GRID;
+	uint town_y = (TileY(t->xy) / AcceptanceMatrix::GRID) * AcceptanceMatrix::GRID;
+	t->xy_aligned= TileXY(town_x, town_y);
+
 	int x = (int)size * 16 + 3;
 	if (size == TSZ_RANDOM) x = (Random() & 0xF) + 8;
 	/* Don't create huge cities when founding town in-game */
@@ -2184,7 +2312,18 @@
 
 	/* Above snow? */
 	int land = _settings_game.game_creation.landscape;
-	if (land == LT_ARCTIC && maxz > HighestSnowLine()) land = -1;
+       switch (land) {
+       case LT_ARCTIC:
+               if (maxz >= HighestSnowLine()) land = -1;
+               break;
+       case LT_TEMPERATE:
+               if (_settings_game.construction.snow_in_temperate && maxz >= HighestSnowLine()) land = -1;
+               break;
+       default:
+               break;
+       };
+
+
 
 	uint bitmask = (1 << rad) + (1 << (land + 12));
 
@@ -2425,6 +2564,8 @@
 
 		t->UpdateVirtCoord();
 		InvalidateWindowData(WC_TOWN_DIRECTORY, 0, 1);
+		InvalidateWindowClassesData(WC_TOWN_VIEW);
+		InvalidateWindowClassesData(WC_INDUSTRY_VIEW);
 		UpdateAllStationVirtCoords();
 	}
 	return CommandCost();
@@ -2547,6 +2688,10 @@
 	Town *t = Town::GetIfValid(p1);
 	if (t == NULL) return CMD_ERROR;
 
+//	if (_settings_game.economy.day_length_balance_type == DBT_ALL_COSTS) {
+//		cost.AffectCost( _settings_game.economy.day_length_balance_factor );
+//	}
+
 	if (flags & DC_EXEC) {
 		/* The more houses, the faster we grow */
 		if (p2 == 0) {
@@ -2872,6 +3017,7 @@
 			 */
 			if (t->ratings[_current_company] > RATING_BRIBE_DOWN_TO) {
 				t->ratings[_current_company] = RATING_BRIBE_DOWN_TO;
+				t->UpdateVirtCoord();
 				SetWindowDirty(WC_TOWN_AUTHORITY, t->index);
 			}
 		} else {
@@ -3004,6 +3150,7 @@
 		t->ratings[i] = Clamp(t->ratings[i], RATING_MINIMUM, RATING_MAXIMUM);
 	}
 
+	t->UpdateVirtCoord();
 	SetWindowDirty(WC_TOWN_AUTHORITY, t->index);
 }
 
@@ -3257,6 +3404,7 @@
 	} else {
 		SetBit(t->have_ratings, _current_company);
 		t->ratings[_current_company] = rating;
+		t->UpdateVirtCoord();
 		SetWindowDirty(WC_TOWN_AUTHORITY, t->index);
 	}
 }
@@ -3372,6 +3520,7 @@
 	NULL,                    // vehicle_enter_tile_proc
 	GetFoundation_Town,      // get_foundation_proc
 	TerraformTile_Town,      // terraform_tile_proc
+	NULL,                    // copypaste_tile_proc
 };
 
 
diff -urNad openttd-1.3.2/src/town_gui.cpp openttd-1.3.2-DC3.0RC3/src/town_gui.cpp
--- openttd-1.3.2/src/town_gui.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/town_gui.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -31,6 +31,7 @@
 #include "townname_func.h"
 #include "core/geometry_func.hpp"
 #include "genworld.h"
+#include "cargodest_gui.h"
 
 #include "widgets/town_widget.h"
 
@@ -297,10 +298,13 @@
 private:
 	Town *town; ///< Town displayed by the window.
 
+	CargoDestinationList dest_list; ///< Sorted list of demand destinations.
+	uint dest_list_top; ///< Top coordinate of the destination list in the #WID_TV_INFOPANEL widget.
+
 public:
 	static const int WID_TV_HEIGHT_NORMAL = 150;
 
-	TownViewWindow(const WindowDesc *desc, WindowNumber window_number) : Window()
+	TownViewWindow(const WindowDesc *desc, WindowNumber window_number) : Window(), dest_list(Town::Get(window_number))
 	{
 		this->CreateNestedTree(desc);
 
@@ -400,6 +404,8 @@
 			DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_LEFT, y += FONT_HEIGHT_NORMAL, STR_TOWN_VIEW_NOISE_IN_TOWN);
 		}
 
+		y = this->dest_list.DrawList(r.left, r.right, y);
+
 		if (this->town->text != NULL) {
 			SetDParamStr(0, this->town->text);
 			DrawStringMultiLine(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_LEFT, y += FONT_HEIGHT_NORMAL, UINT16_MAX, STR_JUST_RAW_STRING, TC_BLACK);
@@ -442,6 +448,10 @@
 			case WID_TV_DELETE: // delete town - only available on Scenario editor
 				DoCommandP(0, this->window_number, 0, CMD_DELETE_TOWN | CMD_MSG(STR_ERROR_TOWN_CAN_T_DELETE));
 				break;
+
+			case WID_TV_INFO: // jump to demand destination
+				this->dest_list.OnClick(pt.y - this->dest_list_top - this->GetWidget<NWidgetBase>(widget)->pos_y);
+				break;
 		}
 	}
 
@@ -458,7 +468,7 @@
 	 * Gets the desired height for the information panel.
 	 * @return the desired height in pixels.
 	 */
-	uint GetDesiredInfoHeight(int width) const
+	uint GetDesiredInfoHeight(int width)
 	{
 		uint aimed_height = 3 * FONT_HEIGHT_NORMAL + WD_FRAMERECT_TOP + WD_FRAMERECT_BOTTOM;
 
@@ -478,6 +488,9 @@
 
 		if (_settings_game.economy.station_noise_level) aimed_height += FONT_HEIGHT_NORMAL;
 
+		this->dest_list_top = aimed_height - FONT_HEIGHT_NORMAL;
+		aimed_height += this->dest_list.GetListHeight();
+
 		if (this->town->text != NULL) {
 			SetDParamStr(0, this->town->text);
 			aimed_height += GetStringHeight(STR_JUST_RAW_STRING, width);
@@ -516,6 +529,13 @@
 		/* Called when setting station noise or required cargoes have changed, in order to resize the window */
 		this->SetDirty(); // refresh display for current size. This will allow to avoid glitches when downgrading
 		this->ResizeWindowAsNeeded();
+
+		/* Rebuild destination list if data is not zero, otherwise just resort. */
+		if (data != 0) {
+			this->dest_list.InvalidateData();
+		} else {
+			this->dest_list.Resort();
+		}
 	}
 
 	virtual void OnQueryTextFinished(char *str)
diff -urNad openttd-1.3.2/src/town.h openttd-1.3.2-DC3.0RC3/src/town.h
--- openttd-1.3.2/src/town.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/town.h	2013-11-22 05:49:07.000000000 +0100
@@ -15,9 +15,13 @@
 #include "viewport_type.h"
 #include "town_map.h"
 #include "subsidy_type.h"
+#include "openttd.h"
+#include "table/strings.h"
+#include "company_func.h"
 #include "newgrf_storage.h"
 #include "cargotype.h"
 #include "tilematrix_type.hpp"
+#include "cargodest_base.h"
 #include <list>
 
 template <typename T>
@@ -51,8 +55,9 @@
 };
 
 /** Town data structure. */
-struct Town : TownPool::PoolItem<&_town_pool> {
+struct Town : TownPool::PoolItem<&_town_pool>, CargoSourceSink {
 	TileIndex xy;                  ///< town center tile
+	TileIndex xy_aligned; ///< NOSAVE: Town centre aligned to the #AcceptanceMatrix grid.
 
 	TownCache cache; ///< Container for all cacheable data.
 
@@ -78,6 +83,7 @@
 	CompanyByte exclusivity;       ///< which company has exclusivity
 	uint8 exclusive_counter;       ///< months till the exclusivity expires
 	int16 ratings[MAX_COMPANIES];  ///< ratings of each company for this town
+	StringID town_label;           ///< Label dependent on _local_company rating.
 
 	TransportedCargoStat<uint32> supplied[NUM_CARGO]; ///< Cargo statistics about supplied cargo.
 	TransportedCargoStat<uint16> received[NUM_TE];    ///< Cargo statistics about received cargotypes.
@@ -105,6 +111,34 @@
 
 	std::list<PersistentStorage *> psa_list;
 
+	/* Current cargo acceptance and production. */
+	uint32 cargo_accepted_weights[NUM_CARGO]; ///< NOSAVE: Weight sum of accepting squares per cargo.
+	uint32 cargo_accepted_max_weight; ///< NOSAVE: Cached maximum weight for an accepting square.
+
+	void UpdateLabel();
+
+	/**
+	 * Returns the correct town label, based on rating.
+	 */
+	inline StringID Label() const{
+		if (!(_game_mode == GM_EDITOR) && (_local_company < MAX_COMPANIES)) {
+			return STR_VIEWPORT_TOWN_POP_VERY_POOR_RATING + this->town_label;
+		} else {
+			return _settings_client.gui.population_in_label ? STR_VIEWPORT_TOWN_POP : STR_VIEWPORT_TOWN;
+		}
+	}
+
+	/**
+	 * Returns the correct town small label, based on rating.
+	 */
+	inline StringID SmallLabel() const{
+		if (!(_game_mode == GM_EDITOR) && (_local_company < MAX_COMPANIES)) {
+			return STR_VIEWPORT_TOWN_TINY_VERY_POOR_RATING + this->town_label;
+		} else {
+			return STR_VIEWPORT_TOWN_TINY_WHITE;
+		}
+	}
+
 	/**
 	 * Creates a new town.
 	 * @param tile center tile of the town
@@ -116,6 +150,30 @@
 
 	void InitializeLayout(TownLayout layout);
 
+	/* virtual */ SourceType GetType() const
+	{
+		return ST_TOWN;
+	}
+
+	/* virtual */ SourceID GetID() const
+	{
+		return this->index;
+	}
+
+	/* virtual */ bool AcceptsCargo(CargoID cid) const
+	{
+		return HasBit(this->cargo_accepted_total, cid);
+	}
+
+	/* virtual */ bool SuppliesCargo(CargoID cid) const
+	{
+		return HasBit(this->cargo_produced, cid);
+	}
+
+	/* virtual */ uint GetDestinationWeight(CargoID cid, byte weight_mod) const;
+	/* virtual */ void CreateSpecialLinks(CargoID cid);
+	/* virtual */ TileArea GetTileForDestination(CargoID cid);
+
 	/**
 	 * Calculate the max town noise.
 	 * The value is counted using the population divided by the content of the
@@ -137,7 +195,10 @@
 		return Town::Get(GetTownIndex(tile));
 	}
 
-	static Town *GetRandom();
+	/** Callback function for #Town::GetRandom. */
+	typedef bool (*EnumTownProc)(const Town *t, void *data);
+
+	static Town *GetRandom(EnumTownProc enum_proc = NULL, TownID skip = INVALID_TOWN, void *data = NULL);
 	static void PostDestructor(size_t index);
 };
 
diff -urNad openttd-1.3.2/src/town_map.h openttd-1.3.2-DC3.0RC3/src/town_map.h
--- openttd-1.3.2/src/town_map.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/town_map.h	2013-11-22 05:49:07.000000000 +0100
@@ -24,7 +24,7 @@
 static inline TownID GetTownIndex(TileIndex t)
 {
 	assert(IsTileType(t, MP_HOUSE) || (IsTileType(t, MP_ROAD) && !IsRoadDepot(t)));
-	return _m[t].m2;
+	return GetTile(t)->m2;
 }
 
 /**
@@ -36,7 +36,7 @@
 static inline void SetTownIndex(TileIndex t, TownID index)
 {
 	assert(IsTileType(t, MP_HOUSE) || (IsTileType(t, MP_ROAD) && !IsRoadDepot(t)));
-	_m[t].m2 = index;
+	GetTile(t)->m2 = index;
 }
 
 /**
@@ -49,7 +49,7 @@
 static inline HouseID GetCleanHouseType(TileIndex t)
 {
 	assert(IsTileType(t, MP_HOUSE));
-	return _m[t].m4 | (GB(_m[t].m3, 6, 1) << 8);
+	return GetTile(t)->m4 | (GB(GetTile(t)->m3, 6, 1) << 8);
 }
 
 /**
@@ -72,8 +72,8 @@
 static inline void SetHouseType(TileIndex t, HouseID house_id)
 {
 	assert(IsTileType(t, MP_HOUSE));
-	_m[t].m4 = GB(house_id, 0, 8);
-	SB(_m[t].m3, 6, 1, GB(house_id, 8, 1));
+	GetTile(t)->m4 = GB(house_id, 0, 8);
+	SB(GetTile(t)->m3, 6, 1, GB(house_id, 8, 1));
 }
 
 /**
@@ -83,7 +83,7 @@
  */
 static inline bool LiftHasDestination(TileIndex t)
 {
-	return HasBit(_me[t].m7, 0);
+	return HasBit(GetTileEx(t)->m7, 0);
 }
 
 /**
@@ -94,8 +94,8 @@
  */
 static inline void SetLiftDestination(TileIndex t, byte dest)
 {
-	SetBit(_me[t].m7, 0);
-	SB(_me[t].m7, 1, 3, dest);
+	SetBit(GetTileEx(t)->m7, 0);
+	SB(GetTileEx(t)->m7, 1, 3, dest);
 }
 
 /**
@@ -105,7 +105,7 @@
  */
 static inline byte GetLiftDestination(TileIndex t)
 {
-	return GB(_me[t].m7, 1, 3);
+	return GB(GetTileEx(t)->m7, 1, 3);
 }
 
 /**
@@ -116,7 +116,7 @@
  */
 static inline void HaltLift(TileIndex t)
 {
-	SB(_me[t].m7, 0, 4, 0);
+	SB(GetTileEx(t)->m7, 0, 4, 0);
 }
 
 /**
@@ -126,7 +126,7 @@
  */
 static inline byte GetLiftPosition(TileIndex t)
 {
-	return GB(_m[t].m6, 2, 6);
+	return GB(GetTileEx(t)->m6, 2, 6);
 }
 
 /**
@@ -136,7 +136,7 @@
  */
 static inline void SetLiftPosition(TileIndex t, byte pos)
 {
-	SB(_m[t].m6, 2, 6, pos);
+	SB(GetTileEx(t)->m6, 2, 6, pos);
 }
 
 /**
@@ -147,7 +147,7 @@
 static inline bool IsHouseCompleted(TileIndex t)
 {
 	assert(IsTileType(t, MP_HOUSE));
-	return HasBit(_m[t].m3, 7);
+	return HasBit(GetTile(t)->m3, 7);
 }
 
 /**
@@ -158,7 +158,7 @@
 static inline void SetHouseCompleted(TileIndex t, bool status)
 {
 	assert(IsTileType(t, MP_HOUSE));
-	SB(_m[t].m3, 7, 1, !!status);
+	SB(GetTile(t)->m3, 7, 1, !!status);
 }
 
 /**
@@ -185,7 +185,7 @@
 static inline byte GetHouseBuildingStage(TileIndex t)
 {
 	assert(IsTileType(t, MP_HOUSE));
-	return IsHouseCompleted(t) ? (byte)TOWN_HOUSE_COMPLETED : GB(_m[t].m5, 3, 2);
+	return IsHouseCompleted(t) ? (byte)TOWN_HOUSE_COMPLETED : GB(GetTile(t)->m5, 3, 2);
 }
 
 /**
@@ -197,7 +197,7 @@
 static inline byte GetHouseConstructionTick(TileIndex t)
 {
 	assert(IsTileType(t, MP_HOUSE));
-	return IsHouseCompleted(t) ? 0 : GB(_m[t].m5, 0, 3);
+	return IsHouseCompleted(t) ? 0 : GB(GetTile(t)->m5, 0, 3);
 }
 
 /**
@@ -210,9 +210,9 @@
 static inline void IncHouseConstructionTick(TileIndex t)
 {
 	assert(IsTileType(t, MP_HOUSE));
-	AB(_m[t].m5, 0, 5, 1);
+	AB(GetTile(t)->m5, 0, 5, 1);
 
-	if (GB(_m[t].m5, 3, 2) == TOWN_HOUSE_COMPLETED) {
+	if (GB(GetTile(t)->m5, 3, 2) == TOWN_HOUSE_COMPLETED) {
 		/* House is now completed.
 		 * Store the year of construction as well, for newgrf house purpose */
 		SetHouseCompleted(t, true);
@@ -228,7 +228,7 @@
 static inline void ResetHouseAge(TileIndex t)
 {
 	assert(IsTileType(t, MP_HOUSE) && IsHouseCompleted(t));
-	_m[t].m5 = 0;
+	GetTile(t)->m5 = 0;
 }
 
 /**
@@ -239,7 +239,7 @@
 static inline void IncrementHouseAge(TileIndex t)
 {
 	assert(IsTileType(t, MP_HOUSE));
-	if (IsHouseCompleted(t) && _m[t].m5 < 0xFF) _m[t].m5++;
+	if (IsHouseCompleted(t) && GetTile(t)->m5 < 0xFF) GetTile(t)->m5++;
 }
 
 /**
@@ -251,7 +251,7 @@
 static inline Year GetHouseAge(TileIndex t)
 {
 	assert(IsTileType(t, MP_HOUSE));
-	return IsHouseCompleted(t) ? _m[t].m5 : 0;
+	return IsHouseCompleted(t) ? GetTile(t)->m5 : 0;
 }
 
 /**
@@ -264,7 +264,7 @@
 static inline void SetHouseRandomBits(TileIndex t, byte random)
 {
 	assert(IsTileType(t, MP_HOUSE));
-	_m[t].m1 = random;
+	GetTile(t)->m1 = random;
 }
 
 /**
@@ -277,7 +277,7 @@
 static inline byte GetHouseRandomBits(TileIndex t)
 {
 	assert(IsTileType(t, MP_HOUSE));
-	return _m[t].m1;
+	return GetTile(t)->m1;
 }
 
 /**
@@ -290,7 +290,7 @@
 static inline void SetHouseTriggers(TileIndex t, byte triggers)
 {
 	assert(IsTileType(t, MP_HOUSE));
-	SB(_m[t].m3, 0, 5, triggers);
+	SB(GetTile(t)->m3, 0, 5, triggers);
 }
 
 /**
@@ -303,7 +303,7 @@
 static inline byte GetHouseTriggers(TileIndex t)
 {
 	assert(IsTileType(t, MP_HOUSE));
-	return GB(_m[t].m3, 0, 5);
+	return GB(GetTile(t)->m3, 0, 5);
 }
 
 /**
@@ -315,7 +315,7 @@
 static inline byte GetHouseProcessingTime(TileIndex t)
 {
 	assert(IsTileType(t, MP_HOUSE));
-	return GB(_m[t].m6, 2, 6);
+	return GB(GetTileEx(t)->m6, 2, 6);
 }
 
 /**
@@ -327,7 +327,7 @@
 static inline void SetHouseProcessingTime(TileIndex t, byte time)
 {
 	assert(IsTileType(t, MP_HOUSE));
-	SB(_m[t].m6, 2, 6, time);
+	SB(GetTileEx(t)->m6, 2, 6, time);
 }
 
 /**
@@ -338,7 +338,7 @@
 static inline void DecHouseProcessingTime(TileIndex t)
 {
 	assert(IsTileType(t, MP_HOUSE));
-	_m[t].m6 -= 1 << 2;
+	GetTileEx(t)->m6 -= 1 << 2;
 }
 
 /**
@@ -356,12 +356,12 @@
 	assert(IsTileType(t, MP_CLEAR));
 
 	SetTileType(t, MP_HOUSE);
-	_m[t].m1 = random_bits;
-	_m[t].m2 = tid;
-	_m[t].m3 = 0;
+	GetTile(t)->m1 = random_bits;
+	GetTile(t)->m2 = tid;
+	GetTile(t)->m3 = 0;
 	SetHouseType(t, type);
 	SetHouseCompleted(t, stage == TOWN_HOUSE_COMPLETED);
-	_m[t].m5 = IsHouseCompleted(t) ? 0 : (stage << 3 | counter);
+	GetTile(t)->m5 = IsHouseCompleted(t) ? 0 : (stage << 3 | counter);
 	SetAnimationFrame(t, 0);
 	SetHouseProcessingTime(t, HouseSpec::Get(type)->processing_time);
 }
diff -urNad openttd-1.3.2/src/track_func.h openttd-1.3.2-DC3.0RC3/src/track_func.h
--- openttd-1.3.2/src/track_func.h	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/track_func.h	2013-11-22 05:49:07.000000000 +0100
@@ -15,6 +15,7 @@
 #include "core/bitmath_func.hpp"
 #include "track_type.h"
 #include "slope_func.h"
+#include "direction_func.h"
 
 /**
  * Iterate through each set Track in a TrackBits value.
@@ -28,6 +29,17 @@
 #define FOR_EACH_SET_TRACK(var, track_bits) FOR_EACH_SET_BIT_EX(Track, var, TrackBits, track_bits)
 
 /**
+ * Iterate through each set Trackdir in a TrackdirBits value.
+ * For more informations see FOR_EACH_SET_BIT_EX.
+ *
+ * @param var Loop index variable that stores fallowing set track. Must be of type Track.
+ * @param trackdir_bits The value to iterate through (any expression).
+ *
+ * @see FOR_EACH_SET_BIT_EX
+ */
+#define FOR_EACH_SET_TRACKDIR(var, trackdir_bits) FOR_EACH_SET_BIT_EX(Trackdir, var, TrackdirBits, trackdir_bits)
+
+/**
  * Convert an Axis to the corresponding Track
  * AXIS_X -> TRACK_X
  * AXIS_Y -> TRACK_Y
@@ -655,4 +667,43 @@
 	return HasBit(_uphill_trackdirs[RemoveHalftileSlope(slope)], dir);
 }
 
+/**
+ * Transform a Track.
+ * @param track The Track to transform.
+ * @param transformation Transformation to perform.
+ * @return The transformed Track.
+ */
+static inline Track TransformTrack(Track track, DirTransformation transformation)
+{
+	extern const byte _track_transformation_map[DTR_END][TRACK_END];
+	return (Track)_track_transformation_map[transformation][track];
+}
+
+/**
+ * Transform a TrackBits.
+ * @param track_bits The TrackBits to transform.
+ * @param transformation Transformation to perform.
+ * @return The transformed TrackBits.
+ */
+static inline TrackBits TransformTrackBits(TrackBits track_bits, DirTransformation transformation)
+{
+	TrackBits ret = track_bits & ~TRACK_BIT_ALL;
+
+	Track t;
+	FOR_EACH_SET_TRACK(t, track_bits & TRACK_BIT_ALL) SetBit(ret, TransformTrack(t, transformation));
+
+	return ret;
+}
+
+/**
+ * Transform a Trackdir.
+ * @param trackdir The Trackdir to transform.
+ * @param transformation Transformation to perform.
+ * @return The transformed Trackdir.
+ */
+static inline Trackdir TransformTrackdir(Trackdir trackdir, DirTransformation transformation)
+{
+	return TrackExitdirToTrackdir(TransformTrack(TrackdirToTrack(trackdir), transformation), TransformDiagDir(TrackdirToExitdir(trackdir), transformation));
+}
+
 #endif /* TRACK_FUNC_H */
diff -urNad openttd-1.3.2/src/track_type.h openttd-1.3.2-DC3.0RC3/src/track_type.h
--- openttd-1.3.2/src/track_type.h	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/track_type.h	2013-11-22 05:49:07.000000000 +0100
@@ -92,6 +92,7 @@
 	TRACKDIR_END,                   ///< Used for iterations
 	INVALID_TRACKDIR  = 0xFF,       ///< Flag for an invalid trackdir
 };
+DECLARE_POSTFIX_INCREMENT(Trackdir);
 
 /** Define basic enum properties */
 template <> struct EnumPropsT<Trackdir> : MakeEnumPropsT<Trackdir, byte, TRACKDIR_BEGIN, TRACKDIR_END, INVALID_TRACKDIR, 4> {};
diff -urNad openttd-1.3.2/src/trafficlight.cpp openttd-1.3.2-DC3.0RC3/src/trafficlight.cpp
--- openttd-1.3.2/src/trafficlight.cpp	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/trafficlight.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -0,0 +1,291 @@
+/* $Id: trafficlight.cpp $ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file trafficlight.cpp Handling of trafficlights. */
+
+#include "stdafx.h"
+#include "openttd.h"
+#include "landscape.h"
+#include "sprite.h"
+#include "viewport_func.h"
+#include "road_map.h"
+#include "command_func.h"
+#include "cheat_func.h"
+#include "animated_tile_func.h"
+#include "economy_func.h"
+#include "road_cmd.h"
+#include "company_func.h"
+#include "company_base.h"
+#include "settings_type.h"
+#include "trafficlight.h"
+#include "trafficlight_type.h"
+#include "date_func.h"
+#include "company_func.h"
+
+#include "table/sprites.h"
+#include "table/strings.h"
+
+#include <set>
+
+
+/* A traffic light consist (TLC) is a set of adjacent tiles with traffic lights on them.
+ * They are linked together to form a big traffic light junction. */
+typedef std::set<TileIndex> TLC;
+
+/**
+ * Gets the traffic light consist (a set of adjacent tiles with traffic lights).
+ * If specified by the checkroadworks parameter, it returns 0 instead if road works are found within the consist.
+ * @param tile           Tile of the traffic light consist.
+ * @param checkroadworks Should we check for roadworks in the consist (and return 0 if found).
+ * @return visited       The traffic light consist (TLC); if checkroadworks == true and roadworks were found, return 0 instead.
+ */
+TLC *GetTrafficLightConsist(TileIndex tile, bool checkroadworks)
+{
+	TLC *visited;
+	TLC *candidates;
+
+	visited = new TLC;
+	candidates = new TLC;
+	candidates->insert(tile);
+
+	while (!candidates->empty()) {
+		TLC::iterator cur = candidates->begin();
+		if (checkroadworks && HasRoadWorks(*cur)) {
+			delete visited;
+			delete candidates;
+			return 0;
+		}
+		uint8 distance_between_traffic_lights = _tlc_distance[_settings_game.construction.max_tlc_distance];
+		for (int i = 0; i < distance_between_traffic_lights; i++) {
+			TileIndex neighbor = *cur + ToTileIndexDiff(_tl_check_offsets[i]);
+			if (HasTrafficLights(neighbor) && (visited->find(neighbor) == visited->end())) candidates->insert(neighbor);
+		}
+		visited->insert(*cur);
+		candidates->erase(cur);
+	}
+	delete candidates;
+	return visited;
+}
+
+/**
+ * Gets the lowest TileIndex of the traffic light consist or 0 if roadworks
+ * are found in the consist.
+ * @param tile    Tile of the traffic light consist.
+ * @return lowest TileIndex in the consist or 0 if roadworks were found.
+ */
+TileIndex GetTLCLowestTileIndexOrRoadWorks(TileIndex tile)
+{
+	TLC *consist = GetTrafficLightConsist(tile, true);
+	TileIndex result = 0;
+	if (consist != 0) result = *(consist->begin());
+	delete consist;
+	return result;
+}
+
+/**
+ * Returns the state of the trafficlights on a tile.
+ * @note In the scenario editor trafficlights are disabled.
+ * @param tile This tile.
+ * @pre        The tile must have trafficlights.
+ * @return     Trafficlights state or disabled state.
+ */
+TrafficLightState GetTLState(TileIndex tile)
+{
+	assert(HasTrafficLights(tile));
+	if (_game_mode == GM_EDITOR) return TLS_OFF;   ///< All lights are off in scenario editor.
+	tile = GetTLCLowestTileIndexOrRoadWorks(tile);
+	if (tile == 0) return TLS_OFF;                 ///< All lights are off when roadworks are in the consist.
+
+	uint16 tl_total = 16 * _settings_game.construction.traffic_lights_green_phase;          // There are (16 * patchsetting) "TL ticks".
+	uint16 tl_tick = ((_tick_counter / 16) + 5 * TileX(tile) + 7 * TileY(tile)) % tl_total; // Each "TL tick" consists of 16 gameticks.
+
+	if (tl_tick < ((tl_total / 2) - 2)) return TLS_X_GREEN_Y_RED;     ///< SW and NE are green, NW and SE are red.
+	if (tl_tick < ((tl_total / 2) - 1)) return TLS_X_YELLOW_Y_RED;    ///< SW and NE are yellow, NW and SE are red.
+	if (tl_tick < (tl_total / 2))       return TLS_X_RED_Y_REDYELLOW; ///< SW and NE are red, NW and SE are red-yellow.
+	if (tl_tick < (tl_total - 2))       return TLS_X_RED_Y_GREEN;     ///< SW and NE are red, NW and SE are green.
+	if (tl_tick < (tl_total - 1))       return TLS_X_RED_Y_YELLOW;    ///< SW and NE are red, NW and SE are yellow.
+	if (tl_tick < tl_total)             return TLS_X_REDYELLOW_Y_RED; ///< SW and NE are red-yellow, NW and SE are red.
+
+	NOT_REACHED();
+	return TLS_OFF;
+}
+
+/**
+ * Which directions are disallowed due to the TLState (red lights..).
+ */
+static const TrackdirBits _tls_to_trackdir[7] = {
+	TRACKDIR_BIT_MASK,                                ///< 0) all directions disallowed
+	TRACKDIR_BIT_Y_NW | TRACKDIR_BIT_Y_SE |           ///< 1) all directions from
+		TRACKDIR_BIT_UPPER_E | TRACKDIR_BIT_LOWER_W |    ///<    y sides
+		TRACKDIR_BIT_LEFT_S | TRACKDIR_BIT_RIGHT_N,      ///<    are disallowed
+	TRACKDIR_BIT_MASK,                                ///< 2) all directions disallowed
+	TRACKDIR_BIT_MASK,                                ///< 3) all directions disallowed
+	TRACKDIR_BIT_X_SW | TRACKDIR_BIT_X_NE |           ///< 4) all directions from
+		TRACKDIR_BIT_UPPER_W | TRACKDIR_BIT_LOWER_E |    ///<    x sides
+		TRACKDIR_BIT_LEFT_N | TRACKDIR_BIT_RIGHT_S,      ///<    are disallowed
+	TRACKDIR_BIT_MASK,                                ///< 5) all directions disallowed
+	TRACKDIR_BIT_MASK,                                ///< 6) all directions disallowed
+};
+
+/**
+ * Which directions in tile are allowed to be taken due to adjacent traffic lights (traffic light consist).
+ * @param tile          Tile to search on.
+ * @return trackdirbits Bitmask of allowed directions.
+ */
+TrackdirBits GetIntraTLCAllowedDirections(TileIndex tile)
+{
+	TrackdirBits trackdirbits = TRACKDIR_BIT_NONE;
+
+	if (HasTrafficLights(tile + TileDiffXY( 1,  0))) // SW.
+		trackdirbits |= TRACKDIR_BIT_X_NE | TRACKDIR_BIT_LOWER_E | TRACKDIR_BIT_LEFT_N;
+	if (HasTrafficLights(tile + TileDiffXY( 0,  1))) // SE
+		trackdirbits |= TRACKDIR_BIT_Y_NW | TRACKDIR_BIT_LOWER_W | TRACKDIR_BIT_RIGHT_N;
+	if (HasTrafficLights(tile + TileDiffXY( 0, -1))) // NW.
+		trackdirbits |= TRACKDIR_BIT_Y_SE | TRACKDIR_BIT_UPPER_E | TRACKDIR_BIT_LEFT_S;
+	if (HasTrafficLights(tile + TileDiffXY(-1,  0))) // NE.
+		trackdirbits |= TRACKDIR_BIT_X_SW | TRACKDIR_BIT_UPPER_W | TRACKDIR_BIT_RIGHT_S;
+
+	return trackdirbits;
+}
+
+/**
+ * Get a bitmask of the directions forbidden to drive on due to traffic light(s).
+ * @param tile Tile to check.
+ * @return     Bitmask of forbidden directions.
+ */
+TrackdirBits GetTrafficLightDisallowedDirections(TileIndex tile)
+{
+	return (_tls_to_trackdir[GetTLState(tile)] & ~GetIntraTLCAllowedDirections(tile));
+}
+
+/**
+ * Checks if the size of a traffic light consist is within the allowed range.
+ * @param tile    Tile to check (can also be a new tile to be added to the TLC).
+ * @return result True if the TLC size is within the allowed range, else false.
+ */
+bool CheckTLCSize(TileIndex tile)
+{
+	if (_settings_game.construction.max_tlc_size == 0) return true;
+	TLC *consist = GetTrafficLightConsist(tile, false);
+	bool result = (consist->size() <= _settings_game.construction.max_tlc_size);
+	delete consist;
+	return result;
+}
+
+/**
+ * Build traffic lights on a crossing.
+ * @param tile         Tile where to place the traffic lights.
+ * @param flags        Operation to perform.
+ * @param p1           Unused.
+ * @param p2           Unused.
+ * @return CommandCost Cost or error.
+ */
+CommandCost CmdBuildTrafficLights(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
+{
+	/* Check if traffic lights are enabled. */
+	if (!_settings_game.construction.traffic_lights) return CMD_ERROR; // Sanity check.
+
+	/* Check for correct location (road). */
+	if (!IsTileType(tile, MP_ROAD) || GetRoadTileType(tile) != ROAD_TILE_NORMAL) return_cmd_error(STR_ERROR_THERE_IS_NO_ROAD);
+
+	/* Check owner only if a valid player is executing this command. */
+	if (Company::IsValidID(_current_company)) {
+		Owner owner = GetTileOwner(tile);
+		if (owner == OWNER_TOWN) {
+			if (!_settings_game.construction.allow_building_tls_in_towns) return_cmd_error(STR_ERROR_TRAFFIC_LIGHTS_NOT_ALLOWED_ON_TOWN_ROADS);
+		} else {
+			if (owner != OWNER_NONE && !IsTileOwner(tile, _current_company)) return_cmd_error(STR_ERROR_AREA_IS_OWNED_BY_ANOTHER); // Owned by ... already displayed in CheckOwnership.
+		}
+	}
+
+	/* Check junction and already built. */
+	if (CountBits(GetAllRoadBits(tile)) < 3) return_cmd_error(STR_ERROR_CAN_ONLY_BE_PLACED_ON_ROAD_JUNCTIONS);
+	if (HasTrafficLights(tile)) return_cmd_error(STR_ERROR_ALREADY_BUILT);
+
+	if (!CheckTLCSize(tile)) return_cmd_error(STR_ERROR_TRAFFIC_LIGHT_CONSIST_TOO_BIG);
+
+	/* Now we may build the traffic lights. */
+	if (flags & DC_EXEC) {
+		MakeTrafficLights(tile);
+		AddAnimatedTile(tile);
+		MarkTileDirtyByTile(tile);
+	}
+	return CommandCost(EXPENSES_CONSTRUCTION, _price[PR_BUILD_SIGNALS]);
+}
+
+/**
+ * Removes traffic lights from a tile.
+ * @param tile         Tile where to remove the traffic lights.
+ * @param flags        Operation to perform.
+ * @param p1           Unused.
+ * @param p2           Unused.
+ * @return CommandCost Cost or error.
+ */
+CommandCost CmdRemoveTrafficLights(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
+{
+	/* Check for correct location (road with traffic lights). */
+	if (!IsTileType(tile, MP_ROAD) || GetRoadTileType(tile) != ROAD_TILE_NORMAL || !HasTrafficLights(tile)) return CMD_ERROR;
+
+	/* Check owner, but only if a valid player is executing this command. */
+	if (Company::IsValidID(_current_company)) {
+		Owner owner = GetTileOwner(tile);
+		if (owner == OWNER_TOWN) {
+			if (!_settings_game.construction.allow_building_tls_in_towns && !_cheats.magic_bulldozer.value) return_cmd_error(STR_ERROR_TRAFFIC_LIGHTS_NOT_ALLOWED_ON_TOWN_ROADS);
+		} else {
+			if (owner != OWNER_NONE && !IsTileOwner(tile, _current_company)) return CMD_ERROR; // Owned by ... already displayed in CheckOwnership.
+		}
+	}
+
+	/* Now we may remove the traffic lights. */
+	if (flags & DC_EXEC) {
+		DeleteAnimatedTile(tile);
+		ClearTrafficLights(tile);
+		MarkTileDirtyByTile(tile);
+	}
+	return CommandCost(EXPENSES_CONSTRUCTION, _price[PR_BUILD_SIGNALS]);
+}
+/**
+ * Clear all traffic lights from the map.
+ */
+void ClearAllTrafficLights()
+{
+	/* Iterate over the whole map and remove any trafficlights found. */
+	for (TileIndex tile = 0; tile < MapSize(); tile++) {
+		if (HasTrafficLights(tile)) {
+			DoCommand(tile, 0, 0, DC_EXEC, CMD_REMOVE_TRAFFICLIGHTS);
+		}
+	}
+}
+
+/**
+ * Draws traffic lights on a tile.
+ * @param ti TileInfo of the tile to draw on.
+ */
+void DrawTrafficLights(TileInfo* ti)
+{
+	RoadBits road = GetAllRoadBits(ti->tile);
+	TrafficLightState state = GetTLState(ti->tile);
+
+	const TileIndex neighbor[4] = { ti->tile + TileDiffXY(1, 0),   // SW.
+					ti->tile + TileDiffXY(0, 1),   // SE.
+					ti->tile + TileDiffXY(0, -1),  // NW.
+					ti->tile + TileDiffXY(-1, 0)}; // NE.
+	const RoadBits rb[4] = {ROAD_SW, ROAD_SE, ROAD_NW, ROAD_NE};
+
+	/* Draw the four directions. */
+	byte rs = _settings_game.vehicle.road_side;
+	for (int i = 0; i < 4; i++) {
+		if (road & rb[i] && !HasTrafficLights(neighbor[i])) {
+			DisallowedRoadDirections drd = DRD_NONE;
+			if (IsTileType(neighbor[i], MP_ROAD) && IsNormalRoad(neighbor[i])) drd = GetDisallowedRoadDirections(neighbor[i]);
+			if (drd != ((i % 2 == 0) ? DRD_SOUTHBOUND : DRD_NORTHBOUND) && drd != DRD_BOTH)
+				DrawRoadDetail(_tls_to_sprites[state][i], ti, _tl_offsets[rs][i].x, _tl_offsets[rs][i].y, 12);
+		}
+	}
+}
diff -urNad openttd-1.3.2/src/trafficlight_func.h openttd-1.3.2-DC3.0RC3/src/trafficlight_func.h
--- openttd-1.3.2/src/trafficlight_func.h	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/trafficlight_func.h	2013-11-22 05:49:07.000000000 +0100
@@ -0,0 +1,19 @@
+/* $Id: trafficlight_func.h $ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file trafficlight_func.h Functions related to trafficlights. */
+
+#include "road_map.h"
+
+TrackdirBits GetTrafficLightDisallowedDirections(TileIndex tile);
+void DrawTrafficLights(TileInfo* ti);
+
+CommandCost CmdBuildTrafficLights(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text);
+CommandCost CmdRemoveTrafficLights(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text);
+void ClearAllTrafficLights();
diff -urNad openttd-1.3.2/src/trafficlight.h openttd-1.3.2-DC3.0RC3/src/trafficlight.h
--- openttd-1.3.2/src/trafficlight.h	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/trafficlight.h	2013-11-22 05:49:07.000000000 +0100
@@ -0,0 +1,133 @@
+/* $Id: trafficlight.h $ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file trafficlight.h variables used for handling trafficlights. */
+
+
+/**
+ * Used for synchronising traffic light signals.
+ * Number below is how far we look into the _tl_check_offsets array when
+ * placing trafficlights, based on _settings_game.construction.max_tlc_distance.
+ */
+static const uint8 _tlc_distance[5] = {
+0,  ///< no synchronizing.
+8,  ///< adjecant tiles only.
+24, ///< 2 tiles away.
+48, ///< 3 tiles away.
+80  ///< 4 tiles away.
+};
+
+/** TileDiffs for the adjacent tiles and those a little further away. */
+static const TileIndexDiffC _tl_check_offsets[80] = {
+	/* Tiles next to this tile (8 tiles). */
+	{-1, -1},
+	{ 0, -1},
+	{ 1, -1},
+	{ 1,  0},
+	{ 1,  1},
+	{ 0,  1},
+	{-1,  1},
+	{-1,  0},
+	/* Tiles two tiles away from this tile (16 tiles). */
+	{-2, -2},
+	{-1, -2},
+	{ 0, -2},
+	{ 1, -2},
+	{ 2, -2},
+	{ 2, -1},
+	{ 2,  0},
+	{ 2,  1},
+	{ 2,  2},
+	{ 1,  2},
+	{ 0,  2},
+	{-1,  2},
+	{-2,  2},
+	{-2,  1},
+	{-2,  0},
+	{-2, -1},
+	/* Tiles three tiles away from this tile (24 tiles). */
+	{-3, -3},
+	{-3, -2},
+	{-3, -1},
+	{-3,  0},
+	{-3,  1},
+	{-3,  2},
+	{-3,  3},
+	{-2,  3},
+	{-1,  3},
+	{ 0,  3},
+	{ 1,  3},
+	{ 2,  3},
+	{ 3,  3},
+	{ 3,  2},
+	{ 3,  1},
+	{ 3,  0},
+	{ 3, -1},
+	{ 3, -2},
+	{ 3, -3},
+	{ 2, -3},
+	{ 1, -3},
+	{ 0, -3},
+	{-1, -3},
+	{-2, -3},
+	/* Tiles four tiles away from this tile (32 tiles). */
+	{-4, -4},
+	{-3, -4},
+	{-2, -4},
+	{-1, -4},
+	{ 0, -4},
+	{ 1, -4},
+	{ 2, -4},
+	{ 3, -4},
+	{ 4, -4},
+	{ 4, -3},
+	{ 4, -2},
+	{ 4, -1},
+	{ 4,  0},
+	{ 4,  1},
+	{ 4,  2},
+	{ 4,  3},
+	{ 4,  4},
+	{ 3,  4},
+	{ 2,  4},
+	{ 1,  4},
+	{ 0,  4},
+	{-1,  4},
+	{-2,  4},
+	{-3,  4},
+	{-4,  4},
+	{-4,  3},
+	{-4,  2},
+	{-4,  1},
+	{-4,  0},
+	{-4, -1},
+	{-4, -2},
+	{-4, -3}
+};
+
+/**
+ * Drawing offsets for the traffic light posts [roadside (left, right)][direction (SW, SE, NW, NE)].
+ */
+static const Point _tl_offsets[2][4] = {
+	{{15, 1}, {14, 15}, {1, 0}, {0, 14}},  // Left side driving.
+	{{15, 14}, {1, 15}, {14, 0}, {0, 1}}   // Right side driving.
+};
+
+/**
+ * Sprites needed for the various states of a TL crossing [state][direction].
+ */
+static const SpriteID _tls_to_sprites[7][4] = {
+	{SPR_TL_SW_NONE,       SPR_TL_SE_NONE,       SPR_TL_NW_NONE,       SPR_TL_NE_NONE},
+	{SPR_TL_SW_GREEN,      SPR_TL_SE_RED,        SPR_TL_NW_RED,        SPR_TL_NE_GREEN},
+	{SPR_TL_SW_YELLOW,     SPR_TL_SE_RED,        SPR_TL_NW_RED,        SPR_TL_NE_YELLOW},
+	{SPR_TL_SW_RED,        SPR_TL_SE_RED_YELLOW, SPR_TL_NW_RED_YELLOW, SPR_TL_NE_RED},
+	{SPR_TL_SW_RED,        SPR_TL_SE_GREEN,      SPR_TL_NW_GREEN,      SPR_TL_NE_RED},
+	{SPR_TL_SW_RED,        SPR_TL_SE_YELLOW,     SPR_TL_NW_YELLOW,     SPR_TL_NE_RED},
+	{SPR_TL_SW_RED_YELLOW, SPR_TL_SE_RED,        SPR_TL_NW_RED,        SPR_TL_NE_RED_YELLOW}
+};
diff -urNad openttd-1.3.2/src/trafficlight_type.h openttd-1.3.2-DC3.0RC3/src/trafficlight_type.h
--- openttd-1.3.2/src/trafficlight_type.h	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/trafficlight_type.h	2013-11-22 05:49:07.000000000 +0100
@@ -0,0 +1,21 @@
+/* $Id: trafficlight_type.h $ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file trafficlight_type.h Types related to the states of trafficlights.*/
+
+/* Which state a traffic light is in. */
+enum TrafficLightState {
+	TLS_OFF,                        ///< all lights are off (during roadworks; always in scedit)
+	TLS_X_GREEN_Y_RED,              ///< SW and NE are green, NW and SE are red
+	TLS_X_YELLOW_Y_RED,             ///< SW and NE are yellow, NW and SE are red
+	TLS_X_RED_Y_REDYELLOW,          ///< SW and NE are red, NW and SE are red-yellow
+	TLS_X_RED_Y_GREEN,              ///< SW and NE are red, NW and SE are green
+	TLS_X_RED_Y_YELLOW,             ///< SW and NE are red, NW and SE are yellow
+	TLS_X_REDYELLOW_Y_RED,          ///< SW and NE are red-yellow, NW and SE are red
+};
diff -urNad openttd-1.3.2/src/train_cmd.cpp openttd-1.3.2-DC3.0RC3/src/train_cmd.cpp
--- openttd-1.3.2/src/train_cmd.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/train_cmd.cpp	2013-11-22 07:05:44.000000000 +0100
@@ -32,12 +32,16 @@
 #include "core/random_func.hpp"
 #include "company_base.h"
 #include "newgrf.h"
+#include "infrastructure_func.h"
 #include "order_backup.h"
 #include "zoom_func.h"
+#include "cargodest_func.h"
 
 #include "table/strings.h"
 #include "table/train_cmd.h"
 
+#include "engine_func.h" //MYGUI
+
 static Track ChooseTrainTrack(Train *v, TileIndex tile, DiagDirection enterdir, TrackBits tracks, bool force_res, bool *got_reservation, bool mark_stuck);
 static bool TrainCheckIfLineEnds(Train *v, bool reverse = true);
 bool TrainController(Train *v, Vehicle *nomove, bool reverse = true); // Also used in vehicle_sl.cpp.
@@ -156,6 +160,8 @@
 		u->InvalidateNewGRFCache();
 	}
 
+	uint32 cargo_mask = 0;
+
 	for (Train *u = this; u != NULL; u = u->Next()) {
 		const Engine *e_u = u->GetEngine();
 		const RailVehicleInfo *rvi_u = &e_u->u.rail;
@@ -200,7 +206,9 @@
 			}
 		}
 
+		/* Store carried cargo. */
 		u->cargo_cap = e_u->DetermineCapacity(u);
+		if (u->cargo_type != INVALID_CARGO && u->cargo_cap > 0) SetBit(cargo_mask, u->cargo_type);
 		u->vcache.cached_cargo_age_period = GetVehicleProperty(u, PROP_TRAIN_CARGO_AGE_PERIOD, e_u->info.cargo_age_period);
 
 		/* check the vehicle length (callback) */
@@ -231,6 +239,7 @@
 	}
 
 	/* store consist weight/max speed in cache */
+	this->vcache.cached_cargo_mask = cargo_mask;
 	this->vcache.cached_max_speed = max_speed;
 	this->tcache.cached_tilt = train_can_tilt;
 	this->tcache.cached_max_curve_speed = this->GetCurveSpeedLimit();
@@ -240,7 +249,7 @@
 
 	if (this->IsFrontEngine()) {
 		this->UpdateAcceleration();
-		SetWindowDirty(WC_VEHICLE_DETAILS, this->index);
+		if ( !HasBit(this->subtype, GVSF_VIRTUAL) ) SetWindowDirty(WC_VEHICLE_DETAILS, this->index);
 		InvalidateWindowData(WC_VEHICLE_REFIT, this->index, VIWD_CONSIST_CHANGED);
 		InvalidateWindowData(WC_VEHICLE_ORDERS, this->index, VIWD_CONSIST_CHANGED);
 	}
@@ -307,7 +316,7 @@
 	static const int absolute_max_speed = UINT16_MAX;
 	int max_speed = absolute_max_speed;
 
-	if (_settings_game.vehicle.train_acceleration_model == AM_ORIGINAL) return max_speed;
+//	if (_settings_game.vehicle.train_acceleration_model == AM_ORIGINAL) return max_speed;
 
 	int curvecount[2] = {0, 0};
 
@@ -447,6 +456,7 @@
 		offset->x = reference_width / 2;
 		offset->y = vehicle_pitch;
 	}
+	//printf("  refwid:%d  gdiw.cachedvehlen(%d):%d  ", reference_width, this->engine_type, this->gcache.cached_veh_length);
 	return this->gcache.cached_veh_length * reference_width / VEHICLE_LENGTH;
 }
 
@@ -1111,6 +1121,8 @@
 	/* Not a front engine, i.e. a free wagon chain. No need to do more. */
 	if (!head->IsFrontEngine()) return;
 
+	PrefillRouteLinks(head);
+
 	/* Update the refit button and window */
 	InvalidateWindowData(WC_VEHICLE_REFIT, head->index, VIWD_CONSIST_CHANGED);
 	SetWindowWidgetDirty(WC_VEHICLE_VIEW, head->index, WID_VV_REFIT);
@@ -1128,6 +1140,7 @@
  * @param p1 various bitstuffed elements
  * - p1 (bit  0 - 19) source vehicle index
  * - p1 (bit      20) move all vehicles following the source vehicle
+ * - p1 (bit	  21) this is a virtual vehicle (for creating TemplateVehicles) MYGUI
  * @param p2 what wagon to put the source wagon AFTER, XXX - INVALID_VEHICLE to make a new line
  * @param text unused
  * @return the cost of this operation or an error
@@ -1147,7 +1160,7 @@
 	/* Do not allow moving crashed vehicles inside the depot, it is likely to cause asserts later */
 	if (src->vehstatus & VS_CRASHED) return CMD_ERROR;
 
-	/* if nothing is selected as destination, try and find a matching vehicle to drag to. */
+	/* if nothing is selected as destination, try and find a m1atching vehicle to drag to. */
 	Train *dst;
 	if (d == INVALID_VEHICLE) {
 		dst = src->IsEngine() ? NULL : FindGoodVehiclePos(src);
@@ -1192,10 +1205,14 @@
 	if (!move_chain && dst != NULL && dst->IsRearDualheaded() && src == dst->other_multiheaded_part) return CommandCost();
 
 	/* Check if all vehicles in the source train are stopped inside a depot. */
-	if (!src_head->IsStoppedInDepot()) return_cmd_error(STR_ERROR_TRAINS_CAN_ONLY_BE_ALTERED_INSIDE_A_DEPOT);
+	/* Do this check only if the vehicle to be moved is non-virtual */ //MYGUI
+	if ( !HasBit(p1, 21) )
+		if (!src_head->IsStoppedInDepot()) return_cmd_error(STR_ERROR_TRAINS_CAN_ONLY_BE_ALTERED_INSIDE_A_DEPOT);
 
 	/* Check if all vehicles in the destination train are stopped inside a depot. */
-	if (dst_head != NULL && !dst_head->IsStoppedInDepot()) return_cmd_error(STR_ERROR_TRAINS_CAN_ONLY_BE_ALTERED_INSIDE_A_DEPOT);
+	/* Do this check only if the destination vehicle is non-virtual */ //MYGUI
+	if ( !HasBit(p1, 21) )
+		if (dst_head != NULL && !dst_head->IsStoppedInDepot()) return_cmd_error(STR_ERROR_TRAINS_CAN_ONLY_BE_ALTERED_INSIDE_A_DEPOT);
 
 	/* First make a backup of the order of the trains. That way we can do
 	 * whatever we want with the order and later on easily revert. */
@@ -1297,9 +1314,15 @@
 			CheckCargoCapacity(dst_head);
 		}
 
+		/* Pre-fill route links after adding a vehicle. */
+		if (dst_head != NULL && dst_head->IsFrontEngine()) PrefillRouteLinks(dst_head);
+
 		/* We are undoubtedly changing something in the depot and train list. */
-		InvalidateWindowData(WC_VEHICLE_DEPOT, src->tile);
-		InvalidateWindowClassesData(WC_TRAINS_LIST, 0);
+		/* But only if the moved vehicle is not virtual */ // MYGUI
+		if ( !HasBit(src->subtype, GVSF_VIRTUAL) ) {
+			InvalidateWindowData(WC_VEHICLE_DEPOT, src->tile);
+			InvalidateWindowClassesData(WC_TRAINS_LIST, 0);
+		}
 	} else {
 		/* We don't want to execute what we're just tried. */
 		RestoreTrainBackup(original_src);
@@ -1386,8 +1409,11 @@
 		NormaliseTrainHead(new_head);
 
 		/* We are undoubtedly changing something in the depot and train list. */
-		InvalidateWindowData(WC_VEHICLE_DEPOT, v->tile);
-		InvalidateWindowClassesData(WC_TRAINS_LIST, 0);
+		/* Unless its a virtual train */ //MYGUI
+		if ( !HasBit(v->subtype, GVSF_VIRTUAL) ) {
+			InvalidateWindowData(WC_VEHICLE_DEPOT, v->tile);
+			InvalidateWindowClassesData(WC_TRAINS_LIST, 0);
+		}
 
 		/* Actually delete the sold 'goods' */
 		delete sell_head;
@@ -1396,6 +1422,7 @@
 		RestoreTrainBackup(original);
 	}
 
+	cost.AffectCost();
 	return cost;
 }
 
@@ -1646,19 +1673,31 @@
 	return HasVehicleOnPos(tile_from, &tile, &TrainApproachingCrossingEnum);
 }
 
+/** Check if the crossing should be closed
+ *  @return train on crossing || train approaching crossing || reserved
+ */
+static inline bool CheckLevelCrossing(TileIndex tile)
+{
+	return HasCrossingReservation(tile) || HasVehicleOnPos(tile, NULL, &TrainOnTileEnum) || TrainApproachingCrossing(tile);
+}
 
 /**
  * Sets correct crossing state
  * @param tile tile to update
  * @param sound should we play sound?
+ * @param force_state force close the crossing due to an adjacent tile
  * @pre tile is a rail-road crossing
  */
-void UpdateLevelCrossing(TileIndex tile, bool sound)
+static void UpdateLevelCrossingTile(TileIndex tile, bool sound, bool force_state = false)
 {
 	assert(IsLevelCrossingTile(tile));
+	bool new_state;
 
-	/* train on crossing || train approaching crossing || reserved */
-	bool new_state = HasVehicleOnPos(tile, NULL, &TrainOnTileEnum) || TrainApproachingCrossing(tile) || HasCrossingReservation(tile);
+	if (force_state) {
+		new_state = force_state;
+	} else {
+		new_state = CheckLevelCrossing(tile);
+	}
 
 	if (new_state != IsCrossingBarred(tile)) {
 		if (new_state && sound) {
@@ -1669,6 +1708,33 @@
 	}
 }
 
+/**
+ * Cycles the adjacent crossings and sets their state
+ * @param tile tile to update
+ * @param sound should we play sound?
+ */
+void UpdateLevelCrossing(TileIndex tile, bool sound)
+{
+	bool is_forced = false;
+	if (!IsLevelCrossingTile(tile)) return;
+
+	Axis axis = GetCrossingRoadAxis(tile);
+
+	for (TileIndex t = tile; !is_forced && IsLevelCrossingTile(t) && GetCrossingRoadAxis(t) == axis; t = TileAddByDiagDir(t, AxisToDiagDir(GetCrossingRoadAxis(t)))) {
+		is_forced |= CheckLevelCrossing(t);
+	}
+	for (TileIndex t = tile; !is_forced && IsLevelCrossingTile(t) && GetCrossingRoadAxis(t) == axis; t = TileAddByDiagDir(t, ReverseDiagDir(AxisToDiagDir(GetCrossingRoadAxis(t))))) {
+		is_forced |= CheckLevelCrossing(t);
+	}
+	
+	for (TileIndex t = tile; IsLevelCrossingTile(t) && GetCrossingRoadAxis(t) == axis; t = TileAddByDiagDir(t, AxisToDiagDir(GetCrossingRoadAxis(t)))) {
+		UpdateLevelCrossingTile(t, sound, is_forced);
+	}
+	for (TileIndex t = tile; IsLevelCrossingTile(t) && GetCrossingRoadAxis(t) == axis; t = TileAddByDiagDir(t, ReverseDiagDir(AxisToDiagDir(GetCrossingRoadAxis(t))))) {
+		UpdateLevelCrossingTile(t, sound, is_forced);
+	}
+}
+
 
 /**
  * Bars crossing and plays ding-ding sound if not barred already
@@ -1678,9 +1744,8 @@
 static inline void MaybeBarCrossingWithSound(TileIndex tile)
 {
 	if (!IsCrossingBarred(tile)) {
-		BarCrossing(tile);
-		if (_settings_client.sound.ambient) SndPlayTileFx(SND_0E_LEVEL_CROSSING, tile);
-		MarkTileDirtyByTile(tile);
+               SetCrossingReservation(tile, true);
+               UpdateLevelCrossing(tile, true);
 	}
 }
 
@@ -1948,7 +2013,7 @@
 
 	if (!t->IsPrimaryVehicle()) return CMD_ERROR;
 
-	CommandCost ret = CheckOwnership(t->owner);
+	CommandCost ret = CheckVehicleControlAllowed(t);
 	if (ret.Failed()) return ret;
 
 
@@ -2790,8 +2855,6 @@
  */
 static void TrainEnterStation(Train *v, StationID station)
 {
-	v->last_station_visited = station;
-
 	/* check if a train ever visited this station before */
 	Station *st = Station::Get(station);
 	if (!(st->had_vehicle_of_type & HVOT_TRAIN)) {
@@ -2810,7 +2873,7 @@
 	v->force_proceed = TFP_NONE;
 	SetWindowDirty(WC_VEHICLE_VIEW, v->index);
 
-	v->BeginLoading();
+	v->BeginLoading(station);
 
 	TriggerStationRandomisation(st, v->tile, SRT_TRAIN_ARRIVES);
 	TriggerStationAnimation(st, v->tile, SAT_TRAIN_ARRIVES);
@@ -2819,7 +2882,7 @@
 /* Check if the vehicle is compatible with the specified tile */
 static inline bool CheckCompatibleRail(const Train *v, TileIndex tile)
 {
-	return IsTileOwner(tile, v->owner) &&
+	return IsInfraTileUsageAllowed(VEH_TRAIN, v->owner, tile) &&
 			(!v->IsFrontEngine() || HasBit(v->compatible_railtypes, GetRailType(tile)));
 }
 
@@ -3307,7 +3370,7 @@
 				v->x_pos = gp.x;
 				v->y_pos = gp.y;
 				VehicleUpdatePosition(v);
-				if ((v->vehstatus & VS_HIDDEN) == 0) VehicleUpdateViewport(v, true);
+				if (v->IsDrawn()) VehicleUpdateViewport(v, true);
 				continue;
 			}
 		}
@@ -3702,6 +3765,17 @@
 	return true;
 }
 
+// MYGUI
+Money Train::CalculateCurrentOverallValue() const
+{
+	Money ovr_value = 0;
+	const Train *v = this;
+	do {
+		ovr_value += v->value;
+	} while ( (v=v->GetNextVehicle()) != NULL );
+	return ovr_value;
+}
+// ENDMYGUI
 
 static bool TrainLocoHandler(Train *v, bool mode)
 {
@@ -3833,7 +3907,7 @@
 	}
 
 	for (Train *u = v; u != NULL; u = u->Next()) {
-		if ((u->vehstatus & VS_HIDDEN) != 0) continue;
+		if (!u->IsDrawn()) continue;
 
 		u->UpdateViewport(false, false);
 	}
@@ -3965,6 +4039,9 @@
 			/* running costs */
 			CommandCost cost(EXPENSES_TRAIN_RUN, this->GetRunningCost() * this->running_ticks / (DAYS_IN_YEAR  * DAY_TICKS));
 
+			/* sharing fee */
+			PayDailyTrackSharingFee(this);
+			
 			this->profit_this_year -= cost.GetCost();
 			this->running_ticks = 0;
 
@@ -3996,3 +4073,199 @@
 
 	return TrackDirectionToTrackdir(FindFirstTrack(this->track), this->direction);
 }
+
+int GetDisplayImageWidth(Train *t, Point *offset)
+{
+        int reference_width = TRAININFO_DEFAULT_VEHICLE_WIDTH;
+        int vehicle_pitch = 0;
+
+        const Engine *e = Engine::Get(t->engine_type);
+        if (e->grf_prop.grffile != NULL && is_custom_sprite(e->u.rail.image_index)) {
+                reference_width = e->grf_prop.grffile->traininfo_vehicle_width;
+                vehicle_pitch = e->grf_prop.grffile->traininfo_vehicle_pitch;
+        }
+
+        if (offset != NULL) {
+                offset->x = reference_width / 2;
+                offset->y = vehicle_pitch;
+        }
+        //printf("  refwid:%d  gdiw.cachedvehlen(%d):%d  ", reference_width, this->engine_type, this->gcache.cached_veh_length);
+        return t->gcache.cached_veh_length * reference_width / VEHICLE_LENGTH;
+}
+
+Train* CmdBuildVirtualRailWagon(const Engine *e)
+{
+        const RailVehicleInfo *rvi = &e->u.rail;
+
+        Train *v = new Train();
+
+        v->x_pos = 0;
+        v->y_pos = 0;
+
+        v->spritenum = rvi->image_index;
+
+        v->engine_type = e->index;
+        v->gcache.first_engine = INVALID_ENGINE; // needs to be set before first callback
+
+        v->direction = DIR_W;
+        v->tile = 0;//INVALID_TILE;
+
+        v->owner = _current_company;
+        v->track = TRACK_BIT_DEPOT;
+        v->vehstatus = VS_HIDDEN | VS_DEFPAL;
+
+        v->SetWagon();
+        v->SetFreeWagon();
+
+        v->cargo_type = e->GetDefaultCargoType();
+        v->cargo_cap = rvi->capacity;
+
+        v->railtype = rvi->railtype;
+
+        v->build_year = _cur_year;
+        v->cur_image = SPR_IMG_QUERY;
+        v->random_bits = VehicleRandomBits();
+
+        v->group_id = DEFAULT_GROUP;
+
+        AddArticulatedParts(v);
+
+        _new_vehicle_id = v->index;
+
+        // from revision r22xxx
+        // VehicleMove(v, false);
+        // new
+        VehicleUpdateViewport(v, false);
+
+        v->First()->ConsistChanged(false);
+        //UpdateTrainGroupID(v->First());
+
+        CheckConsistencyOfArticulatedVehicle(v);
+
+        /* The GVSF_VIRTUAL flag is used to prevent depot-tile sanity checks */
+        SetBit(v->subtype, GVSF_VIRTUAL);
+
+//      GroupStatistics::CountVehicle( v, -1 );
+
+        return v;
+}
+/**
+ * Build a railroad vehicle.
+ * @param tile     tile of the depot where rail-vehicle is built.
+ * @param flags    type of operation.
+ * @param e        the engine to build.
+ * @param data     bit 0 prevents any free cars from being added to the train.
+ * @param ret[out] the vehicle that has been built.
+ * @return the cost of this operation or an error.
+ */
+Train* CmdBuildVirtualRailVehicle(EngineID eid)
+{
+        if ( !IsEngineBuildable(eid, VEH_TRAIN, _current_company) ) return 0;
+        const Engine* e = Engine::Get(eid);
+        const RailVehicleInfo *rvi = &e->u.rail;
+
+        int num_vehicles = (e->u.rail.railveh_type == RAILVEH_MULTIHEAD ? 2 : 1) + CountArticulatedParts(eid, false);
+        if ( !Train::CanAllocateItem(num_vehicles) ) return 0;
+        if (rvi->railveh_type == RAILVEH_WAGON) return CmdBuildVirtualRailWagon(e);
+
+        Train *v = new Train();
+
+        v->x_pos = 0;
+        v->y_pos = 0;
+
+        v->direction = DIR_W;
+        v->tile = 0;//INVALID_TILE;
+        v->owner = _current_company;
+        v->track = TRACK_BIT_DEPOT;
+        v->vehstatus = VS_HIDDEN | VS_STOPPED | VS_DEFPAL;
+        v->spritenum = rvi->image_index;
+        v->cargo_type = e->GetDefaultCargoType();
+        v->cargo_cap = rvi->capacity;
+        v->last_station_visited = INVALID_STATION;
+
+        v->engine_type = e->index;
+        v->gcache.first_engine = INVALID_ENGINE; // needs to be set before first callback
+
+        v->reliability = e->reliability;
+        v->reliability_spd_dec = e->reliability_spd_dec;
+        v->max_age = e->GetLifeLengthInDays();
+
+        v->railtype = rvi->railtype;
+        _new_vehicle_id = v->index;
+
+        v->cur_image = SPR_IMG_QUERY;
+        v->random_bits = VehicleRandomBits();
+
+        v->group_id = DEFAULT_GROUP;
+
+        v->SetFrontEngine();
+        v->SetEngine();
+
+        // from revision r22xxx
+//      VehicleMove(v, false);
+        //      new
+        VehicleUpdateViewport(v, false);
+
+        if (rvi->railveh_type == RAILVEH_MULTIHEAD) {
+                AddRearEngineToMultiheadedTrain(v);
+        } else {
+                AddArticulatedParts(v);
+        }
+
+        v->ConsistChanged(false);
+        //UpdateTrainGroupID(v);
+
+        CheckConsistencyOfArticulatedVehicle(v);
+
+        SetBit(v->subtype, GVSF_VIRTUAL);
+
+//      GroupStatistics::CountVehicle( v, -1 );
+
+        return v;
+}
+
+/**
+ * Delete a train while it is visible.
+ * This happens when a company bankrupts when infrastructure sharing is enabled.
+ * @param v The train to delete.
+ */
+void DeleteVisibleTrain(Train *v)
+{
+	FreeTrainTrackReservation(v);
+	TileIndex crossing = TrainApproachingCrossingTile(v);
+
+	/* delete train from back to front */
+	Train *u;
+	Train *prev = v->Last();
+	do {
+		u = prev;
+		prev = u->Previous();
+		if (prev != NULL) prev->SetNext(NULL);
+
+		/* 'u' shouldn't be accessed after it has been deleted */
+		TileIndex tile = u->tile;
+		TrackBits trackbits = u->track;
+
+		delete u;
+
+		if (trackbits == TRACK_BIT_WORMHOLE) {
+			/* Vehicle is inside a wormhole, u->track contains no useful value then. */
+			trackbits = DiagDirToDiagTrackBits(GetTunnelBridgeDirection(tile));
+		}
+
+		Track track = TrackBitsToTrack(trackbits);
+		if (HasReservedTracks(tile, trackbits)) UnreserveRailTrack(tile, track);
+		if (IsLevelCrossingTile(tile)) UpdateLevelCrossing(tile);
+
+		/* Update signals */
+		if (IsTileType(tile, MP_TUNNELBRIDGE) || IsRailDepotTile(tile)) {
+			AddSideToSignalBuffer(tile, INVALID_DIAGDIR, GetTileOwner(tile));
+		} else {
+			AddTrackToSignalBuffer(tile, track, GetTileOwner(tile));
+		}
+	} while (prev != NULL);
+
+	if (crossing != INVALID_TILE) UpdateLevelCrossing(crossing);
+
+	UpdateSignalsInBuffer();
+}
\ No newline at end of file
diff -urNad openttd-1.3.2/src/train_gui.cpp openttd-1.3.2-DC3.0RC3/src/train_gui.cpp
--- openttd-1.3.2/src/train_gui.cpp	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/train_gui.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -18,6 +18,9 @@
 
 #include "table/strings.h"
 
+// MYGUI_NOEND
+#include <stdio.h>
+
 /**
  * Callback for building wagons.
  * @param result The result of the command.
@@ -55,7 +58,8 @@
  * @param selection Selected vehicle that is dragged.
  * @return The width of the highlight mark.
  */
-static int HighlightDragPosition(int px, int max_width, VehicleID selection)
+// MYGUI_NOEND previously static
+int HighlightDragPosition(int px, int max_width, VehicleID selection)
 {
 	bool rtl = _current_text_dir == TD_RTL;
 
@@ -310,9 +314,11 @@
 	if (det_tab == TDW_TAB_TOTALS) { // Total cargo tab
 		CargoArray act_cargo;
 		CargoArray max_cargo;
+		CargoDestSummary dests[NUM_CARGO];
 		for (const Vehicle *v = Vehicle::Get(veh_id); v != NULL; v = v->Next()) {
 			act_cargo[v->cargo_type] += v->cargo.Count();
 			max_cargo[v->cargo_type] += v->cargo_cap;
+			AddVehicleCargoDestSummary(v, &dests[v->cargo_type]);
 		}
 
 		/* Set scroll-amount separately from counting, as to not compute num double
@@ -320,8 +326,9 @@
 		 */
 		for (CargoID i = 0; i < NUM_CARGO; i++) {
 			if (max_cargo[i] > 0) num++; // only count carriages that the train has
+			num += (int)dests[i].size();
 		}
-		num++; // needs one more because first line is description string
+		num += 2; // needs one more because first line is description string
 	} else {
 		for (const Train *v = Train::Get(veh_id); v != NULL; v = v->GetNextVehicle()) {
 			GetCargoSummaryOfArticulatedVehicle(v, &_cargo_summary);
@@ -421,12 +428,15 @@
 	} else {
 		CargoArray act_cargo;
 		CargoArray max_cargo;
+		CargoDestSummary dests[NUM_CARGO];
 		Money feeder_share = 0;
 
 		for (const Vehicle *u = v; u != NULL; u = u->Next()) {
 			act_cargo[u->cargo_type] += u->cargo.Count();
 			max_cargo[u->cargo_type] += u->cargo_cap;
 			feeder_share             += u->cargo.FeederShare();
+
+			AddVehicleCargoDestSummary(u, &dests[u->cargo_type]);
 		}
 
 		/* draw total cargo tab */
@@ -443,6 +453,17 @@
 				DrawString(left, right, y, FreightWagonMult(i) > 1 ? STR_VEHICLE_DETAILS_TRAIN_TOTAL_CAPACITY_MULT : STR_VEHICLE_DETAILS_TRAIN_TOTAL_CAPACITY);
 				y += WD_MATRIX_TOP + FONT_HEIGHT_NORMAL + WD_MATRIX_BOTTOM;
 			}
+
+			for (CargoDestSummary::const_iterator row = dests[i].begin(); row != dests[i].end() && vscroll_pos > -vscroll_cap; ++row) {
+				if (--vscroll_pos < 0) {
+					SetDParam(0, i);          // {SHORTCARGO} #1
+					SetDParam(1, row->count); // {SHORTCARGO} #2
+					SetDParam(2, row->type == ST_INDUSTRY ? STR_INDUSTRY_NAME : (row->type == ST_TOWN ? STR_TOWN_NAME : STR_COMPANY_NAME)); // {STRING1}
+					SetDParam(3, row->dest);  // Parameter of {STRING1}
+					DrawString(left + 2 * WD_PAR_VSEP_WIDE, right, y, STR_VEHICLE_DETAILS_CARGO_TO);
+					y += WD_MATRIX_TOP + FONT_HEIGHT_NORMAL + WD_MATRIX_BOTTOM;
+				}
+			}
 		}
 		SetDParam(0, feeder_share);
 		DrawString(left, right, y, STR_VEHICLE_INFO_FEEDER_CARGO_VALUE);
diff -urNad openttd-1.3.2/src/train.h openttd-1.3.2-DC3.0RC3/src/train.h
--- openttd-1.3.2/src/train.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/train.h	2013-11-22 05:49:07.000000000 +0100
@@ -48,6 +48,8 @@
 void FreeTrainTrackReservation(const Train *v, TileIndex origin = INVALID_TILE, Trackdir orig_td = INVALID_TRACKDIR);
 bool TryPathReserve(Train *v, bool mark_as_stuck = false, bool first_tile_okay = false);
 
+void DeleteVisibleTrain(Train *v);
+
 int GetTrainStopLocation(StationID station_id, TileIndex tile, const Train *v, int *station_ahead, int *station_length);
 
 void GetTrainSpriteSize(EngineID engine, uint &width, uint &height, int &xoffs, int &yoffs, EngineImageType image_type);
@@ -104,6 +106,7 @@
 	Money GetRunningCost() const;
 	int GetDisplayImageWidth(Point *offset = NULL) const;
 	bool IsInDepot() const { return this->track == TRACK_BIT_DEPOT; }
+	Money CalculateCurrentOverallValue() const;
 	bool Tick();
 	void OnNewDay();
 	uint Crash(bool flooded = false);
@@ -147,6 +150,13 @@
 		return v;
 	}
 
+	// MYGUI
+	inline Train *GetLastUnit() {
+		Train *tmp = this;
+		while ( tmp->GetNextUnit() ) tmp = tmp->GetNextUnit();
+		return tmp;
+	}
+
 	/**
 	 * Calculate the offset from this vehicle's center to the following center taking the vehicle lengths into account.
 	 * @return Offset from center to center.
@@ -320,6 +330,16 @@
 	}
 };
 
+
+// TODO
+CommandCost CmdBuildRailVehicle(TileIndex, DoCommandFlag, const Engine *, uint16, Vehicle**);
+CommandCost CmdMoveRailVehicle(TileIndex, DoCommandFlag , uint32, uint32, const char *);
+CommandCost CmdMoveVirtualRailVehicle(TileIndex, DoCommandFlag, uint32, uint32, const char*);
+
+Train* CmdBuildVirtualRailWagon(const Engine*);
+Train* CmdBuildVirtualRailVehicle(EngineID);
+CommandCost CmdSellRailWagon(DoCommandFlag, Vehicle*, uint16, uint32);
+
 #define FOR_ALL_TRAINS(var) FOR_ALL_VEHICLES_OF_TYPE(Train, var)
 
 #endif /* TRAIN_H */
diff -urNad openttd-1.3.2/src/transparency_gui.cpp openttd-1.3.2-DC3.0RC3/src/transparency_gui.cpp
--- openttd-1.3.2/src/transparency_gui.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/transparency_gui.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -50,6 +50,7 @@
 			case WID_TT_BRIDGES:
 			case WID_TT_STRUCTURES:
 			case WID_TT_CATENARY:
+			case WID_TT_TUNNELS:
 			case WID_TT_LOADING: {
 				uint i = widget - WID_TT_BEGIN;
 				if (HasBit(_transparency_lock, i)) DrawSprite(SPR_LOCK, PAL_NONE, r.left + 1, r.top + 1);
@@ -57,7 +58,7 @@
 			}
 			case WID_TT_BUTTONS:
 				for (uint i = WID_TT_BEGIN; i < WID_TT_END; i++) {
-					if (i == WID_TT_LOADING) continue; // Do not draw button for invisible loading indicators.
+					if (i >= WID_TT_LOADING) continue; // Do not draw button for invisible loading indicators.
 
 					const NWidgetBase *wi = this->GetWidget<NWidgetBase>(i);
 					DrawFrameRect(wi->pos_x + 1, r.top + 2, wi->pos_x + wi->current_x - 2, r.bottom - 2, COLOUR_PALE_GREEN,
@@ -139,6 +140,7 @@
 		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_TT_STRUCTURES), SetMinimalSize(22, 22), SetFill(0, 1), SetDataTip(SPR_IMG_TRANSMITTER, STR_TRANSPARENT_STRUCTURES_TOOLTIP),
 		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_TT_CATENARY), SetMinimalSize(22, 22), SetFill(0, 1), SetDataTip(SPR_BUILD_X_ELRAIL, STR_TRANSPARENT_CATENARY_TOOLTIP),
 		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_TT_LOADING), SetMinimalSize(22, 22), SetFill(0, 1), SetDataTip(SPR_IMG_TRAINLIST, STR_TRANSPARENT_LOADING_TOOLTIP),
+		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_TT_TUNNELS), SetMinimalSize(22, 22), SetFill(0, 1), SetDataTip(SPR_IMG_ROAD_TUNNEL, STR_TRANSPARENT_TUNNELS_TOOLTIP),
 		NWidget(WWT_PANEL, COLOUR_DARK_GREEN), SetFill(1, 1), EndContainer(),
 	EndContainer(),
 	/* Panel with 'invisibility' buttons. */
@@ -156,6 +158,7 @@
 /**
  * Show the transparency toolbar.
  */
+
 void ShowTransparencyToolbar()
 {
 	AllocateWindowDescFront<TransparenciesWindow>(&_transparency_desc, 0);
diff -urNad openttd-1.3.2/src/transparency.h openttd-1.3.2-DC3.0RC3/src/transparency.h
--- openttd-1.3.2/src/transparency.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/transparency.h	2013-11-22 05:49:07.000000000 +0100
@@ -31,6 +31,7 @@
 	TO_STRUCTURES, ///< other objects such as transmitters and lighthouses
 	TO_CATENARY,   ///< catenary
 	TO_LOADING,    ///< loading indicators
+	TO_TUNNELS,    ///< vehicles in tunnels
 	TO_END,
 	TO_INVALID,    ///< Invalid transparency option
 };
diff -urNad openttd-1.3.2/src/tree_cmd.cpp openttd-1.3.2-DC3.0RC3/src/tree_cmd.cpp
--- openttd-1.3.2/src/tree_cmd.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/tree_cmd.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -131,7 +131,11 @@
 {
 	switch (_settings_game.game_creation.landscape) {
 		case LT_TEMPERATE:
-			return (TreeType)(seed * TREE_COUNT_TEMPERATE / 256 + TREE_TEMPERATE);
+			if (_settings_game.construction.snow_in_temperate) {
+				return (TreeType)(seed * TREE_COUNT_SUB_ARCTIC / 256 + TREE_SUB_ARCTIC);
+			} else {
+				return (TreeType)(seed * TREE_COUNT_TEMPERATE / 256 + TREE_TEMPERATE);
+			};
 
 		case LT_ARCTIC:
 			return (TreeType)(seed * TREE_COUNT_SUB_ARCTIC / 256 + TREE_SUB_ARCTIC);
@@ -264,9 +268,12 @@
 			/* The higher we get, the more trees we plant */
 			j = GetTileZ(tile) * 2;
 			/* Above snowline more trees! */
-			if (_settings_game.game_creation.landscape == LT_ARCTIC && ht > GetSnowLine()) j *= 3;
-			while (j--) {
-				PlaceTreeAtSameHeight(tile, ht);
+                               if (_settings_game.game_creation.landscape == LT_ARCTIC || (_settings_game.construction.snow_in_temperate && _settings_game.game_creation.landscape == LT_TEMPERATE)) {
+                                       if (ht > GetSnowLine()) {
+                                               PlaceTreeAtSameHeight(tile, ht);
+                                               PlaceTreeAtSameHeight(tile, ht);
+                                       };
+
 			}
 		}
 	} while (--i);
@@ -451,6 +458,9 @@
 	if (cost.GetCost() == 0) {
 		return_cmd_error(msg);
 	} else {
+		if (_settings_game.economy.day_length_balance_type == DBT_ALL_COSTS) {
+			cost.AffectCost(_settings_game.economy.day_length_balance_factor);
+		}
 		return cost;
 	}
 }
@@ -468,6 +478,8 @@
 		default: DrawGroundSprite(_clear_land_sprites_snow_desert[GetTreeDensity(ti->tile)] + SlopeToSpriteOffset(ti->tileh), PAL_NONE); break;
 	}
 
+	DrawOverlay(ti, MP_TREES);
+
 	/* Do not draw trees when the invisible trees setting is set */
 	if (IsInvisibilitySet(TO_TREES)) return;
 
@@ -639,6 +651,7 @@
 		switch (_settings_game.game_creation.landscape) {
 			case LT_TROPIC: TileLoopTreesDesert(tile); break;
 			case LT_ARCTIC: TileLoopTreesAlps(tile);   break;
+			case LT_TEMPERATE: TileLoopTreesAlps(tile); break;
 		}
 	}
 
@@ -655,7 +668,14 @@
 		}
 	}
 	if (GetTreeCounter(tile) < 15) {
-		AddTreeCounter(tile, 1);
+		if (_settings_game.construction.tree_growth_rate > 0) {
+			/* Nature randomness */
+			uint8 grow_slowing_values[3] = { 5, 20, 120 }; // slow, very slow, extremely slow
+			uint16 prob = 0x10000 / grow_slowing_values[_settings_game.construction.tree_growth_rate - 1];
+			if (GB(Random(), 0, 16) < prob) AddTreeCounter(tile, 1);
+		} else {
+			AddTreeCounter(tile, 1);
+		}
 		return;
 	}
 	SetTreeCounter(tile, 0);
@@ -811,4 +831,5 @@
 	NULL,                     // vehicle_enter_tile_proc
 	GetFoundation_Trees,      // get_foundation_proc
 	TerraformTile_Trees,      // terraform_tile_proc
+	NULL                      // copypaste_tile_proc
 };
diff -urNad openttd-1.3.2/src/tree_map.h openttd-1.3.2-DC3.0RC3/src/tree_map.h
--- openttd-1.3.2/src/tree_map.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/tree_map.h	2013-11-22 05:49:07.000000000 +0100
@@ -74,7 +74,7 @@
 static inline TreeType GetTreeType(TileIndex t)
 {
 	assert(IsTileType(t, MP_TREES));
-	return (TreeType)_m[t].m3;
+	return (TreeType)GetTile(t)->m3;
 }
 
 /**
@@ -89,7 +89,7 @@
 static inline TreeGround GetTreeGround(TileIndex t)
 {
 	assert(IsTileType(t, MP_TREES));
-	return (TreeGround)GB(_m[t].m2, 6, 3);
+	return (TreeGround)GB(GetTile(t)->m2, 6, 3);
 }
 
 /**
@@ -114,7 +114,7 @@
 static inline uint GetTreeDensity(TileIndex t)
 {
 	assert(IsTileType(t, MP_TREES));
-	return GB(_m[t].m2, 4, 2);
+	return GB(GetTile(t)->m2, 4, 2);
 }
 
 /**
@@ -131,8 +131,8 @@
 static inline void SetTreeGroundDensity(TileIndex t, TreeGround g, uint d)
 {
 	assert(IsTileType(t, MP_TREES)); // XXX incomplete
-	SB(_m[t].m2, 4, 2, d);
-	SB(_m[t].m2, 6, 3, g);
+	SB(GetTile(t)->m2, 4, 2, d);
+	SB(GetTile(t)->m2, 6, 3, g);
 }
 
 /**
@@ -149,7 +149,7 @@
 static inline uint GetTreeCount(TileIndex t)
 {
 	assert(IsTileType(t, MP_TREES));
-	return GB(_m[t].m5, 6, 2) + 1;
+	return GB(GetTile(t)->m5, 6, 2) + 1;
 }
 
 /**
@@ -166,7 +166,7 @@
 static inline void AddTreeCount(TileIndex t, int c)
 {
 	assert(IsTileType(t, MP_TREES)); // XXX incomplete
-	_m[t].m5 += c << 6;
+	GetTile(t)->m5 += c << 6;
 }
 
 /**
@@ -181,7 +181,7 @@
 static inline uint GetTreeGrowth(TileIndex t)
 {
 	assert(IsTileType(t, MP_TREES));
-	return GB(_m[t].m5, 0, 3);
+	return GB(GetTile(t)->m5, 0, 3);
 }
 
 /**
@@ -196,7 +196,7 @@
 static inline void AddTreeGrowth(TileIndex t, int a)
 {
 	assert(IsTileType(t, MP_TREES)); // XXX incomplete
-	_m[t].m5 += a;
+	GetTile(t)->m5 += a;
 }
 
 /**
@@ -212,7 +212,7 @@
 static inline void SetTreeGrowth(TileIndex t, uint g)
 {
 	assert(IsTileType(t, MP_TREES)); // XXX incomplete
-	SB(_m[t].m5, 0, 3, g);
+	SB(GetTile(t)->m5, 0, 3, g);
 }
 
 /**
@@ -226,7 +226,7 @@
 static inline uint GetTreeCounter(TileIndex t)
 {
 	assert(IsTileType(t, MP_TREES));
-	return GB(_m[t].m2, 0, 4);
+	return GB(GetTile(t)->m2, 0, 4);
 }
 
 /**
@@ -241,7 +241,7 @@
 static inline void AddTreeCounter(TileIndex t, int a)
 {
 	assert(IsTileType(t, MP_TREES)); // XXX incomplete
-	_m[t].m2 += a;
+	GetTile(t)->m2 += a;
 }
 
 /**
@@ -256,7 +256,7 @@
 static inline void SetTreeCounter(TileIndex t, uint c)
 {
 	assert(IsTileType(t, MP_TREES)); // XXX incomplete
-	SB(_m[t].m2, 0, 4, c);
+	SB(GetTile(t)->m2, 0, 4, c);
 }
 
 /**
@@ -275,12 +275,12 @@
 {
 	SetTileType(t, MP_TREES);
 	SetTileOwner(t, OWNER_NONE);
-	_m[t].m2 = ground << 6 | density << 4 | 0;
-	_m[t].m3 = type;
-	_m[t].m4 = 0 << 5 | 0 << 2;
-	_m[t].m5 = count << 6 | growth;
-	SB(_m[t].m6, 2, 4, 0);
-	_me[t].m7 = 0;
+	GetTile(t)->m2 = ground << 6 | density << 4 | 0;
+	GetTile(t)->m3 = type;
+	GetTile(t)->m4 = 0 << 5 | 0 << 2;
+	GetTile(t)->m5 = count << 6 | growth;
+	SB(GetTileEx(t)->m6, 2, 4, 0);
+	GetTileEx(t)->m7 = 0;
 }
 
 #endif /* TREE_MAP_H */
diff -urNad openttd-1.3.2/src/triphistory_cmd.cpp openttd-1.3.2-DC3.0RC3/src/triphistory_cmd.cpp
--- openttd-1.3.2/src/triphistory_cmd.cpp	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/triphistory_cmd.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -0,0 +1,100 @@
+/** @file triphistory_cmd.cpp */
+
+#include "stdafx.h"
+#include "triphistory.h"
+#include "table/strings.h"
+
+void
+TripHistory::AddValue( Money mvalue, Date dvalue ) {
+	if ( 0 < dvalue ) {
+		t[ 0 ].profit += mvalue;
+		t[ 0 ].date = dvalue;
+	}
+}
+
+void
+TripHistory::NewRound( ) {
+	//move down
+	for ( int i = TRIP_LENGTH - 1; i > 0; i-- ) {
+		this->t[ i ] = this->t[ i - 1 ];
+		//this->trip_history_date_array[ i ] = this->trip_history_date_array[ i - 1 ];
+	}
+
+	this->t[ 0 ].profit = 0;
+	this->t[ 0 ].date = this->t[ 1 ].date;
+
+	//t.push_front( TripHistoryEntry( ) );
+}
+
+size_t
+TripHistory::UpdateCalculated( ) {
+
+	this->total_profit = 0;
+	this->total_change = 0;
+	this->avg_daylength = 0;
+	this->profit_per_day = 0;
+	uint i = 0;
+
+	//
+	while ( i < TRIP_LENGTH && t [ i ].date ) {
+		
+		if ( i > 0 ) {
+			t[ i - 1 ].profit_change =
+				FindPercentChange( t [ i - 1 ].profit, t[ i ].profit );
+			t[ i - 1 ].TBT = t[ i - 1 ].date - t[ i ].date;
+
+			if ( i > 1 ) t[ i - 2 ].TBT_change = t[ i - 2 ].TBT - t[ i - 1 ].TBT;//bad line i don't like it
+
+			//omit first -100% row
+			if ( i > 1 || t [ 0 ].profit_change != -100 )
+				this->total_change += t[ i - 1 ].profit_change;
+			this->avg_daylength += t[ i - 1 ].TBT;
+		}
+
+		// prepare summary
+		
+
+		this->total_profit += t[ i ].profit;
+		i++;
+	}
+
+	if ( i == 0 ) return 0 ;
+	
+	this->avg_daylength /= --i + 1;
+
+	if ( t[ 0 ].date != t[ i ].date ) {
+		this->profit_per_day = total_profit / ( t[ 0 ].date - t[ i ].date );
+	}
+
+	return i;
+	/*
+	Trips::reverse_iterator i = t.rbegin( );
+	while ( i < t.rend( ) ) {
+
+		if ( i + 1 != t.rend( ) ) {
+			(*( i + 1 )).profit_change =
+				FindPercentChange( ( *i ).profit, ( *( i + 1 ) ).profit ); // reverse_itenrator
+
+			( *( i + 1 ) ).TBT = ( *i ).date - ( *( i + 1 ) ).date;
+
+			if ( ( *i ).TBT ) ( *( i + 1 ) ).TBT_change = ( *i ).TBT - ( *( i + 1 ) ).TBT;
+
+			//omit first -100% row
+			this->total_change += ( *i ).profit_change;
+		}
+
+		// prepare summary
+		this->total_profit += ( *i ).profit;
+		this->avg_daylength += ( *i ).TBT;
+
+		i++;
+	}
+
+	this->avg_daylength /= t.size( );
+
+	if ( t.front( ).date != t.back( ).date ) {
+		this->profit_per_day = total_profit / ( t.front( ).date - t.back( ).date );
+	}
+
+	return t.size( );*/
+}
diff -urNad openttd-1.3.2/src/triphistory_gui.cpp openttd-1.3.2-DC3.0RC3/src/triphistory_gui.cpp
--- openttd-1.3.2/src/triphistory_gui.cpp	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/triphistory_gui.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -0,0 +1,221 @@
+/** @file triphistory_gui.cpp */
+
+#include "stdafx.h"
+#include "triphistory.h"
+#include "strings_func.h"
+#include "window_func.h"
+#include "gfx_func.h"
+#include "date_func.h"
+#include "vehicle_base.h"
+#include "table/strings.h"
+
+/* Names of the widgets. Keep them in the same order as in the widget array */
+enum VehicleTripWidgets {
+    VTH_CAPTION,
+    VTH_LABEL_RECEIVED,
+    VTH_LABEL_PROFIT,
+    VTH_LABEL_PERCHANGE,
+    VTH_LABEL_TBT,
+    VTH_LABEL_DAYCHANGE,
+    VTH_MATRIX_RECEIVED,
+    VTH_MATRIX_PROFIT,
+    VTH_MATRIX_PERCHANGE,
+    VTH_MATRIX_TBT,
+    VTH_MATRIX_DAYCHANGE,
+    VTH_SUMMARY,
+
+};
+static const NWidgetPart _vehicle_trip_history_widgets[] = {
+    	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
+		NWidget(WWT_CAPTION, COLOUR_GREY, VTH_CAPTION), SetDataTip(STR_TRIP_HISTORY_CAPTION, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_SHADEBOX, COLOUR_GREY),
+		NWidget(WWT_STICKYBOX, COLOUR_GREY),
+	EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_TEXTBTN, COLOUR_GREY, VTH_LABEL_RECEIVED),	SetMinimalSize(110, 0), SetMinimalTextLines(1, 2), SetResize(1, 0), SetFill(1, 0),
+			SetDataTip(STR_TRIP_HISTORY_RECEIVED_LABEL, STR_TRIP_HISTORY_RECEIVED_LABEL_TIP),
+		NWidget(WWT_TEXTBTN, COLOUR_GREY, VTH_LABEL_PROFIT),	SetMinimalSize(110, 0), SetMinimalTextLines(1, 2), SetResize(1, 0), SetFill(1, 0),
+			SetDataTip(STR_TRIP_HISTORY_PROFIT_LABEL,       STR_TRIP_HISTORY_PROFIT_LABEL_TIP),
+		NWidget(WWT_TEXTBTN, COLOUR_GREY, VTH_LABEL_PERCHANGE), SetMinimalSize(50, 0), SetMinimalTextLines(1, 2), SetResize(1, 0),SetFill(1, 0),
+			SetDataTip(STR_TRIP_HISTORY_DAYCHANGE_LABEL,    STR_TRIP_HISTORY_PERCHANGE_LABEL_TIP),
+		NWidget(WWT_TEXTBTN, COLOUR_GREY, VTH_LABEL_TBT),	SetMinimalSize(70, 0), SetMinimalTextLines(1, 2), SetResize(1, 0),SetFill(1, 0),
+			SetDataTip(STR_TRIP_HISTORY_TBT_LABEL,          STR_TRIP_HISTORY_TBT_LABEL_TIP),
+		NWidget(WWT_TEXTBTN, COLOUR_GREY, VTH_LABEL_DAYCHANGE), SetMinimalSize(50, 0), SetMinimalTextLines(1, 2), SetResize(1, 0),SetFill(1, 0),
+			SetDataTip(STR_TRIP_HISTORY_DAYCHANGE_LABEL,    STR_TRIP_HISTORY_DAYCHANGE_LABEL_TIP),
+	EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_MATRIX, COLOUR_GREY, VTH_MATRIX_RECEIVED),	SetMinimalSize(110, 0), SetDataTip((10 << MAT_ROW_START) | (1 << MAT_COL_START), STR_NULL), SetResize(1, 1),SetFill(1, 0),
+		NWidget(WWT_MATRIX, COLOUR_GREY, VTH_MATRIX_PROFIT),	SetMinimalSize(110, 0), SetDataTip((10 << MAT_ROW_START) | (1 << MAT_COL_START), STR_NULL), SetResize(1, 1),SetFill(1, 0),
+		NWidget(WWT_MATRIX, COLOUR_GREY, VTH_MATRIX_PERCHANGE), SetMinimalSize(50, 0), SetDataTip((10 << MAT_ROW_START) | (1 << MAT_COL_START), STR_NULL), SetResize(1, 1),SetFill(1, 0),
+		NWidget(WWT_MATRIX, COLOUR_GREY, VTH_MATRIX_TBT),	SetMinimalSize(70, 0), SetDataTip((10 << MAT_ROW_START) | (1 << MAT_COL_START), STR_NULL), SetResize(1, 1),SetFill(1, 0),
+		NWidget(WWT_MATRIX, COLOUR_GREY, VTH_MATRIX_DAYCHANGE), SetMinimalSize(50, 0), SetDataTip((10 << MAT_ROW_START) | (1 << MAT_COL_START), STR_NULL), SetResize(1, 1),SetFill(1, 0),
+	EndContainer(),
+	NWidget(WWT_PANEL, COLOUR_GREY, VTH_SUMMARY), SetMinimalTextLines(3, 2), SetResize(1, 0), SetFill(1, 0), EndContainer(),
+};
+
+struct VehicleTripHistoryWindow : Window {
+
+private:
+	uint8 valid_rows; // number of rows in trip history
+public:
+//	VehicleTripHistoryWindow(WindowDesc *desc, WindowNumber window_number) :
+	VehicleTripHistoryWindow(const WindowDesc *desc, WindowNumber window_number) :
+		Window(), valid_rows( 0 )
+	{
+		const Vehicle *v = Vehicle::Get(window_number);
+		this->CreateNestedTree(desc);
+		
+		this->FinishInitNested(desc,window_number);
+		this->owner = v->owner;
+		InvalidateData();
+	}
+/*
+	~VehicleTripHistoryWindow() {
+		if (Vehicle::IsValidID(this->window_number)) {
+			Vehicle *v = Vehicle::Get(this->window_number);
+			free(v->trip_history_pchange_array);
+			free(v->trip_history_TBT_array);
+			free(v->trip_history_TBT_change_array);
+			v->trip_history_avg_daylength = 0;
+			v->trip_history_profitpd = 0;
+			v->trip_history_total_change = 0;
+			v->trip_history_total_profit = 0;
+		}
+	}*/
+
+	virtual void OnInvalidateData(int data = 0, bool gui_scope = true) {
+		Vehicle *v = Vehicle::Get(this->window_number);
+		valid_rows = v->trip_history.UpdateCalculated();
+		this->SetDirty();
+	}
+
+	virtual void SetStringParameters(int widget) const
+	{
+		switch (widget) {
+			case VTH_CAPTION: SetDParam(0, this->window_number); break;
+		}
+	}
+
+	virtual void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize)
+	{
+		switch (widget) {
+			case VTH_SUMMARY: {
+				SetDParam(0, UINT64_MAX >> 2);
+				SetDParam(1, 100);
+				Dimension text_dim = GetStringBoundingBox(STR_TRIP_HISTORY_TOTALINCOME);
+				size->width = text_dim.width + WD_FRAMERECT_LEFT + WD_FRAMERECT_RIGHT;
+				break;
+			}
+
+			case VTH_LABEL_RECEIVED:
+			case VTH_MATRIX_RECEIVED: {
+				SetDParam(0, _date);
+				Dimension text_dim = GetStringBoundingBox(STR_TRIP_HISTORY_DATE);
+				size->width = text_dim.width + WD_MATRIX_LEFT + WD_MATRIX_RIGHT;
+				break;
+			}
+			case VTH_MATRIX_PROFIT:
+			case VTH_MATRIX_PERCHANGE:
+			case VTH_MATRIX_TBT:
+			case VTH_MATRIX_DAYCHANGE:
+				resize->height = FONT_HEIGHT_NORMAL + WD_MATRIX_TOP + WD_MATRIX_BOTTOM;
+				size->height = 10 * resize->height;
+				break;
+		}
+	}
+	virtual void DrawWidget(const Rect &r, int widget) const {
+	    	const Vehicle *v = Vehicle::Get(this->window_number);
+		int y = WD_FRAMERECT_TOP;
+		
+		switch( widget ) {
+		    case VTH_MATRIX_RECEIVED:
+			    for(int i = 0; i <= valid_rows; i++, y += FONT_HEIGHT_NORMAL + WD_MATRIX_TOP + WD_MATRIX_BOTTOM) {
+				    if (v->trip_history.t[i].date > 0) {
+					    SetDParam(0, v->trip_history.t[i].date);
+					    DrawString(r.left + WD_MATRIX_LEFT, r.right - WD_MATRIX_RIGHT, r.top + y, STR_TRIP_HISTORY_DATE, TC_BLACK, SA_RIGHT);
+				    }
+			    }
+			    break;
+		    case VTH_MATRIX_PROFIT:
+			    for(int i = 0; i <= valid_rows; i++, y += FONT_HEIGHT_NORMAL + WD_MATRIX_TOP + WD_MATRIX_BOTTOM) {
+				    if (v->trip_history.t[i].date > 0) {
+					    if ( v->trip_history.t[i].profit > 0 ) {
+						    SetDParam(0, v->trip_history.t[i].profit );
+						    DrawString(r.left + WD_MATRIX_LEFT, r.right - WD_MATRIX_RIGHT, r.top + y, STR_TRIP_HISTORY_PROFIT, TC_BLACK, SA_RIGHT);
+					    } else {
+						    SetDParam(0, -v->trip_history.t[i].profit);
+						    DrawString(r.left + WD_MATRIX_LEFT, r.right - WD_MATRIX_RIGHT, r.top + y, STR_TRIP_HISTORY_VIRTUAL_PROFIT, TC_BLACK, SA_RIGHT);
+					    }
+				    }
+			    }
+			    break;
+		    case VTH_MATRIX_PERCHANGE:
+			    for(int i = 0; i <= valid_rows; i++, y += FONT_HEIGHT_NORMAL + WD_MATRIX_TOP + WD_MATRIX_BOTTOM) {
+				    if (v->trip_history.t[i+1].date > 0) {
+					    SetDParam(0, v->trip_history.t[i].profit_change);
+					    DrawString(r.left + WD_MATRIX_LEFT, r.right - WD_MATRIX_RIGHT, r.top + y,
+						    v->trip_history.t[i].profit_change >= 0 ?
+							    STR_TRIP_HISTORY_PROFITCHANGEPOS :
+							    STR_TRIP_HISTORY_PROFITCHANGENEG, TC_BLACK, SA_RIGHT
+					    );
+				    }
+			    }
+			    break;
+		    case VTH_MATRIX_TBT:
+			    for(int i = 0; i <= valid_rows; i++, y += FONT_HEIGHT_NORMAL + WD_MATRIX_TOP + WD_MATRIX_BOTTOM) {
+				    if (v->trip_history.t[i].date > 0) {
+					    SetDParam(0, v->trip_history.t[i].TBT);
+					    DrawString(r.left + WD_MATRIX_LEFT, r.right - WD_MATRIX_RIGHT, r.top + y, STR_TRIP_HISTORY_TBT, TC_BLACK, SA_RIGHT);
+				    }
+			    }
+			    break;
+		    case VTH_MATRIX_DAYCHANGE:
+			    for(int i = 0; i <= valid_rows; i++, y += FONT_HEIGHT_NORMAL + WD_MATRIX_TOP + WD_MATRIX_BOTTOM) {
+				    if (v->trip_history.t[i+1].date > 0) {
+					    SetDParam(0, v->trip_history.t[i].TBT_change);
+					    DrawString(r.left + WD_MATRIX_LEFT, r.right - WD_MATRIX_RIGHT, r.top + y,
+						    v->trip_history.t[i].TBT_change > 0 ?
+							    STR_TRIP_HISTORY_TBTCHANGEPOS :
+							    STR_TRIP_HISTORY_TBTCHANGENEG, TC_BLACK, SA_RIGHT
+					    );
+				    }
+			    }
+			    break;
+		    case VTH_SUMMARY:
+			    SetDParam(0, valid_rows + 1);
+			    SetDParam(1, v->trip_history.total_profit);
+			    SetDParam(2, v->trip_history.profit_per_day);
+			    DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP, STR_TRIP_HISTORY_TOTALINCOME, TC_BLACK);
+			    SetDParam(0, v->trip_history.avg_daylength);
+			    DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + FONT_HEIGHT_NORMAL + WD_FRAMERECT_TOP, STR_TRIP_HISTORY_DAYAVERAGE, TC_BLACK);
+			    SetDParam(0, valid_rows + 1);
+			    SetDParam(1, v->trip_history.total_change);
+			    DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + 2*FONT_HEIGHT_NORMAL + WD_FRAMERECT_TOP, STR_TRIP_HISTORY_DAYAVERAGE_IMPROVEMENT, TC_BLACK);
+			    break;
+		}
+	}
+};
+
+static WindowDesc _vehicle_trip_history(
+	WDP_AUTO, 380, 191, 
+	WC_VEHICLE_TRIP_HISTORY,WC_VEHICLE_DETAILS,
+	0,
+	_vehicle_trip_history_widgets,
+	lengthof(_vehicle_trip_history_widgets)
+);
+//static const WindowDesc _vehicle_trip_history(
+//       WDP_AUTO, 380, 191,
+//       WC_VEHICLE_TRIP_HISTORY,WC_VEHICLE_DETAILS,
+//       WDF_UNCLICK_BUTTONS,
+//       _vehicle_trip_history_widgets,
+//       lengthof(_vehicle_trip_history_widgets)
+//);
+
+
+void ShowTripHistoryWindow(const Vehicle *v)
+{
+	if (!BringWindowToFrontById(WC_VEHICLE_TRIP_HISTORY, v->index)) {
+		AllocateWindowDescFront<VehicleTripHistoryWindow>(&_vehicle_trip_history, v->index);
+	}
+}
diff -urNad openttd-1.3.2/src/triphistory.h openttd-1.3.2-DC3.0RC3/src/triphistory.h
--- openttd-1.3.2/src/triphistory.h	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/triphistory.h	2013-11-22 05:49:07.000000000 +0100
@@ -0,0 +1,75 @@
+/** @file triphistory.h */
+
+#ifndef TRIPHISTORY_H
+#define TRIPHISTORY_H
+
+#include <deque>
+#include "window_gui.h"
+#include "strings_type.h"
+#include "economy_type.h"
+#include "date_type.h"
+
+// entries to save
+#define TRIP_LENGTH 10
+
+static inline int TripHistoryRound( float x ) 
+{
+	return int( x > 0.0 ? x + 0.5 : x - 0.5 );
+}
+
+struct TripHistoryEntry {
+	Money profit; // Saved
+	Date date; // Saved
+	int32 profit_change; // Calculated
+	Date TBT; // Calculated
+	int32 TBT_change; // Calculated
+
+	TripHistoryEntry( ) : profit( 0 ), date( 0 ), profit_change( 0 ), TBT( 0 ), TBT_change( 0 ) { };
+};
+
+/** Structure to hold data for each vehicle */
+struct TripHistory {
+	// a lot of saveload stuff for std::deque. So...
+	TripHistoryEntry t[ TRIP_LENGTH ];
+
+	Money total_profit; 
+	int32 avg_daylength; 
+	int32 total_change;
+	Money profit_per_day;
+
+	TripHistory( ) :
+		total_profit( 0 ),
+		avg_daylength( 0 ),
+		total_change( 0 ),
+		profit_per_day( 0 ) { }
+
+	void NewRound();
+
+	void AddValue( Money mvalue, Date dvalue );
+
+
+	/**
+	 * Init info for GUI
+	 *
+	 * @return size_t number of valid rows
+	 */
+	size_t UpdateCalculated( );
+
+	int32 FindPercentChange( Money v1, Money v2 ) {
+		float temp;
+
+		if ( v1 > v2 ) {
+			temp = v1 - v2;
+			return TripHistoryRound( ( float ) temp * 100 / ( float ) v1 );
+		}
+
+		if ( v2 > v1 ) {
+			temp = v1 - v2;
+			return TripHistoryRound( ( float ) temp * 100 / ( float ) v2 );
+		}
+
+		return 0;
+	}
+};
+
+#endif /* TRIPHISTORY_H */
diff -urNad openttd-1.3.2/src/tunnelbridge_cmd.cpp openttd-1.3.2-DC3.0RC3/src/tunnelbridge_cmd.cpp
--- openttd-1.3.2/src/tunnelbridge_cmd.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/tunnelbridge_cmd.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -17,6 +17,7 @@
 #include "newgrf_object.h"
 #include "viewport_func.h"
 #include "cmd_helper.h"
+#include "copypaste_cmd.h"
 #include "command_func.h"
 #include "town.h"
 #include "train.h"
@@ -40,6 +41,7 @@
 #include "object_base.h"
 #include "water.h"
 #include "company_gui.h"
+#include "clipboard_gui.h"
 
 #include "table/strings.h"
 #include "table/bridge_land.h"
@@ -196,6 +198,24 @@
 	return_cmd_error(STR_ERROR_BRIDGE_TOO_LONG);
 }
 
+BridgeType FastestAvailableBridgeType(uint bridge_len)
+{
+	BridgeType ret = MAX_BRIDGES;
+	uint max_speed = 0;
+
+	/* loop for all bridgetypes */
+	for (BridgeType brd_type = 0; brd_type != MAX_BRIDGES; brd_type++) {
+		if (CheckBridgeAvailability(brd_type, bridge_len).Failed()) continue;
+		uint speed = GetBridgeSpec(brd_type)->speed;
+		if (max_speed < speed) {
+			max_speed = speed;
+			ret = brd_type;
+		}
+	}
+
+	return ret;
+}
+
 /**
  * Build a Bridge
  * @param end_tile end tile
@@ -226,7 +246,7 @@
 	switch (transport_type) {
 		case TRANSPORT_ROAD:
 			roadtypes = Extract<RoadTypes, 8, 2>(p2);
-			if (!HasExactlyOneBit(roadtypes) || !HasRoadTypesAvail(company, roadtypes)) return CMD_ERROR;
+			if (!HasRoadTypesAvail(company, roadtypes)) return CMD_ERROR;
 			break;
 
 		case TRANSPORT_RAIL:
@@ -391,6 +411,13 @@
 		for (TileIndex tile = tile_start + delta; tile != tile_end; tile += delta) {
 			if (GetTileMaxZ(tile) > z_start) return_cmd_error(STR_ERROR_BRIDGE_TOO_LOW_FOR_TERRAIN);
 
+			if (z_start + TILE_HEIGHT > (TileHeight(tile) + MAX_BRIDGE_HEIGHT) * TILE_HEIGHT) {
+				/* z_start seems to be one height level below the bridge level in all cases.
+				 * So add one TILE_HEIGHT. Then compare, if the currently tested tile is too low.
+				 * If yes, we have a problem... */
+				return_cmd_error(STR_ERROR_BRIDGE_TOO_HIGH_FOR_TERRAIN);
+			}
+
 			if (MayHaveBridgeAbove(tile) && IsBridgeAbove(tile)) {
 				/* Disallow crossing bridges for the time being */
 				return_cmd_error(STR_ERROR_MUST_DEMOLISH_BRIDGE_FIRST);
@@ -544,7 +571,7 @@
  * @param flags type of operation
  * @param p1 bit 0-3 railtype or roadtypes
  *           bit 8-9 transport type
- * @param p2 unused
+ * @param p2 the end tile (only if DC_PASTE flags is set)
  * @param text unused
  * @return the cost of this operation or an error
  */
@@ -557,6 +584,9 @@
 	RailType railtype = INVALID_RAILTYPE;
 	RoadTypes rts = ROADTYPES_NONE;
 	_build_tunnel_endtile = 0;
+
+	TileIndex expected_end_tile = (flags & DC_PASTE) ? p2 : (uint32)0;
+
 	switch (transport_type) {
 		case TRANSPORT_RAIL:
 			railtype = Extract<RailType, 0, 4>(p1);
@@ -565,7 +595,7 @@
 
 		case TRANSPORT_ROAD:
 			rts = Extract<RoadTypes, 0, 2>(p1);
-			if (!HasExactlyOneBit(rts) || !HasRoadTypesAvail(company, rts)) return CMD_ERROR;
+			if (!HasRoadTypesAvail(company, rts)) return CMD_ERROR;
 			break;
 
 		default: return CMD_ERROR;
@@ -586,18 +616,39 @@
 	int start_z;
 	int end_z;
 	Slope start_tileh = GetTileSlope(start_tile, &start_z);
-	DiagDirection direction = GetInclinedSlopeDirection(start_tileh);
-	if (direction == INVALID_DIAGDIR) return_cmd_error(STR_ERROR_SITE_UNSUITABLE_FOR_TUNNEL);
+
+	DiagDirection direction;
+	if (expected_end_tile == 0) { // the end tile is given implicitly by the terrain
+		direction = GetInclinedSlopeDirection(start_tileh);
+		if (direction == INVALID_DIAGDIR) return_cmd_error(STR_ERROR_SITE_UNSUITABLE_FOR_TUNNEL);
+	} else { // the end tile is given explicitly
+		direction = DiagdirBetweenTiles(start_tile, expected_end_tile);
+		if (direction == INVALID_DIAGDIR) return CMD_ERROR;
+		if (InclinedSlope(direction) != RemoveHalftileSlope(start_tileh)) return_cmd_error(STR_ERROR_SITE_UNSUITABLE_FOR_TUNNEL);
+	}
 
 	if (HasTileWaterGround(start_tile)) return_cmd_error(STR_ERROR_CAN_T_BUILD_ON_WATER);
 
-	CommandCost ret = DoCommand(start_tile, 0, 0, flags, CMD_LANDSCAPE_CLEAR);
-	if (ret.Failed()) return ret;
+	/* Check if there is already the entrance we are willing to build */
+	bool may_be_already_built =
+			(flags & DC_PASTE) &&
+			IsTileOwner(start_tile, _current_company) &&
+			IsTunnelTile(start_tile) &&
+			GetTunnelBridgeTransportType(start_tile) == transport_type &&
+			GetTunnelBridgeDirection(start_tile) == direction &&
+			(transport_type == TRANSPORT_RAIL ? GetTileRailType(start_tile) == railtype : GetRoadTypes(start_tile) == rts);
 
-	/* XXX - do NOT change 'ret' in the loop, as it is used as the price
-	 * for the clearing of the entrance of the tunnel. Assigning it to
-	 * cost before the loop will yield different costs depending on start-
-	 * position, because of increased-cost-by-length: 'cost += cost >> 3' */
+	/* If the end tile is not given then we have a match already */
+	if (may_be_already_built && expected_end_tile == 0) return_cmd_error(STR_ERROR_ALREADY_BUILT);
+
+	CommandCost cost(EXPENSES_CONSTRUCTION);
+
+	/* Clear the entrance */
+	if (!may_be_already_built) {
+		CommandCost ret = DoCommand(start_tile, 0, 0, flags, CMD_LANDSCAPE_CLEAR);
+		if (ret.Failed()) return ret;
+		cost.AddCost(ret);
+	}
 
 	TileIndexDiff delta = TileOffsByDiagDir(direction);
 	DiagDirection tunnel_in_way_dir;
@@ -616,14 +667,21 @@
 	/* Number of tiles at which the cost increase coefficient per tile is halved */
 	int tiles_bump = 25;
 
-	CommandCost cost(EXPENSES_CONSTRUCTION);
+	/* XXX: The 'ret' is used recursively inside the loop to calculate the cost-by-length:
+	 * 'ret += ret >> 3'  */
+	CommandCost ret;
 	Slope end_tileh;
 	for (;;) {
 		end_tile += delta;
 		if (!IsValidTile(end_tile)) return_cmd_error(STR_ERROR_TUNNEL_THROUGH_MAP_BORDER);
 		end_tileh = GetTileSlope(end_tile, &end_z);
 
-		if (start_z == end_z) break;
+		if (start_z == end_z) break; // end of tunnel
+
+		if (end_tile == expected_end_tile) { // are we getting too far?
+			_build_tunnel_endtile = end_tile;
+			return_cmd_error(STR_ERROR_SITE_UNSUITABLE_FOR_TUNNEL);
+		}
 
 		if (!_cheats.crossing_tunnels.value && IsTunnelInWayDir(end_tile, start_z, tunnel_in_way_dir)) {
 			return_cmd_error(STR_ERROR_ANOTHER_TUNNEL_IN_THE_WAY);
@@ -635,13 +693,24 @@
 			tiles_bump *= 2;
 		}
 
-		cost.AddCost(_price[PR_BUILD_TUNNEL]);
-		cost.AddCost(cost.GetCost() >> tiles_coef); // add a multiplier for longer tunnels
+		ret.AddCost(_price[PR_BUILD_TUNNEL]);
+		ret.AddCost(ret.GetCost() >> tiles_coef); // add a multiplier for longer tunnels
 	}
 
+	/* is the end tile reached? */
+	if (expected_end_tile != 0 && expected_end_tile != end_tile) {
+		if (may_be_already_built) {
+			return_cmd_error(STR_ERROR_MUST_DEMOLISH_TUNNEL_FIRST);
+		} else {
+			return_cmd_error(STR_ERROR_SITE_UNSUITABLE);
+		}
+	}
+
+	/* booth ends match? */
+	if (may_be_already_built) return_cmd_error(STR_ERROR_ALREADY_BUILT);
+
 	/* Add the cost of the entrance */
 	cost.AddCost(_price[PR_BUILD_TUNNEL]);
-	cost.AddCost(ret);
 
 	/* if the command fails from here on we want the end tile to be highlighted */
 	_build_tunnel_endtile = end_tile;
@@ -650,7 +719,7 @@
 
 	if (HasTileWaterGround(end_tile)) return_cmd_error(STR_ERROR_CAN_T_BUILD_ON_WATER);
 
-	/* Clear the tile in any case */
+	/* Clear the end tile in any case */
 	ret = DoCommand(end_tile, 0, 0, flags, CMD_LANDSCAPE_CLEAR);
 	if (ret.Failed()) return_cmd_error(STR_ERROR_UNABLE_TO_EXCAVATE_LAND);
 	cost.AddCost(ret);
@@ -678,7 +747,7 @@
 
 	/* Pay for the rail/road in the tunnel including entrances */
 	switch (transport_type) {
-		case TRANSPORT_ROAD: cost.AddCost((tiles + 2) * _price[PR_BUILD_ROAD] * 2); break;
+		case TRANSPORT_ROAD: cost.AddCost((tiles + 2) * _price[PR_BUILD_ROAD] * 2 * CountBits(rts)); break;
 		case TRANSPORT_RAIL: cost.AddCost((tiles + 2) * RailBuildCost(railtype)); break;
 		default: break;
 	}
@@ -1174,6 +1243,8 @@
 				if (surface != 0) DrawGroundSprite(surface + tunnelbridge_direction, PAL_NONE);
 			}
 
+			DrawOverlay(ti, MP_TUNNELBRIDGE);
+
 			/* PBS debugging, draw reserved tracks darker */
 			if (_game_mode != GM_MENU && _settings_client.gui.show_track_reservation && HasTunnelBridgeReservation(ti->tile)) {
 				DrawGroundSprite(DiagDirToAxis(tunnelbridge_direction) == AXIS_X ? rti->base_sprites.single_x : rti->base_sprites.single_y, PALETTE_CRASH);
@@ -1572,6 +1643,7 @@
 {
 	bool snow_or_desert = HasTunnelBridgeSnowOrDesert(tile);
 	switch (_settings_game.game_creation.landscape) {
+		case LT_TEMPERATE:
 		case LT_ARCTIC: {
 			/* As long as we do not have a snow density, we want to use the density
 			 * from the entry edge. For tunnels this is the lowest point for bridges the highest point.
@@ -1841,6 +1913,178 @@
 	return DoCommand(tile, 0, 0, flags, CMD_LANDSCAPE_CLEAR);
 }
 
+static void CopyPastePlaceTunnel(GenericTileIndex tile, DiagDirection dir, uint mid_len, TransportType transport_type, uint rail_road_types)
+{
+	GenericTileIndex end_tile = TILE_ADDXY(tile, TileIndexDiffCByDiagDir(dir).x * (mid_len + 1), TileIndexDiffCByDiagDir(dir).y * (mid_len + 1));
+	if (IsMainMapTile(tile)) {
+		_current_pasting->DoCommand(AsMainMapTile(tile), rail_road_types | (transport_type << 8), AsMainMapTile(end_tile), CMD_BUILD_TUNNEL | CMD_MSG(STR_ERROR_CAN_T_BUILD_TUNNEL_HERE));
+		if (_current_pasting->last_result.Failed() && _current_pasting->last_result.GetErrorMessage() == _current_pasting->err_message && _build_tunnel_endtile != 0) {
+			_current_pasting->err_tile = _build_tunnel_endtile;
+		}
+	} else {
+		if (transport_type == TRANSPORT_RAIL) {
+			MakeRailTunnel(tile, OWNER_NONE, dir, (RailType)rail_road_types);
+			MakeRailTunnel(end_tile, OWNER_NONE, ReverseDiagDir(dir), (RailType)rail_road_types);
+		} else {
+			MakeRoadTunnel(tile, OWNER_NONE, dir, (RoadTypes)rail_road_types);
+			MakeRoadTunnel(end_tile, OWNER_NONE, ReverseDiagDir(dir), (RoadTypes)rail_road_types);
+		}
+	}
+}
+
+static void CopyPastePlaceBridge(GenericTileIndex tile, DiagDirection dir, uint mid_len, BridgeType bridgetype, TransportType transport_type, uint rail_road_types)
+{
+	GenericTileIndex end_tile = TILE_ADDXY(tile, TileIndexDiffCByDiagDir(dir).x * (mid_len + 1), TileIndexDiffCByDiagDir(dir).y * (mid_len + 1));
+	if (IsMainMapTile(tile)) {
+		_current_pasting->DoCommand(AsMainMapTile(end_tile), AsMainMapTile(tile), bridgetype | (rail_road_types << 8) | (transport_type << 15), CMD_BUILD_BRIDGE | CMD_MSG(STR_ERROR_CAN_T_BUILD_BRIDGE_HERE));
+	} else {
+		switch (transport_type) {
+			case TRANSPORT_RAIL:
+				MakeRailBridgeRamp(tile, OWNER_NONE, bridgetype, dir, (RailType)rail_road_types);
+				MakeRailBridgeRamp(end_tile, OWNER_NONE, bridgetype, ReverseDiagDir(dir), (RailType)rail_road_types);
+				break;
+
+			case TRANSPORT_ROAD:
+				MakeRoadBridgeRamp(tile, OWNER_NONE, OWNER_NONE, OWNER_NONE, bridgetype, dir, (RoadTypes)rail_road_types);
+				MakeRoadBridgeRamp(end_tile, OWNER_NONE, OWNER_NONE, OWNER_NONE, bridgetype, ReverseDiagDir(dir), (RoadTypes)rail_road_types);
+				break;
+
+			case TRANSPORT_WATER:
+				MakeAqueductBridgeRamp(tile, OWNER_NONE, dir);
+				MakeAqueductBridgeRamp(end_tile, OWNER_NONE, ReverseDiagDir(dir));
+				break;
+
+			default:
+				NOT_REACHED();
+		}
+
+		Axis axis = DiagDirToAxis(dir);
+		while (mid_len-- > 0) {
+			tile = TileAddByDiagDir(tile, dir);
+			SetBridgeMiddle(tile, axis);
+		}
+	}
+}
+
+/**
+ * Test a given tunnel/bridge tile if there is any contented to be copied from it.
+ *
+ * Tunnels and bridges can't be copy/pasted tile by tile, we have to do it in one step for all
+ * tiles (booth ends). So the function writes the other end to location pointed by \c other_end
+ * but only once per a tunnel/bridge - when it's northern tile is tested. For the second tile
+ * (second end) it still returns \c true but writes "invalid" tile.
+ *
+ * If the funtion returns \c false, \c object_rect remains unchanged.
+ *
+ * @param tile the tile to test
+ * @param src_area the area we are copying
+ * @param mode copy-paste mode
+ * @param other_end (out, may be NULL) other end or "invalid" tile, depending on which tile of the bridge was given
+ * @param company the #Company to check ownership against to
+ * @param preview (out, may be NULL) information on how to higlight preview of the tile
+ * @return whether this tile needs to be copy-pasted
+ */
+bool TestTunnelBridgeTileCopyability(GenericTileIndex tile, const GenericTileArea &src_area, CopyPasteMode mode, GenericTileIndex *other_end, CompanyID company = _current_company, TileContentPastePreview *preview = NULL)
+{
+	if (preview != NULL) MemSetT(preview, 0);
+
+	/* test ownership */
+	if (IsMainMapTile(tile) && !IsTileOwner(tile, company)) return false;
+	/* test if tunnel/bridge transport type is enabled in the current copy/paste mode */
+	TransportType tt = GetTunnelBridgeTransportType(tile);
+	assert_compile(CPM_WITH_RAIL_TRANSPORT == 1 << TRANSPORT_RAIL);
+	if (!HasBit(mode, tt)) return false;
+
+	if (IsMainMapTile(tile) || other_end != NULL) {
+		GenericTileIndex end_tile = GetOtherTunnelBridgeEnd(tile);
+		/* test if tunnel/bridge is within copy area */
+		if (IsMainMapTile(tile) && !src_area.Contains(end_tile)) return false;
+
+		if (other_end != NULL) {
+			*other_end = end_tile;
+			if (tile > end_tile) *other_end = GenericTileIndex(INVALID_TILE_INDEX, MapOf(tile)); // copy this tunnel/bridge only once
+		}
+	}
+
+	if (preview != NULL) {
+		preview->highlight_tile_rect = true;
+		if (tt == TRANSPORT_RAIL) preview->highlight_track_bits = AxisToTrackBits(DiagDirToAxis(GetTunnelBridgeDirection(tile)));
+	}
+
+	return true;
+}
+
+void CopyPasteTile_TunnelBridge(GenericTileIndex src_tile, GenericTileIndex dst_tile, const CopyPasteParams &copy_paste)
+{
+	GenericTileIndex src_other_end;
+	if (!TestTunnelBridgeTileCopyability(src_tile, copy_paste.src_area, copy_paste.mode, &src_other_end)) return; // src_other_end will be acquired
+	if (!IsValidTileIndex(src_other_end)) return; // copy this tunnel/bridge only once
+
+	DiagDirection src_dir = GetTunnelBridgeDirection(src_tile);
+	DiagDirection dst_dir = TransformDiagDir(src_dir, copy_paste.transformation);
+	uint mid_len = GetTunnelBridgeLength(src_tile, src_other_end);
+
+	/* Terrafrom tiles if needed */
+	if (IsMainMapTile(dst_tile) && (copy_paste.mode & CPM_TERRAFORM_MASK) == CPM_TERRAFORM_MINIMAL) {
+		TileIndex first_end = AsMainMapTile(dst_tile);
+		TileIndex second_end = first_end + (mid_len + 1) * ToTileIndexDiff(TileIndexDiffCByDiagDir(dst_dir));
+
+		/* copy-paste heights around entrances/heads */
+		CopyPasteHeights(GenericTileArea(src_tile, 1, 1), GenericTileIndex(first_end), copy_paste.transformation, copy_paste.height_delta);
+		if (IsPastingInterrupted()) return;
+		CopyPasteHeights(GenericTileArea(src_other_end, 1, 1), GenericTileIndex(second_end), copy_paste.transformation, copy_paste.height_delta);
+		if (IsPastingInterrupted()) return;
+
+		/* now level land in the middle */
+		if (mid_len > 1) {
+			/* calculate height and leveling variant */
+			CopyPasteLevelVariant variant;
+			uint height;
+			if (IsTunnel(src_tile)) {
+				variant = CPLV_LEVEL_BELOW;
+				height = GetTileMaxZ(src_tile);
+			} else {
+				variant = CPLV_LEVEL_ABOVE;
+				height = GetBridgeHeight(src_tile) - 1;
+			}
+			height += copy_paste.height_delta;
+
+			/* strat from the northern corner of the second (counting from north) middle tile
+			 * and finish at the southern corner of the last but one middle tile */
+			TileArea leveling_area(first_end, second_end);
+			if (DiagDirToAxis(dst_dir) == AXIS_X) {
+				leveling_area.tile += TileDiffXY(2, 0);
+				leveling_area.w -= 3; // length
+				leveling_area.h += 1;
+			} else {
+				leveling_area.tile += TileDiffXY(0, 2);
+				leveling_area.w += 1;
+				leveling_area.h -= 3; // length
+			}
+
+			/* level land */
+			LevelPasteLand(leveling_area, height, variant);
+			if (IsPastingInterrupted()) return;
+		}
+	}
+
+	TransportType transport_type = GetTunnelBridgeTransportType(src_tile);
+	uint rail_road_types = 0;
+	switch (transport_type) {
+		case TRANSPORT_RAIL: rail_road_types = (copy_paste.mode & CPM_CONVERT_RAILTYPE) ? copy_paste.railtype : GetRailType(src_tile); break;
+		case TRANSPORT_ROAD: rail_road_types = GetRoadTypes(src_tile); break;
+		default: break;
+	}
+
+	if (IsTunnel(src_tile)) {
+		CopyPastePlaceTunnel(dst_tile, dst_dir, mid_len, transport_type, rail_road_types);
+	} else {
+		BridgeType bridge_type = (copy_paste.mode & CPM_UPGRADE_BRIDGES) ? FastestAvailableBridgeType(mid_len) : GetBridgeType(src_tile);
+		CopyPastePlaceBridge(dst_tile, dst_dir, mid_len, bridge_type, transport_type, rail_road_types);
+	}
+}
+
+
 extern const TileTypeProcs _tile_type_tunnelbridge_procs = {
 	DrawTile_TunnelBridge,           // draw_tile_proc
 	GetSlopePixelZ_TunnelBridge,     // get_slope_z_proc
@@ -1856,4 +2100,5 @@
 	VehicleEnter_TunnelBridge,       // vehicle_enter_tile_proc
 	GetFoundation_TunnelBridge,      // get_foundation_proc
 	TerraformTile_TunnelBridge,      // terraform_tile_proc
+	CopyPasteTile_TunnelBridge,      // copypaste_tile_proc
 };
diff -urNad openttd-1.3.2/src/tunnelbridge.h openttd-1.3.2-DC3.0RC3/src/tunnelbridge.h
--- openttd-1.3.2/src/tunnelbridge.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/tunnelbridge.h	2013-11-22 05:49:07.000000000 +0100
@@ -15,12 +15,27 @@
 #include "map_func.h"
 
 /**
+ * Maximum height of bridge above ground.
+ * Used when building bridges and terraforming below bridges.
+ * Background: Before the more heightlevels patch, only bridges below height 15
+ * were possible, simply because the landscape wasn´t higher.  With more
+ * heightlevels enabled, one can think about higher bridges in terms of landscape.
+ * Unfortunately, if a bridge becomes higher than height 15, one will see serious
+ * glitches.  Fixing them would be a fairly hard problem.  So, also as even more
+ * high bridges are fairly unrealistic either and this is no restriction compared
+ * to the situation before more heightlevels, the height of bridges is limited
+ * to height 15.
+ */
+static const int MAX_BRIDGE_HEIGHT = 15;
+
+/**
  * Calculates the length of a tunnel or a bridge (without end tiles)
  * @param begin The begin of the tunnel or bridge.
  * @param end   The end of the tunnel or bridge.
  * @return length of bridge/tunnel middle
  */
-static inline uint GetTunnelBridgeLength(TileIndex begin, TileIndex end)
+template <bool Tgeneric>
+static inline uint GetTunnelBridgeLength(typename TileIndexT<Tgeneric>::T begin, typename TileIndexT<Tgeneric>::T end)
 {
 	int x1 = TileX(begin);
 	int y1 = TileY(begin);
@@ -29,6 +44,10 @@
 
 	return abs(x2 + y2 - x1 - y1) - 1;
 }
+/** @copydoc GetTunnelBridgeLength(TileIndexT<Tgeneric>::T,TileIndexT<Tgeneric>::T) */
+static inline uint GetTunnelBridgeLength(TileIndex begin, TileIndex end) { return GetTunnelBridgeLength<false>(begin, end); }
+/** @copydoc GetTunnelBridgeLength(TileIndexT<Tgeneric>::T,TileIndexT<Tgeneric>::T) */
+static inline uint GetTunnelBridgeLength(GenericTileIndex begin, GenericTileIndex end) { return GetTunnelBridgeLength<true>(begin, end); }
 
 extern TileIndex _build_tunnel_endtile;
 
diff -urNad openttd-1.3.2/src/tunnelbridge_map.h openttd-1.3.2-DC3.0RC3/src/tunnelbridge_map.h
--- openttd-1.3.2/src/tunnelbridge_map.h	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/tunnelbridge_map.h	2013-11-22 05:49:07.000000000 +0100
@@ -25,11 +25,16 @@
  * @pre IsTileType(t, MP_TUNNELBRIDGE)
  * @return the above mentioned direction
  */
-static inline DiagDirection GetTunnelBridgeDirection(TileIndex t)
+template <bool Tgeneric>
+static inline DiagDirection GetTunnelBridgeDirection(typename TileIndexT<Tgeneric>::T t)
 {
 	assert(IsTileType(t, MP_TUNNELBRIDGE));
-	return (DiagDirection)GB(_m[t].m5, 0, 2);
+	return (DiagDirection)GB(GetTile(t)->m5, 0, 2);
 }
+/** @copydoc GetTunnelBridgeDirection(TileIndexT<Tgeneric>::T) */
+static inline DiagDirection GetTunnelBridgeDirection(TileIndex t) { return GetTunnelBridgeDirection<false>(t); }
+/** @copydoc GetTunnelBridgeDirection(TileIndexT<Tgeneric>::T) */
+static inline DiagDirection GetTunnelBridgeDirection(GenericTileIndex t) { return GetTunnelBridgeDirection<true>(t); }
 
 /**
  * Tunnel: Get the transport type of the tunnel (road or rail)
@@ -38,11 +43,16 @@
  * @pre IsTileType(t, MP_TUNNELBRIDGE)
  * @return the transport type in the tunnel/bridge
  */
-static inline TransportType GetTunnelBridgeTransportType(TileIndex t)
+template <bool Tgeneric>
+static inline TransportType GetTunnelBridgeTransportType(typename TileIndexT<Tgeneric>::T t)
 {
 	assert(IsTileType(t, MP_TUNNELBRIDGE));
-	return (TransportType)GB(_m[t].m5, 2, 2);
+	return (TransportType)GB(GetTile(t)->m5, 2, 2);
 }
+/** @copydoc GetTunnelBridgeTransportType(TileIndexT<Tgeneric>::T) */
+static inline TransportType GetTunnelBridgeTransportType(TileIndex t) { return GetTunnelBridgeTransportType<false>(t); }
+/** @copydoc GetTunnelBridgeTransportType(TileIndexT<Tgeneric>::T) */
+static inline TransportType GetTunnelBridgeTransportType(GenericTileIndex t) { return GetTunnelBridgeTransportType<true>(t); }
 
 /**
  * Tunnel: Is this tunnel entrance in a snowy or desert area?
@@ -54,7 +64,7 @@
 static inline bool HasTunnelBridgeSnowOrDesert(TileIndex t)
 {
 	assert(IsTileType(t, MP_TUNNELBRIDGE));
-	return HasBit(_me[t].m7, 5);
+	return HasBit(GetTileEx(t)->m7, 5);
 }
 
 /**
@@ -68,7 +78,7 @@
 static inline void SetTunnelBridgeSnowOrDesert(TileIndex t, bool snow_or_desert)
 {
 	assert(IsTileType(t, MP_TUNNELBRIDGE));
-	SB(_me[t].m7, 5, 1, snow_or_desert);
+	SB(GetTileEx(t)->m7, 5, 1, snow_or_desert);
 }
 
 /**
@@ -77,11 +87,16 @@
  * @pre IsTileType(t, MP_TUNNELBRIDGE)
  * @return other end
  */
-static inline TileIndex GetOtherTunnelBridgeEnd(TileIndex t)
+template <bool Tgeneric>
+static inline typename TileIndexT<Tgeneric>::T GetOtherTunnelBridgeEnd(typename TileIndexT<Tgeneric>::T t)
 {
 	assert(IsTileType(t, MP_TUNNELBRIDGE));
 	return IsTunnel(t) ? GetOtherTunnelEnd(t) : GetOtherBridgeEnd(t);
 }
+/** @copydoc GetOtherTunnelBridgeEnd(TileIndexT<Tgeneric>::T) */
+static inline TileIndex GetOtherTunnelBridgeEnd(TileIndex t) { return GetOtherTunnelBridgeEnd<false>(t); }
+/** @copydoc GetOtherTunnelBridgeEnd(TileIndexT<Tgeneric>::T) */
+static inline GenericTileIndex GetOtherTunnelBridgeEnd(GenericTileIndex t) { return GetOtherTunnelBridgeEnd<true>(t); }
 
 
 /**
@@ -94,7 +109,7 @@
 {
 	assert(IsTileType(t, MP_TUNNELBRIDGE));
 	assert(GetTunnelBridgeTransportType(t) == TRANSPORT_RAIL);
-	return HasBit(_m[t].m5, 4);
+	return HasBit(GetTile(t)->m5, 4);
 }
 
 /**
@@ -107,7 +122,7 @@
 {
 	assert(IsTileType(t, MP_TUNNELBRIDGE));
 	assert(GetTunnelBridgeTransportType(t) == TRANSPORT_RAIL);
-	SB(_m[t].m5, 4, 1, b ? 1 : 0);
+	SB(GetTile(t)->m5, 4, 1, b ? 1 : 0);
 }
 
 /**
diff -urNad openttd-1.3.2/src/tunnel_map.cpp openttd-1.3.2-DC3.0RC3/src/tunnel_map.cpp
--- openttd-1.3.2/src/tunnel_map.cpp	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/tunnel_map.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -19,10 +19,11 @@
  * @param tile the tile to search from.
  * @return the tile of the other end of the tunnel.
  */
-TileIndex GetOtherTunnelEnd(TileIndex tile)
+template <bool Tgeneric>
+typename TileIndexT<Tgeneric>::T GetOtherTunnelEnd(typename TileIndexT<Tgeneric>::T tile)
 {
 	DiagDirection dir = GetTunnelBridgeDirection(tile);
-	TileIndexDiff delta = TileOffsByDiagDir(dir);
+	TileIndexDiff delta = TileOffsByDiagDir<Tgeneric>(dir, MapOf(tile));
 	int z = GetTileZ(tile);
 
 	dir = ReverseDiagDir(dir);
@@ -36,7 +37,9 @@
 
 	return tile;
 }
-
+/* instantiate */
+template TileIndex GetOtherTunnelEnd<false>(TileIndex tile);
+template GenericTileIndex GetOtherTunnelEnd<true>(GenericTileIndex tile);
 
 /**
  * Is there a tunnel in the way in the given direction?
diff -urNad openttd-1.3.2/src/tunnel_map.h openttd-1.3.2-DC3.0RC3/src/tunnel_map.h
--- openttd-1.3.2/src/tunnel_map.h	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/tunnel_map.h	2013-11-22 05:49:07.000000000 +0100
@@ -21,23 +21,39 @@
  * @pre IsTileType(t, MP_TUNNELBRIDGE)
  * @return true if and only if this tile is a tunnel (entrance)
  */
-static inline bool IsTunnel(TileIndex t)
+template <bool Tgeneric>
+static inline bool IsTunnel(typename TileIndexT<Tgeneric>::T t)
 {
 	assert(IsTileType(t, MP_TUNNELBRIDGE));
-	return !HasBit(_m[t].m5, 7);
+	return !HasBit(GetTile(t)->m5, 7);
 }
+/** @copydoc IsTunnel(TileIndexT<Tgeneric>::T) */
+static inline bool IsTunnel(TileIndex t) { return IsTunnel<false>(t); }
+/** @copydoc IsTunnel(TileIndexT<Tgeneric>::T) */
+static inline bool IsTunnel(GenericTileIndex t) { return IsTunnel<true>(t); }
 
 /**
  * Is this a tunnel (entrance)?
  * @param t the tile that might be a tunnel
  * @return true if and only if this tile is a tunnel (entrance)
  */
-static inline bool IsTunnelTile(TileIndex t)
+template <bool Tgeneric>
+static inline bool IsTunnelTile(typename TileIndexT<Tgeneric>::T t)
 {
 	return IsTileType(t, MP_TUNNELBRIDGE) && IsTunnel(t);
 }
+/** @copydoc IsTunnelTile(TileIndexT<Tgeneric>::T) */
+static inline bool IsTunnelTile(TileIndex t) { return IsTunnelTile<false>(t); }
+/** @copydoc IsTunnelTile(TileIndexT<Tgeneric>::T) */
+static inline bool IsTunnelTile(GenericTileIndex t) { return IsTunnelTile<true>(t); }
+
+template <bool Tgeneric>
+typename TileIndexT<Tgeneric>::T GetOtherTunnelEnd(typename TileIndexT<Tgeneric>::T t);
+/** @copydoc GetOtherTunnelEnd(TileIndexT<Tgeneric>::T) */
+static inline TileIndex GetOtherTunnelEnd(TileIndex t) { return GetOtherTunnelEnd<false>(t); }
+/** @copydoc GetOtherTunnelEnd(TileIndexT<Tgeneric>::T) */
+static inline GenericTileIndex GetOtherTunnelEnd(GenericTileIndex t) { return GetOtherTunnelEnd<true>(t); }
 
-TileIndex GetOtherTunnelEnd(TileIndex);
 bool IsTunnelInWay(TileIndex, int z);
 bool IsTunnelInWayDir(TileIndex tile, int z, DiagDirection dir);
 
@@ -48,20 +64,25 @@
  * @param d the direction facing out of the tunnel
  * @param r the road type used in the tunnel
  */
-static inline void MakeRoadTunnel(TileIndex t, Owner o, DiagDirection d, RoadTypes r)
+template <bool Tgeneric>
+static inline void MakeRoadTunnel(typename TileIndexT<Tgeneric>::T t, Owner o, DiagDirection d, RoadTypes r)
 {
 	SetTileType(t, MP_TUNNELBRIDGE);
 	SetTileOwner(t, o);
-	_m[t].m2 = 0;
-	_m[t].m3 = 0;
-	_m[t].m4 = 0;
-	_m[t].m5 = TRANSPORT_ROAD << 2 | d;
-	SB(_m[t].m6, 2, 4, 0);
-	_me[t].m7 = 0;
+	GetTile(t)->m2 = 0;
+	GetTile(t)->m3 = 0;
+	GetTile(t)->m4 = 0;
+	GetTile(t)->m5 = TRANSPORT_ROAD << 2 | d;
+	SB(GetTileEx(t)->m6, 2, 4, 0);
+	GetTileEx(t)->m7 = 0;
 	SetRoadOwner(t, ROADTYPE_ROAD, o);
 	if (o != OWNER_TOWN) SetRoadOwner(t, ROADTYPE_TRAM, o);
 	SetRoadTypes(t, r);
 }
+/** @copydoc MakeRoadTunnel(TileIndexT<Tgeneric>::T,Owner,DiagDirection,RoadTypes) */
+static inline void MakeRoadTunnel(TileIndex t, Owner o, DiagDirection d, RoadTypes r) { MakeRoadTunnel<false>(t, o, d, r); }
+/** @copydoc MakeRoadTunnel(TileIndexT<Tgeneric>::T,Owner,DiagDirection,RoadTypes) */
+static inline void MakeRoadTunnel(GenericTileIndex t, Owner o, DiagDirection d, RoadTypes r) { MakeRoadTunnel<true>(t, o, d, r); }
 
 /**
  * Makes a rail tunnel entrance
@@ -70,16 +91,21 @@
  * @param d the direction facing out of the tunnel
  * @param r the rail type used in the tunnel
  */
-static inline void MakeRailTunnel(TileIndex t, Owner o, DiagDirection d, RailType r)
+template <bool Tgeneric>
+static inline void MakeRailTunnel(typename TileIndexT<Tgeneric>::T t, Owner o, DiagDirection d, RailType r)
 {
 	SetTileType(t, MP_TUNNELBRIDGE);
 	SetTileOwner(t, o);
-	_m[t].m2 = 0;
-	_m[t].m3 = r;
-	_m[t].m4 = 0;
-	_m[t].m5 = TRANSPORT_RAIL << 2 | d;
-	SB(_m[t].m6, 2, 4, 0);
-	_me[t].m7 = 0;
+	GetTile(t)->m2 = 0;
+	GetTile(t)->m3 = r;
+	GetTile(t)->m4 = 0;
+	GetTile(t)->m5 = TRANSPORT_RAIL << 2 | d;
+	SB(GetTileEx(t)->m6, 2, 4, 0);
+	GetTileEx(t)->m7 = 0;
 }
+/** @copydoc MakeRailTunnel(TileIndexT<Tgeneric>::T,Owner,DiagDirection,RailType) */
+static inline void MakeRailTunnel(TileIndex t, Owner o, DiagDirection d, RailType r) { MakeRailTunnel<false>(t, o, d, r); }
+/** @copydoc MakeRailTunnel(TileIndexT<Tgeneric>::T,Owner,DiagDirection,RailType) */
+static inline void MakeRailTunnel(GenericTileIndex t, Owner o, DiagDirection d, RailType r) { MakeRailTunnel<true>(t, o, d, r); }
 
 #endif /* TUNNEL_MAP_H */
diff -urNad openttd-1.3.2/src/vehicle_base.h openttd-1.3.2-DC3.0RC3/src/vehicle_base.h
--- openttd-1.3.2/src/vehicle_base.h	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/vehicle_base.h	2013-11-22 05:49:07.000000000 +0100
@@ -15,14 +15,18 @@
 #include "track_type.h"
 #include "command_type.h"
 #include "order_base.h"
+#include "triphistory.h"
 #include "cargopacket.h"
 #include "texteff.hpp"
 #include "engine_type.h"
 #include "order_func.h"
 #include "transport_type.h"
 #include "group_type.h"
+#include "timetable.h"
 #include "base_consist.h"
 
+CommandCost CmdRefitVehicle(TileIndex, DoCommandFlag, uint32, uint32, const char*);
+
 /** Vehicle status bits in #Vehicle::vehstatus. */
 enum VehStatus {
 	VS_HIDDEN          = 0x01, ///< Vehicle is not visible.
@@ -92,6 +96,7 @@
  * This is defined here instead of at #GroundVehicle because some common function require access to these flags.
  * Do not access it directly unless you have to. Use the subtype access functions.
  */
+// MYGUI appended virtual subtype
 enum GroundVehicleSubtypeFlags {
 	GVSF_FRONT            = 0, ///< Leading engine of a consist.
 	GVSF_ARTICULATED_PART = 1, ///< Articulated part of an engine.
@@ -99,10 +104,12 @@
 	GVSF_ENGINE           = 3, ///< Engine that can be front engine, but might be placed behind another engine (not used for road vehicles).
 	GVSF_FREE_WAGON       = 4, ///< First in a wagon chain (in depot) (not used for road vehicles).
 	GVSF_MULTIHEADED      = 5, ///< Engine is multiheaded (not used for road vehicles).
+	GVSF_VIRTUAL		  = 6, ///< Used for virtual trains during template design, needed to skip checks for tile or depot status
 };
 
 /** Cached often queried values common to all vehicles. */
 struct VehicleCache {
+	uint32 cached_cargo_mask; ///< Mask of all cargoes carried by the consist.
 	uint16 cached_max_speed;        ///< Maximum speed of the consist (minimum of the max speed of all vehicles in the consist).
 	uint16 cached_cargo_age_period; ///< Number of ticks before carried cargo is aged.
 
@@ -151,6 +158,8 @@
 	Money profit_last_year;             ///< Profit last year << 8, low 8 bits are fract
 	Money value;                        ///< Value of the vehicle
 
+	TripHistory trip_history;           ///< Trip History Info
+
 	CargoPayment *cargo_payment;        ///< The cargo payment we're currently in
 
 	Rect coord;                         ///< NOSAVE: Graphical bounding box of the vehicle, i.e. what to redraw on moves.
@@ -211,6 +220,8 @@
 	byte waiting_triggers;              ///< Triggers to be yet matched before rerandomizing the random bits.
 
 	StationID last_station_visited;     ///< The last station we stopped at.
+	StationID last_station_loaded;      ///< Last station the vehicle loaded cargo at.
+	OrderID   last_order_id;            ///< Order id which caused the vehicle to arrive at the last loading station.
 
 	CargoID cargo_type;                 ///< type of cargo this vehicle is carrying
 	byte cargo_subtype;                 ///< Used for livery refits (NewGRF variations)
@@ -218,6 +229,7 @@
 	VehicleCargoList cargo;             ///< The cargo this vehicle is carrying
 	uint16 cargo_age_counter;           ///< Ticks till cargo is aged next.
 
+	uint32 travel_time;                 ///< Ticks since last loading
 	byte day_counter;                   ///< Increased by one for each day
 	byte tick_counter;                  ///< Increased by one for each tick
 	byte running_ticks;                 ///< Number of ticks this vehicle was not stopped this day
@@ -243,7 +255,7 @@
 	/** We want to 'destruct' the right class. */
 	virtual ~Vehicle();
 
-	void BeginLoading();
+	void BeginLoading(StationID station);
 	void LeaveStation();
 
 	GroundVehicleCache *GetGroundVehicleCache();
@@ -257,6 +269,12 @@
 	void HandleLoading(bool mode = false);
 
 	/**
+	 * Is this vehicle drawn?
+	 * @return true if it is drawn
+	 */
+	bool IsDrawn() const;
+
+	/**
 	 * Marks the vehicles to be redrawn and updates cached variables
 	 *
 	 * This method marks the area of the vehicle on the screen as dirty.
@@ -476,6 +494,7 @@
 	Money GetDisplayProfitLastYear() const { return (this->profit_last_year >> 8); }
 
 	void SetNext(Vehicle *next);
+	inline void SetFirst(Vehicle *f) { this->first=f; }
 
 	/**
 	 * Get the next vehicle of this vehicle.
@@ -761,6 +780,8 @@
 	bool HasEngineType() const;
 	bool HasDepotOrder() const;
 	void HandlePathfindingResult(bool path_found);
+	void MarkSeparationInvalid();
+	void SetSepSettings(TTSepMode Mode, uint Parameter);
 
 	/**
 	 * Check if the vehicle is a front engine.
@@ -1043,6 +1064,10 @@
 	SpriteID image_override;            ///< Override for the default disaster vehicle sprite.
 	VehicleID big_ufo_destroyer_target; ///< The big UFO that this destroyer is supposed to bomb.
 
+	/* @see in_min/max_height_correction in aircraft.h */
+	bool in_max_height_correction;
+	bool in_min_height_correction;
+
 	/** We don't want GCC to zero our struct! It already is zeroed and has an index! */
 	DisasterVehicle() : SpecializedVehicleBase() {}
 	/** We want to 'destruct' the right class. */
diff -urNad openttd-1.3.2/src/vehicle_cmd.cpp openttd-1.3.2-DC3.0RC3/src/vehicle_cmd.cpp
--- openttd-1.3.2/src/vehicle_cmd.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/vehicle_cmd.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -28,8 +28,10 @@
 #include "autoreplace_gui.h"
 #include "group.h"
 #include "order_backup.h"
+#include "infrastructure_func.h"
 #include "ship.h"
 #include "newgrf.h"
+#include "cargodest_func.h"
 #include "company_base.h"
 
 #include "table/strings.h"
@@ -147,6 +149,7 @@
 		if (v->IsPrimaryVehicle()) {
 			GroupStatistics::CountVehicle(v, 1);
 			OrderBackup::Restore(v, p2);
+			PrefillRouteLinks(v);
 		}
 	}
 
@@ -412,6 +415,7 @@
  * @param p2 various bitstuffed elements
  * - p2 = (bit 0-4)   - New cargo type to refit to.
  * - p2 = (bit 6)     - Automatic refitting.
+ * - p2 = (bit 5)	  - Is a virtual train (used by template replacement to allow refitting without stopped-in-depot checks)
  * - p2 = (bit 7)     - Refit only this vehicle. Used only for cloning vehicles.
  * - p2 = (bit 8-15)  - New cargo subtype to refit to.
  * - p2 = (bit 16-23) - Number of vehicles to refit (not counting articulated parts). Zero means all vehicles.
@@ -430,16 +434,19 @@
 
 	Vehicle *front = v->First();
 
-	CommandCost ret = CheckOwnership(front->owner);
+	CommandCost ret = CheckVehicleControlAllowed(v);
 	if (ret.Failed()) return ret;
 
 	bool auto_refit = HasBit(p2, 6);
+	bool is_virtual_train = HasBit(p2, 5);
 
 	/* Don't allow shadows and such to be refitted. */
 	if (v != front && (v->type == VEH_SHIP || v->type == VEH_AIRCRAFT)) return CMD_ERROR;
 	/* Allow auto-refitting only during loading and normal refitting only in a depot. */
-	if ((!auto_refit || !front->current_order.IsType(OT_LOADING)) && !front->IsStoppedInDepot()) return_cmd_error(STR_ERROR_TRAIN_MUST_BE_STOPPED_INSIDE_DEPOT + front->type);
-	if (front->vehstatus & VS_CRASHED) return_cmd_error(STR_ERROR_VEHICLE_IS_DESTROYED);
+	if ( ! is_virtual_train ) {
+		if ((!auto_refit || !front->current_order.IsType(OT_LOADING)) && !front->IsStoppedInDepot()) return_cmd_error(STR_ERROR_TRAIN_MUST_BE_STOPPED_INSIDE_DEPOT + front->type);
+		if (front->vehstatus & VS_CRASHED) return_cmd_error(STR_ERROR_VEHICLE_IS_DESTROYED);
+	}
 
 	/* Check cargo */
 	CargoID new_cid = GB(p2, 0, 5);
@@ -478,8 +485,14 @@
 			default: NOT_REACHED();
 		}
 
+		if (front->IsPrimaryVehicle()) PrefillRouteLinks(front);
+
 		InvalidateWindowData(WC_VEHICLE_DETAILS, front->index);
-		SetWindowDirty(WC_VEHICLE_DEPOT, front->tile);
+		/* virtual vehicles get their cargo changed by the TemplateCreateWindow, so set this dirty instead of a depot window */
+		//if ( HasBit(v->subtype, GVSF_VIRTUAL) ) SetWindowDirty(WC_CREATE_TEMPLATE, -1); // MYGUI
+		if ( HasBit(v->subtype, GVSF_VIRTUAL) ) SetWindowClassesDirty(WC_CREATE_TEMPLATE);
+		else SetWindowDirty(WC_VEHICLE_DEPOT, front->tile);
+
 		InvalidateWindowClassesData(GetWindowClassForVehicleType(v->type), 0);
 	} else {
 		/* Always invalidate the cache; querycost might have filled it. */
@@ -506,7 +519,7 @@
 	Vehicle *v = Vehicle::GetIfValid(p1);
 	if (v == NULL || !v->IsPrimaryVehicle()) return CMD_ERROR;
 
-	CommandCost ret = CheckOwnership(v->owner);
+	CommandCost ret = CheckVehicleControlAllowed(v);
 	if (ret.Failed()) return ret;
 
 	if (v->vehstatus & VS_CRASHED) return_cmd_error(STR_ERROR_VEHICLE_IS_DESTROYED);
@@ -565,6 +578,8 @@
 		SetWindowWidgetDirty(WC_VEHICLE_VIEW, v->index, WID_VV_START_STOP);
 		SetWindowDirty(WC_VEHICLE_DEPOT, v->tile);
 		SetWindowClassesDirty(GetWindowClassForVehicleType(v->type));
+
+		v->MarkSeparationInvalid();
 	}
 	return CommandCost();
 }
@@ -665,7 +680,7 @@
 	VehicleType vehicle_type = Extract<VehicleType, 0, 3>(p1);
 
 	if (!IsCompanyBuildableVehicleType(vehicle_type)) return CMD_ERROR;
-	if (!IsDepotTile(tile) || !IsTileOwner(tile, _current_company)) return CMD_ERROR;
+	if (!IsDepotTile(tile) || !IsInfraUsageAllowed(vehicle_type, _current_company, GetTileOwner(tile))) return CMD_ERROR;
 
 	/* Get the list of vehicles in the depot */
 	BuildDepotVehicleList(vehicle_type, tile, &list, &list, true);
diff -urNad openttd-1.3.2/src/vehicle.cpp openttd-1.3.2-DC3.0RC3/src/vehicle.cpp
--- openttd-1.3.2/src/vehicle.cpp	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/vehicle.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -18,6 +18,7 @@
 #include "viewport_func.h"
 #include "news_func.h"
 #include "command_func.h"
+#include "command_type.h"
 #include "company_func.h"
 #include "train.h"
 #include "aircraft.h"
@@ -41,6 +42,7 @@
 #include "roadstop_base.h"
 #include "core/random_func.hpp"
 #include "core/backup_type.hpp"
+#include "infrastructure_func.h"
 #include "order_backup.h"
 #include "sound_func.h"
 #include "effectvehicle_func.h"
@@ -49,10 +51,14 @@
 #include "bridge_map.h"
 #include "tunnel_map.h"
 #include "depot_map.h"
+#include "cargodest_func.h"
 #include "gamelog.h"
 
 #include "table/strings.h"
 
+// MYGUI
+#include "aaa_template_vehicle_func.h"
+
 #define GEN_HASH(x, y) ((GB((y), 6 + ZOOM_LVL_SHIFT, 6) << 6) + GB((x), 7 + ZOOM_LVL_SHIFT, 6))
 
 VehicleID _new_vehicle_id;
@@ -90,7 +96,35 @@
 void VehicleServiceInDepot(Vehicle *v)
 {
 	v->date_of_last_service = _date;
-	v->breakdowns_since_last_service = 0;
+       if(v->breakdowns_since_last_service != 0){
+	   if (_settings_game.vehicle.repair_cost)
+	   {
+               ExpensesType type = INVALID_EXPENSES;
+               _current_company = v->owner;
+               switch (v->type) {
+                       case VEH_AIRCRAFT:
+                               type = EXPENSES_AIRCRAFT_RUN;
+                               break;
+                       case VEH_TRAIN:
+                               type = EXPENSES_TRAIN_RUN;
+                               break;
+                       case VEH_SHIP:
+                               type = EXPENSES_SHIP_RUN;
+                               break;
+                       case VEH_ROAD:
+                               type = EXPENSES_ROADVEH_RUN;
+                               break;
+                       default:
+                               NOT_REACHED();
+               }
+               assert(type != INVALID_EXPENSES);
+               CommandCost cost(type, (v->breakdowns_since_last_service * v->value >> 10) + 1);
+               v->First()->profit_this_year -= cost.GetCost() << 8;
+               SubtractMoneyFromCompany(cost);
+               ShowCostOrIncomeAnimation(v->x_pos, v->y_pos, v->z_pos, cost.GetCost());
+	    }
+               v->breakdowns_since_last_service = 0;
+       }
 	v->reliability = v->GetEngine()->reliability;
 	/* Prevent vehicles from breaking down directly after exiting the depot. */
 	v->breakdown_chance /= 4;
@@ -109,11 +143,21 @@
 	 * vehicles to go for service is lame. */
 	if (this->vehstatus & (VS_STOPPED | VS_CRASHED)) return false;
 
+       Date interval = this->service_interval;
+
+       if (!_settings_game.economy.slow_down_veh_rel_drop_down) {
+               interval /= _settings_game.economy.day_length_factor;
+               if (interval == 0) interval = 1;
+       }
+
+
 	/* Are we ready for the next service cycle? */
 	const Company *c = Company::Get(this->owner);
 	if (this->ServiceIntervalIsPercent() ?
-			(this->reliability >= this->GetEngine()->reliability * (100 - this->GetServiceInterval()) / 100) :
-			(this->date_of_last_service + this->GetServiceInterval() >= _date)) {
+//			(this->reliability >= this->GetEngine()->reliability * (100 - this->GetServiceInterval()) / 100) :
+//			(this->date_of_last_service + this->GetServiceInterval() >= _date)) {
+                       (this->reliability >= Engine::Get(this->engine_type)->reliability * (100 - interval) / 100) :
+                       (this->date_of_last_service + interval >= _date)) {
 		return false;
 	}
 
@@ -206,6 +250,17 @@
 	return RandomRange(pass + 1); // Randomise deceased passengers.
 }
 
+/** Marks the separation of this vehicle's order list invalid. */
+void Vehicle::MarkSeparationInvalid()
+{
+	if (this->orders.list != NULL) this->orders.list->MarkSeparationInvalid();
+}
+
+/** Sets new separation settings for this vehicle's shared orders. */
+void Vehicle::SetSepSettings(TTSepMode Mode, uint Parameter)
+{
+	if (this->orders.list != NULL) this->orders.list->SetSepSettings(Mode, Parameter);
+}
 
 /**
  * Displays a "NewGrf Bug" error message for a engine, and pauses the game if not networking.
@@ -268,7 +323,10 @@
 	this->fill_percent_te_id = INVALID_TE_ID;
 	this->first              = this;
 	this->colourmap          = PAL_NONE;
+	this->last_station_loaded = INVALID_STATION;
 	this->cargo_age_counter  = 1;
+	this->current_order.index = INVALID_ORDER;
+	this->last_order_id      = INVALID_ORDER;
 }
 
 /**
@@ -311,6 +369,14 @@
 	return NULL;
 }
 
+bool Vehicle::IsDrawn() const
+{
+	return !(this->vehstatus & VS_HIDDEN) ||
+			(IsTransparencySet(TO_TUNNELS) &&
+				((this->type == VEH_TRAIN && Train::From(this)->track == TRACK_BIT_WORMHOLE) ||
+				(this->type == VEH_ROAD && RoadVehicle::From(this)->state == RVSB_WORMHOLE)));
+}
+
 
 /**
  * Helper function for FindVehicleOnPos/HasVehicleOnPos.
@@ -606,6 +672,13 @@
 typedef SmallMap<Vehicle *, bool, 4> AutoreplaceMap;
 static AutoreplaceMap _vehicles_to_autoreplace;
 
+/**
+ * List of vehicles that are issued for template replacement this tick.
+ * Mapping is {vehicle : leave depot after replacement}
+ */
+typedef SmallMap<Train *, bool, 4> TemplateReplacementMap;
+static TemplateReplacementMap _vehicles_to_templatereplace;
+
 void InitializeVehicles()
 {
 	_vehicles_to_autoreplace.Reset();
@@ -788,7 +861,7 @@
 
 	/* sometimes, eg. for disaster vehicles, when company bankrupts, when removing crashed/flooded vehicles,
 	 * it may happen that vehicle chain is deleted when visible */
-	if (!(this->vehstatus & VS_HIDDEN)) MarkSingleVehicleDirty(this);
+	if (this->IsDrawn()) MarkSingleVehicleDirty(this);
 
 	Vehicle *v = this->Next();
 	this->SetNext(NULL);
@@ -807,14 +880,25 @@
  */
 void VehicleEnteredDepotThisTick(Vehicle *v)
 {
-	/* Vehicle should stop in the depot if it was in 'stopping' state */
-	_vehicles_to_autoreplace[v] = !(v->vehstatus & VS_STOPPED);
+	/* Template Replacement Setup stuff */ // MYGUI
+	bool stayInDepot = v->current_order.GetDepotActionType();
+	TemplateReplacement *tr = GetTemplateReplacementByGroupID(v->group_id);
+	if ( tr ) {
+		if ( stayInDepot )	_vehicles_to_templatereplace[(Train*)v] = true;
+		else				_vehicles_to_templatereplace[(Train*)v] = false;
+	}
+	/* Moved the assignment for auto replacement here to prevent auto replacement
+	 * from happening if template replacement is also scheduled */
+	else
+		/* Vehicle should stop in the depot if it was in 'stopping' state */
+		_vehicles_to_autoreplace[v] = !(v->vehstatus & VS_STOPPED);
 
 	/* We ALWAYS set the stopped state. Even when the vehicle does not plan on
 	 * stopping in the depot, so we stop it to ensure that it will not reserve
 	 * the path out of the depot before we might autoreplace it to a different
 	 * engine. The new engine would not own the reserved path we store that we
 	 * stopped the vehicle, so autoreplace can start it again */
+
 	v->vehstatus |= VS_STOPPED;
 }
 
@@ -855,6 +939,7 @@
 void CallVehicleTicks()
 {
 	_vehicles_to_autoreplace.Clear();
+	_vehicles_to_templatereplace.Clear();
 
 	RunVehicleDayProc();
 
@@ -897,6 +982,8 @@
 				/* Do not play any sound when stopped */
 				if ((front->vehstatus & VS_STOPPED) && (front->type != VEH_TRAIN || front->cur_speed == 0)) continue;
 
+                               v->travel_time++;
+
 				/* Check vehicle type specifics */
 				switch (v->type) {
 					case VEH_TRAIN:
@@ -931,6 +1018,7 @@
 		}
 	}
 
+	/* do Auto Replacement */
 	Backup<CompanyByte> cur_company(_current_company, FILE_LINE);
 	for (AutoreplaceMap::iterator it = _vehicles_to_autoreplace.Begin(); it != _vehicles_to_autoreplace.End(); it++) {
 		v = it->first;
@@ -975,8 +1063,28 @@
 		SetDParam(1, error_message);
 		AddVehicleAdviceNewsItem(message, v->index);
 	}
-
 	cur_company.Restore();
+
+	/* do Template Replacement */
+	Backup<CompanyByte> tmpl_cur_company(_current_company, FILE_LINE);
+	for (TemplateReplacementMap::iterator it = _vehicles_to_templatereplace.Begin(); it != _vehicles_to_templatereplace.End(); it++) {
+
+		Train *t = it->first;
+
+		tmpl_cur_company.Change(t->owner);
+
+		bool stayInDepot = it->second;
+
+		it->first->vehstatus |= VS_STOPPED;
+		REPLACEMENT_IN_PROGRESS = true;
+
+		CmdTemplateReplaceVehicle(t, stayInDepot, DC_EXEC);
+		/* Redraw main gui for changed statistics */
+		SetWindowClassesDirty(WC_TEMPLATEGUI_MAIN);
+
+		REPLACEMENT_IN_PROGRESS = false;
+	}
+	tmpl_cur_company.Restore();
 }
 
 /**
@@ -991,7 +1099,7 @@
 	if (v->vehstatus & VS_DEFPAL) pal = (v->vehstatus & VS_CRASHED) ? PALETTE_CRASH : GetVehiclePalette(v);
 
 	/* Check whether the vehicle shall be transparent due to the game state */
-	bool shadowed = (v->vehstatus & VS_SHADOW) != 0;
+	bool shadowed = (v->vehstatus & (VS_SHADOW | VS_HIDDEN));
 
 	if (v->type == VEH_EFFECT) {
 		/* Check whether the vehicle shall be transparent/invisible due to GUI settings.
@@ -1042,7 +1150,7 @@
 			const Vehicle *v = _vehicle_viewport_hash[x + y]; // already masked & 0xFFF
 
 			while (v != NULL) {
-				if (!(v->vehstatus & VS_HIDDEN) &&
+				if (v->IsDrawn() &&
 						l <= v->coord.right &&
 						t <= v->coord.bottom &&
 						r >= v->coord.left &&
@@ -1077,7 +1185,7 @@
 	y = ScaleByZoom(y, vp->zoom) + vp->virtual_top;
 
 	FOR_ALL_VEHICLES(v) {
-		if ((v->vehstatus & (VS_HIDDEN | VS_UNCLICKABLE)) == 0 &&
+		if (v->IsDrawn() && !(v->vehstatus & VS_UNCLICKABLE) &&
 				x >= v->coord.left && x <= v->coord.right &&
 				y >= v->coord.top && y <= v->coord.bottom) {
 
@@ -1122,8 +1230,12 @@
 	int rel, rel_old;
 
 	/* decrease reliability */
-	v->reliability = rel = max((rel_old = v->reliability) - v->reliability_spd_dec, 0);
-	if ((rel_old >> 8) != (rel >> 8)) SetWindowDirty(WC_VEHICLE_DETAILS, v->index);
+	if (!_settings_game.economy.slow_down_veh_rel_drop_down ||
+			(_date_fract < DAY_TICKS &&
+			_settings_game.economy.slow_down_veh_rel_drop_down)) {
+		v->reliability = rel = max((rel_old = v->reliability) - v->reliability_spd_dec, 0);
+		if ((rel_old >> 8) != (rel >> 8)) SetWindowDirty(WC_VEHICLE_DETAILS, v->index);
+	}
 
 	if (v->breakdown_ctr != 0 || (v->vehstatus & VS_STOPPED) ||
 			_settings_game.difficulty.vehicle_breakdowns < 1 ||
@@ -1226,6 +1338,9 @@
  */
 void AgeVehicle(Vehicle *v)
 {
+       if (_date_fract >= DAY_TICKS &&
+               _settings_game.economy.slow_down_veh_rel_drop_down) return;
+
 	if (v->age < MAX_DAY) {
 		v->age++;
 		if (v->IsPrimaryVehicle() && v->age == VEHICLE_PROFIT_MIN_AGE + 1) GroupStatistics::VehicleReachedProfitAge(v);
@@ -1430,6 +1545,7 @@
 				AddVehicleAdviceNewsItem(STR_NEWS_TRAIN_IS_WAITING + v->type, v->index);
 			}
 			AI::NewEvent(v->owner, new ScriptEventVehicleWaitingInDepot(v->index));
+			v->MarkSeparationInvalid();
 		}
 	}
 }
@@ -1901,12 +2017,15 @@
 
 /**
  * Prepare everything to begin the loading when arriving at a station.
+ * @param station The station ID of the station.
  * @pre IsTileType(this->tile, MP_STATION) || this->type == VEH_SHIP.
  */
-void Vehicle::BeginLoading()
+void Vehicle::BeginLoading(StationID station)
 {
 	assert(IsTileType(this->tile, MP_STATION) || this->type == VEH_SHIP);
 
+	this->last_station_visited = station;
+
 	if (this->current_order.IsType(OT_GOTO_STATION) &&
 			this->current_order.GetDestination() == this->last_station_visited) {
 		this->DeleteUnreachedImplicitOrders();
@@ -1987,6 +2106,7 @@
 					implicit_order->MakeImplicit(this->last_station_visited);
 					InsertOrder(this, implicit_order, this->cur_implicit_order_index);
 					if (this->cur_implicit_order_index > 0) --this->cur_implicit_order_index;
+					this->current_order.index = implicit_order->index;
 
 					/* InsertOrder disabled creation of implicit orders for all vehicles with the same implicit order.
 					 * Reenable it for this vehicle */
@@ -1998,7 +2118,35 @@
 		this->current_order.MakeLoading(false);
 	}
 
-	Station::Get(this->last_station_visited)->loading_vehicles.push_back(this);
+       /* If all requirements for separation are met, we can initialize it. */
+       if (_settings_game.order.automatic_timetable_separation
+                       && this->IsOrderListShared()
+                       && this->orders.list->IsCompleteTimetable()
+                       && (this->cur_real_order_index == 0)) {
+
+               if (!this->orders.list->IsSeparationValid()) this->orders.list->InitializeSeparation();
+               this->lateness_counter = this->orders.list->SeparateVehicle();
+       }
+
+	UpdateVehicleRouteLinks(this, station);
+
+	/* Save the id of the order which made us arrive here. MakeLoading
+	 * does not overwrite the index so it is still valid here. */
+	this->last_order_id = this->current_order.index;
+	this->last_station_loaded = station;
+
+	Station *last_visited = Station::Get(this->last_station_visited);
+	last_visited->loading_vehicles.push_back(this);
+
+	/* Update the next hop for waiting cargo. */
+	CargoID cid;
+	FOR_EACH_SET_CARGO_ID(cid, this->vcache.cached_cargo_mask) {
+		/* Only update if the last update was at least route_recalc_delay ticks earlier. */
+		if (CargoHasDestinations(cid) && last_visited->goods[cid].cargo_counter == 0) {
+			last_visited->goods[cid].cargo.UpdateCargoNextHop(last_visited, cid);
+			last_visited->goods[cid].cargo_counter = _settings_game.economy.cargodest.route_recalc_delay;
+		}
+	}
 
 	PrepareUnload(this);
 
@@ -2025,6 +2173,9 @@
 	/* Only update the timetable if the vehicle was supposed to stop here. */
 	if (this->current_order.GetNonStopType() != ONSF_STOP_EVERYWHERE) UpdateVehicleTimetable(this, false);
 
+	/* Reset travel time counter. */
+	this->travel_time = 0;
+
 	this->current_order.MakeLeaveStation();
 	Station *st = Station::Get(this->last_station_visited);
 	st->loading_vehicles.remove(this);
@@ -2054,6 +2205,9 @@
 		case OT_LOADING: {
 			uint wait_time = max(this->current_order.wait_time - this->lateness_counter, 0);
 
+			/* Pay the loading fee for using someone else's station, if appropriate */
+			if (!mode && this->type != VEH_TRAIN) PayStationSharingFee(this, Station::Get(this->last_station_visited));
+
 			/* Not the first call for this tick, or still loading */
 			if (mode || !HasBit(this->vehicle_flags, VF_LOADING_FINISHED) || this->current_order_time < wait_time) return;
 
@@ -2247,8 +2401,6 @@
 			this->cur_speed < 2) {
 		return;
 	}
-
-	uint max_speed = this->vcache.cached_max_speed;
 	if (this->type == VEH_TRAIN) {
 		const Train *t = Train::From(this);
 		/* For trains, do not show any smoke when:
@@ -2260,11 +2412,7 @@
 				t->cur_speed >= t->Train::GetCurrentMaxSpeed())) {
 			return;
 		}
-
-		max_speed = min(max_speed, t->gcache.cached_max_track_speed);
-		max_speed = min(max_speed, this->current_order.max_speed);
 	}
-	if (this->type == VEH_ROAD || this->type == VEH_SHIP) max_speed = min(max_speed, this->current_order.max_speed * 2);
 
 	const Vehicle *v = this;
 
@@ -2310,7 +2458,7 @@
 				 * third of its maximum speed spectrum. Steam emission finally normalises at very close to vehicle's maximum speed.
 				 * REGULATION:
 				 * - instead of 1, 4 / 2^smoke_amount (max. 2) is used to provide sufficient regulation to steam puffs' amount. */
-				if (GB(v->tick_counter, 0, ((4 >> _settings_game.vehicle.smoke_amount) + ((this->cur_speed * 3) / max_speed))) == 0) {
+				if (GB(v->tick_counter, 0, ((4 >> _settings_game.vehicle.smoke_amount) + ((this->cur_speed * 3) / this->vcache.cached_max_speed))) == 0) {
 					CreateEffectVehicleRel(v, x, y, 10, EV_STEAM_SMOKE);
 					sound = true;
 				}
@@ -2332,8 +2480,8 @@
 				if (v->type == VEH_TRAIN) {
 					power_weight_effect = (32 >> (Train::From(this)->gcache.cached_power >> 10)) - (32 >> (Train::From(this)->gcache.cached_weight >> 9));
 				}
-				if (this->cur_speed < (max_speed >> (2 >> _settings_game.vehicle.smoke_amount)) &&
-						Chance16((64 - ((this->cur_speed << 5) / max_speed) + power_weight_effect), (512 >> _settings_game.vehicle.smoke_amount))) {
+				if (this->cur_speed < (this->vcache.cached_max_speed >> (2 >> _settings_game.vehicle.smoke_amount)) &&
+						Chance16((64 - ((this->cur_speed << 5) / this->vcache.cached_max_speed) + power_weight_effect), (512 >> _settings_game.vehicle.smoke_amount))) {
 					CreateEffectVehicleRel(v, x, y, 10, EV_DIESEL_SMOKE);
 					sound = true;
 				}
@@ -2348,7 +2496,7 @@
 				 * REGULATION:
 				 * - in Chance16 the last value is 360 / 2^smoke_amount (max. sparks when 90 = smoke_amount of 2). */
 				if (GB(v->tick_counter, 0, 2) == 0 &&
-						Chance16((6 - ((this->cur_speed << 2) / max_speed)), (360 >> _settings_game.vehicle.smoke_amount))) {
+						Chance16((6 - ((this->cur_speed << 2) / this->vcache.cached_max_speed)), (360 >> _settings_game.vehicle.smoke_amount))) {
 					CreateEffectVehicleRel(v, x, y, 10, EV_ELECTRIC_SPARK);
 					sound = true;
 				}
@@ -2413,6 +2561,7 @@
 	if (this->next_shared != NULL) this->next_shared->previous_shared = this;
 
 	shared_chain->orders.list->AddVehicle(this);
+	shared_chain->orders.list->MarkSeparationInvalid();
 }
 
 /**
@@ -2425,6 +2574,7 @@
 	bool were_first = (this->FirstShared() == this);
 	VehicleListIdentifier vli(VL_SHARED_ORDERS, this->type, this->owner, this->FirstShared()->index);
 
+	this->orders.list->MarkSeparationInvalid();
 	this->orders.list->RemoveVehicle(this);
 
 	if (!were_first) {
diff -urNad openttd-1.3.2/src/vehicle_gui_base.h openttd-1.3.2-DC3.0RC3/src/vehicle_gui_base.h
--- openttd-1.3.2/src/vehicle_gui_base.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/vehicle_gui_base.h	2013-11-22 05:49:07.000000000 +0100
@@ -27,6 +27,7 @@
 	VehicleListIdentifier vli; ///< Identifier of the vehicle list we want to currently show.
 
 	enum ActionDropdownItem {
+		ADI_TEMPLATE_REPLACE,
 		ADI_REPLACE,
 		ADI_SERVICE,
 		ADI_DEPOT,
diff -urNad openttd-1.3.2/src/vehicle_gui.cpp openttd-1.3.2-DC3.0RC3/src/vehicle_gui.cpp
--- openttd-1.3.2/src/vehicle_gui.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/vehicle_gui.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -36,9 +36,11 @@
 #include "company_base.h"
 #include "engine_func.h"
 #include "station_base.h"
+#include "infrastructure_func.h"
 #include "tilehighlight_func.h"
+#include "triphistory.h"
 #include "zoom_func.h"
-
+#include "network/network.h"
 
 Sorting _sorting;
 
@@ -156,6 +158,7 @@
 {
 	DropDownList *list = new DropDownList();
 
+	if (!_networking) list->push_back(new DropDownListStringItem(STR_TMPL_TEMPLATE_REPLACEMENT, ADI_TEMPLATE_REPLACE, false));		// MYGUI_NOEND
 	if (show_autoreplace) list->push_back(new DropDownListStringItem(STR_VEHICLE_LIST_REPLACE_VEHICLES, ADI_REPLACE, false));
 	list->push_back(new DropDownListStringItem(STR_VEHICLE_LIST_SEND_FOR_SERVICING, ADI_SERVICE, false));
 	list->push_back(new DropDownListStringItem(this->vehicle_depot_name[this->vli.vtype], ADI_DEPOT, false));
@@ -370,6 +373,7 @@
 	VehicleID selected_vehicle;  ///< First vehicle in the current selection.
 	uint8 num_vehicles;          ///< Number of selected vehicles.
 	bool auto_refit;             ///< Select cargo for auto-refitting.
+	bool is_virtual_train;
 
 	/**
 	 * Collects all (cargo, subcargo) refit options of a vehicle chain.
@@ -483,10 +487,11 @@
 		return NULL;
 	}
 
-	RefitWindow(const WindowDesc *desc, const Vehicle *v, VehicleOrderID order, bool auto_refit) : Window()
+	RefitWindow(const WindowDesc *desc, const Vehicle *v, VehicleOrderID order, bool auto_refit, bool is_virtual) : Window()
 	{
 		this->sel = -1;
 		this->auto_refit = auto_refit;
+		this->is_virtual_train = is_virtual;
 		this->CreateNestedTree(desc);
 
 		this->vscroll = this->GetScrollbar(WID_VR_SCROLLBAR);
@@ -506,6 +511,34 @@
 		this->SetWidgetDisabledState(WID_VR_REFIT, this->sel == -1);
 	}
 
+	~RefitWindow()
+	{
+		if (this->window_number != INVALID_VEHICLE) {
+			const Vehicle *veh = Vehicle::Get(this->window_number);
+			MarkAllRoutePathsDirty(veh);
+			MarkAllRouteStopoversDirty(veh);
+			FocusWindowById(WC_VEHICLE_VIEW, this->window_number);
+		}
+	}
+
+	virtual void OnFocus()
+	{
+		if (this->window_number != INVALID_VEHICLE) {
+			const Vehicle *veh = Vehicle::Get(this->window_number);
+			MarkAllRoutePathsDirty(veh);
+			MarkAllRouteStopoversDirty(veh);
+		}
+	}
+
+	virtual void OnFocusLost()
+	{
+		if (this->window_number != INVALID_VEHICLE) {
+			const Vehicle *veh = Vehicle::Get(this->window_number);
+			MarkAllRoutePathsDirty(veh);
+			MarkAllRouteStopoversDirty(veh);
+		}
+	}
+
 	virtual void OnInit()
 	{
 		if (this->cargo != NULL) {
@@ -840,14 +873,15 @@
 			}
 
 			case WID_VR_REFIT: // refit button
+
 				if (this->cargo != NULL) {
 					const Vehicle *v = Vehicle::Get(this->window_number);
 
 					if (this->order == INVALID_VEH_ORDER_ID) {
 						bool delete_window = this->selected_vehicle == v->index && this->num_vehicles == UINT8_MAX;
-						if (DoCommandP(v->tile, this->selected_vehicle, this->cargo->cargo | this->cargo->subtype << 8 | this->num_vehicles << 16, GetCmdRefitVeh(v)) && delete_window) delete this;
+						if (DoCommandP(v->tile, this->selected_vehicle, this->cargo->cargo | this->cargo->subtype << 8 | this->num_vehicles << 16 | this->is_virtual_train << 5, GetCmdRefitVeh(v)) && delete_window) delete this;
 					} else {
-						if (DoCommandP(v->tile, v->index, this->cargo->cargo | this->cargo->subtype << 8 | this->order << 16, CMD_ORDER_REFIT)) delete this;
+						if (DoCommandP(v->tile, v->index, this->cargo->cargo | this->cargo->subtype << 8 | this->order << 16 | this->is_virtual_train << 5, CMD_ORDER_REFIT)) delete this;
 					}
 				}
 				break;
@@ -928,10 +962,10 @@
  * @param parent the parent window of the refit window
  * @param auto_refit Choose cargo for auto-refitting
  */
-void ShowVehicleRefitWindow(const Vehicle *v, VehicleOrderID order, Window *parent, bool auto_refit)
+void ShowVehicleRefitWindow(const Vehicle *v, VehicleOrderID order, Window *parent, bool auto_refit, bool is_virtual_train)
 {
 	DeleteWindowById(WC_VEHICLE_REFIT, v->index);
-	RefitWindow *w = new RefitWindow(&_vehicle_refit_desc, v, order, auto_refit);
+	RefitWindow *w = new RefitWindow(&_vehicle_refit_desc, v, order, auto_refit, is_virtual_train);
 	w->parent = parent;
 }
 
@@ -1676,6 +1710,7 @@
 	NWidget(NWID_HORIZONTAL),
 		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
 		NWidget(WWT_CAPTION, COLOUR_GREY, WID_VD_CAPTION), SetDataTip(STR_VEHICLE_DETAILS_CAPTION, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_VD_TRIP_HISTORY),SetMinimalSize(44, 0),SetDataTip(STR_TRIP_HISTORY, STR_TRIP_HISTORY_TOOLTIP),
 		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_VD_RENAME_VEHICLE), SetMinimalSize(40, 0), SetMinimalTextLines(1, WD_FRAMERECT_TOP + WD_FRAMERECT_BOTTOM + 2), SetDataTip(STR_VEHICLE_NAME_BUTTON, STR_NULL /* filled in later */),
 		NWidget(WWT_SHADEBOX, COLOUR_GREY),
 		NWidget(WWT_STICKYBOX, COLOUR_GREY),
@@ -1699,6 +1734,7 @@
 	NWidget(NWID_HORIZONTAL),
 		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
 		NWidget(WWT_CAPTION, COLOUR_GREY, WID_VD_CAPTION), SetDataTip(STR_VEHICLE_DETAILS_CAPTION, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_VD_TRIP_HISTORY),SetMinimalSize(44, 0),SetDataTip(STR_TRIP_HISTORY, STR_TRIP_HISTORY_TOOLTIP),
 		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_VD_RENAME_VEHICLE), SetMinimalSize(40, 0), SetMinimalTextLines(1, WD_FRAMERECT_TOP + WD_FRAMERECT_BOTTOM + 2), SetDataTip(STR_VEHICLE_NAME_BUTTON, STR_NULL /* filled in later */),
 		NWidget(WWT_SHADEBOX, COLOUR_GREY),
 		NWidget(WWT_STICKYBOX, COLOUR_GREY),
@@ -1748,6 +1784,7 @@
 struct VehicleDetailsWindow : Window {
 	TrainDetailsWindowTabs tab; ///< For train vehicles: which tab is displayed.
 	Scrollbar *vscroll;
+	uint info_height;
 
 	/** Initialize a newly created vehicle details window */
 	VehicleDetailsWindow(const WindowDesc *desc, WindowNumber window_number) : Window()
@@ -1762,6 +1799,17 @@
 
 		this->owner = v->owner;
 		this->tab = TDW_TAB_CARGO;
+                info_height=0;
+	}
+
+	~VehicleDetailsWindow()
+	{
+		if (this->window_number != INVALID_VEHICLE) {
+			const Vehicle *veh = Vehicle::Get(this->window_number);
+			MarkAllRoutePathsDirty(veh);
+			MarkAllRouteStopoversDirty(veh);
+			FocusWindowById(WC_VEHICLE_VIEW, this->window_number);
+		}
 	}
 
 	/**
@@ -1806,6 +1854,27 @@
 		} else {
 			desired_height = WD_FRAMERECT_TOP + 4 * FONT_HEIGHT_NORMAL + 3 + WD_FRAMERECT_BOTTOM;
 		}
+
+                int num = 0;
+                CargoArray act_cargo;
+                CargoArray max_cargo;
+                CargoDestSummary dests[NUM_CARGO];
+                for (const Vehicle *u = v; u != NULL; u = u->Next()) {
+                        act_cargo[u->cargo_type] += u->cargo.Count();
+                        max_cargo[u->cargo_type] += u->cargo_cap;
+                        AddVehicleCargoDestSummary(u, &dests[u->cargo_type]);
+                }
+
+                /* Set scroll-amount separately from counting, as to not compute num double
+                 * for more carriages of the same type
+                 */
+                for (CargoID i = 0; i < NUM_CARGO; i++) {
+                        if (max_cargo[i] > 0) num++; // only count carriages that the train has
+                        num += (int)dests[i].size();
+                }
+                num += 2; // needs one more because first line is description string
+                desired_height += num * (FONT_HEIGHT_NORMAL + 1);
+
 		return desired_height;
 	}
 
@@ -1841,11 +1910,11 @@
 						break;
 
 					case VEH_SHIP:
-						size->height = WD_FRAMERECT_TOP + 4 * FONT_HEIGHT_NORMAL + 3 + WD_FRAMERECT_BOTTOM;
+						size->height = this->GetRoadVehDetailsHeight(v);
 						break;
 
 					case VEH_AIRCRAFT:
-						size->height = WD_FRAMERECT_TOP + 5 * FONT_HEIGHT_NORMAL + 4 + WD_FRAMERECT_BOTTOM;
+						size->height = this->GetRoadVehDetailsHeight(v);
 						break;
 
 					default:
@@ -1930,7 +1999,13 @@
 				SetDParam(1, v->age / DAYS_IN_LEAP_YEAR);
 				SetDParam(0, (v->age + DAYS_IN_YEAR < v->max_age) ? STR_VEHICLE_INFO_AGE : STR_VEHICLE_INFO_AGE_RED);
 				SetDParam(2, v->max_age / DAYS_IN_LEAP_YEAR);
-				SetDParam(3, v->GetDisplayRunningCost());
+				/* Multiply running costs with day length */
+				if (_settings_game.economy.day_length_balance_type == DBT_ALL_COSTS ||
+					_settings_game.economy.day_length_balance_type == DBT_RUN_COST) {
+					SetDParam(3, v->GetDisplayRunningCost() * _settings_game.economy.day_length_balance_factor);
+				} else {
+					SetDParam(3, v->GetDisplayRunningCost());
+				}
 				DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, y, STR_VEHICLE_INFO_AGE_RUNNING_COST_YR);
 				y += FONT_HEIGHT_NORMAL;
 
@@ -2020,7 +2095,17 @@
 		if (v->type == VEH_TRAIN) {
 			this->DisableWidget(this->tab + WID_VD_DETAILS_CARGO_CARRIED);
 			this->vscroll->SetCount(GetTrainDetailsWndVScroll(v->index, this->tab));
-		}
+		} else {
+                        /* redraw detail window when it gets larger - thx BoyC */
+                        uint expected = this->GetRoadVehDetailsHeight(v);
+                        NWidgetBase *nwi=GetWidget<NWidgetBase>(WID_VD_MIDDLE_DETAILS);
+                        if (expected>nwi->current_y)
+                        {
+                            info_height=expected;
+                            ReInit();
+                            return;
+                        }
+                }
 
 		/* Disable service-scroller when interval is set to disabled */
 		this->SetWidgetsDisabledState(!IsVehicleServiceIntervalEnabled(v->type, v->owner),
@@ -2039,6 +2124,12 @@
 	virtual void OnClick(Point pt, int widget, int click_count)
 	{
 		switch (widget) {
+			case WID_VD_TRIP_HISTORY: {
+				const Vehicle *v = Vehicle::Get(this->window_number);
+				ShowTripHistoryWindow(v);
+				break;
+			}
+		  
 			case WID_VD_RENAME_VEHICLE: { // rename
 				const Vehicle *v = Vehicle::Get(this->window_number);
 				SetDParam(0, v->index);
@@ -2113,6 +2204,24 @@
 			nwi->widget_data = (this->vscroll->GetCapacity() << MAT_ROW_START) + (1 << MAT_COL_START);
 		}
 	}
+
+	virtual void OnFocus()
+	{
+		if (this->window_number != INVALID_VEHICLE) {
+			const Vehicle *veh = Vehicle::Get(this->window_number);
+			MarkAllRoutePathsDirty(veh);
+			MarkAllRouteStopoversDirty(veh);
+		}
+	}
+
+	virtual void OnFocusLost()
+	{
+		if (this->window_number != INVALID_VEHICLE) {
+			const Vehicle *veh = Vehicle::Get(this->window_number);
+			MarkAllRoutePathsDirty(veh);
+			MarkAllRouteStopoversDirty(veh);
+		}
+	}
 };
 
 /** Vehicle details window descriptor. */
@@ -2384,12 +2493,36 @@
 
 	~VehicleViewWindow()
 	{
+               if (this->window_number != INVALID_VEHICLE) {
+                       const Vehicle *veh = Vehicle::Get(this->window_number);
+                       MarkAllRoutePathsDirty(veh);
+                       MarkAllRouteStopoversDirty(veh);
+               }
 		DeleteWindowById(WC_VEHICLE_ORDERS, this->window_number, false);
 		DeleteWindowById(WC_VEHICLE_REFIT, this->window_number, false);
 		DeleteWindowById(WC_VEHICLE_DETAILS, this->window_number, false);
 		DeleteWindowById(WC_VEHICLE_TIMETABLE, this->window_number, false);
+		DeleteWindowById(WC_VEHICLE_TRIP_HISTORY, this->window_number, false);
 	}
 
+       virtual void OnFocus()
+       {
+               if (this->window_number != INVALID_VEHICLE) {
+                       const Vehicle *veh = Vehicle::Get(this->window_number);
+                       MarkAllRoutePathsDirty(veh);
+                       MarkAllRouteStopoversDirty(veh);
+               }
+       }
+
+       virtual void OnFocusLost()
+       {
+               if (this->window_number != INVALID_VEHICLE) {
+                       const Vehicle *veh = Vehicle::Get(this->window_number);
+                       MarkAllRoutePathsDirty(veh);
+                       MarkAllRouteStopoversDirty(veh);
+               }
+       }
+
 	virtual void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize)
 	{
 		const Vehicle *v = Vehicle::Get(this->window_number);
@@ -2412,6 +2545,7 @@
 	{
 		const Vehicle *v = Vehicle::Get(this->window_number);
 		bool is_localcompany = v->owner == _local_company;
+		bool can_control = IsVehicleControlAllowed(v, _local_company);
 		bool refitable_and_stopped_in_depot = IsVehicleRefitable(v);
 
 		this->SetWidgetDisabledState(WID_VV_GOTO_DEPOT, !is_localcompany);
@@ -2420,8 +2554,8 @@
 
 		if (v->type == VEH_TRAIN) {
 			this->SetWidgetLoweredState(WID_VV_FORCE_PROCEED, Train::From(v)->force_proceed == TFP_SIGNAL);
-			this->SetWidgetDisabledState(WID_VV_FORCE_PROCEED, !is_localcompany);
-			this->SetWidgetDisabledState(WID_VV_TURN_AROUND, !is_localcompany);
+			this->SetWidgetDisabledState(WID_VV_FORCE_PROCEED, !can_control);
+			this->SetWidgetDisabledState(WID_VV_TURN_AROUND, !can_control);
 		}
 
 		this->DrawWidgets();
@@ -2730,3 +2864,28 @@
 
 	return vehicle_width;
 }
+
+/**
+ * Sum the cargo carried by a vehicle by final destination.
+ * @param v The vehicle.
+ * @param sum The cargo summary is added to this.
+ */
+void AddVehicleCargoDestSummary(const Vehicle *v, CargoDestSummary *sum)
+{
+	const VehicleCargoList::List *packets = v->cargo.Packets();
+	for (VehicleCargoList::ConstIterator it = packets->begin(); it != packets->end(); ++it) {
+		const CargoPacket *cp = *it;
+
+		/* Search for an existing list entry. */
+		CargoDestSummary::iterator data;
+		for (data = sum->begin(); data != sum->end(); ++data) {
+			if (data->type == cp->DestinationType() && data->dest == cp->DestinationID()) {
+				data->count += cp->Count();
+				break;
+			}
+		}
+
+		/* Not found, insert new entry. */
+		if (data == sum->end() && cp->DestinationID() != INVALID_SOURCE) sum->push_back(CargoDestSummaryData(cp->DestinationID(), cp->DestinationType(), cp->Count()));
+	}
+}
diff -urNad openttd-1.3.2/src/vehicle_gui.h openttd-1.3.2-DC3.0RC3/src/vehicle_gui.h
--- openttd-1.3.2/src/vehicle_gui.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/vehicle_gui.h	2013-11-22 05:49:07.000000000 +0100
@@ -18,8 +18,9 @@
 #include "station_type.h"
 #include "engine_type.h"
 #include "company_type.h"
+#include <list>
 
-void ShowVehicleRefitWindow(const Vehicle *v, VehicleOrderID order, Window *parent, bool auto_refit = false);
+void ShowVehicleRefitWindow(const Vehicle *v, VehicleOrderID order, Window *parent, bool auto_refit = false, bool is_virtual_train = false);
 
 /** The tabs in the train details window */
 enum TrainDetailsWindowTabs {
@@ -37,6 +38,22 @@
 	VIWD_AUTOREPLACE       = -4, ///< Autoreplace replaced the vehicle.
 };
 
+/** List item for one destination. */
+struct CargoDestSummaryData {
+	SourceID dest;     ///< Destination ID
+	SourceType type;   ///< Destination type
+	uint count;        ///< Cargo count
+
+	CargoDestSummaryData(SourceID dest, SourceType type, uint count)
+		: dest(dest), type(type), count(count)
+	{ }
+};
+
+/** List of cargo amounts grouped by final destination. */
+typedef std::list<CargoDestSummaryData> CargoDestSummary;
+
+void AddVehicleCargoDestSummary(const Vehicle *v, CargoDestSummary *sum);
+
 int DrawVehiclePurchaseInfo(int left, int right, int y, EngineID engine_number);
 
 void DrawTrainImage(const Train *v, int left, int right, int y, VehicleID selection, EngineImageType image_type, int skip, VehicleID drag_dest = INVALID_VEHICLE);
@@ -101,4 +118,6 @@
 
 void DrawVehicleImage(const Vehicle *v, int left, int right, int y, VehicleID selection, EngineImageType image_type, int skip);
 
+void ShowTripHistoryWindow(const Vehicle *v);
+
 #endif /* VEHICLE_GUI_H */
diff -urNad openttd-1.3.2/src/vehiclelist.cpp openttd-1.3.2-DC3.0RC3/src/vehiclelist.cpp
--- openttd-1.3.2/src/vehiclelist.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/vehiclelist.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -143,7 +143,7 @@
 		case VL_GROUP_LIST:
 			if (vli.index != ALL_GROUP) {
 				FOR_ALL_VEHICLES(v) {
-					if (v->type == vli.vtype && v->IsPrimaryVehicle() &&
+					if (!HasBit(v->subtype, GVSF_VIRTUAL) && v->type == vli.vtype && v->IsPrimaryVehicle() &&	//MYGUI
 							v->owner == vli.company && v->group_id == vli.index) {
 						*list->Append() = v;
 					}
@@ -154,7 +154,7 @@
 
 		case VL_STANDARD:
 			FOR_ALL_VEHICLES(v) {
-				if (v->type == vli.vtype && v->owner == vli.company && v->IsPrimaryVehicle()) {
+				if (!HasBit(v->subtype, GVSF_VIRTUAL) && v->type == vli.vtype && v->owner == vli.company && v->IsPrimaryVehicle()) { //MYGUI
 					*list->Append() = v;
 				}
 			}
diff -urNad openttd-1.3.2/src/vehicle_type.h openttd-1.3.2-DC3.0RC3/src/vehicle_type.h
--- openttd-1.3.2/src/vehicle_type.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/vehicle_type.h	2013-11-22 05:49:07.000000000 +0100
@@ -72,7 +72,7 @@
 	DEPOT_COMMAND_MASK  = 0xFU << 28,
 };
 
-static const uint MAX_LENGTH_VEHICLE_NAME_CHARS = 32; ///< The maximum length of a vehicle name in characters including '\0'
+static const uint MAX_LENGTH_VEHICLE_NAME_CHARS = 168; ///< The maximum length of a vehicle name in characters including '\0'
 
 /** The length of a vehicle in tile units. */
 static const uint VEHICLE_LENGTH = 8;
diff -urNad openttd-1.3.2/src/viewport.cpp openttd-1.3.2-DC3.0RC3/src/viewport.cpp
--- openttd-1.3.2/src/viewport.cpp	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/viewport.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -39,18 +39,31 @@
 #include "blitter/factory.hpp"
 #include "strings_func.h"
 #include "zoom_func.h"
+#include "overlay.h"
+#include "overlay_cmd.h"
 #include "vehicle_func.h"
 #include "company_func.h"
 #include "waypoint_func.h"
 #include "window_func.h"
 #include "tilehighlight_func.h"
+#include "clipboard_gui.h"
 #include "window_gui.h"
+#include "depot_base.h"
 
 #include "table/strings.h"
 #include "table/palettes.h"
 
+#include <map>
+
 Point _tile_fract_coords;
 
+struct RailTrackEndpoint {
+	TileIndex tile;
+	TrackdirBits dirs;
+};
+
+RailTrackEndpoint _rail_track_endpoints[4];
+
 struct StringSpriteToDraw {
 	StringID string;
 	Colours colour;
@@ -146,6 +159,7 @@
 
 static void MarkViewportDirty(const ViewPort *vp, int left, int top, int right, int bottom);
 
+DrawPixelInfo _dpi_for_text;
 static ViewportDrawer _vd;
 
 TileHighlightData _thd;
@@ -205,6 +219,8 @@
 		vp->follow_vehicle = (VehicleID)(follow_flags & 0xFFFFF);
 		veh = Vehicle::Get(vp->follow_vehicle);
 		pt = MapXYZToViewport(vp, veh->x_pos, veh->y_pos, veh->z_pos);
+		MarkAllRoutePathsDirty(veh);
+		MarkAllRouteStopoversDirty(veh);
 	} else {
 		uint x = TileX(follow_flags) * TILE_SIZE;
 		uint y = TileY(follow_flags) * TILE_SIZE;
@@ -390,9 +406,9 @@
 
 	/* we need to move variables in to the valid range, as the
 	 * GetTileZoomCenterWindow() function can call here with invalid x and/or y,
-	 * when the user tries to zoom out along the sides of the map */
-	a = Clamp(a, -4 * (int)TILE_SIZE, (int)(MapMaxX() * TILE_SIZE) - 1);
-	b = Clamp(b, -4 * (int)TILE_SIZE, (int)(MapMaxY() * TILE_SIZE) - 1);
+	 * when the user tries to zoom out along the sides of the map. */
+        a = Clamp(a, -4 * (int)TILE_SIZE, (int)(MapMaxX() * TILE_SIZE) - 1);
+        b = Clamp(b, -4 * (int)TILE_SIZE, (int)(MapMaxY() * TILE_SIZE) - 1);
 
 	/* (a, b) is the X/Y-world coordinate that belongs to (x,y) if the landscape would be completely flat on height 0.
 	 * Now find the Z-world coordinate by fix point iteration.
@@ -896,6 +912,32 @@
 	DrawSelectionSprite(sel, pal, ti, 7, FOUNDATION_PART_NORMAL);
 }
 
+/**
+ * Draws a selection point on a tile.
+ *
+ * @param ti TileInfo Tile that is being drawn
+ * @param pal Palette to apply.
+ */
+static void DrawPointSelection(const TileInfo *ti, PaletteID pal)
+{
+	/* Figure out the Z coordinate for the single dot. */
+	int z = 0;
+	FoundationPart foundation_part = FOUNDATION_PART_NORMAL;
+	if (ti->tileh & SLOPE_N) {
+		z += TILE_HEIGHT;
+		if (RemoveHalftileSlope(ti->tileh) == SLOPE_STEEP_N) z += TILE_HEIGHT;
+	}
+	if (IsHalftileSlope(ti->tileh)) {
+		Corner halftile_corner = GetHalftileSlopeCorner(ti->tileh);
+		if ((halftile_corner == CORNER_W) || (halftile_corner == CORNER_E)) z += TILE_HEIGHT;
+		if (halftile_corner != CORNER_S) {
+			foundation_part = FOUNDATION_PART_HALFTILE;
+			if (IsSteepSlope(ti->tileh)) z -= TILE_HEIGHT;
+		}
+	}
+	DrawSelectionSprite(_cur_dpi->zoom <= ZOOM_LVL_DETAIL ? SPR_DOT : SPR_DOT_SMALL, pal, ti, z, foundation_part);
+}
+
 static bool IsPartOfAutoLine(int px, int py)
 {
 	px -= _thd.selstart.x;
@@ -963,6 +1005,31 @@
 	DrawSelectionSprite(image, _thd.make_square_red ? PALETTE_SEL_TILE_RED : pal, ti, 7, foundation_part);
 }
 
+static void DrawPastePreviewSelection(const TileInfo *ti, bool is_redsq)
+{
+	TilePastePreview tile_preview;
+	GetTilePastePreview(ti->tile, &tile_preview);
+
+	/* draw tile rectangle */
+	if (!is_redsq && tile_preview.highlight_tile_rect) DrawTileSelectionRect(ti, PAL_NONE);
+
+	/* draw tracks */
+	Track t;
+	FOR_EACH_SET_TRACK(t, tile_preview.highlight_track_bits) DrawAutorailSelection(ti, t);
+
+	/* draw height point */
+	PaletteID pal;
+	int height_diff = tile_preview.tile_height - TileHeight(ti->tile);
+	if (height_diff > 0) {
+		pal = PALETTE_SEL_TILE_RED; // target height is grater then current
+	} else if (height_diff < 0) {
+		pal = PALETTE_SEL_TILE_BLUE; // target height is lower then current
+	} else {
+		pal = PAL_NONE; // target and current height is the same
+	}
+	DrawPointSelection(ti, pal);
+}
+
 /**
  * Checks if the specified tile is selected and if so draws selection using correct selectionstyle.
  * @param *ti TileInfo Tile that is being drawn
@@ -988,22 +1055,11 @@
 		if (_thd.drawstyle & HT_RECT) {
 			if (!is_redsq) DrawTileSelectionRect(ti, _thd.make_square_red ? PALETTE_SEL_TILE_RED : PAL_NONE);
 		} else if (_thd.drawstyle & HT_POINT) {
-			/* Figure out the Z coordinate for the single dot. */
-			int z = 0;
-			FoundationPart foundation_part = FOUNDATION_PART_NORMAL;
-			if (ti->tileh & SLOPE_N) {
-				z += TILE_HEIGHT;
-				if (RemoveHalftileSlope(ti->tileh) == SLOPE_STEEP_N) z += TILE_HEIGHT;
-			}
-			if (IsHalftileSlope(ti->tileh)) {
-				Corner halftile_corner = GetHalftileSlopeCorner(ti->tileh);
-				if ((halftile_corner == CORNER_W) || (halftile_corner == CORNER_E)) z += TILE_HEIGHT;
-				if (halftile_corner != CORNER_S) {
-					foundation_part = FOUNDATION_PART_HALFTILE;
-					if (IsSteepSlope(ti->tileh)) z -= TILE_HEIGHT;
-				}
+			if (_thd.place_mode & HT_PASTE_PREVIEW) {
+				DrawPastePreviewSelection(ti, is_redsq);
+			} else {
+				DrawPointSelection(ti, PAL_NONE);
 			}
-			DrawSelectionSprite(_cur_dpi->zoom <= ZOOM_LVL_DETAIL ? SPR_DOT : SPR_DOT_SMALL, PAL_NONE, ti, z, foundation_part);
 		} else if (_thd.drawstyle & HT_RAIL) {
 			/* autorail highlight piece under cursor */
 			HighLightStyle type = _thd.drawstyle & HT_DIR_MASK;
@@ -1036,91 +1092,290 @@
 	}
 }
 
+/** Given a screen coordinate (x,y) as e.g. stored in _vd.dpi, this function
+ *  returns the tile coordinate of the tile which would be painted at (x,y)
+ *  if one assumes height zero at that position.
+ *  @param x some x screen coordinate
+ *  @param y some y screen coordinate
+ *  @return tile coordinate assuming height zero as described
+ */
+static inline Point GetTileCoordFromScreenCoord(int x, int y)
+{
+
+       /* First convert from the screen coordinate system (where the width of tiles
+        * is twice their height) to the tile coordinate system. That means, turn
+        * around by 45 degrees and make the tiles quadratic. */
+       Point tile_coord = InverseRemapCoords(x, y);
+
+
+       /* Scale from a 16x16-grid to a 1x1-grid as returned by TileX/TileY. */
+       tile_coord.x /= (int)TILE_SIZE;
+       tile_coord.y /= (int)TILE_SIZE;
+
+       return tile_coord;
+}
+
+/**
+ * Returns the y coordinate in the viewport coordinate system where the given
+ * tile is painted.
+ * @param tile Any tile.
+ * @return The viewport y coordinate where the tile is painted.
+ */
+static int GetViewportY(Point tile)
+{
+       return (tile.y * TILE_SIZE + tile.x * TILE_SIZE - GetTileMaxPixelZOutsideMap(tile.x, tile.y)) << ZOOM_LVL_SHIFT;
+}
+
+/**
+ * Returns the position of the tile at the northern end of the column of the
+ * given tile.
+ * @param tile Any tile.
+ * @return northern_end Position of the tile at the northern end of the column as described.
+ */
+static Point GetNorthernEndOfColumn(Point tile)
+{
+       Point northern_end;
+
+       if (tile.x < tile.y) {
+               northern_end.x = 0;
+               northern_end.y = tile.y - tile.x;
+       } else {
+               northern_end.x = tile.x - tile.y;
+               northern_end.y = 0;
+       }
+
+       return northern_end;
+}
+
+/**
+ * Returns the position of the tile at the southern end of the column of the
+ * given tile.
+ * @param tile any tile.
+ * @return southern_end position of the tile at the soutern end of the column as described.
+ */
+static Point GetSouthernEndOfColumn(Point tile)
+{
+       Point distance_to_end;
+       distance_to_end.x = (int)MapMaxX() - tile.x;
+       distance_to_end.y = (int)MapMaxY() - tile.y;
+       Point southern_end;
+
+       if (distance_to_end.x < distance_to_end.y) {
+               southern_end.x = tile.x + distance_to_end.x;
+               southern_end.y = tile.y + distance_to_end.x;
+       } else {
+               southern_end.x = tile.x + distance_to_end.y;
+               southern_end.y = tile.y + distance_to_end.y;
+       }
+
+       return southern_end;
+}
+
+/**
+ * Returns the tile exactly in the middle between two given tiles.
+ *
+ * @param tile Point upper_tile, any tile.
+ * @param tile Point lower_tile, any tile.
+ * @return middle_tile The tile in the middle of Point upper_tile and Point lower_tile.
+ */
+static Point GetMiddleTile(Point upper_tile, Point lower_tile) {
+       /* If upper_tile is lower than lower_tile swap tiles.
+        * Since we are only interested in the middle tile here, it is safe to do so. */
+       if (upper_tile.x <= lower_tile.x) Swap(upper_tile.x, lower_tile.x);
+       if (upper_tile.y <= lower_tile.y) Swap(upper_tile.y, lower_tile.y);
+
+       Point middle_tile;
+
+       middle_tile.x = upper_tile.x + (lower_tile.x - upper_tile.x) / 2;
+       middle_tile.y = upper_tile.y + (lower_tile.y - upper_tile.y) / 2;
+       return middle_tile;
+}
+
+/**
+ * Given a tile coordinate ignoring height, this returns the row actually
+ * painted at this tile coordinate if one recognizes height.
+ *
+ * The problem concerning this calculation is that we have not enough
+ * information to calculate this in one closed formula. Which row we
+ * search rather depends on the height distribution on the map. So
+ * we have to search.
+ * 
+ * First, the searched tile may be located outside map. Then, we know
+ * that we are not too far outside map, so we can step tile by tile,
+ * starting at the given tile, until we have passed the searched tile.
+ *
+ * If the searched tile is inside map, searching is more difficult. A
+ * linear search on some thousand tiles would be not that efficient. But,
+ * we can solve the problem by interval intersection. We know for sure,
+ * that the searched tile is south of the given tile, simply because
+ * mountains of height > 0 (and we have only such mountains) are always
+ * painted north of their tile. So we choose a tile half way between the
+ * given tile and the southern end of the map, have a look wether it is
+ * north or south of the given position, and intersect again. Until
+ * our interval has length 1, then we take the upper one.
+ *
+ * @param tile some tile coordinate
+ * @param viewport_y the viewport y corresponding to tile, if one assumes height zero for that tile
+ * @return the row which is painted at this coordinate, according to the discussion above.
+ */
+int GetRowAtTile(int viewport_y, Point tile)
+{
+       Point northern_tile = GetNorthernEndOfColumn(tile);
+       Point southern_tile = GetSouthernEndOfColumn(tile);
+
+       int northern_tile_viewport_y = GetViewportY(northern_tile);
+       int southern_tile_viewport_y = GetViewportY(southern_tile);
+
+       DEBUG(driver, 9, "==> GetRowAtTile: tile=(%i,%i); n/s_tile=(%i,%i),(%i,%i); n/s_tile_vp_y=(%i,%i); viewport_y = %i",
+                       tile.x, tile.y, northern_tile.x, northern_tile.y, southern_tile.x, southern_tile.y,
+                       northern_tile_viewport_y, southern_tile_viewport_y, viewport_y);
+
+       if (northern_tile_viewport_y >= viewport_y) {
+               /* We are north of the map, search tile by tile with direction north. */
+               while (northern_tile_viewport_y >= viewport_y) {
+                       northern_tile.x--;
+                       northern_tile.y--;
+                       northern_tile_viewport_y = GetViewportY(northern_tile);
+               }
+
+               DEBUG(driver, 9, "==> We are north of the map => Returning row for (%i,%i)",
+                               northern_tile.x, northern_tile.y);
+
+               return northern_tile.x + northern_tile.y;
+       } else if (southern_tile_viewport_y <= viewport_y) {
+               /* We are south of the map, search tile by tile with direction south. */
+               while (southern_tile_viewport_y <= viewport_y) {
+                       southern_tile.x++;
+                       southern_tile.y++;
+                       southern_tile_viewport_y = GetViewportY(southern_tile);
+               }
+
+               DEBUG(driver, 9, "==> We are south of the map => Returning row for (%i,%i)",
+                               southern_tile.x, southern_tile.y);
+               return southern_tile.x + southern_tile.y;
+       } else {
+           /* We are inside the map. */
+
+           /* Invariant in the code below: The searched tile shown at viewport_y
+                * always is between upper_tile and lower_tile. */
+               Point upper_tile = tile;
+               Point lower_tile = GetSouthernEndOfColumn(upper_tile);
+               int middle_bound;
+
+               DEBUG(driver, 9, "==> GetRowAtTile for vp_y = %i, (upper_)tile (%i,%i), lower_tile (%i,%i)",
+                               viewport_y, upper_tile.x, upper_tile.y, lower_tile.x, lower_tile.y);
+
+               do {
+                       Point middle_tile = GetMiddleTile(upper_tile, lower_tile);
+                       middle_bound = GetViewportY(middle_tile);
+
+                       DEBUG(driver, 9, "====> upper: (%i,%i), middle (%i,%i), lower (%i,%i); m_bound = %i",
+                                       upper_tile.x, upper_tile.y, middle_tile.x, middle_tile.y,
+                                       lower_tile.x, lower_tile.y, middle_bound);
+
+                       if (middle_bound >= viewport_y) {
+                               /* The tile shown at viewport_y is somewhere in the upper half of
+                                * the currently observed section. */
+                               lower_tile = middle_tile;
+                       } else {
+                               /* The tile shown at viewport_y is somewhere in the lower half of
+                                * the currently observed section. */
+                               upper_tile = middle_tile;
+                       }
+               }
+               while (lower_tile.y - upper_tile.y > 1);
+
+               /* Now our interval has length 1, so it only contains two tiles, and we take
+                * the upper one, calculating and returning its row. */
+               return upper_tile.x + upper_tile.y;
+       }
+}
+
 static void ViewportAddLandscape()
 {
-	int x, y, width, height;
-	TileInfo ti;
-	bool direction;
+        int x, y, width, height;
+        TileInfo ti;
+        bool direction;
 
-	_cur_ti = &ti;
+        _cur_ti = &ti;
 
-	/* Transform into tile coordinates and round to closest full tile */
-	x = ((_vd.dpi.top >> (1 + ZOOM_LVL_SHIFT)) - (_vd.dpi.left >> (2 + ZOOM_LVL_SHIFT))) & ~TILE_UNIT_MASK;
-	y = ((_vd.dpi.top >> (1 + ZOOM_LVL_SHIFT)) + (_vd.dpi.left >> (2 + ZOOM_LVL_SHIFT)) - TILE_SIZE) & ~TILE_UNIT_MASK;
+        /* Transform into tile coordinates and round to closest full tile */
+        x = ((_vd.dpi.top >> (1 + ZOOM_LVL_SHIFT)) - (_vd.dpi.left >> (2 + ZOOM_LVL_SHIFT))) & ~TILE_UNIT_MASK;
+        y = ((_vd.dpi.top >> (1 + ZOOM_LVL_SHIFT)) + (_vd.dpi.left >> (2 + ZOOM_LVL_SHIFT)) - TILE_SIZE) & ~TILE_UNIT_MASK;
 
-	/* determine size of area */
-	{
-		Point pt = RemapCoords(x, y, 241);
-		width = (_vd.dpi.left + _vd.dpi.width - pt.x + 96 * ZOOM_LVL_BASE - 1) >> (6 + ZOOM_LVL_SHIFT);
-		height = (_vd.dpi.top + _vd.dpi.height - pt.y) >> (5 + ZOOM_LVL_SHIFT) << 1;
-	}
+        /* determine size of area */
+        {
+                Point pt = RemapCoords(x, y, 241);
+                width = (_vd.dpi.left + _vd.dpi.width - pt.x + 96 * ZOOM_LVL_BASE - 1) >> (6 + ZOOM_LVL_SHIFT);
+                height = (_vd.dpi.top + _vd.dpi.height - pt.y) >> (2 + ZOOM_LVL_SHIFT) << 1;
+        }
 
-	assert(width > 0);
-	assert(height > 0);
+        assert(width > 0);
+        assert(height > 0);
 
-	direction = false;
+        direction = false;
 
-	do {
-		int width_cur = width;
-		uint x_cur = x;
-		uint y_cur = y;
+        do {
+                int width_cur = width;
+                uint x_cur = x;
+                uint y_cur = y;
 
-		do {
-			TileType tt = MP_VOID;
+                do {
+                        TileType tt = MP_VOID;
 
-			ti.x = x_cur;
-			ti.y = y_cur;
+                        ti.x = x_cur;
+                        ti.y = y_cur;
 
-			ti.z = 0;
+                        ti.z = 0;
 
-			ti.tileh = SLOPE_FLAT;
-			ti.tile = INVALID_TILE;
+                        ti.tileh = SLOPE_FLAT;
+                        ti.tile = INVALID_TILE;
 
-			if (x_cur < MapMaxX() * TILE_SIZE &&
-					y_cur < MapMaxY() * TILE_SIZE) {
-				TileIndex tile = TileVirtXY(x_cur, y_cur);
+                        if (x_cur < MapMaxX() * TILE_SIZE &&
+                                        y_cur < MapMaxY() * TILE_SIZE) {
+                                TileIndex tile = TileVirtXY(x_cur, y_cur);
 
-				if (!_settings_game.construction.freeform_edges || (TileX(tile) != 0 && TileY(tile) != 0)) {
-					if (x_cur == ((int)MapMaxX() - 1) * TILE_SIZE || y_cur == ((int)MapMaxY() - 1) * TILE_SIZE) {
-						uint maxh = max<uint>(TileHeight(tile), 1);
-						for (uint h = 0; h < maxh; h++) {
-							AddTileSpriteToDraw(SPR_SHADOW_CELL, PAL_NONE, ti.x, ti.y, h * TILE_HEIGHT);
-						}
-					}
+                                if (!_settings_game.construction.freeform_edges || (TileX(tile) != 0 && TileY(tile) != 0)) {
+                                        if (x_cur == ((int)MapMaxX() - 1) * TILE_SIZE || y_cur == ((int)MapMaxY() - 1) * TILE_SIZE) {
+                                                uint maxh = max<uint>(TileHeight(tile), 1);
+                                                for (uint h = 0; h < maxh; h++) {
+                                                        AddTileSpriteToDraw(SPR_SHADOW_CELL, PAL_NONE, ti.x, ti.y, h * TILE_HEIGHT);
+                                                }
+                                        }
 
-					ti.tile = tile;
-					ti.tileh = GetTilePixelSlope(tile, &ti.z);
-					tt = GetTileType(tile);
-				}
-			}
+                                        ti.tile = tile;
+                                        ti.tileh = GetTilePixelSlope(tile, &ti.z);
+                                        tt = GetTileType(tile);
+                                }
+                        }
 
-			_vd.foundation_part = FOUNDATION_PART_NONE;
-			_vd.foundation[0] = -1;
-			_vd.foundation[1] = -1;
-			_vd.last_foundation_child[0] = NULL;
-			_vd.last_foundation_child[1] = NULL;
+                        _vd.foundation_part = FOUNDATION_PART_NONE;
+                        _vd.foundation[0] = -1;
+                        _vd.foundation[1] = -1;
+                        _vd.last_foundation_child[0] = NULL;
+                        _vd.last_foundation_child[1] = NULL;
 
-			_tile_type_procs[tt]->draw_tile_proc(&ti);
+                        _tile_type_procs[tt]->draw_tile_proc(&ti);
 
-			if ((x_cur == (int)MapMaxX() * TILE_SIZE && IsInsideMM(y_cur, 0, MapMaxY() * TILE_SIZE + 1)) ||
-					(y_cur == (int)MapMaxY() * TILE_SIZE && IsInsideMM(x_cur, 0, MapMaxX() * TILE_SIZE + 1))) {
-				TileIndex tile = TileVirtXY(x_cur, y_cur);
-				ti.tile = tile;
-				ti.tileh = GetTilePixelSlope(tile, &ti.z);
-				tt = GetTileType(tile);
-			}
-			if (ti.tile != INVALID_TILE) DrawTileSelection(&ti);
+                        if ((x_cur == (int)MapMaxX() * TILE_SIZE && IsInsideMM(y_cur, 0, MapMaxY() * TILE_SIZE + 1)) ||
+                                        (y_cur == (int)MapMaxY() * TILE_SIZE && IsInsideMM(x_cur, 0, MapMaxX() * TILE_SIZE + 1))) {
+                                TileIndex tile = TileVirtXY(x_cur, y_cur);
+                                ti.tile = tile;
+                                ti.tileh = GetTilePixelSlope(tile, &ti.z);
+                                tt = GetTileType(tile);
+                        }
+                        if (ti.tile != INVALID_TILE) DrawTileSelection(&ti);
 
-			y_cur += 0x10;
-			x_cur -= 0x10;
-		} while (--width_cur);
+                        y_cur += 0x10;
+                        x_cur -= 0x10;
+                } while (--width_cur);
 
-		if ((direction ^= 1) != 0) {
-			y += 0x10;
-		} else {
-			x += 0x10;
-		}
-	} while (--height);
+                if ((direction ^= 1) != 0) {
+                        y += 0x10;
+                } else {
+                        x += 0x10;
+                }
+        } while (--height);
 }
 
 /**
@@ -1172,8 +1427,7 @@
 	const Town *t;
 	FOR_ALL_TOWNS(t) {
 		ViewportAddString(dpi, ZOOM_LVL_OUT_16X, &t->cache.sign,
-				_settings_client.gui.population_in_label ? STR_VIEWPORT_TOWN_POP : STR_VIEWPORT_TOWN,
-				STR_VIEWPORT_TOWN_TINY_WHITE, STR_VIEWPORT_TOWN_TINY_BLACK,
+				t->Label(), t->SmallLabel(), STR_VIEWPORT_TOWN_TINY_BLACK,
 				t->index, t->cache.population);
 	}
 }
@@ -1376,6 +1630,189 @@
 		        pt4.x - pt1.x, pt4.y - pt1.y);
 	}
 }
+#define X PC_BLACK
+#define I PC_YELLOW
+#define ROUTE_STOPOVER_WIDTH 23
+#define ROUTE_STOPOVER_HEIGHT 23
+static const uint8 _route_stopover[ROUTE_STOPOVER_HEIGHT][ROUTE_STOPOVER_WIDTH] = {
+       { 0, 0, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, 0, 0 },
+       { 0, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, 0 },
+       { X, X, X, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, X, X, X },
+       { X, X, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, X, X },
+       { X, X, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, X, X },
+       { X, X, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, X, X },
+       { X, X, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, X, X },
+       { X, X, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, X, X },
+       { X, X, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, X, X },
+       { X, X, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, X, X },
+       { X, X, X, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, X, X, X },
+       { 0, X, X, X, X, X, X, X, X, X, X, I, X, X, X, X, X, X, X, X, X, X, 0 },
+       { 0, 0, X, X, X, X, X, X, X, X, X, I, X, X, X, X, X, X, X, X, X, 0, 0 },
+       { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, X, I, X, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
+       { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, X, I, X, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
+       { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, X, I, X, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
+       { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, X, I, X, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
+       { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, X, I, X, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
+       { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, X, I, X, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
+       { 0, 0, 0, 0, 0, 0, 0, 0, X, I, I, I, I, I, X, 0, 0, 0, 0, 0, 0, 0, 0 },
+       { 0, 0, 0, 0, 0, 0, 0, 0, 0, X, I, I, I, X, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
+       { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, X, I, X, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
+       { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, X, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
+};
+#undef X
+#undef I
+static inline void DrawRouteStopover(const ViewPort *vp, const TileIndex tile)
+{
+       if (tile == INVALID_TILE) return;
+       const Point pt = RemapCoords2(TileX(tile) * TILE_SIZE, TileY(tile) * TILE_SIZE);
+       const int w = UnScaleByZoom(_vd.dpi.width, _vd.dpi.zoom);
+       const int h = UnScaleByZoom(_vd.dpi.height, _vd.dpi.zoom);
+       const int x = UnScaleByZoomLower(pt.x - _vd.dpi.left, _vd.dpi.zoom) - (ROUTE_STOPOVER_WIDTH / 2);
+       const int y = UnScaleByZoomLower(pt.y - _vd.dpi.top,  _vd.dpi.zoom) - ROUTE_STOPOVER_HEIGHT;
+       
+       /* Where is it allowed to draw? */
+       const int bounds_lef = max(0, x);
+       const int bounds_rig = min(w, x + ROUTE_STOPOVER_WIDTH);
+       if (bounds_rig <= bounds_lef) return;
+       const int bounds_top = max(0, y);
+       const int bounds_bot = min(h, y + ROUTE_STOPOVER_WIDTH);
+       if (bounds_bot <= bounds_top) return;
+
+       /* OK, let's draw! */
+       Blitter *blitter = BlitterFactoryBase::GetCurrentBlitter();
+       for (int j = bounds_top; j < bounds_bot; j++) {
+               for (int i = bounds_lef; i < bounds_rig; i++) {
+                       const uint8 colour = _route_stopover[j - y][i - x];
+                       if (colour)
+                               blitter->SetPixel(_vd.dpi.dst_ptr, i, j, colour);
+               }
+       }
+
+       /* Write order's info */
+       DrawPixelInfo *old_dpi = _cur_dpi;
+       _cur_dpi = &_dpi_for_text;
+       DrawString(_dpi_for_text.left + x + 2, _dpi_for_text.left + x + ROUTE_STOPOVER_WIDTH - 2, _dpi_for_text.top + y + 3, STR_VIEWPORT_MAP_SHOW_VEHICLE_ROUTE_STOPOVER, TC_FROMSTRING, SA_CENTER, false, FS_SMALL);
+       _cur_dpi = old_dpi;
+}
+
+static inline const Vehicle *GetVehicleOfFocusedWindow(void)
+{
+       if (_focused_window) {
+               switch (_focused_window->window_class) {
+                       case WC_VEHICLE_VIEW:
+                       case WC_VEHICLE_ORDERS:
+                       case WC_VEHICLE_TIMETABLE:
+                       case WC_VEHICLE_DETAILS:
+                       case WC_VEHICLE_REFIT:
+                               if (_focused_window->window_number != INVALID_VEHICLE) return Vehicle::Get(_focused_window->window_number);
+                               break;
+                       default:
+                               break;
+               }
+       }
+       return NULL;
+}
+
+static inline TileIndex GetLastValidOrderLocation(const Vehicle *veh)
+{
+	Order *order;
+	TileIndex tmp, result = INVALID_TILE;
+	FOR_VEHICLE_ORDERS(veh, order) {
+		switch (order->GetType()) {
+			case OT_GOTO_STATION:
+			case OT_GOTO_WAYPOINT:
+			case OT_IMPLICIT:
+			case OT_GOTO_DEPOT:
+				tmp = order->GetLocation(veh, veh->type == VEH_AIRCRAFT);
+				if (tmp != INVALID_TILE) result = tmp;
+				break;
+			default:
+				break;
+		}
+	}
+	return result;
+}
+
+static inline Order *GetFinalOrder(const Vehicle *veh, Order *order)
+{
+	while (order->IsType(OT_CONDITIONAL))
+		order = veh->GetOrder(order->GetConditionSkipToOrder());
+	return order;
+}
+
+/**
+ * Draw the route path of a vehicle
+ */
+static void ViewportMapDrawVehicleRoutePath(const ViewPort *vp)
+{
+	Order *order;
+	const Vehicle *veh = GetVehicleOfFocusedWindow();
+	if (!veh) return;
+
+	TileIndex from_tile;
+	switch (_settings_client.gui.show_vehicle_route_path) {
+		case 0: // No
+			return;
+
+		case 1: // Simple
+			from_tile = GetLastValidOrderLocation(veh);
+			if (from_tile == INVALID_TILE) return;
+			FOR_VEHICLE_ORDERS(veh, order) {
+				const Point from_pt = RemapCoords2(TileX(from_tile) * TILE_SIZE, TileY(from_tile) * TILE_SIZE);
+				const int from_x = UnScaleByZoom(from_pt.x, vp->zoom);
+				const int from_y = UnScaleByZoom(from_pt.y, vp->zoom);
+
+				Order *final_order = GetFinalOrder(veh, order);
+				const TileIndex to_tile = final_order->GetLocation(veh, veh->type == VEH_AIRCRAFT);
+				if (to_tile == INVALID_TILE) continue;
+				const Point to_pt = RemapCoords2(TileX(to_tile) * TILE_SIZE, TileY(to_tile) * TILE_SIZE);
+				const int to_x = UnScaleByZoom(to_pt.x, vp->zoom);
+				const int to_y = UnScaleByZoom(to_pt.y, vp->zoom);
+				
+				DrawPixelInfo *old_dpi = _cur_dpi;
+				_cur_dpi = &_dpi_for_text;
+				GfxDrawLine(from_x, from_y, to_x, to_y, PC_BLACK, 3);
+				GfxDrawLine(from_x, from_y, to_x, to_y, (final_order == order) ? PC_WHITE : PC_YELLOW, 1);
+				_cur_dpi = old_dpi;
+				
+				const OrderType ot = order->GetType();
+				if (ot == OT_GOTO_STATION || ot == OT_GOTO_DEPOT || ot == OT_GOTO_WAYPOINT || ot == OT_IMPLICIT) from_tile = to_tile;
+			}
+			break;
+	}
+}
+
+/**
+ * Draw the route stopovers of a vehicle
+ */
+static void ViewportMapDrawVehicleRouteStopovers(const ViewPort *vp)
+    {
+       const Vehicle *veh = GetVehicleOfFocusedWindow();
+       if (!veh) return;
+
+       Order *order;
+       int order_rank = 0;
+       FOR_VEHICLE_ORDERS(veh, order) {
+               SetDParam(0, ++order_rank);
+               switch (order->GetType()) {
+                       case OT_GOTO_STATION:
+                               SetDParam(1, STR_VIEWPORT_MAP_SHOW_VEHICLE_ROUTE_STOPOVER_STATION);
+                               goto draw;
+                       case OT_GOTO_DEPOT:
+                               SetDParam(1, STR_VIEWPORT_MAP_SHOW_VEHICLE_ROUTE_STOPOVER_DEPOT);
+                               goto draw;
+                       case OT_GOTO_WAYPOINT:
+                               SetDParam(1, STR_VIEWPORT_MAP_SHOW_VEHICLE_ROUTE_STOPOVER_WAYPOINT);
+                               goto draw;
+                       case OT_IMPLICIT:
+                               SetDParam(1, STR_VIEWPORT_MAP_SHOW_VEHICLE_ROUTE_STOPOVER_IMPLICIT);
+draw:
+                               DrawRouteStopover(vp, order->GetLocation(veh, veh->type == VEH_AIRCRAFT));
+                               break;
+                       default: break; // OT_NOTHING OT_LOADING OT_LEAVESTATION OT_DUMMY OT_CONDITIONAL
+               }
+       }
+}
 
 /**
  * Draw/colour the blocks that have been redrawn.
@@ -1475,6 +1912,13 @@
 
 	_vd.dpi.dst_ptr = BlitterFactoryBase::GetCurrentBlitter()->MoveTo(old_dpi->dst_ptr, x - old_dpi->left, y - old_dpi->top);
 
+       _dpi_for_text        = _vd.dpi;
+       _dpi_for_text.left   = UnScaleByZoom(_dpi_for_text.left,   _dpi_for_text.zoom);
+       _dpi_for_text.top    = UnScaleByZoom(_dpi_for_text.top,    _dpi_for_text.zoom);
+       _dpi_for_text.width  = UnScaleByZoom(_dpi_for_text.width,  _dpi_for_text.zoom);
+       _dpi_for_text.height = UnScaleByZoom(_dpi_for_text.height, _dpi_for_text.zoom);
+       _dpi_for_text.zoom   = ZOOM_LVL_NORMAL;
+
 	ViewportAddLandscape();
 	ViewportAddVehicles(&_vd.dpi);
 
@@ -1497,7 +1941,9 @@
 	if (_draw_bounding_boxes) ViewportDrawBoundingBoxes(&_vd.parent_sprites_to_sort);
 	if (_draw_dirty_blocks) ViewportDrawDirtyBlocks();
 
+	ViewportMapDrawVehicleRoutePath(vp);
 	if (_vd.string_sprites_to_draw.Length() != 0) ViewportDrawStrings(&_vd.dpi, &_vd.string_sprites_to_draw);
+       if (_settings_client.gui.show_vehicle_route_stopovers) ViewportMapDrawVehicleRouteStopovers(vp);
 
 	_cur_dpi = old_dpi;
 
@@ -1567,6 +2013,16 @@
 	dpi->top -= this->top;
 }
 
+/**
+ * How far should I allow scrolling outside the map?
+ *
+ * @see ClampViewportToMap()
+ */
+inline uint16 GetMaxScrollOutsideMap() {
+	/* Allow scrolling to high peaks at the NE/NW border if AllowMoreHeightlevels is true. */
+	return MAXSCROLL;
+}
+
 static inline void ClampViewportToMap(const ViewPort *vp, int &x, int &y)
 {
 	/* Centre of the viewport is hot spot */
@@ -1578,9 +2034,9 @@
 	int vx = -x + y * 2;
 	int vy =  x + y * 2;
 
-	/* clamp to size of map */
-	vx = Clamp(vx, 0, MapMaxX() * TILE_SIZE * 4 * ZOOM_LVL_BASE);
-	vy = Clamp(vy, 0, MapMaxY() * TILE_SIZE * 4 * ZOOM_LVL_BASE);
+	/* Clamp to size of map. */
+        vx = Clamp(vx, 0, MapMaxX() * TILE_SIZE * 4 * ZOOM_LVL_BASE);
+        vy = Clamp(vy, 0, MapMaxY() * TILE_SIZE * 4 * ZOOM_LVL_BASE);
 
 	/* Convert map coordinates to viewport coordinates */
 	x = (-vx + vy) / 2;
@@ -1631,6 +2087,9 @@
 	}
 }
 
+       
+
+
 /**
  * Marks a viewport as dirty for repaint if it displays (a part of) the area the needs to be repainted.
  * @param vp     The viewport to mark as dirty
@@ -1684,6 +2143,34 @@
 	}
 }
 
+static void MarkRouteStopoverDirty(const TileIndex tile)
+{
+	assert(tile != INVALID_TILE);
+	Window *w;
+	const Point pt = RemapCoords2(TileX(tile) * TILE_SIZE, TileY(tile) * TILE_SIZE);
+	FOR_ALL_WINDOWS_FROM_BACK(w) {
+		const ViewPort *vp = w->viewport;
+		if (vp != NULL) {
+			assert(vp->width != 0);
+			const int half_width = ScaleByZoom((ROUTE_STOPOVER_WIDTH / 2) + 1, vp->zoom);
+			const int height = ScaleByZoom(ROUTE_STOPOVER_HEIGHT, vp->zoom);
+			MarkViewportDirty(vp, pt.x - half_width, pt.y - height, pt.x + half_width, pt.y);
+		}
+	}
+}
+
+void MarkAllRouteStopoversDirty(const Vehicle *veh)
+{
+	if (!_settings_client.gui.show_vehicle_route_stopovers) return;
+//	if (!_settings_client.gui.viewport_map_in_realtime) return;
+	
+	Order *order;
+	FOR_VEHICLE_ORDERS(veh, order) {
+		const TileIndex tile = order->GetLocation(veh, veh->type == VEH_AIRCRAFT);
+		if (tile != INVALID_TILE) MarkRouteStopoverDirty(tile);
+	}
+}
+
 void ConstrainAllViewportsZoom()
 {
 	Window *w;
@@ -1714,6 +2201,76 @@
 	);
 }
 
+static void MarkTileLineDirty(const TileIndex from_tile, const TileIndex to_tile)
+{
+	assert(from_tile != INVALID_TILE);
+	assert(to_tile != INVALID_TILE);
+
+	int x1 = TileX(from_tile);
+	int y1 = TileY(from_tile);
+	const int x2 = TileX(to_tile);
+	const int y2 = TileY(to_tile);
+
+	/* http://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm#Simplification */
+	const int dx = abs(x2 - x1);
+	const int dy = abs(y2 - y1);
+	const int sx = (x1 < x2) ? 1 : -1;
+	const int sy = (y1 < y2) ? 1 : -1;
+	int err = dx - dy;
+	for (;;) {
+		MarkTileDirtyByTile(TileXY(x1, y1));
+		if (x1 == x2 && y1 == y2) break;
+		const int e2 = 2 * err;
+		if (e2 > -dy) {
+			err -= dy;
+			x1 += sx;
+		}
+		if (e2 < dx) {
+			err += dx;
+			y1 += sy;
+		}
+	}
+}
+
+void MarkAllRoutePathsDirty(const Vehicle *veh)
+{
+//	if (!_settings_client.gui.viewport_map_in_realtime) return;
+	
+	Order *order;
+	TileIndex from_tile;
+	switch (_settings_client.gui.show_vehicle_route_path) {
+		case 0: // No
+			return;
+
+		case 1: // Simple
+			from_tile = GetLastValidOrderLocation(veh);
+			if (from_tile == INVALID_TILE) return;
+			FOR_VEHICLE_ORDERS(veh, order) {
+				Order *final_order = GetFinalOrder(veh, order);
+				const TileIndex to_tile = final_order->GetLocation(veh, veh->type == VEH_AIRCRAFT);
+				if (to_tile == INVALID_TILE) continue;
+				MarkTileLineDirty(from_tile, to_tile);
+				const OrderType ot = order->GetType();
+				if (ot == OT_GOTO_STATION || ot == OT_GOTO_DEPOT || ot == OT_GOTO_WAYPOINT || ot == OT_IMPLICIT) from_tile = to_tile;
+			}
+			break;
+	}
+}
+
+void MarkTileDirtyByTileOutsideMap(int x, int y)
+{
+	Point pt = RemapCoords(x * TILE_SIZE, y * TILE_SIZE, GetTilePixelZOutsideMap(x, y));
+	/* Since tiles painted outside the map don't contain buildings, trees, etc.,
+	 * this reduced area for repainting should suffice. If not, adjust the offsets
+	 * used below. */
+	MarkAllViewportsDirty(
+		pt.x - TILE_SIZE + 1,
+		pt.y,
+		pt.x + TILE_SIZE - 1,
+		pt.y + TILE_SIZE + TILE_HEIGHT - 1
+	);
+}
+
 /**
  * Marks the selected tiles as dirty.
  *
@@ -1940,7 +2497,7 @@
 	pt = GetTileBelowCursor();
 	if (pt.x == -1) return;
 
-	if ((_thd.place_mode & HT_DRAG_MASK) == HT_POINT) {
+	if ((_thd.place_mode & HT_DRAG_MASK) == HT_POINT && !(_thd.place_mode & HT_PASTE_PREVIEW)) {
 		pt.x += TILE_SIZE / 2;
 		pt.y += TILE_SIZE / 2;
 	}
@@ -1953,7 +2510,7 @@
 }
 
 
-bool HandleViewportClicked(const ViewPort *vp, int x, int y)
+bool HandleViewportClicked(const ViewPort *vp, int x, int y, bool double_click)
 {
 	const Vehicle *v = CheckClickOnVehicle(vp, x, y);
 
@@ -1961,6 +2518,13 @@
 		if (v != NULL && VehicleClicked(v)) return true;
 	}
 
+	/* Double-clicking finishes current polyline and starts new one. */
+	if (double_click && (_thd.place_mode & HT_POLY)) {
+		ClearRailPlacementEndpoints();
+		SetTileSelectSize(1, 1);
+		return true;
+	}
+
 	/* Vehicle placement mode already handled above. */
 	if ((_thd.place_mode & HT_DRAG_MASK) != HT_NONE) {
 		PlaceObject();
@@ -1976,9 +2540,10 @@
 		DEBUG(misc, 2, "Vehicle %d (index %d) at %p", v->unitnumber, v->index, v);
 		if (IsCompanyBuildableVehicleType(v)) {
 			v = v->First();
+			WindowClass wc = _thd.GetCallbackWnd()->window_class;
 			if (_ctrl_pressed && v->owner == _local_company) {
 				StartStopVehicle(v, true);
-			} else {
+			} else if ( wc != WC_CREATE_TEMPLATE && wc != WC_TEMPLATEGUI_MAIN) {
 				ShowVehicleViewWindow(v);
 			}
 		}
@@ -2000,7 +2565,14 @@
 bool ScrollWindowTo(int x, int y, int z, Window *w, bool instant)
 {
 	/* The slope cannot be acquired outside of the map, so make sure we are always within the map. */
-	if (z == -1) z = GetSlopePixelZ(Clamp(x, 0, MapSizeX() * TILE_SIZE - 1), Clamp(y, 0, MapSizeY() * TILE_SIZE - 1));
+	if (z == -1) {
+		if ( x >= 0 && x <= (int)MapSizeX() * (int)TILE_SIZE - 1
+				&& y >= 0 && y <= (int)MapSizeY() * (int)TILE_SIZE - 1) {
+			z = GetSlopePixelZ(x, y);
+		} else {
+			z = TileHeightOutsideMap(x / TILE_SIZE, y / TILE_SIZE);
+		}
+	}
 
 	Point pt = MapXYZToViewport(w->viewport, x, y, z);
 	w->viewport->follow_vehicle = INVALID_VEHICLE;
@@ -2113,7 +2685,7 @@
 	return FindWindowById(this->window_class, this->window_number);
 }
 
-
+static HighLightStyle CalcPolyrailDrawstyle(Point pt);
 
 /**
  * Updates tile highlighting for all cases.
@@ -2166,32 +2738,48 @@
 					break;
 				case HT_POINT:
 					new_drawstyle = HT_POINT;
-					x1 += TILE_SIZE / 2;
-					y1 += TILE_SIZE / 2;
+					if (!(_thd.place_mode & HT_PASTE_PREVIEW)) {
+						x1 += TILE_SIZE / 2;
+						y1 += TILE_SIZE / 2;
+					}
 					break;
 				case HT_RAIL:
-					/* Draw one highlighted tile in any direction */
-					new_drawstyle = GetAutorailHT(pt.x, pt.y);
-					break;
 				case HT_LINE:
-					switch (_thd.place_mode & HT_DIR_MASK) {
-						case HT_DIR_X: new_drawstyle = HT_LINE | HT_DIR_X; break;
-						case HT_DIR_Y: new_drawstyle = HT_LINE | HT_DIR_Y; break;
-
-						case HT_DIR_HU:
-						case HT_DIR_HL:
-							new_drawstyle = (pt.x & TILE_UNIT_MASK) + (pt.y & TILE_UNIT_MASK) <= TILE_SIZE ? HT_LINE | HT_DIR_HU : HT_LINE | HT_DIR_HL;
+					/* Handle polyline highlight */
+					if (_thd.place_mode & HT_POLY) {
+						new_drawstyle = CalcPolyrailDrawstyle(pt);
+						if (new_drawstyle != HT_NONE) {
+							x1 = min(_thd.selstart.x, _thd.selend.x);
+							y1 = min(_thd.selstart.y, _thd.selend.y);
+							_thd.new_size.x = abs<int>(_thd.selstart.x - (_thd.selend.x & ~TILE_UNIT_MASK)) + TILE_SIZE;
+							_thd.new_size.y = abs<int>(_thd.selstart.y - (_thd.selend.y & ~TILE_UNIT_MASK)) + TILE_SIZE;
 							break;
+						}
+					}
+					/* Handle regular (non-polyline) highlight */
+					if (_thd.place_mode & HT_RAIL) {
+						/* Draw one highlighted tile in any direction */
+						new_drawstyle = GetAutorailHT(pt.x, pt.y);
+					} else { // HT_LINE
+						switch (_thd.place_mode & HT_DIR_MASK) {
+							case HT_DIR_X: new_drawstyle = HT_LINE | HT_DIR_X; break;
+							case HT_DIR_Y: new_drawstyle = HT_LINE | HT_DIR_Y; break;
 
-						case HT_DIR_VL:
-						case HT_DIR_VR:
-							new_drawstyle = (pt.x & TILE_UNIT_MASK) > (pt.y & TILE_UNIT_MASK) ? HT_LINE | HT_DIR_VL : HT_LINE | HT_DIR_VR;
-							break;
+							case HT_DIR_HU:
+							case HT_DIR_HL:
+								new_drawstyle = (pt.x & TILE_UNIT_MASK) + (pt.y & TILE_UNIT_MASK) <= TILE_SIZE ? HT_LINE | HT_DIR_HU : HT_LINE | HT_DIR_HL;
+								break;
 
-						default: NOT_REACHED();
+							case HT_DIR_VL:
+							case HT_DIR_VR:
+								new_drawstyle = (pt.x & TILE_UNIT_MASK) > (pt.y & TILE_UNIT_MASK) ? HT_LINE | HT_DIR_VL : HT_LINE | HT_DIR_VR;
+								break;
+
+							default: NOT_REACHED();
+						}
+						_thd.selstart.x = x1 & ~TILE_UNIT_MASK;
+						_thd.selstart.y = y1 & ~TILE_UNIT_MASK;
 					}
-					_thd.selstart.x = x1 & ~TILE_UNIT_MASK;
-					_thd.selstart.y = y1 & ~TILE_UNIT_MASK;
 					break;
 				default:
 					NOT_REACHED();
@@ -2455,7 +3043,31 @@
 	return (int)(h1 - h0) * TILE_HEIGHT_STEP;
 }
 
-static const StringID measure_strings_length[] = {STR_NULL, STR_MEASURE_LENGTH, STR_MEASURE_LENGTH_HEIGHTDIFF};
+static void ShowLengthMeasurement(HighLightStyle style, TileIndex start_tile, TileIndex end_tile, TooltipCloseCondition close_cond = TCC_LEFT_CLICK, bool show_single_tile_length = false)
+{
+	static const StringID measure_strings_length[] = {STR_NULL, STR_MEASURE_LENGTH, STR_MEASURE_LENGTH_HEIGHTDIFF};
+
+	if (_settings_client.gui.measure_tooltip) {
+		uint distance = DistanceManhattan(start_tile, end_tile) + 1;
+		byte index = 0;
+		uint64 params[2];
+
+		if (show_single_tile_length || distance != 1) {
+			int heightdiff = CalcHeightdiff(style, distance, start_tile, end_tile);
+			/* If we are showing a tooltip for horizontal or vertical drags,
+			 * 2 tiles have a length of 1. To bias towards the ceiling we add
+			 * one before division. It feels more natural to count 3 lengths as 2 */
+			if ((style & HT_DIR_MASK) != HT_DIR_X && (style & HT_DIR_MASK) != HT_DIR_Y) {
+				distance = CeilDiv(distance, 2);
+			}
+
+			params[index++] = distance;
+			if (heightdiff != 0) params[index++] = heightdiff;
+		}
+
+		ShowMeasurementTooltips(measure_strings_length[index], index, params, close_cond);
+	}
+}
 
 /**
  * Check for underflowing the map.
@@ -2486,8 +3098,178 @@
 	test = max;
 }
 
+static const struct {
+	Point start_point_offset;
+	Point direction;
+}
+_auto_line_by_trackdir[] = {
+	{ {     TILE_SIZE - 2,     TILE_SIZE / 2 }, { -1,  0 } }, // TRACKDIR_X_NE
+	{ {     TILE_SIZE / 2,                 0 }, {  0, +1 } }, // TRACKDIR_Y_SE
+	{ { TILE_SIZE / 2 - 1,                 0 }, { -1, +1 } }, // TRACKDIR_UPPER_E
+	{ {     TILE_SIZE - 1,     TILE_SIZE / 2 }, { -1, +1 } }, // TRACKDIR_LOWER_E
+	{ {     TILE_SIZE / 2,                 0 }, { +1, +1 } }, // TRACKDIR_LEFT_S
+	{ {                 0,     TILE_SIZE / 2 }, { +1, +1 } }, // TRACKDIR_RIGHT_S
+	{ { 0, 0 }, { 0, 0 } }, // TRACKDIR_RVREV_NE
+	{ { 0, 0 }, { 0, 0 } }, // TRACKDIR_RVREV_SE
+	{ {                 0,     TILE_SIZE / 2 }, { +1,  0 } }, // TRACKDIR_X_SW
+	{ {     TILE_SIZE / 2,     TILE_SIZE - 1 }, {  0, -1 } }, // TRACKDIR_Y_NW
+	{ {                 0, TILE_SIZE / 2 - 1 }, { +1, -1 } }, // TRACKDIR_UPPER_W
+	{ {     TILE_SIZE / 2,     TILE_SIZE - 1 }, { +1, -1 } }, // TRACKDIR_LOWER_W
+	{ {     TILE_SIZE - 1, TILE_SIZE / 2 - 1 }, { -1, -1 } }, // TRACKDIR_LEFT_N
+	{ { TILE_SIZE / 2 - 1,     TILE_SIZE - 1 }, { -1, -1 } }  // TRACKDIR_RIGHT_N
+};
+
+/**
+ * Returns the distnce from a given point to a rail line.
+ *
+ * @param pt The point to get the distance from.
+ * @param start_tile Coordinates, in tile "units", of the tile where the line starts.
+ * @param trackdir The first trackdir of the line.
+ * @return X/Y coordinates of the vector that connects the 'pt' point with the line at the best path.
+ */
+static Point GetDistanceToAutoLine(Point pt, Point start_tile, Trackdir trackdir)
+{
+	assert(IsValidTrackdir(trackdir) && !IsReversingRoadTrackdir(trackdir));
+
+	/* calculate distance from the given point to the point where the line starts */
+	Point d = {
+		start_tile.x + _auto_line_by_trackdir[trackdir].start_point_offset.x - pt.x,
+		start_tile.y + _auto_line_by_trackdir[trackdir].start_point_offset.y - pt.y
+	};
+	/* get line direction */
+	Point direction = _auto_line_by_trackdir[trackdir].direction;
+	/* correct the start point for "diagonal" dirs; there are two possible lines, choose the closer one */
+	if (direction.x == 0) { // TRACKDIR_Y_SE and TRACKDIR_Y_NW trackdirs
+		d.x -= (int)(d.x > 0);
+	} else if (direction.y == 0) { // TRACKDIR_X_NE and TRACKDIR_X_SW trackdirs
+		d.y -= (int)(d.y > 0);
+	}
+
+	/* calculate distance to the end of the line */
+	int scale = direction.x * direction.x + direction.y * direction.y;
+	int length = d.x * direction.y - d.y * direction.x;
+	Point ret = { direction.y, -direction.x }; // 'direction' rotated 90 degree right
+	if (length > 0) { // is the 'p' point on the left side of the line ("up" is pointed by 'direction')
+		ret.x -= direction.x;
+		ret.y -= direction.y;
+	} else {
+		ret.x += direction.x;
+		ret.y += direction.y;
+	}
+	ret.x = length * ret.x / scale;
+	ret.y = length * ret.y / scale;
+
+	/* test if the calculated end point is behind the start point;
+	 * if not return the distance to the start point */
+	if (((d.x < ret.x) == (direction.x < 0)) && ((d.y < ret.y) == (direction.y < 0))) return d;
+
+	return ret;
+}
+
+static void ClampAutoLineToMapBorders(Point *line_end, Track line_orientation)
+{
+	int padding = _settings_game.construction.freeform_edges ? TILE_SIZE : 0;
+
+	Rect borders = {
+		padding,                              // left
+		padding,                              // top
+		MapSizeX() * TILE_SIZE - padding - 1, // right
+		MapSizeY() * TILE_SIZE - padding - 1  // bottom
+	};
+
+	switch (line_orientation) {
+		case TRACK_X:
+			line_end->y = Clamp(line_end->y, borders.top, borders.bottom);
+			break;
+
+		case TRACK_Y:
+			line_end->x = Clamp(line_end->x, borders.left, borders.right);
+			break;
+
+		case TRACK_UPPER:
+		case TRACK_LOWER:
+			if (line_end->x < borders.left) {
+				line_end->y += borders.left - line_end->x;
+				line_end->x += borders.left - line_end->x;
+			} else if (line_end->x > borders.right) {
+				line_end->y += borders.right - line_end->x;
+				line_end->x += borders.right - line_end->x;
+			}
+			if (line_end->y < borders.top) {
+				line_end->x += borders.top - line_end->y;
+				line_end->y += borders.top - line_end->y;
+			} else if (line_end->y > borders.bottom) {
+				line_end->x += borders.bottom - line_end->y;
+				line_end->y += borders.bottom - line_end->y;
+			}
+			break;
+
+		case TRACK_LEFT:
+		case TRACK_RIGHT:
+			if (line_end->x < borders.left) {
+				line_end->y -= borders.left - line_end->x;
+				line_end->x += borders.left - line_end->x;
+			} else if (line_end->x > borders.right) {
+				line_end->y -= borders.right - line_end->x;
+				line_end->x += borders.right - line_end->x;
+			}
+			if (line_end->y < borders.top) {
+				line_end->x -= borders.top - line_end->y;
+				line_end->y += borders.top - line_end->y;
+			} else if (line_end->y > borders.bottom) {
+				line_end->x -= borders.bottom - line_end->y;
+				line_end->y += borders.bottom - line_end->y;
+			}
+			break;
+
+		default:
+			NOT_REACHED();
+	}
+
+	assert(IsInsideMM(line_end->x, borders.left, borders.right + 1) && IsInsideMM(line_end->y, borders.top, borders.bottom + 1));
+}
+
+static const TrackdirBits _autoline_dirs_allowed_by_highlight_dir[] = {
+	TRACKDIR_BIT_X_NE | TRACKDIR_BIT_X_SW,                                                     // HT_DIR_X
+	TRACKDIR_BIT_Y_NW | TRACKDIR_BIT_Y_SE,                                                     // HT_DIR_Y
+	TRACKDIR_BIT_UPPER_E | TRACKDIR_BIT_LOWER_E | TRACKDIR_BIT_UPPER_W | TRACKDIR_BIT_LOWER_W, // HT_DIR_HU
+	TRACKDIR_BIT_UPPER_E | TRACKDIR_BIT_LOWER_E | TRACKDIR_BIT_UPPER_W | TRACKDIR_BIT_LOWER_W, // HT_DIR_HL
+	TRACKDIR_BIT_LEFT_N | TRACKDIR_BIT_RIGHT_N | TRACKDIR_BIT_LEFT_S | TRACKDIR_BIT_RIGHT_S,   // HT_DIR_VL
+	TRACKDIR_BIT_LEFT_N | TRACKDIR_BIT_RIGHT_N | TRACKDIR_BIT_LEFT_S | TRACKDIR_BIT_RIGHT_S,   // HT_DIR_VR
+};
+
+static Trackdir FindBestAutoLine(const Point &pt, RailTrackEndpoint *start_points, uint num_start_points, TrackdirBits allowed_trackdirs, Point *ret_start_tile, Point *ret_end_pos)
+{
+	Trackdir ret = INVALID_TRACKDIR;
+	uint best_distance = UINT_MAX;
+
+	for (; num_start_points-- > 0; start_points++) {
+		/* skip invalid tiles */
+		if (!IsValidTile(start_points->tile)) continue;
+
+		Trackdir trackdir;
+		FOR_EACH_SET_TRACKDIR(trackdir, start_points->dirs & allowed_trackdirs) {
+			Point start_tile = { TileX(start_points->tile) * TILE_SIZE, TileY(start_points->tile) * TILE_SIZE };
+			Point offset = GetDistanceToAutoLine(pt, start_tile, trackdir);
+			uint distance = (uint)(offset.x * offset.x + offset.y * offset.y);
+			if (distance < best_distance) {
+				*ret_start_tile = start_tile;
+				ret_end_pos->x = pt.x + offset.x;
+				ret_end_pos->y = pt.y + offset.y;
+				best_distance = distance;
+				ret = trackdir;
+			}
+		}
+	}
+
+	/* cut the line at map borders */
+	if (ret != INVALID_TRACKDIR) ClampAutoLineToMapBorders(ret_end_pos, TrackdirToTrack(ret));
+
+	return ret;
+}
+
 /** while dragging */
-static void CalcRaildirsDrawstyle(int x, int y, int method)
+static void CalcRaildirsDrawstyle(int x, int y, ViewportPlaceMethod method)
 {
 	HighLightStyle b;
 
@@ -2672,32 +3454,31 @@
 		}
 	}
 
-	if (_settings_client.gui.measure_tooltip) {
-		TileIndex t0 = TileVirtXY(_thd.selstart.x, _thd.selstart.y);
-		TileIndex t1 = TileVirtXY(x, y);
-		uint distance = DistanceManhattan(t0, t1) + 1;
-		byte index = 0;
-		uint64 params[2];
+	_thd.selend.x = x;
+	_thd.selend.y = y;
+	_thd.next_drawstyle = b;
 
-		if (distance != 1) {
-			int heightdiff = CalcHeightdiff(b, distance, t0, t1);
-			/* If we are showing a tooltip for horizontal or vertical drags,
-			 * 2 tiles have a length of 1. To bias towards the ceiling we add
-			 * one before division. It feels more natural to count 3 lengths as 2 */
-			if ((b & HT_DIR_MASK) != HT_DIR_X && (b & HT_DIR_MASK) != HT_DIR_Y) {
-				distance = CeilDiv(distance, 2);
-			}
+	ShowLengthMeasurement(b, TileVirtXY(_thd.selstart.x, _thd.selstart.y), TileVirtXY(_thd.selend.x, _thd.selend.y));
+}
 
-			params[index++] = distance;
-			if (heightdiff != 0) params[index++] = heightdiff;
-		}
+static HighLightStyle CalcPolyrailDrawstyle(Point pt)
+{
+	/* directions allowed by highlight method */
+	TrackdirBits allowed_trackdirs = (_thd.place_mode & HT_RAIL) ? TRACKDIR_BIT_MASK : _autoline_dirs_allowed_by_highlight_dir[_thd.place_mode & HT_DIR_MASK];
 
-		ShowMeasurementTooltips(measure_strings_length[index], index, params);
-	}
+	/* now find the best track */
+	Trackdir best_trackdir = FindBestAutoLine(pt, _rail_track_endpoints, lengthof(_rail_track_endpoints), allowed_trackdirs, &_thd.selstart, &_thd.selend);
+	if (best_trackdir == INVALID_TRACKDIR) return HT_NONE; // no match
 
-	_thd.selend.x = x;
-	_thd.selend.y = y;
-	_thd.next_drawstyle = b;
+	TileIndex start_tile = TileVirtXY(_thd.selstart.x, _thd.selstart.y);
+	TileIndex end_tile = TileVirtXY(_thd.selend.x, _thd.selend.y);
+
+	HighLightStyle ret = HT_POLY |
+			(HighLightStyle)TrackdirToTrack(best_trackdir) | // cast TRACK_XXX to HT_DIR_XXX
+			(start_tile == end_tile ? HT_RAIL : HT_LINE); // one tile case or multitile selection
+
+	ShowLengthMeasurement(ret, start_tile, end_tile, TCC_HOVER, true);
+	return ret;
 }
 
 /**
@@ -2769,27 +3550,12 @@
 				x = sx + Clamp(x - sx, -limit, limit);
 				y = sy + Clamp(y - sy, -limit, limit);
 			}
-			if (_settings_client.gui.measure_tooltip) {
-				TileIndex t0 = TileVirtXY(sx, sy);
-				TileIndex t1 = TileVirtXY(x, y);
-				uint distance = DistanceManhattan(t0, t1) + 1;
-				byte index = 0;
-				uint64 params[2];
-
-				if (distance != 1) {
-					/* With current code passing a HT_LINE style to calculate the height
-					 * difference is enough. However if/when a point-tool is created
-					 * with this method, function should be called with new_style (below)
-					 * instead of HT_LINE | style case HT_POINT is handled specially
-					 * new_style := (_thd.next_drawstyle & HT_RECT) ? HT_LINE | style : _thd.next_drawstyle; */
-					int heightdiff = CalcHeightdiff(HT_LINE | style, 0, t0, t1);
-
-					params[index++] = distance;
-					if (heightdiff != 0) params[index++] = heightdiff;
-				}
-
-				ShowMeasurementTooltips(measure_strings_length[index], index, params);
-			}
+			/* With current code passing a HT_LINE style to calculate the height
+			 * difference is enough. However if/when a point-tool is created
+			 * with this method, function should be called with new_style (below)
+			 * instead of HT_LINE | style case HT_POINT is handled specially
+			 * new_style := (_thd.next_drawstyle & HT_RECT) ? HT_LINE | style : _thd.next_drawstyle; */
+			ShowLengthMeasurement(HT_LINE | style, TileVirtXY(sx, sy), TileVirtXY(x, y));
 			break;
 
 		case VPM_X_AND_Y_LIMITED: // Drag an X by Y constrained rect area.
@@ -2900,7 +3666,7 @@
 	} else if (_thd.select_method & VPM_SIGNALDIRS) {
 		_thd.place_mode = HT_RECT | others;
 	} else if (_thd.select_method & VPM_RAILDIRS) {
-		_thd.place_mode = (_thd.select_method & ~VPM_RAILDIRS) ? _thd.next_drawstyle : (HT_RAIL | others);
+		_thd.place_mode = (_thd.select_method & ~VPM_RAILDIRS ? _thd.next_drawstyle : HT_RAIL) | others;
 	} else {
 		_thd.place_mode = HT_POINT | others;
 	}
@@ -2911,6 +3677,19 @@
 	return ES_HANDLED;
 }
 
+extern EventState VpHandleMouseWheel(int mousewheel)
+{
+	EventState ret = ES_NOT_HANDLED;
+
+	Window *w = _thd.GetCallbackWnd();
+	if (w != NULL) {
+		ret = w->OnPlaceMouseWheel(GetTileBelowCursor(), mousewheel);
+		if (ret == ES_HANDLED) SetSelectionTilesDirty();
+	}
+
+	return ret;
+}
+
 void SetObjectToPlaceWnd(CursorID icon, PaletteID pal, HighLightStyle mode, Window *w)
 {
 	SetObjectToPlace(icon, pal, mode, w->window_class, w->window_number);
@@ -2966,3 +3745,95 @@
 {
 	SetObjectToPlace(SPR_CURSOR_MOUSE, PAL_NONE, HT_NONE, WC_MAIN_WINDOW, 0);
 }
+
+void RemoveConnectedEndpointDirs(RailTrackEndpoint *a, const RailTrackEndpoint &b)
+{
+	if (IsValidTile(a->tile) && IsValidTile(b.tile)) {
+		for (DiagDirection test_dir = DIAGDIR_BEGIN; test_dir < DIAGDIR_END; test_dir++) {
+			TrackdirBits test_trackdirs = DiagdirReachesTrackdirs(test_dir);
+			if (test_trackdirs & a->dirs) {
+				if (a->tile == b.tile) {
+					if (b.dirs & test_trackdirs) a->dirs &= ~test_trackdirs;
+				} else if (a->tile - TileOffsByDiagDir(test_dir) == b.tile) {
+					if (b.dirs & DiagdirReachesTrackdirs(ReverseDiagDir(test_dir))) a->dirs &= ~test_trackdirs;
+				}
+				if (a->dirs == TRACKDIR_BIT_NONE) {
+					a->tile = INVALID_TILE;
+					return;
+				}
+			}
+		}
+	}
+}
+
+/**
+ * Store the position of lastly built rail track; for highlighting purposes.
+ *
+ * In "polyline" highlighting mode, the stored end point of the track
+ * will be used as the start point of a being highlighted track.
+ *
+ * @param start_tile    tile where the track starts
+ * @param end_tile      tile where the track ends
+ * @param start_track   track piece on the start_tile
+ * @param bidirectional whether to allow to highlight next track in any direction; otherwise new track will have to fallow the stored one (usefull when placing tunnels and bridges)
+ */
+void StoreRailPlacementEndpoints(TileIndex start_tile, TileIndex end_tile, Track start_track, bool bidirectional)
+{
+	const uint NUM_ENDPOINTS = lengthof(_rail_track_endpoints);
+
+	RailTrackEndpoint new_endpoints[NUM_ENDPOINTS] = {
+		{ INVALID_TILE, TRACKDIR_BIT_NONE },
+		{ INVALID_TILE, TRACKDIR_BIT_NONE },
+		{ INVALID_TILE, TRACKDIR_BIT_NONE },
+		{ INVALID_TILE, TRACKDIR_BIT_NONE },
+	};
+
+	if (start_tile != INVALID_TILE && end_tile != INVALID_TILE) {
+		/* calculate trackdirs at booth ends of the track (pointing toward track middle) */
+		Trackdir start_trackdir = TrackToTrackdir(start_track);
+		Trackdir end_trackdir = ReverseTrackdir(start_trackdir);
+		if (start_tile != end_tile) { // multi-tile case
+			/* determine proper direction (toward track middle) */
+			uint distance = DistanceManhattan(start_tile, end_tile);
+			if (distance < DistanceManhattan(TileAddByDiagDir(start_tile, TrackdirToExitdir(start_trackdir)), end_tile)) {
+				Swap(start_trackdir, end_trackdir);
+			}
+			/* determine proper track on the end tile - switch between upper/lower or left/right based on the length */
+			if (distance % 2 != 0) end_trackdir = NextTrackdir(end_trackdir);
+		}
+
+		/* compute new endpoints */
+		DiagDirection start_exit_dir = TrackdirToExitdir(ReverseTrackdir(start_trackdir));
+		DiagDirection end_exit_dir = TrackdirToExitdir(ReverseTrackdir(end_trackdir));
+		new_endpoints[0].tile = TileAddByDiagDir(start_tile, start_exit_dir);
+		new_endpoints[0].dirs = DiagdirReachesTrackdirs(start_exit_dir);
+		new_endpoints[1].tile = TileAddByDiagDir(end_tile, end_exit_dir);
+		new_endpoints[1].dirs = DiagdirReachesTrackdirs(end_exit_dir);
+		if (bidirectional) {
+			new_endpoints[2].tile = start_tile;
+			new_endpoints[2].dirs = DiagdirReachesTrackdirs(ReverseDiagDir(start_exit_dir));
+			new_endpoints[3].tile = end_tile;
+			new_endpoints[3].dirs = DiagdirReachesTrackdirs(ReverseDiagDir(end_exit_dir));
+		}
+
+		/* exclude all endpoints stored previously */
+		for (uint i = 0; i < NUM_ENDPOINTS; i++) {
+			for (uint j = 0; j < NUM_ENDPOINTS; j++) {
+				RemoveConnectedEndpointDirs(&new_endpoints[i], _rail_track_endpoints[j]);
+			}
+		}
+	}
+
+	/* store endpoints */
+	MemCpyT(_rail_track_endpoints, new_endpoints, NUM_ENDPOINTS);
+}
+
+void DrawOverlay(const TileInfo *ti, TileType tt) 
+{
+	if (Overlays::Instance()->IsTileInCatchmentArea(ti, PRODUCTION)) { 
+		DrawTileSelectionRect(ti, PALETTE_SEL_TILE_BLUE);
+	} else if (Overlays::Instance()->IsTileInCatchmentArea(ti, ACCEPTANCE)) { 
+		//DrawTileSelectionRect(ti, PALETTE_TO_LIGHT_BLUE);
+		DrawTileSelectionRect(ti, PALETTE_SEL_TILE_RED);
+	}
+}
diff -urNad openttd-1.3.2/src/viewport_func.h openttd-1.3.2-DC3.0RC3/src/viewport_func.h
--- openttd-1.3.2/src/viewport_func.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/viewport_func.h	2013-11-22 05:49:07.000000000 +0100
@@ -16,9 +16,31 @@
 #include "viewport_type.h"
 #include "window_type.h"
 #include "tile_type.h"
+#include "tile_cmd.h"
+#include "vehicle_base.h"
 
 static const int TILE_HEIGHT_STEP = 50; ///< One Z unit tile height difference is displayed as 50m.
 
+/**
+ * The maximum amount of pixels one may scroll outside map.
+ * Considering,when increasing height at tile (1, 1)
+ * the first overlapping tile on tile(1, 1, 0) is tile(4, 4, 1),
+ * or the first tile completely drawn outside the map(no height) is tile(1, 1, 4),
+ * value below has been calculated as follows:
+ *
+ * extra_pixels_needed_for heightlevels = (max_possible_height / overlap * TILE_SIZE / 2)
+ * eg. 256 / 4 * 8 / 2 = 256 pixels for tile(1, 1, 255) to be inside viewport when fully zoomed in 
+ * 22 pixels for the toolbar.
+ * 200 pixels to be safe with tall buildings on tile(1, 1, 255).
+ *
+ * TODO: 200 is a guesstimate. If you know a correct value, please insert it and correct line above.
+ *
+ * @note Subtract 8 for each pixel needed.
+ */
+enum  ScrollMaxOutsideMap {
+  MAXSCROLL = 3824, ///< tile(1, 1) having height 255
+};
+
 void SetSelectionRed(bool);
 
 void DeleteWindowViewport(Window *w);
@@ -28,6 +50,8 @@
 void UpdateViewportPosition(Window *w);
 
 void MarkAllViewportsDirty(int left, int top, int right, int bottom);
+void MarkAllRouteStopoversDirty(const Vehicle *veh);
+void MarkAllRoutePathsDirty(const Vehicle *veh);
 
 bool DoZoomInOutWindow(ZoomStateChange how, Window *w);
 void ZoomInOrOutToCursorWindow(bool in, Window * w);
@@ -57,7 +81,7 @@
 void StartSpriteCombine();
 void EndSpriteCombine();
 
-bool HandleViewportClicked(const ViewPort *vp, int x, int y);
+bool HandleViewportClicked(const ViewPort *vp, int x, int y, bool double_click);
 void SetRedErrorSquare(TileIndex tile);
 void SetTileSelectSize(int w, int h);
 void SetTileSelectBigSize(int ox, int oy, int sx, int sy);
@@ -66,6 +90,7 @@
 
 bool ScrollWindowToTile(TileIndex tile, Window *w, bool instant = false);
 bool ScrollWindowTo(int x, int y, int z, Window *w, bool instant = false);
+uint16 GetMaxScrollOutsideMap();
 
 bool ScrollMainWindowToTile(TileIndex tile, bool instant = false);
 bool ScrollMainWindowTo(int x, int y, int z = -1, bool instant = false);
@@ -76,4 +101,8 @@
 
 void MarkTileDirtyByTile(TileIndex tile);
 
+int GetRowAtTile(int viewport_y, Point tile);
+void MarkTileDirtyByTileOutsideMap(int x, int y);
+
+void DrawOverlay(const TileInfo *ti, TileType tt);
 #endif /* VIEWPORT_FUNC_H */
diff -urNad openttd-1.3.2/src/viewport_gui.cpp openttd-1.3.2-DC3.0RC3/src/viewport_gui.cpp
--- openttd-1.3.2/src/viewport_gui.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/viewport_gui.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -16,12 +16,15 @@
 #include "strings_func.h"
 #include "zoom_func.h"
 #include "window_func.h"
+#include "industry.h"
+#include "town_map.h"
 
 #include "widgets/viewport_widget.h"
 
 #include "table/strings.h"
 #include "table/sprites.h"
 
+
 /* Extra ViewPort Window Stuff */
 static const NWidgetPart _nested_extra_view_port_widgets[] = {
 	NWidget(NWID_HORIZONTAL),
@@ -139,6 +142,60 @@
 			ZoomInOrOutToCursorWindow(wheel < 0, this);
 		}
 	}
+	
+	virtual void OnMouseOver(Point pt, int widget)
+	{
+		/* Show tooltip with last month production or town name */
+		if (pt.x != -1) {
+			TileIndex tile;
+			const bool viewport_is_in_map_mode = (this->viewport->zoom >= ZOOM_LVL_MAX);
+			if (viewport_is_in_map_mode) {
+				NWidgetViewport *nvp = this->GetWidget<NWidgetViewport>(WID_EV_VIEWPORT);
+				const int a = ((ScaleByZoom(pt.x - nvp->pos_x, this->viewport->zoom) + this->viewport->virtual_left) >> 2) / ZOOM_LVL_BASE;
+				const int b = ((ScaleByZoom(pt.y - nvp->pos_y, this->viewport->zoom) + this->viewport->virtual_top) >> 1) / ZOOM_LVL_BASE;
+				tile = TileVirtXY(b - a, b + a);
+			} else {
+				const Point p = GetTileBelowCursor();
+				tile = TileVirtXY(p.x, p.y);
+			}
+			if (tile >= MapSize()) return;
+
+			switch (GetTileType(tile)) {
+				case MP_ROAD:
+					if (IsRoadDepot(tile)) return;
+					/* FALL THROUGH */
+				case MP_HOUSE: {
+					if (HasBit(_display_opt, DO_SHOW_TOWN_NAMES)) return; // No need for a town name tooltip when it is already displayed
+					if (!viewport_is_in_map_mode) return;
+					const TownID tid = GetTownIndex(tile);
+					if (!tid) return;
+					SetDParam(0, tid);
+					GuiShowTooltips(this, STR_TOWN_NAME_TOOLTIP, 0, NULL, TCC_HOVER);
+					break;
+				}
+				case MP_INDUSTRY: {
+					const Industry *ind = Industry::GetByTile(tile);
+					const IndustrySpec *indsp = GetIndustrySpec(ind->type);
+
+					StringID str = STR_INDUSTRY_VIEW_TRANSPORTED_TOOLTIP;
+					uint prm_count = 0;
+					SetDParam(prm_count++, indsp->name);
+					for (byte i = 0; i < lengthof(ind->produced_cargo); i++) {
+						if (ind->produced_cargo[i] != CT_INVALID) {
+							SetDParam(prm_count++, ind->produced_cargo[i]);
+							SetDParam(prm_count++, ind->last_month_production[i]);
+							SetDParam(prm_count++, ToPercent8(ind->last_month_pct_transported[i]));
+							str++;
+						}
+					}
+					GuiShowTooltips(this, str, 0, NULL, TCC_HOVER);
+					break;
+				}
+				default:
+					return;
+			}
+		}
+	}
 
 	/**
 	 * Some data on this window has become invalid.
diff -urNad openttd-1.3.2/src/viewport_type.h openttd-1.3.2-DC3.0RC3/src/viewport_type.h
--- openttd-1.3.2/src/viewport_type.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/viewport_type.h	2013-11-22 05:49:07.000000000 +0100
@@ -95,6 +95,7 @@
 	DDSP_RAISE_AND_LEVEL_AREA, ///< Raise / level area
 	DDSP_LOWER_AND_LEVEL_AREA, ///< Lower / level area
 	DDSP_LEVEL_AREA,           ///< Level area
+	DDSP_BUY_LAND,             ///< Buy land
 	DDSP_CREATE_DESERT,        ///< Fill area with desert
 	DDSP_CREATE_ROCKS,         ///< Fill area with rocks
 	DDSP_CREATE_WATER,         ///< Create a canal
@@ -117,6 +118,9 @@
 	DDSP_BUILD_TRUCKSTOP,      ///< Road stop placement (trucks)
 	DDSP_REMOVE_BUSSTOP,       ///< Road stop removal (buses)
 	DDSP_REMOVE_TRUCKSTOP,     ///< Road stop removal (trucks)
+
+	/* Clipboard */
+	DDSP_COPY_TO_CLIPBOARD,    ///< Copy area to clipboard
 };
 
 #endif /* VIEWPORT_TYPE_H */
diff -urNad openttd-1.3.2/src/void_cmd.cpp openttd-1.3.2-DC3.0RC3/src/void_cmd.cpp
--- openttd-1.3.2/src/void_cmd.cpp	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/void_cmd.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -13,13 +13,15 @@
 #include "tile_cmd.h"
 #include "command_func.h"
 #include "viewport_func.h"
+#include "slope_func.h"
 
 #include "table/strings.h"
 #include "table/sprites.h"
 
 static void DrawTile_Void(TileInfo *ti)
 {
-	DrawGroundSprite(SPR_SHADOW_CELL, PAL_NONE);
+	DrawGroundSprite(SPR_FLAT_BLACKTILES + SlopeToSpriteOffset(ti->tileh), PAL_NONE);
+//DrawGroundSprite(SPR_SHADOW_CELL + SlopeToSpriteOffset(ti->tileh), PAL_NONE);
 }
 
 
@@ -80,4 +82,5 @@
 	NULL,                     // vehicle_enter_tile_proc
 	GetFoundation_Void,       // get_foundation_proc
 	TerraformTile_Void,       // terraform_tile_proc
+	NULL                      // copypaste_tile_proc
 };
diff -urNad openttd-1.3.2/src/void_map.h openttd-1.3.2-DC3.0RC3/src/void_map.h
--- openttd-1.3.2/src/void_map.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/void_map.h	2013-11-22 05:49:07.000000000 +0100
@@ -18,17 +18,22 @@
  * Make a nice void tile ;)
  * @param t the tile to make void
  */
-static inline void MakeVoid(TileIndex t)
+template <bool Tgeneric>
+static inline void MakeVoid(typename TileIndexT<Tgeneric>::T t)
 {
 	SetTileType(t, MP_VOID);
 	SetTileHeight(t, 0);
-	_m[t].m1 = 0;
-	_m[t].m2 = 0;
-	_m[t].m3 = 0;
-	_m[t].m4 = 0;
-	_m[t].m5 = 0;
-	_m[t].m6 = 0;
-	_me[t].m7 = 0;
+	GetTile(t)->m1 = 0;
+	GetTile(t)->m2 = 0;
+	GetTile(t)->m3 = 0;
+	GetTile(t)->m4 = 0;
+	GetTile(t)->m5 = 0;
+	GetTileEx(t)->m6 = 0;
+	GetTileEx(t)->m7 = 0;
 }
+/** @copydoc MakeVoid(TileIndexT<Tgeneric>::T) */
+static inline void MakeVoid(TileIndex t) { MakeVoid<false>(t); }
+/** @copydoc MakeVoid(TileIndexT<Tgeneric>::T) */
+static inline void MakeVoid(GenericTileIndex t) { MakeVoid<true>(t); }
 
 #endif /* VOID_MAP_H */
diff -urNad openttd-1.3.2/src/watch_gui.cpp openttd-1.3.2-DC3.0RC3/src/watch_gui.cpp
--- openttd-1.3.2/src/watch_gui.cpp	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/watch_gui.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -0,0 +1,417 @@
+/* $Id: watch_gui.cpp  17678 2009-10-07 20:54:05  muxy $ */
+
+/** @file watch_gui.cpp GUI that follow other company building. */
+
+#include "stdafx.h"
+#include "watch_gui.h"
+#include "widget_type.h"
+#include "gfx_type.h"
+#include "gfx_func.h"
+#include "company_base.h"
+#include "company_gui.h"
+#include "viewport_func.h"
+#include "window_func.h"
+#include "strings_func.h"
+#include "zoom_func.h"
+#include "map_func.h"
+
+#include "network/network.h"
+#include "network/network_func.h"
+#include "network/network_base.h"
+
+#include "table/sprites.h"
+#include "table/strings.h"
+
+/** Make the widgets columns for company button, has_client and activity Blot.
+ * @param biggest_index Storage for collecting the biggest index used in the returned tree.
+ * @return Horizontal container with butons columns.
+ * @post \c *biggest_index contains the largest used index in the tree.
+ */
+static NWidgetBase *MakeCompanyButtons(int *biggest_index)
+{
+	NWidgetHorizontal *widget_container_horiz = NULL;         // Storage for all cols.
+	NWidgetVertical *widget_container_company = NULL;         // Storage for company Col.
+	NWidgetVertical *widget_container_hasclient = NULL;       // Storage for Has Client Blot.
+	NWidgetVertical *widget_container_activity = NULL;        // Storage for Activity Blot.
+	//NWidgetVertical *widget_container_action1 = NULL;         // Storage for Action 1
+
+	widget_container_horiz = new NWidgetHorizontal( );
+	widget_container_company = new NWidgetVertical( );
+	widget_container_hasclient  = new NWidgetVertical( );
+	widget_container_activity = new NWidgetVertical( );
+	//widget_container_action1 = new NWidgetVertical( );
+
+	Dimension company_sprite_size = GetSpriteSize( SPR_COMPANY_ICON );
+	company_sprite_size.width  += WD_MATRIX_LEFT + WD_MATRIX_RIGHT;
+	company_sprite_size.height += WD_MATRIX_TOP + WD_MATRIX_BOTTOM + 1; // 1 for the 'offset' of being pressed
+
+	Dimension blot_sprite_size = GetSpriteSize( SPR_BLOT );
+	blot_sprite_size.width  += WD_MATRIX_LEFT + WD_MATRIX_RIGHT;
+	blot_sprite_size.height += WD_MATRIX_TOP + WD_MATRIX_BOTTOM + 1; // 1 for the 'offset' of being pressed
+
+
+	for (int company_num = COMPANY_FIRST; company_num < MAX_COMPANIES; company_num++ ) {
+
+		/* Manage Company Buttons */
+		NWidgetBackground *company_panel = new NWidgetBackground( WWT_PANEL, COLOUR_GREY, EWW_PB_COMPANY_FIRST + company_num );
+		company_panel->SetMinimalSize( company_sprite_size.width, company_sprite_size.height );
+		company_panel->SetResize( 0, 0 );
+		company_panel->SetFill( 1, 0 );
+		company_panel->SetDataTip( 0x0, STR_WATCH_CLICK_TO_WATCH_COMPANY );
+		widget_container_company->Add( company_panel );
+
+		/* Manage Has Client Blot */
+		NWidgetBackground *hasclient_panel = new NWidgetBackground( WWT_PANEL, COLOUR_GREY, EWW_HAS_CLIENT_FIRST + company_num );
+		company_panel->SetMinimalSize( blot_sprite_size.width, blot_sprite_size.height );
+		company_panel->SetResize( 0, 0 );
+		company_panel->SetFill( 1, 0 );
+		widget_container_hasclient->Add( hasclient_panel );
+
+		/* Manage Activit Blot */
+		/*
+		NWidgetBackground *activity_panel = new NWidgetBackground( WWT_PANEL, COLOUR_GREY, EWW_ACTIVITY_FIRST + company_num );
+		company_panel->SetMinimalSize( blot_sprite_size.width, blot_sprite_size.height );
+		company_panel->SetResize( 0, 0 );
+		company_panel->SetFill( 1, 0 );
+		widget_container_activity->Add( activity_panel );
+		*/
+
+		/* Button Action1 */
+		/*
+		NWidgetBackground *action1_panel =  new NWidgetBackground( WWT_PANEL, COLOUR_GREY, EWW_PB_ACTION1_FIRST + company_num );
+		company_panel->SetResize( 0, 0 );
+		company_panel->SetFill( 1, 0 );
+		widget_container_action1->Add( action1_panel );
+		*/
+	}
+
+	/* Add the verticals widgets to the horizontal container */
+	widget_container_horiz->Add( widget_container_company );
+	widget_container_horiz->Add( widget_container_hasclient );
+	/* widget_container_horiz->Add( widget_container_activity ); */
+	//widget_container_horiz->Add( widget_container_action1 );
+
+	/* return the horizontal widget container */
+	return widget_container_horiz;
+}
+
+
+/**
+ * Watch Company Window Widgets Array
+ * The Company Button, Has Client Blot and Activity Blot Columns
+ * Are made through a function regarding MAX_COMPANIES value
+ */
+static const NWidgetPart _nested_watch_company_widgets[] = {
+	/* Title Bar with close box, title, shade and stick boxes */
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
+		NWidget(WWT_CAPTION, COLOUR_GREY, EWW_CAPTION ), SetDataTip(STR_WATCH_WINDOW_TITLE, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_SHADEBOX, COLOUR_GREY),
+		NWidget(WWT_STICKYBOX, COLOUR_GREY),
+	EndContainer( ),
+	NWidget( NWID_HORIZONTAL ),
+		NWidget( NWID_VERTICAL ),
+			NWidgetFunction( MakeCompanyButtons ),
+			/* Buton Zoom Out, In, Scrollto */
+			NWidget(NWID_HORIZONTAL),
+				NWidget( WWT_PUSHIMGBTN, COLOUR_GREY, EWW_ZOOMOUT ), SetDataTip( SPR_IMG_ZOOMOUT, STR_TOOLBAR_TOOLTIP_ZOOM_THE_VIEW_OUT),
+				NWidget( WWT_PUSHIMGBTN, COLOUR_GREY, EWW_ZOOMIN ),  SetDataTip( SPR_IMG_ZOOMIN, STR_TOOLBAR_TOOLTIP_ZOOM_THE_VIEW_IN),
+				NWidget( WWT_PUSHIMGBTN, COLOUR_GREY, EWW_CENTER ),  SetDataTip( SPR_CENTRE_VIEW_VEHICLE, STR_EXTRA_VIEW_MOVE_MAIN_TO_VIEW_TT),
+				NWidget( WWT_PANEL, COLOUR_GREY, EWW_NEW_WINDOW ),   SetDataTip( 0, STR_WATCH_CLICK_NEW_WINDOW ), EndContainer( ),
+			EndContainer( ),
+			/* Background panel for resize purpose */
+			NWidget( WWT_PANEL, COLOUR_GREY ), SetResize( 0, 1 ), EndContainer( ),
+		EndContainer( ),
+		/* Watch Pannel */
+		NWidget(WWT_PANEL, COLOUR_GREY),
+			NWidget(NWID_VIEWPORT, INVALID_COLOUR, EWW_WATCH), SetPadding(2, 2, 2, 2), SetResize(1, 1), SetFill(1, 1),
+		EndContainer( ),
+	EndContainer( ),
+	/* Status Bar with resize buton */
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_PANEL, COLOUR_GREY), SetFill(1, 1), SetResize(1, 0), EndContainer(),
+		NWidget(WWT_RESIZEBOX, COLOUR_GREY),
+	EndContainer( ),
+};
+
+/**
+ * Watch Company Window Descriptor
+ */
+static const WindowDesc _watch_company_desc(
+	WDP_AUTO, 300, 257,
+	WC_WATCH_COMPANY, WC_NONE,
+	0,
+	_nested_watch_company_widgets, lengthof( _nested_watch_company_widgets )
+);
+
+//static int WatchCompany::button1_state[MAX_COMPANIES];
+
+/** Watch Company Class Constructor
+ * @param desc Window Descriptor The Window Descriptor
+ * @param window_number The window number for the class
+ * @param company_to_watch Company ID for watching a particular company
+ */
+WatchCompany::WatchCompany(const WindowDesc *desc, int window_number, CompanyID company_to_watch = INVALID_COMPANY ) : Window( )
+{
+	this->watched_company = company_to_watch;
+
+	this->InitNested(desc, window_number);
+	this->owner = this->watched_company;
+
+	/* Reset activity and client count for all companies */
+	for (CompanyID i = COMPANY_FIRST; i < MAX_COMPANIES; i++) {
+		this->company_activity[i] = 0;
+		this->company_count_client[i] = 0;
+	}
+	
+	/* Init the viewport area */
+	NWidgetViewport *nvp = this->GetWidget<NWidgetViewport>(EWW_WATCH);
+	nvp->InitializeViewport(this, 0, ZOOM_LVL_NORMAL);
+	
+	Point pt;
+	/* the main window with the main view */
+	const Window *w = FindWindowById(WC_MAIN_WINDOW, 0);
+	
+	/* center on same place as main window (zoom is maximum, no adjustment needed) */
+	pt.x = w->viewport->scrollpos_x + w->viewport->virtual_width / 2;
+	pt.y = w->viewport->scrollpos_y + w->viewport->virtual_height / 2;
+
+	this->viewport->scrollpos_x = pt.x - this->viewport->virtual_width / 2;
+	this->viewport->scrollpos_y = pt.y - this->viewport->virtual_height / 2;
+	this->viewport->dest_scrollpos_x = this->viewport->scrollpos_x;
+	this->viewport->dest_scrollpos_y = this->viewport->scrollpos_y;
+
+	if ( this->watched_company != INVALID_COMPANY ) {
+		Company *c = Company::Get( this->watched_company );
+		this->ScrollToTile( c->last_build_coordinate );
+	}
+	this->InvalidateData( );
+}
+
+void WatchCompany::SetStringParameters(int widget) const
+{
+	switch (widget) {
+		case EWW_CAPTION:
+			if (this->watched_company == INVALID_COMPANY) {
+				GetString( (char *)this->company_name, STR_JUST_NOTHING, lastof(this->company_name) );
+			} else {
+				const Company *c = Company::Get( this->watched_company );
+				SetDParam( 0, c->index );
+				GetString( (char *)this->company_name, STR_COMPANY_NAME, lastof(this->company_name) );
+			}
+			SetDParamStr( 0, this->company_name );
+			break;
+	}
+}
+
+
+void WatchCompany::OnPaint()
+{
+	this->DrawWidgets();
+}
+
+void WatchCompany::DrawWidget(const Rect &r, int widget) const
+{
+	/* draw the widget */
+	/* Company Button */
+	if (IsInsideMM(widget, EWW_PB_COMPANY_FIRST, EWW_PB_COMPANY_LAST + 1)) {
+		if (this->IsWidgetDisabled(widget)) return;
+		CompanyID cid = (CompanyID)(widget - ( EWW_PB_COMPANY_FIRST ) );
+		int offset = (cid == this->watched_company) ? 1 : 0;
+		Dimension sprite_size = GetSpriteSize(SPR_COMPANY_ICON);
+		DrawCompanyIcon(cid, (r.left + r.right - sprite_size.width) / 2 + offset, (r.top + r.bottom - sprite_size.height) / 2 + offset);
+		return;
+	}
+	/* Has Client Blot */
+	if (IsInsideMM( widget, EWW_HAS_CLIENT_FIRST, EWW_HAS_CLIENT_LAST + 1 )) {
+		if ( Company::IsValidID( widget-EWW_HAS_CLIENT_FIRST ) ) {
+			/* Draw the Blot only if Company Exists */
+			Dimension sprite_size = GetSpriteSize(SPR_BLOT);
+#ifdef ENABLE_NETWORK
+			if (!_networking) { // Local game, draw the Blot
+				DrawSprite(SPR_BLOT, Company::IsValidAiID(widget-EWW_HAS_CLIENT_FIRST)?PALETTE_TO_ORANGE:PALETTE_TO_GREEN, (r.left + r.right - sprite_size.width) / 2, (r.top + r.bottom - sprite_size.height) / 2 );
+			} else { // Network game, draw the blot according to company client count
+				DrawSprite(SPR_BLOT, this->company_count_client[widget-EWW_HAS_CLIENT_FIRST]>0?(company_activity[widget-EWW_HAS_CLIENT_FIRST]>0?PALETTE_TO_RED:PALETTE_TO_GREEN):PALETTE_TO_GREY, (r.left + r.right - sprite_size.width) / 2, (r.top + r.bottom - sprite_size.height) / 2 );
+			}
+#else
+			DrawSprite(SPR_BLOT, Company::IsValidAiID(widget-EWW_HAS_CLIENT_FIRST)?PALETTE_TO_ORANGE:PALETTE_TO_GREEN, (r.left + r.right - sprite_size.width) / 2, (r.top + r.bottom - sprite_size.height) / 2 );
+#endif
+		}
+	}
+	/* Activity Blot */
+	/*
+	if (IsInsideMM( widget, EWW_ACTIVITY_FIRST, EWW_ACTIVITY_LAST + 1 )) {
+		if ( Company::IsValidID(widget-EWW_ACTIVITY_FIRST) ) {
+			// Draw the Blot only if Company Exists
+			Dimension sprite_size = GetSpriteSize(SPR_BLOT);
+			DrawSprite(SPR_BLOT, company_activity[widget-EWW_ACTIVITY_FIRST]>0?PALETTE_TO_RED:PALETTE_TO_GREY, (r.left + r.right - sprite_size.width) / 2, (r.top + r.bottom - sprite_size.height) / 2 );
+		}
+	}
+	*/
+}
+
+void WatchCompany::OnResize()
+{
+	if (this->viewport != NULL) {
+		NWidgetViewport *nvp = this->GetWidget<NWidgetViewport>(EWW_WATCH);
+		nvp->UpdateViewportCoordinates(this);
+	}
+}
+
+void WatchCompany::OnScroll(Point delta)
+{
+	const ViewPort *vp = IsPtInWindowViewport(this, _cursor.pos.x, _cursor.pos.y);
+	if (vp == NULL) return;
+
+	this->viewport->scrollpos_x += ScaleByZoom(delta.x, vp->zoom);
+	this->viewport->scrollpos_y += ScaleByZoom(delta.y, vp->zoom);
+	this->viewport->dest_scrollpos_x = this->viewport->scrollpos_x;
+	this->viewport->dest_scrollpos_y = this->viewport->scrollpos_y;
+}
+
+void WatchCompany::OnMouseWheel( int wheel )
+{
+	ZoomInOrOutToCursorWindow(wheel < 0, this);
+}
+
+void WatchCompany::OnClick(Point pt, int widget, int click_count)
+{
+	if (IsInsideMM(widget, EWW_PB_COMPANY_FIRST, EWW_PB_COMPANY_LAST + 1)) {
+		/* Click on Company Button */
+		if (!this->IsWidgetDisabled(widget)) {
+			if (this->watched_company != INVALID_COMPANY) {
+				/* Raise the watched company button  */
+				this->RaiseWidget(this->watched_company + EWW_PB_COMPANY_FIRST);
+			}
+			if (this->watched_company == (CompanyID)(widget - EWW_PB_COMPANY_FIRST)) {
+				/* Stop watching watched_company */
+				this->watched_company = INVALID_COMPANY;
+			} else {
+				/* Lower the new watched company button */
+				this->watched_company = (CompanyID)(widget - EWW_PB_COMPANY_FIRST);
+				this->LowerWidget(this->watched_company + EWW_PB_COMPANY_FIRST);
+				Company *c = Company::Get( this->watched_company );
+				this->ScrollToTile( c->last_build_coordinate );
+			}
+			this->owner = this->watched_company;
+			this->SetDirty();
+		}
+	} else if ( IsInsideMM(widget, EWW_PB_ACTION1_FIRST, EWW_PB_ACTION1_LAST + 1)) {
+		if ( !this->IsWidgetDisabled(widget) ) {
+			this->ToggleWidgetLoweredState( widget );
+			this->SetDirty();
+		}
+	} else {
+		switch (widget) {
+			case EWW_ZOOMOUT: DoZoomInOutWindow(ZOOM_OUT, this); break;
+			case EWW_ZOOMIN: DoZoomInOutWindow(ZOOM_IN,  this); break;
+
+			case EWW_CENTER: { // location button (move main view to same spot as this view) 'Center Main View'
+				Window *w = FindWindowById(WC_MAIN_WINDOW, 0);
+				int x = this->viewport->scrollpos_x; // Where is the watch looking at
+				int y = this->viewport->scrollpos_y;
+
+				/* set the main view to same location. Based on the center, adjusting for zoom */
+				w->viewport->dest_scrollpos_x =  x - (w->viewport->virtual_width -  this->viewport->virtual_width) / 2;
+				w->viewport->dest_scrollpos_y =  y - (w->viewport->virtual_height - this->viewport->virtual_height) / 2;
+			} break;
+				
+			case EWW_NEW_WINDOW:
+				ShowWatchWindow( this->watched_company );
+				break;
+		}
+	}
+}
+
+void WatchCompany::OnInvalidateData(int data, bool gui_scope)
+{
+	if(!gui_scope)  return; //nothing special from command scope here
+	/* Disable the companies who are not active */
+	for (CompanyID i = COMPANY_FIRST; i < MAX_COMPANIES; i++) {
+		this->SetWidgetDisabledState(EWW_PB_COMPANY_FIRST + i , !Company::IsValidID(i) );
+		this->SetWidgetDisabledState(EWW_PB_ACTION1_FIRST + i , !Company::IsValidID(i) );
+	}
+	/* Check if the currently selected company is still active. */
+	if (this->watched_company != INVALID_COMPANY) {
+		/* Make sure the widget is lowered */
+		this->LowerWidget(EWW_PB_COMPANY_FIRST + this->watched_company);
+		/* Check if the watched Company is still a valid one */
+		if (!Company::IsValidID(this->watched_company)) {
+			/* Invalid Company Raise the associated widget. */
+			this->RaiseWidget(this->watched_company + EWW_PB_COMPANY_FIRST );
+			this->watched_company = INVALID_COMPANY;
+		}
+	}
+#ifdef ENABLE_NETWORK
+	/* Reset company count - network only */
+	for (CompanyID i = COMPANY_FIRST; i < MAX_COMPANIES; i++) {
+		this->company_count_client[i] = 0;
+	}
+	/* Calculate client count into company - network only */
+	NetworkClientInfo *ci;
+	FOR_ALL_CLIENT_INFOS( ci ) {
+		if (Company::IsValidID(ci->client_playas)) {
+			company_count_client[ci->client_playas]+=1;
+		}
+	}
+#endif
+	HandleZoomMessage(this, this->viewport, EWW_ZOOMIN, EWW_ZOOMOUT);
+}
+
+void WatchCompany::ScrollToTile( TileIndex tile )
+{
+	/* Scroll window to the tile, only if not zero */
+	if (tile != 0) {
+		ScrollWindowTo( TileX(tile) * TILE_SIZE + TILE_SIZE / 2, TileY(tile) * TILE_SIZE + TILE_SIZE / 2, -1, this );
+	}
+}
+
+/** OnDoCommand function - Called by the DoCommand
+ *  @param company The company ID who's client is building
+ *  @param tile The tile number where action took place
+ */
+void WatchCompany::OnDoCommand( CompanyByte company, TileIndex tile )
+{
+	/* Check if its my company */
+	if (this->watched_company == company)
+	{
+		this->ScrollToTile( tile );
+	}
+	/* set the company_activity to its max in order to paint the BLOT in red
+	 * This will result by having the activity blot set to red for all companies
+	 * even the one watched. To avoid this behaviour and not to light the blot of
+	 * the watched company, the code can be moved just after the ScrollToTile call.
+	 */
+	if (tile != 0) {
+		this->company_activity[company] = MAX_ACTIVITY;
+		this->SetDirty( );
+	}
+}
+
+/** Used to decrement the activity counter
+ *
+ */
+void WatchCompany::OnTick()
+{
+	bool set_dirty = false;
+	for (CompanyID i = COMPANY_FIRST; i < MAX_COMPANIES; i++) {
+		if ( this->company_activity[i]>0 ) {
+			this->company_activity[i]--;
+			if ( this->company_activity[i]==0 ) {
+				set_dirty = true;
+			}
+		}
+	}
+	/* If one company_activity reaches 0, then redraw */
+	if (set_dirty) {
+		this->SetDirty();
+	}
+}
+
+void ShowWatchWindow( CompanyID company_to_watch = INVALID_COMPANY )
+{
+	int i = 0;
+	/* find next free window number for watch viewport */
+	while (FindWindowById(WC_WATCH_COMPANY, i) != NULL) i++;
+	new WatchCompany( &_watch_company_desc, i, company_to_watch );
+}
diff -urNad openttd-1.3.2/src/watch_gui.h openttd-1.3.2-DC3.0RC3/src/watch_gui.h
--- openttd-1.3.2/src/watch_gui.h	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/watch_gui.h	2013-11-22 05:49:07.000000000 +0100
@@ -0,0 +1,63 @@
+/* $Id: watch_gui.h 17678 2009-10-07 20:54:05  muxy $ */
+
+/** @file watch_gui.h GUI Functions related to watching. */
+
+#ifndef WATCH_GUI_H
+#define WATCH_GUI_H
+
+#include "window_gui.h"
+#include "company_base.h"
+
+#define MAX_ACTIVITY 30
+
+enum WatchCompanyWidgets {
+	EWW_CAPTION,
+	EWW_PB_COMPANY_FIRST,
+	EWW_PB_COMPANY_LAST  = EWW_PB_COMPANY_FIRST + MAX_COMPANIES - 1,
+	EWW_HAS_CLIENT_FIRST,
+	EWW_HAS_CLIENT_LAST = EWW_HAS_CLIENT_FIRST + MAX_COMPANIES - 1,
+	EWW_ACTIVITY_FIRST,
+	EWW_ACTIVITY_LAST = EWW_ACTIVITY_FIRST + MAX_COMPANIES - 1,
+	EWW_PB_ACTION1_FIRST,
+	EWW_PB_ACTION1_LAST = EWW_PB_ACTION1_FIRST + MAX_COMPANIES - 1,
+	EWW_WATCH,
+	EWW_ZOOMIN,
+	EWW_ZOOMOUT,
+	EWW_CENTER,
+	EWW_NEW_WINDOW
+};
+
+class WatchCompany : public Window
+{
+
+protected:
+
+	CompanyID watched_company;                            // Company ID beeing watched.
+	int company_activity[MAX_COMPANIES];                  // int array for activity blot.
+	int company_count_client[MAX_COMPANIES];              // company client count.
+	char company_name[MAX_LENGTH_COMPANY_NAME_CHARS];     // company name for title display
+
+	void SetWatchWindowTitle( );
+	void ScrollToTile( TileIndex tile );
+
+
+public:
+
+	WatchCompany(const WindowDesc *desc, int window_number, CompanyID company_to_watch );
+
+	virtual void SetStringParameters(int widget) const;
+	virtual void OnPaint( );
+	virtual void DrawWidget(const Rect &r, int widget) const;
+	virtual void OnClick(Point pt, int widget, int click_count);
+	virtual void OnResize( );
+	virtual void OnScroll(Point delta);
+	virtual void OnMouseWheel(int wheel);
+	virtual void OnInvalidateData(int data, bool gui_scope );
+	virtual void OnTick( );
+	
+	void OnDoCommand( CompanyByte company, TileIndex tile );
+};
+
+void ShowWatchWindow( CompanyID company_to_watch );
+
+#endif // COMPANY_GUI_H 
diff -urNad openttd-1.3.2/src/water_cmd.cpp openttd-1.3.2-DC3.0RC3/src/water_cmd.cpp
--- openttd-1.3.2/src/water_cmd.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/water_cmd.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -11,6 +11,7 @@
 
 #include "stdafx.h"
 #include "cmd_helper.h"
+#include "copypaste_cmd.h"
 #include "landscape.h"
 #include "viewport_func.h"
 #include "command_func.h"
@@ -38,6 +39,7 @@
 #include "date_func.h"
 #include "company_base.h"
 #include "company_gui.h"
+#include "clipboard_gui.h"
 #include "newgrf_generic.h"
 
 #include "table/strings.h"
@@ -103,8 +105,15 @@
 
 	TileIndex tile2 = tile + (axis == AXIS_X ? TileDiffXY(1, 0) : TileDiffXY(0, 1));
 
-	if (!HasTileWaterGround(tile) || !HasTileWaterGround(tile2)) {
-		return_cmd_error(STR_ERROR_MUST_BE_BUILT_ON_WATER);
+	WaterClass wc1, wc2;
+	if ((flags & DC_PASTE) && !(flags & DC_EXEC)) {
+		/* When pasting a ship depot, there may be no water yet (a canal will be placed when DC_EXE'ing).
+		 * Ignore that there is no water so we can calculate the cost more precisely. */
+		wc1 = wc2 = WATER_CLASS_INVALID;
+	} else {
+		if (!HasTileWaterGround(tile) || !HasTileWaterGround(tile2)) return_cmd_error(STR_ERROR_MUST_BE_BUILT_ON_WATER);
+		wc1 = GetWaterClass(tile);
+		wc2 = GetWaterClass(tile2);
 	}
 
 	if ((MayHaveBridgeAbove(tile) && IsBridgeAbove(tile)) ||
@@ -117,8 +126,6 @@
 
 	if (!Depot::CanAllocateItem()) return CMD_ERROR;
 
-	WaterClass wc1 = GetWaterClass(tile);
-	WaterClass wc2 = GetWaterClass(tile2);
 	CommandCost cost = CommandCost(EXPENSES_CONSTRUCTION, _price[PR_BUILD_DEPOT_SHIP]);
 
 	bool add_cost = !IsWaterTile(tile);
@@ -145,6 +152,7 @@
 		Company::Get(_current_company)->infrastructure.water += 2 * LOCK_DEPOT_TILE_FACTOR;
 		DirtyCompanyInfrastructureWindows(_current_company);
 
+		assert(wc1 != WATER_CLASS_INVALID && wc2 != WATER_CLASS_INVALID);
 		MakeShipDepot(tile,  _current_company, depot->index, DEPOT_PART_NORTH, axis, wc1);
 		MakeShipDepot(tile2, _current_company, depot->index, DEPOT_PART_SOUTH, axis, wc2);
 		MarkTileDirtyByTile(tile);
@@ -866,6 +874,7 @@
 			DrawWaterDepot(ti);
 			break;
 	}
+	DrawOverlay(ti, MP_WATER);
 }
 
 void DrawShipDepotSprite(int x, int y, Axis axis, DepotPart part)
@@ -1315,6 +1324,175 @@
 	return DoCommand(tile, 0, 0, flags, CMD_LANDSCAPE_CLEAR);
 }
 
+void CopyPastePlaceCannal(GenericTileIndex tile)
+{
+	if (IsMainMapTile(tile)) {
+		_current_pasting->DoCommand(AsMainMapTile(tile), AsMainMapTile(tile), WATER_CLASS_CANAL, CMD_BUILD_CANAL | CMD_MSG(STR_ERROR_CAN_T_BUILD_CANALS));
+	} else {
+		MakeCanal(tile, OWNER_NONE, 0);
+	}
+}
+
+static void CopyPastePlaceLock(GenericTileIndex tile, DiagDirection dir)
+{
+	if (IsMainMapTile(tile)) {
+		TileIndex t = AsMainMapTile(tile);
+		if (dir != GetInclinedSlopeDirection(GetTilePixelSlope(tile, NULL))) {
+			_current_pasting->CollectError(t, STR_ERROR_LAND_SLOPED_IN_WRONG_DIRECTION, STR_ERROR_CAN_T_BUILD_LOCKS);
+		} else if (IsTileType(t, MP_WATER) && IsTileOwner(t, _current_company) && IsLock(t) && GetLockPart(t) == LOCK_PART_MIDDLE) {
+			_current_pasting->CollectError(t, STR_ERROR_ALREADY_BUILT, STR_ERROR_CAN_T_BUILD_LOCKS);
+		} else {
+			_current_pasting->DoCommand(t, 0, 0, CMD_BUILD_LOCK | CMD_MSG(STR_ERROR_CAN_T_BUILD_LOCKS));
+		}
+	} else {
+		MakeLock(tile, OWNER_NONE, dir, WATER_CLASS_INVALID, WATER_CLASS_INVALID, WATER_CLASS_INVALID);
+	}
+}
+
+static void CopyPastePlaceShipDepot(GenericTileIndex tile, DiagDirection dir)
+{
+	GenericTileIndex other_tile = TileAddByDiagDir(tile, ReverseDiagDir(dir));
+
+	if (IsMainMapTile(tile)) {
+		TileIndex t1 = AsMainMapTile(tile);
+		TileIndex t2 = AsMainMapTile(other_tile);
+		/* build a canal if not on water */
+		if (!HasTileWaterGround(t1)) {
+			CopyPastePlaceCannal(GenericTileIndex(t1));
+			if (_current_pasting->last_result.Failed()) return;
+		}
+		if (!HasTileWaterGround(t2)) {
+			CopyPastePlaceCannal(GenericTileIndex(t2));
+			if (_current_pasting->last_result.Failed()) return;
+		}
+		/* build the depot */
+		if (IsShipDepotTile(t1) && IsTileOwner(t1, _current_company) && GetOtherShipDepotTile(t1) == t2) {
+			_current_pasting->CollectError(t1, STR_ERROR_ALREADY_BUILT, STR_ERROR_CAN_T_BUILD_SHIP_DEPOT);
+		} else {
+			_current_pasting->DoCommand(min(t1, t2), DiagDirToAxis(dir), 0, CMD_BUILD_SHIP_DEPOT | CMD_MSG(STR_ERROR_CAN_T_BUILD_SHIP_DEPOT));
+		}
+	} else {
+		MakeShipDepot(min(tile, other_tile), OWNER_NONE, 0, DEPOT_PART_NORTH, DiagDirToAxis(dir), WATER_CLASS_INVALID);
+		MakeShipDepot(max(tile, other_tile), OWNER_NONE, 0, DEPOT_PART_SOUTH, DiagDirToAxis(dir), WATER_CLASS_INVALID);
+	}
+}
+
+/**
+ * Test a given water tile if there is any contented to be copied from it.
+ *
+ * Some water objects (e.g. water locks) can't be copy/pasted tile by tile, we have to do it with
+ * bigger rectangular pieces. The function writes this area to location pointed by \c object_rect
+ * but only once per a piece - when a certain tile is tested:
+ *    - in case of water locks, valid area is written when the center tile of a lock is tested
+ *    - in case of ship depots, valid area is written when the northern tile of a depot is tested
+ * For the rest of tiles the function still returns \c true but writes "invalid" area.
+ *
+ * If the funtion returns \c false, \c object_rect remains unchanged.
+ *
+ * @param tile the tile to test
+ * @param src_area the tile area we are copying
+ * @param mode copy-paste mode
+ * @param object_rect (out, may be NULL) area to be copy pasted in this step or "invalid" area, depending on which tile was given
+ * @param company the #Company to check ownership against to
+ * @param preview (out, may be NULL) information on how to higlight preview of the tile
+ * @return whether this tile needs to be copy-pasted
+ */
+bool TestWaterTileCopyability(GenericTileIndex tile, const GenericTileArea &src_area, CopyPasteMode mode, GenericTileArea *object_rect, CompanyID company = _current_company, TileContentPastePreview *preview = NULL)
+{
+	if (preview != NULL) MemSetT(preview, 0);
+
+	if (!(mode & CPM_WITH_WATER_TRANSPORT)) return false;
+	if (IsMainMapTile(tile) && !IsTileOwner(tile, company)) return false;
+
+	switch (GetWaterTileType(tile)) {
+		case WATER_TILE_CLEAR:
+			if (GetWaterClass(tile) != WATER_CLASS_CANAL) return false; // copy only cannals
+			if (object_rect != NULL) *object_rect = GenericTileArea(tile, 1, 1);
+			break;
+
+		case WATER_TILE_LOCK:
+			if (IsMainMapTile(tile) || object_rect != NULL) {
+				DiagDirection dir = GetLockDirection(tile);
+				switch (GetLockPart(tile)) {
+					case LOCK_PART_MIDDLE: {
+						GenericTileArea ta(tile, 1, 1);
+						ta.Add(TileAddByDiagDir(tile, dir));
+						ta.Add(TileAddByDiagDir(tile, ReverseDiagDir(dir)));
+						if (IsMainMapTile(tile) && !src_area.Contains(ta)) return false;
+						if (object_rect != NULL) *object_rect = ta;
+						break;
+					}
+
+					case LOCK_PART_UPPER:
+						dir = ReverseDiagDir(dir);
+						/* FALLTHROUGH */
+					case LOCK_PART_LOWER:
+						if (IsMainMapTile(tile) && !src_area.Contains(TileAddByDiagDir(TileAddByDiagDir(tile, dir), dir))) return false;
+						if (object_rect != NULL) *object_rect = GenericTileArea(GenericTileIndex(INVALID_TILE_INDEX, MapOf(tile)), 0, 0);
+						break;
+				}
+			}
+			break;
+
+		case WATER_TILE_DEPOT: {
+			/* test if the depot is within copy area */
+			GenericTileIndex other_tile = GetOtherShipDepotTile(tile);
+			if (IsMainMapTile(tile) && !src_area.Contains(other_tile)) return false;
+
+			if (object_rect != NULL) {
+				if (tile < other_tile) { // copy this depot only once
+					*object_rect = GenericTileArea(tile, other_tile);
+				} else {
+					*object_rect = GenericTileArea(GenericTileIndex(INVALID_TILE_INDEX, MapOf(tile)), 0, 0);
+				}
+			}
+			break;
+		}
+
+		default:
+			return false;
+	}
+
+	if (preview != NULL) preview->highlight_tile_rect = true;
+	return true;
+}
+
+void CopyPasteTile_Water(GenericTileIndex src_tile, GenericTileIndex dst_tile, const CopyPasteParams &copy_paste)
+{
+	GenericTileArea src_object_rect;
+	if (!TestWaterTileCopyability(src_tile, copy_paste.src_area, copy_paste.mode, &src_object_rect)) return;
+	if (!IsValidTileIndex(src_object_rect.tile)) return; // copy water object (e.g. water lock or ship depot) only once
+
+	/* Terraform tiles if needed */
+	if (IsMainMapTile(dst_tile) && (copy_paste.mode & CPM_TERRAFORM_MASK) == CPM_TERRAFORM_MINIMAL) {
+		GenericTileIndex t = copy_paste.src_area.ReverseTransformTile(src_tile, dst_tile, copy_paste.transformation); // transformed northern tile of the area.src
+		t = copy_paste.src_area.TransformTile(src_object_rect.tile, t, copy_paste.transformation); // transformed northern tile of the src_object_rect
+		t = src_object_rect.ReverseTransformedNorth(t, copy_paste.transformation); // northern tile of the transformed src_object_rect
+		CopyPasteHeights(src_object_rect, t, copy_paste.transformation, copy_paste.height_delta);
+		if (IsPastingInterrupted()) return;
+	}
+
+	switch (GetWaterTileType(src_tile)) {
+		case WATER_TILE_CLEAR:
+			CopyPastePlaceCannal(dst_tile);
+			break;
+
+		case WATER_TILE_LOCK: {
+			DiagDirection dir = TransformDiagDir(GetLockDirection(src_tile), copy_paste.transformation);
+			CopyPastePlaceLock(dst_tile, dir);
+			break;
+		}
+
+		case WATER_TILE_DEPOT:
+			CopyPastePlaceShipDepot(dst_tile, TransformDiagDir(GetShipDepotDirection(src_tile), copy_paste.transformation));
+			break;
+
+		default:
+			NOT_REACHED();
+			break;
+	}
+}
+
 
 extern const TileTypeProcs _tile_type_water_procs = {
 	DrawTile_Water,           // draw_tile_proc
@@ -1331,4 +1509,5 @@
 	VehicleEnter_Water,       // vehicle_enter_tile_proc
 	GetFoundation_Water,      // get_foundation_proc
 	TerraformTile_Water,      // terraform_tile_proc
+	CopyPasteTile_Water,      // copypaste_tile_proc
 };
diff -urNad openttd-1.3.2/src/water_map.h openttd-1.3.2-DC3.0RC3/src/water_map.h
--- openttd-1.3.2/src/water_map.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/water_map.h	2013-11-22 05:49:07.000000000 +0100
@@ -74,17 +74,22 @@
  * @param t Water tile to query.
  * @return Water tile type at the tile.
  */
-static inline WaterTileType GetWaterTileType(TileIndex t)
+template <bool Tgeneric>
+static inline WaterTileType GetWaterTileType(typename TileIndexT<Tgeneric>::T t)
 {
 	assert(IsTileType(t, MP_WATER));
 
-	switch (GB(_m[t].m5, WBL_TYPE_BEGIN, WBL_TYPE_COUNT)) {
-		case WBL_TYPE_NORMAL: return HasBit(_m[t].m5, WBL_COAST_FLAG) ? WATER_TILE_COAST : WATER_TILE_CLEAR;
+	switch (GB(GetTile(t)->m5, WBL_TYPE_BEGIN, WBL_TYPE_COUNT)) {
+		case WBL_TYPE_NORMAL: return HasBit(GetTile(t)->m5, WBL_COAST_FLAG) ? WATER_TILE_COAST : WATER_TILE_CLEAR;
 		case WBL_TYPE_LOCK:   return WATER_TILE_LOCK;
 		case WBL_TYPE_DEPOT:  return WATER_TILE_DEPOT;
 		default: NOT_REACHED();
 	}
 }
+/** @copydoc GetWaterTileType(TileIndexT<Tgeneric>::T) */
+static inline WaterTileType GetWaterTileType(TileIndex t) { return GetWaterTileType<false>(t); }
+/** @copydoc GetWaterTileType(TileIndexT<Tgeneric>::T) */
+static inline WaterTileType GetWaterTileType(GenericTileIndex t) { return GetWaterTileType<true>(t); }
 
 /**
  * Checks whether the tile has an waterclass associated.
@@ -92,10 +97,15 @@
  * @param t Tile to query.
  * @return True if the tiletype has a waterclass.
  */
-static inline bool HasTileWaterClass(TileIndex t)
+template <bool Tgeneric>
+static inline bool HasTileWaterClass(typename TileIndexT<Tgeneric>::T t)
 {
 	return IsTileType(t, MP_WATER) || IsTileType(t, MP_STATION) || IsTileType(t, MP_INDUSTRY) || IsTileType(t, MP_OBJECT);
 }
+/** @copydoc HasTileWaterClass(TileIndexT<Tgeneric>::T) */
+static inline bool HasTileWaterClass(TileIndex t) { return HasTileWaterClass<false>(t); }
+/** @copydoc HasTileWaterClass(TileIndexT<Tgeneric>::T) */
+static inline bool HasTileWaterClass(GenericTileIndex t) { return HasTileWaterClass<true>(t); }
 
 /**
  * Get the water class at a tile.
@@ -103,11 +113,16 @@
  * @pre IsTileType(t, MP_WATER) || IsTileType(t, MP_STATION) || IsTileType(t, MP_INDUSTRY) || IsTileType(t, MP_OBJECT)
  * @return Water class at the tile.
  */
-static inline WaterClass GetWaterClass(TileIndex t)
+template <bool Tgeneric>
+static inline WaterClass GetWaterClass(typename TileIndexT<Tgeneric>::T t)
 {
 	assert(HasTileWaterClass(t));
-	return (WaterClass)GB(_m[t].m1, 5, 2);
+	return (WaterClass)GB(GetTile(t)->m1, 5, 2);
 }
+/** @copydoc GetWaterClass(TileIndexT<Tgeneric>::T) */
+static inline WaterClass GetWaterClass(TileIndex t) { return GetWaterClass<false>(t); }
+/** @copydoc GetWaterClass(TileIndexT<Tgeneric>::T) */
+static inline WaterClass GetWaterClass(GenericTileIndex t) { return GetWaterClass<true>(t); }
 
 /**
  * Set the water class at a tile.
@@ -115,11 +130,16 @@
  * @param wc New water class.
  * @pre IsTileType(t, MP_WATER) || IsTileType(t, MP_STATION) || IsTileType(t, MP_INDUSTRY) || IsTileType(t, MP_OBJECT)
  */
-static inline void SetWaterClass(TileIndex t, WaterClass wc)
+template <bool Tgeneric>
+static inline void SetWaterClass(typename TileIndexT<Tgeneric>::T t, WaterClass wc)
 {
 	assert(HasTileWaterClass(t));
-	SB(_m[t].m1, 5, 2, wc);
+	SB(GetTile(t)->m1, 5, 2, wc);
 }
+/** @copydoc SetWaterClass(TileIndexT<Tgeneric>::T,WaterClass) */
+static inline void SetWaterClass(TileIndex t, WaterClass wc) { return SetWaterClass<false>(t, wc); }
+/** @copydoc SetWaterClass(TileIndexT<Tgeneric>::T,WaterClass) */
+static inline void SetWaterClass(GenericTileIndex t, WaterClass wc) { return SetWaterClass<true>(t, wc); }
 
 /**
  * Tests if the tile was built on water.
@@ -138,10 +158,15 @@
  * @return \c true if any type of clear water like ocean, river, or canal.
  * @pre IsTileType(t, MP_WATER)
  */
-static inline bool IsWater(TileIndex t)
+template <bool Tgeneric>
+static inline bool IsWater(typename TileIndexT<Tgeneric>::T t)
 {
 	return GetWaterTileType(t) == WATER_TILE_CLEAR;
 }
+/** @copydoc IsWater(TileIndexT<Tgeneric>::T) */
+static inline bool IsWater(TileIndex t) { return IsWater<false>(t); }
+/** @copydoc IsWater(TileIndexT<Tgeneric>::T) */
+static inline bool IsWater(GenericTileIndex t) { return IsWater<true>(t); }
 
 /**
  * Is it a sea water tile?
@@ -160,10 +185,15 @@
  * @return \c true if it is a canal tile.
  * @pre IsTileType(t, MP_WATER)
  */
-static inline bool IsCanal(TileIndex t)
+template <bool Tgeneric>
+static inline bool IsCanal(typename TileIndexT<Tgeneric>::T t)
 {
 	return IsWater(t) && GetWaterClass(t) == WATER_CLASS_CANAL;
 }
+/** @copydoc IsCanal(TileIndexT<Tgeneric>::T) */
+static inline bool IsCanal(TileIndex t) { return IsCanal<false>(t); }
+/** @copydoc IsCanal(TileIndexT<Tgeneric>::T) */
+static inline bool IsCanal(GenericTileIndex t) { return IsCanal<true>(t); }
 
 /**
  * Is it a river water tile?
@@ -181,10 +211,15 @@
  * @param t Tile to query.
  * @return \c true if it is a plain water tile.
  */
-static inline bool IsWaterTile(TileIndex t)
+template <bool Tgeneric>
+static inline bool IsWaterTile(typename TileIndexT<Tgeneric>::T t)
 {
 	return IsTileType(t, MP_WATER) && IsWater(t);
 }
+/** @copydoc IsWaterTile(TileIndexT<Tgeneric>::T) */
+static inline bool IsWaterTile(TileIndex t) { return IsWaterTile<false>(t); }
+/** @copydoc IsWaterTile(TileIndexT<Tgeneric>::T) */
+static inline bool IsWaterTile(GenericTileIndex t) { return IsWaterTile<true>(t); }
 
 /**
  * Is it a coast tile?
@@ -192,10 +227,15 @@
  * @return \c true if it is a sea water tile.
  * @pre IsTileType(t, MP_WATER)
  */
-static inline bool IsCoast(TileIndex t)
+template <bool Tgeneric>
+static inline bool IsCoast(typename TileIndexT<Tgeneric>::T t)
 {
 	return GetWaterTileType(t) == WATER_TILE_COAST;
 }
+/** @copydoc IsCoast(TileIndexT<Tgeneric>::T) */
+static inline bool IsCoast(TileIndex t) { return IsCoast<false>(t); }
+/** @copydoc IsCoast(TileIndexT<Tgeneric>::T) */
+static inline bool IsCoast(GenericTileIndex t) { return IsCoast<true>(t); }
 
 /**
  * Is it a coast tile
@@ -213,20 +253,30 @@
  * @return \c true if it is a ship depot tile.
  * @pre IsTileType(t, MP_WATER)
  */
-static inline bool IsShipDepot(TileIndex t)
+template <bool Tgeneric>
+static inline bool IsShipDepot(typename TileIndexT<Tgeneric>::T t)
 {
 	return GetWaterTileType(t) == WATER_TILE_DEPOT;
 }
+/** @copydoc IsShipDepot(TileIndexT<Tgeneric>::T) */
+static inline bool IsShipDepot(TileIndex t) { return IsShipDepot<false>(t); }
+/** @copydoc IsShipDepot(TileIndexT<Tgeneric>::T) */
+static inline bool IsShipDepot(GenericTileIndex t) { return IsShipDepot<true>(t); }
 
 /**
  * Is it a ship depot tile?
  * @param t Tile to query.
  * @return \c true if it is a ship depot tile.
  */
-static inline bool IsShipDepotTile(TileIndex t)
+template <bool Tgeneric>
+static inline bool IsShipDepotTile(typename TileIndexT<Tgeneric>::T t)
 {
 	return IsTileType(t, MP_WATER) && IsShipDepot(t);
 }
+/** @copydoc IsShipDepotTile(TileIndexT<Tgeneric>::T) */
+static inline bool IsShipDepotTile(TileIndex t) { return IsShipDepotTile<false>(t); }
+/** @copydoc IsShipDepotTile(TileIndexT<Tgeneric>::T) */
+static inline bool IsShipDepotTile(GenericTileIndex t) { return IsShipDepotTile<true>(t); }
 
 /**
  * Get the axis of the ship depot.
@@ -234,11 +284,16 @@
  * @return Axis of the depot.
  * @pre IsShipDepotTile(t)
  */
-static inline Axis GetShipDepotAxis(TileIndex t)
+template <bool Tgeneric>
+static inline Axis GetShipDepotAxis(typename TileIndexT<Tgeneric>::T t)
 {
 	assert(IsShipDepotTile(t));
-	return (Axis)GB(_m[t].m5, WBL_DEPOT_AXIS, 1);
+	return (Axis)GB(GetTile(t)->m5, WBL_DEPOT_AXIS, 1);
 }
+/** @copydoc GetShipDepotAxis(TileIndexT<Tgeneric>::T) */
+static inline Axis GetShipDepotAxis(TileIndex t) { return GetShipDepotAxis<false>(t); }
+/** @copydoc GetShipDepotAxis(TileIndexT<Tgeneric>::T) */
+static inline Axis GetShipDepotAxis(GenericTileIndex t) { return GetShipDepotAxis<true>(t); }
 
 /**
  * Get the part of a ship depot.
@@ -246,11 +301,16 @@
  * @return Part of the depot.
  * @pre IsShipDepotTile(t)
  */
-static inline DepotPart GetShipDepotPart(TileIndex t)
+template <bool Tgeneric>
+static inline DepotPart GetShipDepotPart(typename TileIndexT<Tgeneric>::T t)
 {
 	assert(IsShipDepotTile(t));
-	return (DepotPart)GB(_m[t].m5, WBL_DEPOT_PART, 1);
+	return (DepotPart)GB(GetTile(t)->m5, WBL_DEPOT_PART, 1);
 }
+/** @copydoc GetShipDepotPart(TileIndexT<Tgeneric>::T) */
+static inline DepotPart GetShipDepotPart(TileIndex t) { return GetShipDepotPart<false>(t); }
+/** @copydoc GetShipDepotPart(TileIndexT<Tgeneric>::T) */
+static inline DepotPart GetShipDepotPart(GenericTileIndex t) { return GetShipDepotPart<true>(t); }
 
 /**
  * Get the direction of the ship depot.
@@ -258,10 +318,15 @@
  * @return Direction of the depot.
  * @pre IsShipDepotTile(t)
  */
-static inline DiagDirection GetShipDepotDirection(TileIndex t)
+template <bool Tgeneric>
+static inline DiagDirection GetShipDepotDirection(typename TileIndexT<Tgeneric>::T t)
 {
 	return XYNSToDiagDir(GetShipDepotAxis(t), GetShipDepotPart(t));
 }
+/** @copydoc GetShipDepotDirection(TileIndexT<Tgeneric>::T) */
+static inline DiagDirection GetShipDepotDirection(TileIndex t) { return GetShipDepotDirection<false>(t); }
+/** @copydoc GetShipDepotDirection(TileIndexT<Tgeneric>::T) */
+static inline DiagDirection GetShipDepotDirection(GenericTileIndex t) { return GetShipDepotDirection<true>(t); }
 
 /**
  * Get the other tile of the ship depot.
@@ -269,10 +334,15 @@
  * @return Tile containing the other section of the depot.
  * @pre IsShipDepotTile(t)
  */
-static inline TileIndex GetOtherShipDepotTile(TileIndex t)
+template <bool Tgeneric>
+static inline typename TileIndexT<Tgeneric>::T GetOtherShipDepotTile(typename TileIndexT<Tgeneric>::T t)
 {
-	return t + (GetShipDepotPart(t) != DEPOT_PART_NORTH ? -1 : 1) * (GetShipDepotAxis(t) != AXIS_X ? TileDiffXY(0, 1) : TileDiffXY(1, 0));
+	return t + (GetShipDepotPart(t) != DEPOT_PART_NORTH ? -1 : 1) * (GetShipDepotAxis(t) != AXIS_X ? TileDiffXY(0, 1, MapOf(t)) : TileDiffXY(1, 0, MapOf(t)));
 }
+/** @copydoc GetOtherShipDepotTile(TileIndexT<Tgeneric>::T) */
+static inline TileIndex GetOtherShipDepotTile(TileIndex t) { return GetOtherShipDepotTile<false>(t); }
+/** @copydoc GetOtherShipDepotTile(TileIndexT<Tgeneric>::T) */
+static inline GenericTileIndex GetOtherShipDepotTile(GenericTileIndex t) { return GetOtherShipDepotTile<true>(t); }
 
 /**
  * Get the most northern tile of a ship depot.
@@ -294,10 +364,15 @@
  * @return \c true if it is a water lock tile.
  * @pre IsTileType(t, MP_WATER)
  */
-static inline bool IsLock(TileIndex t)
+template <bool Tgeneric>
+static inline bool IsLock(typename TileIndexT<Tgeneric>::T t)
 {
 	return GetWaterTileType(t) == WATER_TILE_LOCK;
 }
+/** @copydoc IsLock(TileIndexT<Tgeneric>::T) */
+static inline bool IsLock(TileIndex t) { return IsLock<false>(t); }
+/** @copydoc IsLock(TileIndexT<Tgeneric>::T) */
+static inline bool IsLock(GenericTileIndex t) { return IsLock<true>(t); }
 
 /**
  * Get the direction of the water lock.
@@ -305,11 +380,16 @@
  * @return Direction of the lock.
  * @pre IsTileType(t, MP_WATER) && IsLock(t)
  */
-static inline DiagDirection GetLockDirection(TileIndex t)
+template <bool Tgeneric>
+static inline DiagDirection GetLockDirection(typename TileIndexT<Tgeneric>::T t)
 {
 	assert(IsLock(t));
-	return (DiagDirection)GB(_m[t].m5, WBL_LOCK_ORIENT_BEGIN, WBL_LOCK_ORIENT_COUNT);
+	return (DiagDirection)GB(GetTile(t)->m5, WBL_LOCK_ORIENT_BEGIN, WBL_LOCK_ORIENT_COUNT);
 }
+/** @copydoc GetLockDirection(TileIndexT<Tgeneric>::T) */
+static inline DiagDirection GetLockDirection(TileIndex t) { return GetLockDirection<false>(t); }
+/** @copydoc GetLockDirection(TileIndexT<Tgeneric>::T) */
+static inline DiagDirection GetLockDirection(GenericTileIndex t) { return GetLockDirection<true>(t); }
 
 /**
  * Get the part of a lock.
@@ -317,11 +397,16 @@
  * @return The part.
  * @pre IsTileType(t, MP_WATER) && IsLock(t)
  */
-static inline byte GetLockPart(TileIndex t)
+template <bool Tgeneric>
+static inline byte GetLockPart(typename TileIndexT<Tgeneric>::T t)
 {
 	assert(IsLock(t));
-	return GB(_m[t].m5, WBL_LOCK_PART_BEGIN, WBL_LOCK_PART_COUNT);
+	return GB(GetTile(t)->m5, WBL_LOCK_PART_BEGIN, WBL_LOCK_PART_COUNT);
 }
+/** @copydoc GetLockPart(TileIndexT<Tgeneric>::T) */
+static inline byte GetLockPart(TileIndex t) { return GetLockPart<false>(t); }
+/** @copydoc GetLockPart(TileIndexT<Tgeneric>::T) */
+static inline byte GetLockPart(GenericTileIndex t) { return GetLockPart<true>(t); }
 
 /**
  * Get the random bits of the water tile.
@@ -332,7 +417,7 @@
 static inline byte GetWaterTileRandomBits(TileIndex t)
 {
 	assert(IsTileType(t, MP_WATER));
-	return _m[t].m4;
+	return GetTile(t)->m4;
 }
 
 /**
@@ -356,12 +441,12 @@
 	SetTileType(t, MP_WATER);
 	SetTileOwner(t, OWNER_WATER);
 	SetWaterClass(t, WATER_CLASS_SEA);
-	_m[t].m2 = 0;
-	_m[t].m3 = 0;
-	_m[t].m4 = 0;
-	_m[t].m5 = WBL_TYPE_NORMAL << WBL_TYPE_BEGIN | 1 << WBL_COAST_FLAG;
-	SB(_m[t].m6, 2, 4, 0);
-	_me[t].m7 = 0;
+	GetTile(t)->m2 = 0;
+	GetTile(t)->m3 = 0;
+	GetTile(t)->m4 = 0;
+	GetTile(t)->m5 = WBL_TYPE_NORMAL << WBL_TYPE_BEGIN | 1 << WBL_COAST_FLAG;
+	SB(GetTileEx(t)->m6, 2, 4, 0);
+	GetTileEx(t)->m7 = 0;
 }
 
 /**
@@ -371,18 +456,23 @@
  * @param wc The class of water the tile has to be
  * @param random_bits Eventual random bits to be set for this tile
  */
-static inline void MakeWater(TileIndex t, Owner o, WaterClass wc, uint8 random_bits)
+template <bool Tgeneric>
+static inline void MakeWater(typename TileIndexT<Tgeneric>::T t, Owner o, WaterClass wc, uint8 random_bits)
 {
 	SetTileType(t, MP_WATER);
 	SetTileOwner(t, o);
 	SetWaterClass(t, wc);
-	_m[t].m2 = 0;
-	_m[t].m3 = 0;
-	_m[t].m4 = random_bits;
-	_m[t].m5 = WBL_TYPE_NORMAL << WBL_TYPE_BEGIN;
-	SB(_m[t].m6, 2, 4, 0);
-	_me[t].m7 = 0;
+	GetTile(t)->m2 = 0;
+	GetTile(t)->m3 = 0;
+	GetTile(t)->m4 = random_bits;
+	GetTile(t)->m5 = WBL_TYPE_NORMAL << WBL_TYPE_BEGIN;
+	SB(GetTileEx(t)->m6, 2, 4, 0);
+	GetTileEx(t)->m7 = 0;
 }
+/** @copydoc MakeWater(TileIndexT<Tgeneric>::T,Owner,WaterClass,uint8) */
+static inline void MakeWater(TileIndex t, Owner o, WaterClass wc, uint8 random_bits) { MakeWater<false>(t, o, wc, random_bits); }
+/** @copydoc MakeWater(TileIndexT<Tgeneric>::T,Owner,WaterClass,uint8) */
+static inline void MakeWater(GenericTileIndex t, Owner o, WaterClass wc, uint8 random_bits) { MakeWater<true>(t, o, wc, random_bits); }
 
 /**
  * Make a sea tile.
@@ -409,11 +499,16 @@
  * @param o The owner of the canal
  * @param random_bits Random bits to be set for this tile
  */
-static inline void MakeCanal(TileIndex t, Owner o, uint8 random_bits)
+template <bool Tgeneric>
+static inline void MakeCanal(typename TileIndexT<Tgeneric>::T t, Owner o, uint8 random_bits)
 {
 	assert(o != OWNER_WATER);
 	MakeWater(t, o, WATER_CLASS_CANAL, random_bits);
 }
+/** @copydoc MakeCanal(TileIndexT<Tgeneric>::T,Owner,uint) */
+static inline void MakeCanal(TileIndex t, Owner o, uint8 random_bits) { MakeCanal<false>(t, o, random_bits); }
+/** @copydoc MakeCanal(TileIndexT<Tgeneric>::T,Owner,uint) */
+static inline void MakeCanal(GenericTileIndex t, Owner o, uint8 random_bits) { MakeCanal<true>(t, o, random_bits); }
 
 /**
  * Make a ship depot section.
@@ -424,18 +519,23 @@
  * @param a    Axis of the depot.
  * @param original_water_class Original water class.
  */
-static inline void MakeShipDepot(TileIndex t, Owner o, DepotID did, DepotPart part, Axis a, WaterClass original_water_class)
+template <bool Tgeneric>
+static inline void MakeShipDepot(typename TileIndexT<Tgeneric>::T t, Owner o, DepotID did, DepotPart part, Axis a, WaterClass original_water_class)
 {
 	SetTileType(t, MP_WATER);
 	SetTileOwner(t, o);
 	SetWaterClass(t, original_water_class);
-	_m[t].m2 = did;
-	_m[t].m3 = 0;
-	_m[t].m4 = 0;
-	_m[t].m5 = WBL_TYPE_DEPOT << WBL_TYPE_BEGIN | part << WBL_DEPOT_PART | a << WBL_DEPOT_AXIS;
-	SB(_m[t].m6, 2, 4, 0);
-	_me[t].m7 = 0;
+	GetTile(t)->m2 = did;
+	GetTile(t)->m3 = 0;
+	GetTile(t)->m4 = 0;
+	GetTile(t)->m5 = WBL_TYPE_DEPOT << WBL_TYPE_BEGIN | part << WBL_DEPOT_PART | a << WBL_DEPOT_AXIS;
+	SB(GetTileEx(t)->m6, 2, 4, 0);
+	GetTileEx(t)->m7 = 0;
 }
+/** @copydoc MakeShipDepot(TileIndexT<Tgeneric>::T,Owner,DepotID,DepotPart,Axis,WaterClass) */
+static inline void MakeShipDepot(TileIndex t, Owner o, DepotID did, DepotPart part, Axis a, WaterClass original_water_class) { MakeShipDepot<false>(t, o, did, part, a, original_water_class); }
+/** @copydoc MakeShipDepot(TileIndexT<Tgeneric>::T,Owner,DepotID,DepotPart,Axis,WaterClass) */
+static inline void MakeShipDepot(GenericTileIndex t, Owner o, DepotID did, DepotPart part, Axis a, WaterClass original_water_class) { MakeShipDepot<true>(t, o, did, part, a, original_water_class); }
 
 /**
  * Make a lock section.
@@ -446,18 +546,23 @@
  * @param original_water_class Original water class.
  * @see MakeLock
  */
-static inline void MakeLockTile(TileIndex t, Owner o, LockPart part, DiagDirection dir, WaterClass original_water_class)
+template <bool Tgeneric>
+static inline void MakeLockTile(typename TileIndexT<Tgeneric>::T t, Owner o, LockPart part, DiagDirection dir, WaterClass original_water_class)
 {
 	SetTileType(t, MP_WATER);
 	SetTileOwner(t, o);
 	SetWaterClass(t, original_water_class);
-	_m[t].m2 = 0;
-	_m[t].m3 = 0;
-	_m[t].m4 = 0;
-	_m[t].m5 = WBL_TYPE_LOCK << WBL_TYPE_BEGIN | part << WBL_LOCK_PART_BEGIN | dir << WBL_LOCK_ORIENT_BEGIN;
-	SB(_m[t].m6, 2, 4, 0);
-	_me[t].m7 = 0;
+	GetTile(t)->m2 = 0;
+	GetTile(t)->m3 = 0;
+	GetTile(t)->m4 = 0;
+	GetTile(t)->m5 = WBL_TYPE_LOCK << WBL_TYPE_BEGIN | part << WBL_LOCK_PART_BEGIN | dir << WBL_LOCK_ORIENT_BEGIN;
+	SB(GetTileEx(t)->m6, 2, 4, 0);
+	GetTileEx(t)->m7 = 0;
 }
+/** @copydoc MakeLockTile(TileIndexT<Tgeneric>::T,Owner,LockPart,DiagDirection,WaterClass) */
+static inline void MakeLockTile(TileIndex t, Owner o, LockPart part, DiagDirection dir, WaterClass original_water_class) { MakeLockTile<false>(t, o, part, dir, original_water_class); }
+/** @copydoc MakeLockTile(TileIndexT<Tgeneric>::T,Owner,LockPart,DiagDirection,WaterClass) */
+static inline void MakeLockTile(GenericTileIndex t, Owner o, LockPart part, DiagDirection dir, WaterClass original_water_class) { MakeLockTile<true>(t, o, part, dir, original_water_class); }
 
 /**
  * Make a water lock.
@@ -468,9 +573,10 @@
  * @param wc_upper Original water class of the upper part.
  * @param wc_middle Original water class of the middle part.
  */
-static inline void MakeLock(TileIndex t, Owner o, DiagDirection d, WaterClass wc_lower, WaterClass wc_upper, WaterClass wc_middle)
+template <bool Tgeneric>
+static inline void MakeLock(typename TileIndexT<Tgeneric>::T t, Owner o, DiagDirection d, WaterClass wc_lower, WaterClass wc_upper, WaterClass wc_middle)
 {
-	TileIndexDiff delta = TileOffsByDiagDir(d);
+	TileIndexDiff delta = TileOffsByDiagDir<Tgeneric>(d, MapOf(t));
 
 	/* Keep the current waterclass and owner for the tiles.
 	 * It allows to restore them after the lock is deleted */
@@ -478,5 +584,9 @@
 	MakeLockTile(t - delta, IsWaterTile(t - delta) ? GetTileOwner(t - delta) : o, LOCK_PART_LOWER, d, wc_lower);
 	MakeLockTile(t + delta, IsWaterTile(t + delta) ? GetTileOwner(t + delta) : o, LOCK_PART_UPPER, d, wc_upper);
 }
+/** @copydoc MakeLock(TileIndexT<Tgeneric>::T,Owner,DiagDirection,WaterClass,WaterClass,WaterClass) */
+static inline void MakeLock(TileIndex t, Owner o, DiagDirection d, WaterClass wc_lower, WaterClass wc_upper, WaterClass wc_middle) { MakeLock<false>(t, o, d, wc_lower, wc_upper, wc_middle); }
+/** @copydoc MakeLock(TileIndexT<Tgeneric>::T,Owner,DiagDirection,WaterClass,WaterClass,WaterClass) */
+static inline void MakeLock(GenericTileIndex t, Owner o, DiagDirection d, WaterClass wc_lower, WaterClass wc_upper, WaterClass wc_middle) { MakeLock<true>(t, o, d, wc_lower, wc_upper, wc_middle); }
 
 #endif /* WATER_MAP_H */
diff -urNad openttd-1.3.2/src/waypoint_cmd.cpp openttd-1.3.2-DC3.0RC3/src/waypoint_cmd.cpp
--- openttd-1.3.2/src/waypoint_cmd.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/waypoint_cmd.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -13,6 +13,8 @@
 
 #include "cmd_helper.h"
 #include "command_func.h"
+#include "copypaste_cmd.h"
+#include "clipboard_func.h"
 #include "landscape.h"
 #include "bridge_map.h"
 #include "town.h"
@@ -99,8 +101,9 @@
  * @param tile the tile to check for suitability
  * @param axis the axis of the waypoint
  * @param waypoint Waypoint the waypoint to check for is already joined to. If we find another waypoint it can join to it will throw an error.
+ * @param flags flags for the command
  */
-static CommandCost IsValidTileForWaypoint(TileIndex tile, Axis axis, StationID *waypoint)
+static CommandCost IsValidTileForWaypoint(TileIndex tile, Axis axis, StationID *waypoint, DoCommandFlag flags)
 {
 	/* if waypoint is set, then we have special handling to allow building on top of already existing waypoints.
 	 * so waypoint points to INVALID_STATION if we can build on any waypoint.
@@ -118,11 +121,21 @@
 		}
 	}
 
-	if (GetAxisForNewWaypoint(tile) != axis) return_cmd_error(STR_ERROR_NO_SUITABLE_RAILROAD_TRACK);
+	/* When pasting a waypoint, there may be no track yet (it will be placed when DC_EXEC'ing).
+	 * Ignore that so we can calculate the cost more precisely. */
+	bool ignore_lack_of_tracks = (flags & DC_PASTE) && !(flags & DC_EXEC);
+
+	if (!ignore_lack_of_tracks || IsTileType(tile, MP_RAILWAY)) {
+		if (GetAxisForNewWaypoint(tile) != axis) return_cmd_error(STR_ERROR_NO_SUITABLE_RAILROAD_TRACK);
+	}
 
 	Owner owner = GetTileOwner(tile);
-	CommandCost ret = CheckOwnership(owner);
-	if (ret.Succeeded()) ret = EnsureNoVehicleOnGround(tile);
+	if (!ignore_lack_of_tracks || owner != OWNER_NONE) {
+		CommandCost ret = CheckOwnership(owner);
+		if (ret.Failed()) return ret;
+	}
+
+	CommandCost ret = EnsureNoVehicleOnGround(tile);
 	if (ret.Failed()) return ret;
 
 	Slope tileh = GetTileSlope(tile);
@@ -180,9 +193,8 @@
 
 	bool reuse = (station_to_join != NEW_STATION);
 	if (!reuse) station_to_join = INVALID_STATION;
-	bool distant_join = (station_to_join != INVALID_STATION);
 
-	if (distant_join && (!_settings_game.station.distant_join_stations || !Waypoint::IsValidID(station_to_join))) return CMD_ERROR;
+	if (station_to_join != INVALID_STATION && !Waypoint::IsValidID(station_to_join)) return CMD_ERROR;
 
 	/* Make sure the area below consists of clear tiles. (OR tiles belonging to a certain rail station) */
 	StationID est = INVALID_STATION;
@@ -191,7 +203,7 @@
 	TileIndexDiff offset = TileOffsByDiagDir(AxisToDiagDir(OtherAxis(axis)));
 	for (int i = 0; i < count; i++) {
 		TileIndex tile = start_tile + i * offset;
-		CommandCost ret = IsValidTileForWaypoint(tile, axis, &est);
+		CommandCost ret = IsValidTileForWaypoint(tile, axis, &est, flags);
 		if (ret.Failed()) return ret;
 	}
 
@@ -286,7 +298,18 @@
  */
 CommandCost CmdBuildBuoy(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
 {
-	if (tile == 0 || !HasTileWaterGround(tile)) return_cmd_error(STR_ERROR_SITE_UNSUITABLE);
+	if (tile == 0) return_cmd_error(STR_ERROR_SITE_UNSUITABLE);
+
+	WaterClass wc;
+	if ((flags & DC_PASTE) && !(flags & DC_EXEC)) {
+		/* When pasting a buoy, there may be no water yet (a canal will be placed when DC_EXE'ing).
+		 * Ignore that there is no water so we can calculate the cost more precisely. */
+		wc = WATER_CLASS_INVALID;
+	} else {
+		if (!HasTileWaterGround(tile)) return_cmd_error(STR_ERROR_SITE_UNSUITABLE);
+		wc = GetWaterClass(tile);
+	}
+
 	if (MayHaveBridgeAbove(tile) && IsBridgeAbove(tile)) return_cmd_error(STR_ERROR_MUST_DEMOLISH_BRIDGE_FIRST);
 
 	if (GetTileSlope(tile) != SLOPE_FLAT) return_cmd_error(STR_ERROR_SITE_UNSUITABLE);
@@ -321,7 +344,8 @@
 
 		if (wp->town == NULL) MakeDefaultName(wp);
 
-		MakeBuoy(tile, wp->index, GetWaterClass(tile));
+		assert(wc != WATER_CLASS_INVALID);
+		MakeBuoy(tile, wp->index, wc);
 
 		wp->UpdateVirtCoord();
 		InvalidateWindowData(WC_WAYPOINT_VIEW, wp->index);
@@ -420,3 +444,54 @@
 	}
 	return CommandCost();
 }
+
+extern ClipboardStationsBuilder _clipboard_stations_builder;
+
+void CopyPastePlaceRailWaypoint(GenericTileIndex tile, StationID sid, Axis axis, byte gfx, StationClassID spec_class, byte spec_index, RailType rt, bool adjacent)
+{
+	if (IsMainMapTile(tile)) {
+		TileIndex t = AsMainMapTile(tile);
+		/* check if required track is already there, try to build one if not */
+		if (!IsTileOwner(t, _current_company) ||
+				(!IsRailWaypointTile(tile) && !IsPlainRailTile(tile)) ||
+				GetRailType(t) != rt ||
+				(IsTileType(t, MP_STATION) ? GetRailStationAxis(tile) != axis : !HasBit(GetTrackBits(t), AxisToTrack(axis)))) {
+			CopyPastePlaceTracks(tile, rt, AxisToTrackBits(axis));
+			if (_current_pasting->last_result.Failed()) return;
+		}
+		/* build the waypoint */
+		uint32 p1 = 0;
+		SB(p1, 0, 4, rt);
+		SB(p1, 4, 1, axis);
+		SB(p1, 8, 8, 1);  // width
+		SB(p1, 16, 8, 1); // height
+		SB(p1, 24, 1, adjacent);
+		uint32 p2 = 0;
+		SB(p2, 0, 8, spec_class);
+		SB(p2, 8, 8, spec_index);
+		SB(p2, 16, 16, sid);
+		_current_pasting->DoCommand(t, p1, p2, CMD_BUILD_RAIL_WAYPOINT | CMD_MSG(STR_ERROR_CAN_T_BUILD_TRAIN_WAYPOINT));
+	} else {
+		MakeRailWaypoint(tile, OWNER_NONE, sid, axis, gfx - axis, rt);
+		uint custom_specindex = _clipboard_stations_builder.AddWaypointPart(sid, spec_class, spec_index);
+		SetCustomStationSpecIndex(tile, custom_specindex);
+	}
+}
+
+void CopyPastePlaceBuoy(GenericTileIndex tile, StationID sid, WaterClass wc)
+{
+	if (IsMainMapTile(tile)) {
+		TileIndex t = AsMainMapTile(tile);
+		/* build a piece of canal if not on water */
+		if (!HasTileWaterGround(t)) {
+			CopyPastePlaceCannal(tile);
+			if (_current_pasting->last_result.Failed()) return;
+		}
+		/* build the buoy */
+		_current_pasting->DoCommand(t, 0, 0, CMD_BUILD_BUOY | CMD_MSG(STR_ERROR_CAN_T_POSITION_BUOY_HERE));
+	} else {
+		SetTileOwner(tile, OWNER_NONE);
+		MakeBuoy(tile, sid, wc);
+		_clipboard_stations_builder.AddBuoyPart(sid);
+	}
+}
diff -urNad openttd-1.3.2/src/waypoint_gui.cpp openttd-1.3.2-DC3.0RC3/src/waypoint_gui.cpp
--- openttd-1.3.2/src/waypoint_gui.cpp	2013-07-27 17:09:40.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/waypoint_gui.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -22,6 +22,7 @@
 #include "company_base.h"
 #include "window_func.h"
 #include "waypoint_base.h"
+#include "departures_gui.h"
 
 #include "widgets/waypoint_widget.h"
 
@@ -109,6 +110,10 @@
 			case WID_W_SHOW_VEHICLES: // show list of vehicles having this waypoint in their orders
 				ShowVehicleListWindow(this->wp->owner, this->vt, this->wp->index);
 				break;
+
+			case WID_W_DEPARTURES: // show departure times of vehicles
+				ShowWaypointDepartures((StationID)this->wp->index);
+				break;
 		}
 	}
 
@@ -164,6 +169,7 @@
 	NWidget(NWID_HORIZONTAL),
 		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_W_CENTER_VIEW), SetMinimalSize(100, 12), SetResize(1, 0), SetFill(1, 0), SetDataTip(STR_BUTTON_LOCATION, STR_BUOY_VIEW_CENTER_TOOLTIP),
 		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_W_RENAME), SetMinimalSize(100, 12), SetResize(1, 0), SetFill(1, 0), SetDataTip(STR_BUTTON_RENAME, STR_BUOY_VIEW_CHANGE_BUOY_NAME),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_W_DEPARTURES), SetMinimalSize(100, 12), SetResize(1, 0), SetFill(1, 0), SetDataTip(STR_STATION_VIEW_DEPARTURES_BUTTON, STR_STATION_VIEW_DEPARTURES_TOOLTIP),
 		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_W_SHOW_VEHICLES), SetMinimalSize(15, 12), SetDataTip(STR_SHIP, STR_STATION_VIEW_SCHEDULED_SHIPS_TOOLTIP),
 		NWidget(WWT_RESIZEBOX, COLOUR_GREY),
 	EndContainer(),
diff -urNad openttd-1.3.2/src/widgets/build_vehicle_widget.h openttd-1.3.2-DC3.0RC3/src/widgets/build_vehicle_widget.h
--- openttd-1.3.2/src/widgets/build_vehicle_widget.h	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/widgets/build_vehicle_widget.h	2013-11-22 05:49:07.000000000 +0100
@@ -21,9 +21,12 @@
 	WID_BV_LIST,                      ///< List of vehicles.
 	WID_BV_SCROLLBAR,                 ///< Scrollbar of list.
 	WID_BV_PANEL,                     ///< Button panel.
+	WID_BV_BUILD_REFIT,
+	WID_BV_BUILD_REFIT_SEL,
 	WID_BV_BUILD,                     ///< Build panel.
 	WID_BV_BUILD_SEL,                 ///< Build button.
 	WID_BV_RENAME,                    ///< Rename button.
+        BUILD_VEHICLE_WIDGET_BUILD,               /// TODO: own
 };
 
 #endif /* WIDGETS_BUILD_VEHICLE_WIDGET_H */
diff -urNad openttd-1.3.2/src/widgets/clipboard_widget.h openttd-1.3.2-DC3.0RC3/src/widgets/clipboard_widget.h
--- openttd-1.3.2/src/widgets/clipboard_widget.h	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/widgets/clipboard_widget.h	2013-11-22 05:49:07.000000000 +0100
@@ -0,0 +1,48 @@
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file clipboard_widget.h Types related to the clipboard widgets. */
+
+#ifndef WIDGETS_CLIPBOARD_WIDGET_H
+#define WIDGETS_CLIPBOARD_WIDGET_H
+
+/** Widgets of the #ClipboardToolbarWindow class. */
+enum ClipboardToolbarWidgets {
+	WID_CT_CLIPBOARD_1,                                     ///< Button to switch to clipboard #1
+	WID_CT_CLIPBOARD_2,                                     ///< Button to switch to clipboard #2
+	WID_CT_CLIPBOARD_3,                                     ///< Button to switch to clipboard #3
+	WID_CT_CLIPBOARD_4,                                     ///< Button to switch to clipboard #4
+
+	WID_CT_COPY,                                            ///< Copy button (single player)
+	WID_CT_PASTE,                                           ///< Paste button (single player)
+
+	WID_CT_PASTE_FLAG_BUTTON_BEGIN,                         ///< First button to toggle copy-paste flag
+	WID_CT_WITH_RAIL = WID_CT_PASTE_FLAG_BUTTON_BEGIN,      ///< Toggle rails button
+	WID_CT_WITH_ROAD,                                       ///< Toggle roads button
+	WID_CT_WITH_WATER,                                      ///< Toggle water button
+	WID_CT_WITH_AIR,                                        ///< Toggle air button
+	WID_CT_MIRROR_SIGNALS,                                  ///< Toggle signal mirrorig button
+	WID_CT_UPGRADE_BRIDGES,                                 ///< Toggle bridge upgrading button
+	WID_CT_PASTE_FLAG_BUTTON_END,                           ///< Past-the-last button to toggle copy-paste flag
+
+	WID_CT_CONVERT_RAILTYPE = WID_CT_PASTE_FLAG_BUTTON_END, ///< Button to select railtype to convert to
+
+	WID_CT_TERRAFORM,                                       ///< Button to select terraforming mode
+
+	WID_CT_TRANSFORMATION,                                  ///< Button to show/reset clipboard transformation
+	WID_CT_ROTATE_LEFT,                                     ///< Rotate left button
+	WID_CT_ROTATE_RIGHT,                                    ///< Rotate right button
+	WID_CT_REFLECT_NE_SW,                                   ///< Reflect against NE-SW axis button
+	WID_CT_REFLECT_NW_SE,                                   ///< Reflect against NW-SE axis button
+
+	WID_CT_HEIGHT_DIFF_GLYPH,                               ///< Image in front of buttons to increase/decrease height level
+	WID_CT_HEIGHT_DIFF,                                     ///< Panel with buttons to increase/decrease height level
+	WID_CT_HEIGHT_DIFF_INCREASE,                            ///< Button to increase height level
+	WID_CT_HEIGHT_DIFF_DECREASE,                            ///< Button to decrease height level
+};
+
+#endif /* WIDGETS_CLIPBOARD_WIDGET_H */
diff -urNad openttd-1.3.2/src/widgets/company_widget.h openttd-1.3.2-DC3.0RC3/src/widgets/company_widget.h
--- openttd-1.3.2/src/widgets/company_widget.h	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/widgets/company_widget.h	2013-11-22 05:49:07.000000000 +0100
@@ -48,6 +48,9 @@
 
 	WID_C_VIEW_INFRASTRUCTURE,        ///< Panel about infrastructure.
 
+    WID_C_SELECT_GIVE_MONEY,          ///< Selection widget for the give money button.
+	WID_C_GIVE_MONEY,                 ///< Button to give money.
+
 	WID_C_HAS_PASSWORD,               ///< Has company password lock.
 	WID_C_SELECT_MULTIPLAYER,         ///< Multiplayer selection panel.
 	WID_C_COMPANY_PASSWORD,           ///< Button to set company password.
diff -urNad openttd-1.3.2/src/widgets/departures_widget.h openttd-1.3.2-DC3.0RC3/src/widgets/departures_widget.h
--- openttd-1.3.2/src/widgets/departures_widget.h	1970-01-01 01:00:00.000000000 +0100
+++ openttd-1.3.2-DC3.0RC3/src/widgets/departures_widget.h	2013-11-22 05:49:07.000000000 +0100
@@ -0,0 +1,29 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file waypoint_widget.h Types related to the waypoint widgets. */
+
+#ifndef WIDGETS_DEPARTURES_WIDGET_H
+#define WIDGETS_DEPARTURES_WIDGET_H
+
+/** Widgets of the WC_DEPARTURES_BOARD. */
+enum DeparturesWindowWidgets {
+	WID_DB_CAPTION,		        ///< Window caption
+	WID_DB_LIST,			    ///< List of departures
+	WID_DB_SCROLLBAR,	        ///< List scrollbar
+	WID_DB_SHOW_DEPS,           ///< Toggle departures button
+	WID_DB_SHOW_ARRS,           ///< Toggle arrivals button
+	WID_DB_SHOW_VIA,            ///< Toggle via button
+	WID_DB_SHOW_TRAINS,         ///< Toggle trains button
+	WID_DB_SHOW_ROADVEHS,       ///< Toggle road vehicles button
+	WID_DB_SHOW_SHIPS,          ///< Toggle ships button
+	WID_DB_SHOW_PLANES,         ///< Toggle planes button
+};
+
+#endif /* WIDGETS_DEPARTURES_WIDGET_H */
diff -urNad openttd-1.3.2/src/widgets/genworld_widget.h openttd-1.3.2-DC3.0RC3/src/widgets/genworld_widget.h
--- openttd-1.3.2/src/widgets/genworld_widget.h	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/widgets/genworld_widget.h	2013-11-22 05:49:07.000000000 +0100
@@ -30,6 +30,10 @@
 
 	WID_GL_GENERATE_BUTTON,             ///< 'Generate' button.
 
+	WID_GL_MAX_HEIGHTLEVEL_DOWN,        ///< Decrease max. heightlevel
+	WID_GL_MAX_HEIGHTLEVEL_TEXT,        ///< Max. heightlevel
+	WID_GL_MAX_HEIGHTLEVEL_UP,          ///< Increase max. heightlevel
+
 	WID_GL_START_DATE_DOWN,             ///< Decrease start year.
 	WID_GL_START_DATE_TEXT,             ///< Start year.
 	WID_GL_START_DATE_UP,               ///< Increase start year.
diff -urNad openttd-1.3.2/src/widgets/group_widget.h openttd-1.3.2-DC3.0RC3/src/widgets/group_widget.h
--- openttd-1.3.2/src/widgets/group_widget.h	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/widgets/group_widget.h	2013-11-22 05:49:07.000000000 +0100
@@ -32,6 +32,7 @@
 	WID_GL_DELETE_GROUP,             ///< Delete group button.
 	WID_GL_RENAME_GROUP,             ///< Rename group button.
 	WID_GL_REPLACE_PROTECTION,       ///< Replace protection button.
+	WID_GL_INFO,                     ///< Group info.
 };
 
 #endif /* WIDGETS_GROUP_WIDGET_H */
diff -urNad openttd-1.3.2/src/widgets/industry_widget.h openttd-1.3.2-DC3.0RC3/src/widgets/industry_widget.h
--- openttd-1.3.2/src/widgets/industry_widget.h	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/widgets/industry_widget.h	2013-11-22 05:49:07.000000000 +0100
@@ -36,6 +36,8 @@
 	WID_ID_DROPDOWN_CRITERIA, ///< Dropdown for the criteria of the sort.
 	WID_ID_INDUSTRY_LIST,     ///< Industry list.
 	WID_ID_SCROLLBAR,         ///< Scrollbar of the list.
+	WID_ID_TYPESALL,          ///< Toggle all industry types button.
+	WID_ID_TYPE_START,        ///< Widget numbers used for list of industry types (not present in _industry_directory_widgets).
 };
 
 /** Widgets of the #IndustryCargoesWindow class */
diff -urNad openttd-1.3.2/src/widgets/order_widget.h openttd-1.3.2-DC3.0RC3/src/widgets/order_widget.h
--- openttd-1.3.2/src/widgets/order_widget.h	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/widgets/order_widget.h	2013-11-22 05:49:07.000000000 +0100
@@ -32,6 +32,8 @@
 	WID_O_COND_VARIABLE,             ///< Choose condition variable.
 	WID_O_COND_COMPARATOR,           ///< Choose condition type.
 	WID_O_COND_VALUE,                ///< Choose condition value.
+	WID_O_COND_CARGO,
+	WID_O_SEL_COND_VALUE,            ///< widget for conditional value or conditional cargo type.
 	WID_O_SEL_TOP_LEFT,              ///< #NWID_SELECTION widget for left part of the top row of the 'your train' order window.
 	WID_O_SEL_TOP_MIDDLE,            ///< #NWID_SELECTION widget for middle part of the top row of the 'your train' order window.
 	WID_O_SEL_TOP_RIGHT,             ///< #NWID_SELECTION widget for right part of the top row of the 'your train' order window.
diff -urNad openttd-1.3.2/src/widgets/road_widget.h openttd-1.3.2-DC3.0RC3/src/widgets/road_widget.h
--- openttd-1.3.2/src/widgets/road_widget.h	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/widgets/road_widget.h	2013-11-22 05:49:07.000000000 +0100
@@ -23,6 +23,7 @@
 	WID_ROT_BUS_STATION,    ///< Build bus station.
 	WID_ROT_TRUCK_STATION,  ///< Build truck station.
 	WID_ROT_ONE_WAY,        ///< Build one-way road.
+	WID_ROT_TRAFFIC_LIGHT,  ///< Build trafficlights.
 	WID_ROT_BUILD_BRIDGE,   ///< Build bridge.
 	WID_ROT_BUILD_TUNNEL,   ///< Build tunnel.
 	WID_ROT_REMOVE,         ///< Remove road.
diff -urNad openttd-1.3.2/src/widgets/smallmap_widget.h openttd-1.3.2-DC3.0RC3/src/widgets/smallmap_widget.h
--- openttd-1.3.2/src/widgets/smallmap_widget.h	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/widgets/smallmap_widget.h	2013-11-22 05:49:07.000000000 +0100
@@ -23,6 +23,7 @@
 	WID_SM_CONTOUR,        ///< Button to select the contour view (height map).
 	WID_SM_VEHICLES,       ///< Button to select the vehicles view.
 	WID_SM_INDUSTRIES,     ///< Button to select the industries view.
+	WID_SM_ROUTE_LINKS,    ///< Button to select the route link view.
 	WID_SM_ROUTES,         ///< Button to select the routes view.
 	WID_SM_VEGETATION,     ///< Button to select the vegetation view.
 	WID_SM_OWNERS,         ///< Button to select the owners view.
diff -urNad openttd-1.3.2/src/widgets/station_widget.h openttd-1.3.2-DC3.0RC3/src/widgets/station_widget.h
--- openttd-1.3.2/src/widgets/station_widget.h	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/widgets/station_widget.h	2013-11-22 05:49:07.000000000 +0100
@@ -19,13 +19,16 @@
 	WID_SV_SCROLLBAR,          ///< Scrollbar.
 	WID_SV_ACCEPT_RATING_LIST, ///< List of accepted cargoes / rating of cargoes.
 	WID_SV_LOCATION,           ///< 'Location' button.
+	WID_SV_COVERAGE,           ///< Show area coverage button
 	WID_SV_ACCEPTS_RATINGS,    ///< 'Accepts' / 'Ratings' button.
+	WID_SV_CARGO_FROM_TO_VIA,  ///< 'Source' button
 	WID_SV_RENAME,             ///< 'Rename' button.
 	WID_SV_CLOSE_AIRPORT,      ///< 'Close airport' button.
 	WID_SV_TRAINS,             ///< List of scheduled trains button.
 	WID_SV_ROADVEHS,           ///< List of scheduled road vehs button.
 	WID_SV_SHIPS,              ///< List of scheduled ships button.
 	WID_SV_PLANES,             ///< List of scheduled planes button.
+    WID_SV_DEPARTURES,         ///< Departures button.
 };
 
 /** Widgets of the #CompanyStationsWindow class. */
diff -urNad openttd-1.3.2/src/widgets/terraform_widget.h openttd-1.3.2-DC3.0RC3/src/widgets/terraform_widget.h
--- openttd-1.3.2/src/widgets/terraform_widget.h	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/widgets/terraform_widget.h	2013-11-22 05:49:07.000000000 +0100
@@ -19,6 +19,7 @@
 	WID_TT_LOWER_LAND = WID_TT_BUTTONS_START, ///< Lower land button.
 	WID_TT_RAISE_LAND,                        ///< Raise land button.
 	WID_TT_LEVEL_LAND,                        ///< Level land button.
+	WID_TT_CLIPBOARD,                         ///< Button to open the clipboard toolbar
 	WID_TT_DEMOLISH,                          ///< Demolish aka dynamite button.
 	WID_TT_BUY_LAND,                          ///< Buy land button.
 	WID_TT_PLANT_TREES,                       ///< Plant trees button (note: opens separate window, no place-push-button).
diff -urNad openttd-1.3.2/src/widgets/timetable_widget.h openttd-1.3.2-DC3.0RC3/src/widgets/timetable_widget.h
--- openttd-1.3.2/src/widgets/timetable_widget.h	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/widgets/timetable_widget.h	2013-11-22 05:49:07.000000000 +0100
@@ -31,6 +31,9 @@
 	WID_VT_EXPECTED_SELECTION,          ///< Disable/hide the expected selection button.
 	WID_VT_CHANGE_SPEED,                ///< Change speed limit button.
 	WID_VT_CLEAR_SPEED,                 ///< Clear speed limit button.
+	WID_VT_TTSEP_MODE_DROPDOWN,         ///< Select separation mode dropdown
+	WID_VT_TTSEP_SET_PARAMETER,         ///< Set the separation parameter (time / number)
+	WID_VT_TTSEP_PANEL_TEXT             ///< Panel area for separation info text
 };
 
 #endif /* WIDGETS_TIMETABLE_WIDGET_H */
diff -urNad openttd-1.3.2/src/widgets/transparency_widget.h openttd-1.3.2-DC3.0RC3/src/widgets/transparency_widget.h
--- openttd-1.3.2/src/widgets/transparency_widget.h	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/widgets/transparency_widget.h	2013-11-22 05:49:07.000000000 +0100
@@ -25,6 +25,7 @@
 	WID_TT_STRUCTURES,               ///< Object structure transparency toggle button.
 	WID_TT_CATENARY,                 ///< Catenary transparency toggle button.
 	WID_TT_LOADING,                  ///< Loading indicators transparency toggle button.
+	WID_TT_TUNNELS,
 	WID_TT_END,                      ///< End of toggle buttons.
 
 	/* Panel with buttons for invisibility */
diff -urNad openttd-1.3.2/src/widgets/vehicle_widget.h openttd-1.3.2-DC3.0RC3/src/widgets/vehicle_widget.h
--- openttd-1.3.2/src/widgets/vehicle_widget.h	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/widgets/vehicle_widget.h	2013-11-22 05:49:07.000000000 +0100
@@ -45,6 +45,7 @@
 /** Widgets of the #VehicleDetailsWindow class. */
 enum VehicleDetailsWidgets {
 	WID_VD_CAPTION,                     ///< Caption of window.
+	WID_VD_TRIP_HISTORY,                ///< Show the trip history of vehicle.
 	WID_VD_RENAME_VEHICLE,              ///< Rename this vehicle.
 	WID_VD_TOP_DETAILS,                 ///< Panel with generic details.
 	WID_VD_INCREASE_SERVICING_INTERVAL, ///< Increase the servicing interval.
diff -urNad openttd-1.3.2/src/widgets/waypoint_widget.h openttd-1.3.2-DC3.0RC3/src/widgets/waypoint_widget.h
--- openttd-1.3.2/src/widgets/waypoint_widget.h	2013-07-27 17:09:28.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/widgets/waypoint_widget.h	2013-11-22 05:49:07.000000000 +0100
@@ -19,6 +19,7 @@
 	WID_W_CENTER_VIEW,   ///< Center the main view on this waypoint.
 	WID_W_RENAME,        ///< Rename this waypoint.
 	WID_W_SHOW_VEHICLES, ///< Show the vehicles visiting this waypoint.
+    WID_W_DEPARTURES,    ///< Departures button.
 };
 
 #endif /* WIDGETS_WAYPOINT_WIDGET_H */
diff -urNad openttd-1.3.2/src/window.cpp openttd-1.3.2-DC3.0RC3/src/window.cpp
--- openttd-1.3.2/src/window.cpp	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/window.cpp	2013-11-22 05:49:07.000000000 +0100
@@ -1192,7 +1192,10 @@
 	/* Give focus to the opened window unless a text box
 	 * of focused window has focus (so we don't interrupt typing). But if the new
 	 * window has a text box, then take focus anyway. */
-	if (!EditBoxInGlobalFocus() || this->nested_root->GetWidgetOfType(WWT_EDITBOX) != NULL) SetFocusedWindow(this);
+//	if (!EditBoxInGlobalFocus() || this->nested_root->GetWidgetOfType(WWT_EDITBOX) != NULL) SetFocusedWindow(this);
+//if (!_scrolling_viewport && this->window_class != WC_OSK && (!EditBoxInGlobalFocus() || this->nested_root->GetWidgetOfType(WWT_EDITBOX) != NULL)) SetFocusedWindow(this);
+//  if (!_scrolling_viewport && this->window_class != WC_TOOLTIPS && this->window_class != WC_NEWS_WINDOW && this->window_class != 
+	if (!_scrolling_viewport && this->window_class != WC_TOOLTIPS && this->window_class != WC_NEWS_WINDOW && this->window_class != WC_OSK && (!EditBoxInGlobalFocus() || this->nested_root->GetWidgetOfType(WWT_EDITBOX) != NULL)) SetFocusedWindow(this);
 
 	/* Insert the window into the correct location in the z-ordering. */
 	AddWindowToZOrdering(this);
@@ -2311,6 +2314,20 @@
 }
 
 /**
+ * Focus a window by its class and window number (if it is open).
+ * @param cls Window class
+ * @param number Number of the window within the window class
+ */
+void FocusWindowById(WindowClass cls, WindowNumber number)
+{
+	Window *w = FindWindowById(cls, number);
+	if (w) {
+		SetFocusedWindow(w);
+		MaybeBringWindowToFront(w);
+	}
+}
+
+/**
  * Handle keyboard input.
  * @param raw_key Lower 8 bits contain the ASCII character, the higher 16 bits the keycode
  */
@@ -2431,6 +2448,7 @@
 	MAX_OFFSET_HOVER = 5,            ///< Maximum mouse movement before stopping a hover event.
 };
 extern EventState VpHandlePlaceSizingDrag();
+extern EventState VpHandleMouseWheel(int mousewheel);
 
 static void ScrollMainViewport(int x, int y)
 {
@@ -2492,11 +2510,12 @@
 	HandlePlacePresize();
 	UpdateTileSelection();
 
-	if (VpHandlePlaceSizingDrag()  == ES_HANDLED) return;
-	if (HandleMouseDragDrop()      == ES_HANDLED) return;
-	if (HandleWindowDragging()     == ES_HANDLED) return;
-	if (HandleScrollbarScrolling() == ES_HANDLED) return;
-	if (HandleViewportScroll()     == ES_HANDLED) return;
+	if (VpHandlePlaceSizingDrag()      == ES_HANDLED) return;
+	if (VpHandleMouseWheel(mousewheel) == ES_HANDLED) return;
+	if (HandleMouseDragDrop()          == ES_HANDLED) return;
+	if (HandleWindowDragging()         == ES_HANDLED) return;
+	if (HandleScrollbarScrolling()     == ES_HANDLED) return;
+	if (HandleViewportScroll()         == ES_HANDLED) return;
 
 	HandleMouseOver();
 
@@ -2528,7 +2547,7 @@
 			case MC_DOUBLE_LEFT:
 			case MC_LEFT:
 				DEBUG(misc, 2, "Cursor: 0x%X (%d)", _cursor.sprite, _cursor.sprite);
-				if (!HandleViewportClicked(vp, x, y) &&
+				if (!HandleViewportClicked(vp, x, y, click == MC_DOUBLE_LEFT) &&
 						!(w->flags & WF_DISABLE_VP_SCROLL) &&
 						_settings_client.gui.left_mouse_btn_scrolling) {
 					_scrolling_viewport = true;
diff -urNad openttd-1.3.2/src/window_func.h openttd-1.3.2-DC3.0RC3/src/window_func.h
--- openttd-1.3.2/src/window_func.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/window_func.h	2013-11-22 05:49:07.000000000 +0100
@@ -52,4 +52,6 @@
 void DeleteWindowById(WindowClass cls, WindowNumber number, bool force = true);
 void DeleteWindowByClass(WindowClass cls);
 
+void FocusWindowById(WindowClass cls, WindowNumber number);
+
 #endif /* WINDOW_FUNC_H */
diff -urNad openttd-1.3.2/src/window_gui.h openttd-1.3.2-DC3.0RC3/src/window_gui.h
--- openttd-1.3.2/src/window_gui.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/window_gui.h	2013-11-22 05:49:07.000000000 +0100
@@ -738,6 +738,15 @@
 	virtual void OnPlaceMouseUp(ViewportPlaceMethod select_method, ViewportDragDropSelectionProcess select_proc, Point pt, TileIndex start_tile, TileIndex end_tile) {}
 
 	/**
+	 * The user scrolling the mouse wheel while the tile highlight mode
+	 * has been set.
+	 * @param pt         the exact point on the map where the mouse is.
+	 * @param mousewheel the amount of scrolls.
+	 * @return #ES_HANDLED to prevent viewport from zooming.
+	 */
+	virtual EventState OnPlaceMouseWheel(Point pt, int mousewheel) { return ES_NOT_HANDLED; }
+
+	/**
 	 * The user moves over the map when a tile highlight mode has been set
 	 * when the special mouse mode has been set to 'PRESIZE' mode. An
 	 * example of this is the tile highlight for dock building.
diff -urNad openttd-1.3.2/src/window_type.h openttd-1.3.2-DC3.0RC3/src/window_type.h
--- openttd-1.3.2/src/window_type.h	2013-07-27 17:09:39.000000000 +0200
+++ openttd-1.3.2-DC3.0RC3/src/window_type.h	2013-11-22 05:49:07.000000000 +0100
@@ -104,6 +104,7 @@
 	 */
 	WC_ERRMSG,
 
+	WC_WATCH_COMPANY,
 	/**
 	 * Tooltip window; %Window numbers:
 	 *   - 0 = #ToolTipsWidgets
@@ -219,6 +220,12 @@
 	WC_VEHICLE_TIMETABLE,
 
 	/**
+	 * Vehicle trip history; %Window numbers:
+	 *   - #VehicleID = #VehicleTripHistoryWidgets
+	 */
+	WC_VEHICLE_TRIP_HISTORY,
+
+	/**
 	 * Company colour selection; %Window numbers:
 	 *   - #CompanyID = #SelectCompanyLiveryWidgets
 	 */
@@ -664,6 +671,17 @@
 	 */
 	WC_SPRITE_ALIGNER,
 
+    /**
+     * Departure boards
+     */
+	WC_DEPARTURES_BOARD,
+
+	WC_TEMPLATEGUI_MAIN,
+	WC_TEMPLATEGUI_RPLALL,
+	WC_BUILD_VIRTUAL_TRAIN,
+	WC_CREATE_TEMPLATE,
+
+
 	WC_INVALID = 0xFFFF, ///< Invalid window.
 };
 
